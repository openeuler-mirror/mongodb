diff --git a/src/third_party/asio-asio-1-11-0/asio/COPYING b/src/third_party/asio-asio-1-11-0/asio/COPYING
index 2411d10..5a0dd10 100644
--- a/src/third_party/asio-asio-1-11-0/asio/COPYING
+++ b/src/third_party/asio-asio-1-11-0/asio/COPYING
@@ -1,4 +1,4 @@
-Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 
 Distributed under the Boost Software License, Version 1.0. (See accompanying
 file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/Makefile.am b/src/third_party/asio-asio-1-11-0/asio/include/Makefile.am
index 8defef3..26362bc 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/Makefile.am
+++ b/src/third_party/asio-asio-1-11-0/asio/include/Makefile.am
@@ -18,6 +18,7 @@ nobase_include_HEADERS = \
 	asio/basic_streambuf.hpp \
 	asio/basic_stream_socket.hpp \
 	asio/basic_waitable_timer.hpp \
+	asio/bind_executor.hpp \
 	asio/buffered_read_stream_fwd.hpp \
 	asio/buffered_read_stream.hpp \
 	asio/buffered_stream_fwd.hpp \
@@ -43,8 +44,12 @@ nobase_include_HEADERS = \
 	asio/detail/buffer_resize_guard.hpp \
 	asio/detail/buffer_sequence_adapter.hpp \
 	asio/detail/call_stack.hpp \
+	asio/detail/chrono.hpp \
 	asio/detail/chrono_time_traits.hpp \
 	asio/detail/completion_handler.hpp \
+	asio/detail/concurrency_hint.hpp \
+	asio/detail/conditionally_enabled_event.hpp \
+	asio/detail/conditionally_enabled_mutex.hpp \
 	asio/detail/config.hpp \
 	asio/detail/consuming_buffers.hpp \
 	asio/detail/cstddef.hpp \
@@ -85,6 +90,7 @@ nobase_include_HEADERS = \
 	asio/detail/impl/handler_tracking.ipp \
 	asio/detail/impl/kqueue_reactor.hpp \
 	asio/detail/impl/kqueue_reactor.ipp \
+	asio/detail/impl/null_event.ipp \
 	asio/detail/impl/pipe_select_interrupter.ipp \
 	asio/detail/impl/posix_event.ipp \
 	asio/detail/impl/posix_mutex.ipp \
@@ -111,8 +117,8 @@ nobase_include_HEADERS = \
 	asio/detail/impl/timer_queue_set.ipp \
 	asio/detail/impl/win_event.ipp \
 	asio/detail/impl/win_iocp_handle_service.ipp \
-	asio/detail/impl/win_iocp_io_service.hpp \
-	asio/detail/impl/win_iocp_io_service.ipp \
+	asio/detail/impl/win_iocp_io_context.hpp \
+	asio/detail/impl/win_iocp_io_context.ipp \
 	asio/detail/impl/win_iocp_serial_port_service.ipp \
 	asio/detail/impl/win_iocp_socket_service_base.ipp \
 	asio/detail/impl/win_mutex.ipp \
@@ -126,6 +132,7 @@ nobase_include_HEADERS = \
 	asio/detail/impl/win_tss_ptr.ipp \
 	asio/detail/io_control.hpp \
 	asio/detail/is_buffer_sequence.hpp \
+	asio/detail/is_executor.hpp \
 	asio/detail/keyword_tss_ptr.hpp \
 	asio/detail/kqueue_reactor.hpp \
 	asio/detail/limits.hpp \
@@ -180,6 +187,7 @@ nobase_include_HEADERS = \
 	asio/detail/regex_fwd.hpp \
 	asio/detail/resolve_endpoint_op.hpp \
 	asio/detail/resolve_op.hpp \
+	asio/detail/resolve_query_op.hpp \
 	asio/detail/resolver_service_base.hpp \
 	asio/detail/resolver_service.hpp \
 	asio/detail/scheduler.hpp \
@@ -209,6 +217,7 @@ nobase_include_HEADERS = \
 	asio/detail/std_thread.hpp \
 	asio/detail/strand_executor_service.hpp \
 	asio/detail/strand_service.hpp \
+	asio/detail/string_view.hpp \
 	asio/detail/thread_context.hpp \
 	asio/detail/thread_group.hpp \
 	asio/detail/thread.hpp \
@@ -226,6 +235,7 @@ nobase_include_HEADERS = \
 	asio/detail/variadic_templates.hpp \
 	asio/detail/wait_handler.hpp \
 	asio/detail/wait_op.hpp \
+	asio/detail/winapp_thread.hpp \
 	asio/detail/wince_thread.hpp \
 	asio/detail/win_event.hpp \
 	asio/detail/win_fd_set_adapter.hpp \
@@ -234,7 +244,7 @@ nobase_include_HEADERS = \
 	asio/detail/win_iocp_handle_read_op.hpp \
 	asio/detail/win_iocp_handle_service.hpp \
 	asio/detail/win_iocp_handle_write_op.hpp \
-	asio/detail/win_iocp_io_service.hpp \
+	asio/detail/win_iocp_io_context.hpp \
 	asio/detail/win_iocp_null_buffers_op.hpp \
 	asio/detail/win_iocp_operation.hpp \
 	asio/detail/win_iocp_overlapped_op.hpp \
@@ -273,7 +283,7 @@ nobase_include_HEADERS = \
 	asio/error_code.hpp \
 	asio/error.hpp \
 	asio/execution_context.hpp \
-	asio/executor_work.hpp \
+	asio/executor_work_guard.hpp \
 	asio/executor.hpp \
 	asio/generic/basic_endpoint.hpp \
 	asio/generic/datagram_protocol.hpp \
@@ -300,8 +310,8 @@ nobase_include_HEADERS = \
 	asio/impl/executor.hpp \
 	asio/impl/executor.ipp \
 	asio/impl/handler_alloc_hook.ipp \
-	asio/impl/io_service.hpp \
-	asio/impl/io_service.ipp \
+	asio/impl/io_context.hpp \
+	asio/impl/io_context.ipp \
 	asio/impl/post.hpp \
 	asio/impl/read_at.hpp \
 	asio/impl/read.hpp \
@@ -318,21 +328,24 @@ nobase_include_HEADERS = \
 	asio/impl/use_future.hpp \
 	asio/impl/write_at.hpp \
 	asio/impl/write.hpp \
+	asio/io_context_strand.hpp \
+	asio/io_context.hpp \
 	asio/io_service_strand.hpp \
 	asio/io_service.hpp \
 	asio/ip/address.hpp \
-	asio/ip/address_iterator_v4.hpp \
-	asio/ip/address_iterator_v6.hpp \
-	asio/ip/address_range_v4.hpp \
-	asio/ip/address_range_v6.hpp \
 	asio/ip/address_v4.hpp \
+	asio/ip/address_v4_iterator.hpp \
+	asio/ip/address_v4_range.hpp \
 	asio/ip/address_v6.hpp \
+	asio/ip/address_v6_iterator.hpp \
+	asio/ip/address_v6_range.hpp \
 	asio/ip/bad_address_cast.hpp \
 	asio/ip/basic_endpoint.hpp \
 	asio/ip/basic_resolver_entry.hpp \
 	asio/ip/basic_resolver.hpp \
 	asio/ip/basic_resolver_iterator.hpp \
 	asio/ip/basic_resolver_query.hpp \
+	asio/ip/basic_resolver_results.hpp \
 	asio/ip/detail/endpoint.hpp \
 	asio/ip/detail/impl/endpoint.ipp \
 	asio/ip/detail/socket_option.hpp \
@@ -353,6 +366,7 @@ nobase_include_HEADERS = \
 	asio/ip/multicast.hpp \
 	asio/ip/network_v4.hpp \
 	asio/ip/network_v6.hpp \
+	asio/ip/resolver_base.hpp \
 	asio/ip/resolver_query_base.hpp \
 	asio/ip/resolver_service.hpp \
 	asio/ip/tcp.hpp \
@@ -368,10 +382,11 @@ nobase_include_HEADERS = \
 	asio/local/detail/endpoint.hpp \
 	asio/local/detail/impl/endpoint.ipp \
 	asio/local/stream_protocol.hpp \
-	asio/package.hpp \
+	asio/packaged_task.hpp \
 	asio/placeholders.hpp \
 	asio/posix/basic_descriptor.hpp \
 	asio/posix/basic_stream_descriptor.hpp \
+	asio/posix/descriptor.hpp \
 	asio/posix/descriptor_base.hpp \
 	asio/posix/stream_descriptor.hpp \
 	asio/posix/stream_descriptor_service.hpp \
@@ -430,10 +445,10 @@ nobase_include_HEADERS = \
 	asio/ts/buffer.hpp \
 	asio/ts/executor.hpp \
 	asio/ts/internet.hpp \
-	asio/ts/io_service.hpp \
-	asio/ts/networking.hpp \
+	asio/ts/io_context.hpp \
+	asio/ts/netfwd.hpp \
+	asio/ts/net.hpp \
 	asio/ts/socket.hpp \
-	asio/ts/thread_pool.hpp \
 	asio/ts/timer.hpp \
 	asio/unyield.hpp \
 	asio/use_future.hpp \
@@ -447,12 +462,12 @@ nobase_include_HEADERS = \
 	asio/windows/basic_stream_handle.hpp \
 	asio/windows/object_handle.hpp \
 	asio/windows/object_handle_service.hpp \
+	asio/windows/overlapped_handle.hpp \
 	asio/windows/overlapped_ptr.hpp \
 	asio/windows/random_access_handle.hpp \
 	asio/windows/random_access_handle_service.hpp \
 	asio/windows/stream_handle.hpp \
 	asio/windows/stream_handle_service.hpp \
-	asio/wrap.hpp \
 	asio/write_at.hpp \
 	asio/write.hpp \
 	asio/yield.hpp
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio.hpp
index 61acc16..1e42e03 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio.hpp
@@ -2,7 +2,7 @@
 // asio.hpp
 // ~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -31,6 +31,7 @@
 #include "asio/basic_stream_socket.hpp"
 #include "asio/basic_streambuf.hpp"
 #include "asio/basic_waitable_timer.hpp"
+#include "asio/bind_executor.hpp"
 #include "asio/buffer.hpp"
 #include "asio/buffered_read_stream_fwd.hpp"
 #include "asio/buffered_read_stream.hpp"
@@ -51,7 +52,7 @@
 #include "asio/error_code.hpp"
 #include "asio/execution_context.hpp"
 #include "asio/executor.hpp"
-#include "asio/executor_work.hpp"
+#include "asio/executor_work_guard.hpp"
 #include "asio/generic/basic_endpoint.hpp"
 #include "asio/generic/datagram_protocol.hpp"
 #include "asio/generic/raw_protocol.hpp"
@@ -61,13 +62,17 @@
 #include "asio/handler_continuation_hook.hpp"
 #include "asio/handler_invoke_hook.hpp"
 #include "asio/handler_type.hpp"
+#include "asio/io_context.hpp"
+#include "asio/io_context_strand.hpp"
 #include "asio/io_service.hpp"
 #include "asio/io_service_strand.hpp"
 #include "asio/ip/address.hpp"
-#include "asio/ip/address_iterator_v4.hpp"
-#include "asio/ip/address_range_v4.hpp"
 #include "asio/ip/address_v4.hpp"
+#include "asio/ip/address_v4_iterator.hpp"
+#include "asio/ip/address_v4_range.hpp"
 #include "asio/ip/address_v6.hpp"
+#include "asio/ip/address_v6_iterator.hpp"
+#include "asio/ip/address_v6_range.hpp"
 #include "asio/ip/bad_address_cast.hpp"
 #include "asio/ip/basic_endpoint.hpp"
 #include "asio/ip/basic_resolver.hpp"
@@ -77,6 +82,7 @@
 #include "asio/ip/host_name.hpp"
 #include "asio/ip/icmp.hpp"
 #include "asio/ip/multicast.hpp"
+#include "asio/ip/resolver_base.hpp"
 #include "asio/ip/resolver_query_base.hpp"
 #include "asio/ip/resolver_service.hpp"
 #include "asio/ip/tcp.hpp"
@@ -90,9 +96,11 @@
 #include "asio/local/connect_pair.hpp"
 #include "asio/local/datagram_protocol.hpp"
 #include "asio/local/stream_protocol.hpp"
+#include "asio/packaged_task.hpp"
 #include "asio/placeholders.hpp"
 #include "asio/posix/basic_descriptor.hpp"
 #include "asio/posix/basic_stream_descriptor.hpp"
+#include "asio/posix/descriptor.hpp"
 #include "asio/posix/descriptor_base.hpp"
 #include "asio/posix/stream_descriptor.hpp"
 #include "asio/posix/stream_descriptor_service.hpp"
@@ -117,6 +125,7 @@
 #include "asio/thread.hpp"
 #include "asio/thread_pool.hpp"
 #include "asio/time_traits.hpp"
+#include "asio/use_future.hpp"
 #include "asio/uses_executor.hpp"
 #include "asio/version.hpp"
 #include "asio/wait_traits.hpp"
@@ -127,12 +136,12 @@
 #include "asio/windows/basic_stream_handle.hpp"
 #include "asio/windows/object_handle.hpp"
 #include "asio/windows/object_handle_service.hpp"
+#include "asio/windows/overlapped_handle.hpp"
 #include "asio/windows/overlapped_ptr.hpp"
 #include "asio/windows/random_access_handle.hpp"
 #include "asio/windows/random_access_handle_service.hpp"
 #include "asio/windows/stream_handle.hpp"
 #include "asio/windows/stream_handle_service.hpp"
-#include "asio/wrap.hpp"
 #include "asio/write.hpp"
 #include "asio/write_at.hpp"
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/associated_allocator.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/associated_allocator.hpp
index 4b78ba4..3834b86 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/associated_allocator.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/associated_allocator.hpp
@@ -2,7 +2,7 @@
 // associated_allocator.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/associated_executor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/associated_executor.hpp
index 9389d55..74603c5 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/associated_executor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/associated_executor.hpp
@@ -2,7 +2,7 @@
 // associated_executor.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/async_result.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/async_result.hpp
index d835761..cd866bb 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/async_result.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/async_result.hpp
@@ -2,7 +2,7 @@
 // async_result.hpp
 // ~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -25,10 +25,93 @@ namespace asio {
 
 /// An interface for customising the behaviour of an initiating function.
 /**
+ * The async_result traits class is used for determining:
+ *
+ * @li the concrete completion handler type to be called at the end of the
+ * asynchronous operation;
+ *
+ * @li the initiating function return type; and
+ *
+ * @li how the return value of the initiating function is obtained.
+ *
+ * The trait allows the handler and return types to be determined at the point
+ * where the specific completion handler signature is known.
+ *
+ * This template may be specialised for user-defined completion token types.
+ * The primary template assumes that the CompletionToken is the completion
+ * handler.
+ */
+#if defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
+template <typename CompletionToken, typename Signature>
+#else // defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
+template <typename CompletionToken, typename Signature = void>
+#endif // defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
+class async_result
+{
+public:
+#if defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
+  /// The concrete completion handler type for the specific signature.
+  typedef CompletionToken completion_handler_type;
+
+  /// The return type of the initiating function.
+  typedef void return_type;
+#else // defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
+  // For backward compatibility, determine the concrete completion handler type
+  // by using the legacy handler_type trait.
+  typedef typename handler_type<CompletionToken, Signature>::type
+    completion_handler_type;
+
+  // For backward compatibility, determine the initiating function return type
+  // using the legacy single-parameter version of async_result.
+  typedef typename async_result<completion_handler_type>::type return_type;
+#endif // defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
+
+  /// Construct an async result from a given handler.
+  /**
+   * When using a specalised async_result, the constructor has an opportunity
+   * to initialise some state associated with the completion handler, which is
+   * then returned from the initiating function.
+   */
+  explicit async_result(completion_handler_type& h)
+#if defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
+    // No data members to initialise.
+#else // defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
+    : legacy_result_(h)
+#endif // defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
+  {
+    (void)h;
+  }
+
+  /// Obtain the value to be returned from the initiating function.
+  return_type get()
+  {
+#if defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
+    // Nothing to do.
+#else // defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
+    return legacy_result_.get();
+#endif // defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
+  }
+
+private:
+  async_result(const async_result&) ASIO_DELETED;
+  async_result& operator=(const async_result&) ASIO_DELETED;
+
+#if defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
+  // No data members.
+#else // defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
+  async_result<completion_handler_type> legacy_result_;
+#endif // defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
+};
+
+#if !defined(ASIO_NO_DEPRECATED)
+
+/// (Deprecated: Use two-parameter version of async_result.) An interface for
+/// customising the behaviour of an initiating function.
+/**
  * This template may be specialised for user-defined handler types.
  */
 template <typename Handler>
-class async_result
+class async_result<Handler>
 {
 public:
   /// The return type of the initiating function.
@@ -50,33 +133,42 @@ public:
   }
 };
 
-/// Helper template to deduce the real type of a handler, capture a local copy
-/// of the handler, and then create an async_result for the handler.
-template <typename Handler, typename Signature>
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+/// Helper template to deduce the handler type from a CompletionToken, capture
+/// a local copy of the handler, and then create an async_result for the
+/// handler.
+template <typename CompletionToken, typename Signature>
 struct async_completion
 {
   /// The real handler type to be used for the asynchronous operation.
-  typedef typename asio::handler_type<
-    Handler, Signature>::type handler_type;
+  typedef typename asio::async_result<
+    typename decay<CompletionToken>::type,
+      Signature>::completion_handler_type completion_handler_type;
 
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
   /// Constructor.
   /**
-   * The constructor creates the concrete handler and makes the link between
-   * the handler and the asynchronous result.
+   * The constructor creates the concrete completion handler and makes the link
+   * between the handler and the asynchronous result.
    */
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  explicit async_completion(
-      typename remove_reference<Handler>::type& orig_handler)
-    : handler(static_cast<typename conditional<
-        is_same<Handler, handler_type>::value,
-        handler_type&, Handler&&>::type>(orig_handler)),
-      result(handler)
+  explicit async_completion(CompletionToken& token)
+    : completion_handler(static_cast<typename conditional<
+        is_same<CompletionToken, completion_handler_type>::value,
+        completion_handler_type&, CompletionToken&&>::type>(token)),
+      result(completion_handler)
   {
   }
 #else // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  explicit async_completion(const Handler& orig_handler)
-    : handler(orig_handler),
-      result(handler)
+  explicit async_completion(typename decay<CompletionToken>::type& token)
+    : completion_handler(token),
+      result(completion_handler)
+  {
+  }
+
+  explicit async_completion(const typename decay<CompletionToken>::type& token)
+    : completion_handler(token),
+      result(completion_handler)
   {
   }
 #endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
@@ -84,25 +176,22 @@ struct async_completion
   /// A copy of, or reference to, a real handler object.
 #if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
   typename conditional<
-    is_same<Handler, handler_type>::value,
-    handler_type&, handler_type>::type handler;
+    is_same<CompletionToken, completion_handler_type>::value,
+    completion_handler_type&, completion_handler_type>::type completion_handler;
 #else // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  typename asio::handler_type<Handler, Signature>::type handler;
+  completion_handler_type completion_handler;
 #endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
 
   /// The result of the asynchronous operation's initiating function.
-  async_result<typename asio::handler_type<
-    Handler, Signature>::type> result;
+  async_result<typename decay<CompletionToken>::type, Signature> result;
 };
 
 namespace detail {
 
-template <typename Handler, typename Signature>
-struct async_result_type_helper
+template <typename CompletionToken, typename Signature>
+struct async_result_helper
+  : async_result<typename decay<CompletionToken>::type, Signature>
 {
-  typedef typename async_result<
-      typename handler_type<Handler, Signature>::type
-    >::type type;
 };
 
 } // namespace detail
@@ -111,15 +200,22 @@ struct async_result_type_helper
 #include "asio/detail/pop_options.hpp"
 
 #if defined(GENERATING_DOCUMENTATION)
-# define ASIO_INITFN_RESULT_TYPE(h, sig) \
+# define ASIO_INITFN_RESULT_TYPE(ct, sig) \
   void_or_deduced
 #elif defined(_MSC_VER) && (_MSC_VER < 1500)
-# define ASIO_INITFN_RESULT_TYPE(h, sig) \
-  typename ::asio::detail::async_result_type_helper<h, sig>::type
+# define ASIO_INITFN_RESULT_TYPE(ct, sig) \
+  typename ::asio::detail::async_result_helper< \
+    ct, sig>::return_type
+#define ASIO_HANDLER_TYPE(ct, sig) \
+  typename ::asio::detail::async_result_helper< \
+    ct, sig>::completion_handler_type
 #else
-# define ASIO_INITFN_RESULT_TYPE(h, sig) \
+# define ASIO_INITFN_RESULT_TYPE(ct, sig) \
+  typename ::asio::async_result< \
+    typename ::asio::decay<ct>::type, sig>::return_type
+#define ASIO_HANDLER_TYPE(ct, sig) \
   typename ::asio::async_result< \
-    typename ::asio::handler_type<h, sig>::type>::type
+    typename ::asio::decay<ct>::type, sig>::completion_handler_type
 #endif
 
 #endif // ASIO_ASYNC_RESULT_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_datagram_socket.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_datagram_socket.hpp
index 350e826..a451013 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_datagram_socket.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_datagram_socket.hpp
@@ -2,7 +2,7 @@
 // basic_datagram_socket.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -18,12 +18,15 @@
 #include "asio/detail/config.hpp"
 #include <cstddef>
 #include "asio/basic_socket.hpp"
-#include "asio/datagram_socket_service.hpp"
 #include "asio/detail/handler_type_requirements.hpp"
 #include "asio/detail/throw_error.hpp"
 #include "asio/detail/type_traits.hpp"
 #include "asio/error.hpp"
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+# include "asio/datagram_socket_service.hpp"
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #include "asio/detail/push_options.hpp"
 
 namespace asio {
@@ -37,14 +40,19 @@ namespace asio {
  * @e Distinct @e objects: Safe.@n
  * @e Shared @e objects: Unsafe.
  */
-template <typename Protocol,
-    typename DatagramSocketService = datagram_socket_service<Protocol> >
+template <typename Protocol
+    ASIO_SVC_TPARAM_DEF1(= datagram_socket_service<Protocol>)>
 class basic_datagram_socket
-  : public basic_socket<Protocol, DatagramSocketService>
+  : public basic_socket<Protocol ASIO_SVC_TARG>
 {
 public:
   /// The native representation of a socket.
-  typedef typename DatagramSocketService::native_handle_type native_handle_type;
+#if defined(GENERATING_DOCUMENTATION)
+  typedef implementation_defined native_handle_type;
+#else
+  typedef typename basic_socket<
+    Protocol ASIO_SVC_TARG>::native_handle_type native_handle_type;
+#endif
 
   /// The protocol type.
   typedef Protocol protocol_type;
@@ -57,12 +65,12 @@ public:
    * This constructor creates a datagram socket without opening it. The open()
    * function must be called before data can be sent or received on the socket.
    *
-   * @param io_service The io_service object that the datagram socket will use
+   * @param io_context The io_context object that the datagram socket will use
    * to dispatch handlers for any asynchronous operations performed on the
    * socket.
    */
-  explicit basic_datagram_socket(asio::io_service& io_service)
-    : basic_socket<Protocol, DatagramSocketService>(io_service)
+  explicit basic_datagram_socket(asio::io_context& io_context)
+    : basic_socket<Protocol ASIO_SVC_TARG>(io_context)
   {
   }
 
@@ -70,7 +78,7 @@ public:
   /**
    * This constructor creates and opens a datagram socket.
    *
-   * @param io_service The io_service object that the datagram socket will use
+   * @param io_context The io_context object that the datagram socket will use
    * to dispatch handlers for any asynchronous operations performed on the
    * socket.
    *
@@ -78,9 +86,9 @@ public:
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_datagram_socket(asio::io_service& io_service,
+  basic_datagram_socket(asio::io_context& io_context,
       const protocol_type& protocol)
-    : basic_socket<Protocol, DatagramSocketService>(io_service, protocol)
+    : basic_socket<Protocol ASIO_SVC_TARG>(io_context, protocol)
   {
   }
 
@@ -91,7 +99,7 @@ public:
    * to the specified endpoint on the local machine. The protocol used is the
    * protocol associated with the given endpoint.
    *
-   * @param io_service The io_service object that the datagram socket will use
+   * @param io_context The io_context object that the datagram socket will use
    * to dispatch handlers for any asynchronous operations performed on the
    * socket.
    *
@@ -100,9 +108,9 @@ public:
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_datagram_socket(asio::io_service& io_service,
+  basic_datagram_socket(asio::io_context& io_context,
       const endpoint_type& endpoint)
-    : basic_socket<Protocol, DatagramSocketService>(io_service, endpoint)
+    : basic_socket<Protocol ASIO_SVC_TARG>(io_context, endpoint)
   {
   }
 
@@ -111,7 +119,7 @@ public:
    * This constructor creates a datagram socket object to hold an existing
    * native socket.
    *
-   * @param io_service The io_service object that the datagram socket will use
+   * @param io_context The io_context object that the datagram socket will use
    * to dispatch handlers for any asynchronous operations performed on the
    * socket.
    *
@@ -121,10 +129,10 @@ public:
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_datagram_socket(asio::io_service& io_service,
+  basic_datagram_socket(asio::io_context& io_context,
       const protocol_type& protocol, const native_handle_type& native_socket)
-    : basic_socket<Protocol, DatagramSocketService>(
-        io_service, protocol, native_socket)
+    : basic_socket<Protocol ASIO_SVC_TARG>(
+        io_context, protocol, native_socket)
   {
   }
 
@@ -137,11 +145,10 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_datagram_socket(io_service&) constructor.
+   * constructed using the @c basic_datagram_socket(io_context&) constructor.
    */
   basic_datagram_socket(basic_datagram_socket&& other)
-    : basic_socket<Protocol, DatagramSocketService>(
-        ASIO_MOVE_CAST(basic_datagram_socket)(other))
+    : basic_socket<Protocol ASIO_SVC_TARG>(std::move(other))
   {
   }
 
@@ -154,12 +161,11 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_datagram_socket(io_service&) constructor.
+   * constructed using the @c basic_datagram_socket(io_context&) constructor.
    */
   basic_datagram_socket& operator=(basic_datagram_socket&& other)
   {
-    basic_socket<Protocol, DatagramSocketService>::operator=(
-        ASIO_MOVE_CAST(basic_datagram_socket)(other));
+    basic_socket<Protocol ASIO_SVC_TARG>::operator=(std::move(other));
     return *this;
   }
 
@@ -172,15 +178,13 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_datagram_socket(io_service&) constructor.
+   * constructed using the @c basic_datagram_socket(io_context&) constructor.
    */
-  template <typename Protocol1, typename DatagramSocketService1>
+  template <typename Protocol1 ASIO_SVC_TPARAM1>
   basic_datagram_socket(
-      basic_datagram_socket<Protocol1, DatagramSocketService1>&& other,
+      basic_datagram_socket<Protocol1 ASIO_SVC_TARG1>&& other,
       typename enable_if<is_convertible<Protocol1, Protocol>::value>::type* = 0)
-    : basic_socket<Protocol, DatagramSocketService>(
-        ASIO_MOVE_CAST2(basic_datagram_socket<
-          Protocol1, DatagramSocketService1>)(other))
+    : basic_socket<Protocol ASIO_SVC_TARG>(std::move(other))
   {
   }
 
@@ -194,20 +198,27 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_datagram_socket(io_service&) constructor.
+   * constructed using the @c basic_datagram_socket(io_context&) constructor.
    */
-  template <typename Protocol1, typename DatagramSocketService1>
+  template <typename Protocol1 ASIO_SVC_TPARAM1>
   typename enable_if<is_convertible<Protocol1, Protocol>::value,
       basic_datagram_socket>::type& operator=(
-        basic_datagram_socket<Protocol1, DatagramSocketService1>&& other)
+        basic_datagram_socket<Protocol1 ASIO_SVC_TARG1>&& other)
   {
-    basic_socket<Protocol, DatagramSocketService>::operator=(
-        ASIO_MOVE_CAST2(basic_datagram_socket<
-          Protocol1, DatagramSocketService1>)(other));
+    basic_socket<Protocol ASIO_SVC_TARG>::operator=(std::move(other));
     return *this;
   }
 #endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
 
+  /// Destroys the socket.
+  /**
+   * This function destroys the socket, cancelling any outstanding asynchronous
+   * operations associated with the socket as if by calling @c cancel.
+   */
+  ~basic_datagram_socket()
+  {
+  }
+
   /// Send some data on a connected socket.
   /**
    * This function is used to send data on the datagram socket. The function
@@ -313,7 +324,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The async_send operation can only be used with a connected socket.
    * Use the async_send_to function to send data on an unconnected datagram
@@ -338,8 +349,18 @@ public:
     // not meet the documented type requirements for a WriteHandler.
     ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_send(this->get_implementation(),
         buffers, 0, ASIO_MOVE_CAST(WriteHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<WriteHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_send(this->get_implementation(),
+        buffers, 0, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Start an asynchronous send on a connected socket.
@@ -364,7 +385,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The async_send operation can only be used with a connected socket.
    * Use the async_send_to function to send data on an unconnected datagram
@@ -381,8 +402,18 @@ public:
     // not meet the documented type requirements for a WriteHandler.
     ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_send(this->get_implementation(),
         buffers, flags, ASIO_MOVE_CAST(WriteHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<WriteHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_send(this->get_implementation(),
+        buffers, flags, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Send a datagram to the specified endpoint.
@@ -496,7 +527,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @par Example
    * To send a single data buffer use the @ref buffer function as follows:
@@ -521,9 +552,20 @@ public:
     // not meet the documented type requirements for a WriteHandler.
     ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_send_to(
         this->get_implementation(), buffers, destination, 0,
         ASIO_MOVE_CAST(WriteHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<WriteHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_send_to(
+        this->get_implementation(), buffers, destination, 0,
+        init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Start an asynchronous send.
@@ -551,7 +593,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    */
   template <typename ConstBufferSequence, typename WriteHandler>
   ASIO_INITFN_RESULT_TYPE(WriteHandler,
@@ -564,9 +606,20 @@ public:
     // not meet the documented type requirements for a WriteHandler.
     ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_send_to(
         this->get_implementation(), buffers, destination, flags,
         ASIO_MOVE_CAST(WriteHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<WriteHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_send_to(
+        this->get_implementation(), buffers, destination, flags,
+        init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Receive some data on a connected socket.
@@ -678,7 +731,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The async_receive operation can only be used with a connected socket.
    * Use the async_receive_from function to receive data on an unconnected
@@ -704,8 +757,18 @@ public:
     // not meet the documented type requirements for a ReadHandler.
     ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_receive(this->get_implementation(),
         buffers, 0, ASIO_MOVE_CAST(ReadHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<ReadHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_receive(this->get_implementation(),
+        buffers, 0, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Start an asynchronous receive on a connected socket.
@@ -730,7 +793,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The async_receive operation can only be used with a connected socket.
    * Use the async_receive_from function to receive data on an unconnected
@@ -747,8 +810,18 @@ public:
     // not meet the documented type requirements for a ReadHandler.
     ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_receive(this->get_implementation(),
         buffers, flags, ASIO_MOVE_CAST(ReadHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<ReadHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_receive(this->get_implementation(),
+        buffers, flags, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Receive a datagram with the endpoint of the sender.
@@ -865,7 +938,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @par Example
    * To receive into a single data buffer use the @ref buffer function as
@@ -887,9 +960,20 @@ public:
     // not meet the documented type requirements for a ReadHandler.
     ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_receive_from(
         this->get_implementation(), buffers, sender_endpoint, 0,
         ASIO_MOVE_CAST(ReadHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<ReadHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_receive_from(
+        this->get_implementation(), buffers, sender_endpoint, 0,
+        init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Start an asynchronous receive.
@@ -919,7 +1003,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    */
   template <typename MutableBufferSequence, typename ReadHandler>
   ASIO_INITFN_RESULT_TYPE(ReadHandler,
@@ -932,9 +1016,20 @@ public:
     // not meet the documented type requirements for a ReadHandler.
     ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_receive_from(
         this->get_implementation(), buffers, sender_endpoint, flags,
         ASIO_MOVE_CAST(ReadHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<ReadHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_receive_from(
+        this->get_implementation(), buffers, sender_endpoint, flags,
+        init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 };
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_deadline_timer.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_deadline_timer.hpp
index 7cc1374..085c8ee 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_deadline_timer.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_deadline_timer.hpp
@@ -2,7 +2,7 @@
 // basic_deadline_timer.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -22,10 +22,17 @@
 
 #include <cstddef>
 #include "asio/basic_io_object.hpp"
-#include "asio/deadline_timer_service.hpp"
 #include "asio/detail/handler_type_requirements.hpp"
 #include "asio/detail/throw_error.hpp"
 #include "asio/error.hpp"
+#include "asio/time_traits.hpp"
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+# include "asio/deadline_timer_service.hpp"
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+# include "asio/detail/deadline_timer_service.hpp"
+# define ASIO_SVC_T detail::deadline_timer_service<TimeTraits>
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
 
 #include "asio/detail/push_options.hpp"
 
@@ -50,7 +57,7 @@ namespace asio {
  * Performing a blocking wait:
  * @code
  * // Construct a timer without setting an expiry time.
- * asio::deadline_timer timer(io_service);
+ * asio::deadline_timer timer(io_context);
  *
  * // Set an expiry time relative to now.
  * timer.expires_from_now(boost::posix_time::seconds(5));
@@ -73,7 +80,7 @@ namespace asio {
  * ...
  *
  * // Construct a timer with an absolute expiry time.
- * asio::deadline_timer timer(io_service,
+ * asio::deadline_timer timer(io_context,
  *     boost::posix_time::time_from_string("2005-12-07 23:59:59.000"));
  *
  * // Start an asynchronous wait.
@@ -120,12 +127,15 @@ namespace asio {
  * it contains the value asio::error::operation_aborted.
  */
 template <typename Time,
-    typename TimeTraits = asio::time_traits<Time>,
-    typename TimerService = deadline_timer_service<Time, TimeTraits> >
+    typename TimeTraits = asio::time_traits<Time>
+    ASIO_SVC_TPARAM_DEF2(= deadline_timer_service<Time, TimeTraits>)>
 class basic_deadline_timer
-  : public basic_io_object<TimerService>
+  : ASIO_SVC_ACCESS basic_io_object<ASIO_SVC_T>
 {
 public:
+  /// The type of the executor associated with the object.
+  typedef io_context::executor_type executor_type;
+
   /// The time traits type.
   typedef TimeTraits traits_type;
 
@@ -141,11 +151,11 @@ public:
    * expires_at() or expires_from_now() functions must be called to set an
    * expiry time before the timer can be waited on.
    *
-   * @param io_service The io_service object that the timer will use to dispatch
+   * @param io_context The io_context object that the timer will use to dispatch
    * handlers for any asynchronous operations performed on the timer.
    */
-  explicit basic_deadline_timer(asio::io_service& io_service)
-    : basic_io_object<TimerService>(io_service)
+  explicit basic_deadline_timer(asio::io_context& io_context)
+    : basic_io_object<ASIO_SVC_T>(io_context)
   {
   }
 
@@ -153,15 +163,15 @@ public:
   /**
    * This constructor creates a timer and sets the expiry time.
    *
-   * @param io_service The io_service object that the timer will use to dispatch
+   * @param io_context The io_context object that the timer will use to dispatch
    * handlers for any asynchronous operations performed on the timer.
    *
    * @param expiry_time The expiry time to be used for the timer, expressed
    * as an absolute time.
    */
-  basic_deadline_timer(asio::io_service& io_service,
+  basic_deadline_timer(asio::io_context& io_context,
       const time_type& expiry_time)
-    : basic_io_object<TimerService>(io_service)
+    : basic_io_object<ASIO_SVC_T>(io_context)
   {
     asio::error_code ec;
     this->get_service().expires_at(this->get_implementation(), expiry_time, ec);
@@ -172,15 +182,15 @@ public:
   /**
    * This constructor creates a timer and sets the expiry time.
    *
-   * @param io_service The io_service object that the timer will use to dispatch
+   * @param io_context The io_context object that the timer will use to dispatch
    * handlers for any asynchronous operations performed on the timer.
    *
    * @param expiry_time The expiry time to be used for the timer, relative to
    * now.
    */
-  basic_deadline_timer(asio::io_service& io_service,
+  basic_deadline_timer(asio::io_context& io_context,
       const duration_type& expiry_time)
-    : basic_io_object<TimerService>(io_service)
+    : basic_io_object<ASIO_SVC_T>(io_context)
   {
     asio::error_code ec;
     this->get_service().expires_from_now(
@@ -188,6 +198,89 @@ public:
     asio::detail::throw_error(ec, "expires_from_now");
   }
 
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+  /// Move-construct a basic_deadline_timer from another.
+  /**
+   * This constructor moves a timer from one object to another.
+   *
+   * @param other The other basic_deadline_timer object from which the move will
+   * occur.
+   *
+   * @note Following the move, the moved-from object is in the same state as if
+   * constructed using the @c basic_deadline_timer(io_context&) constructor.
+   */
+  basic_deadline_timer(basic_deadline_timer&& other)
+    : basic_io_object<ASIO_SVC_T>(std::move(other))
+  {
+  }
+
+  /// Move-assign a basic_deadline_timer from another.
+  /**
+   * This assignment operator moves a timer from one object to another. Cancels
+   * any outstanding asynchronous operations associated with the target object.
+   *
+   * @param other The other basic_deadline_timer object from which the move will
+   * occur.
+   *
+   * @note Following the move, the moved-from object is in the same state as if
+   * constructed using the @c basic_deadline_timer(io_context&) constructor.
+   */
+  basic_deadline_timer& operator=(basic_deadline_timer&& other)
+  {
+    basic_io_object<ASIO_SVC_T>::operator=(std::move(other));
+    return *this;
+  }
+#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+
+  /// Destroys the timer.
+  /**
+   * This function destroys the timer, cancelling any outstanding asynchronous
+   * wait operations associated with the timer as if by calling @c cancel.
+   */
+  ~basic_deadline_timer()
+  {
+  }
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+  // These functions are provided by basic_io_object<>.
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_context()
+  {
+    return basic_io_object<ASIO_SVC_T>::get_io_context();
+  }
+
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_service()
+  {
+    return basic_io_object<ASIO_SVC_T>::get_io_service();
+  }
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// Get the executor associated with the object.
+  executor_type get_executor() ASIO_NOEXCEPT
+  {
+    return basic_io_object<ASIO_SVC_T>::get_executor();
+  }
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
   /// Cancel any asynchronous operations that are waiting on the timer.
   /**
    * This function forces the completion of any pending asynchronous wait
@@ -495,7 +588,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    */
   template <typename WaitHandler>
   ASIO_INITFN_RESULT_TYPE(WaitHandler,
@@ -506,8 +599,18 @@ public:
     // not meet the documented type requirements for a WaitHandler.
     ASIO_WAIT_HANDLER_CHECK(WaitHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_wait(this->get_implementation(),
         ASIO_MOVE_CAST(WaitHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<WaitHandler,
+      void (asio::error_code)> init(handler);
+
+    this->get_service().async_wait(this->get_implementation(),
+        init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 };
 
@@ -515,6 +618,10 @@ public:
 
 #include "asio/detail/pop_options.hpp"
 
+#if !defined(ASIO_ENABLE_OLD_SERVICES)
+# undef ASIO_SVC_T
+#endif // !defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // defined(ASIO_HAS_BOOST_DATE_TIME)
        // || defined(GENERATING_DOCUMENTATION)
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_io_object.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_io_object.hpp
index 934f581..b0ccfcb 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_io_object.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_io_object.hpp
@@ -2,7 +2,7 @@
 // basic_io_object.hpp
 // ~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,7 +16,7 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -34,12 +34,13 @@ namespace detail
     typedef typename service_type::implementation_type implementation_type;
 
     template <typename T, typename U>
-    static auto eval(T* t, U* u) -> decltype(t->move_construct(*u, *u), char());
-    static char (&eval(...))[2];
+    static auto asio_service_has_move_eval(T* t, U* u)
+      -> decltype(t->move_construct(*u, *u), char());
+    static char (&asio_service_has_move_eval(...))[2];
 
   public:
     static const bool value =
-      sizeof(service_has_move::eval(
+      sizeof(asio_service_has_move_eval(
         static_cast<service_type*>(0),
         static_cast<implementation_type*>(0))) == 1;
   };
@@ -67,28 +68,42 @@ public:
   typedef typename service_type::implementation_type implementation_type;
 
 #if !defined(ASIO_NO_DEPRECATED)
-  /// (Deprecated: Use get_executor().) Get the io_service associated with the
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
   /// object.
   /**
-   * This function may be used to obtain the io_service object that the I/O
+   * This function may be used to obtain the io_context object that the I/O
    * object uses to dispatch handlers for asynchronous operations.
    *
-   * @return A reference to the io_service object that the I/O object will use
+   * @return A reference to the io_context object that the I/O object will use
    * to dispatch handlers. Ownership is not transferred to the caller.
    */
-  asio::io_service& get_io_service()
+  asio::io_context& get_io_context()
   {
-    return service_.get_io_service();
+    return service_.get_io_context();
+  }
+
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_service()
+  {
+    return service_.get_io_context();
   }
 #endif // !defined(ASIO_NO_DEPRECATED)
 
   /// The type of the executor associated with the object.
-  typedef asio::io_service::executor_type executor_type;
+  typedef asio::io_context::executor_type executor_type;
 
   /// Get the executor associated with the object.
   executor_type get_executor() ASIO_NOEXCEPT
   {
-    return service_.get_io_service().get_executor();
+    return service_.get_io_context().get_executor();
   }
 
 protected:
@@ -97,8 +112,8 @@ protected:
    * Performs:
    * @code get_service().construct(get_implementation()); @endcode
    */
-  explicit basic_io_object(asio::io_service& io_service)
-    : service_(asio::use_service<IoObjectService>(io_service))
+  explicit basic_io_object(asio::io_context& io_context)
+    : service_(asio::use_service<IoObjectService>(io_context))
   {
     service_.construct(implementation_);
   }
@@ -180,22 +195,27 @@ public:
   typedef typename service_type::implementation_type implementation_type;
 
 #if !defined(ASIO_NO_DEPRECATED)
-  asio::io_service& get_io_service()
+  asio::io_context& get_io_context()
+  {
+    return service_->get_io_context();
+  }
+
+  asio::io_context& get_io_service()
   {
-    return service_->get_io_service();
+    return service_->get_io_context();
   }
 #endif // !defined(ASIO_NO_DEPRECATED)
 
-  typedef asio::io_service::executor_type executor_type;
+  typedef asio::io_context::executor_type executor_type;
 
   executor_type get_executor() ASIO_NOEXCEPT
   {
-    return service_->get_io_service().get_executor();
+    return service_->get_io_context().get_executor();
   }
 
 protected:
-  explicit basic_io_object(asio::io_service& io_service)
-    : service_(&asio::use_service<IoObjectService>(io_service))
+  explicit basic_io_object(asio::io_context& io_context)
+    : service_(&asio::use_service<IoObjectService>(io_context))
   {
     service_->construct(implementation_);
   }
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_raw_socket.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_raw_socket.hpp
index 33031c0..3011493 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_raw_socket.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_raw_socket.hpp
@@ -2,7 +2,7 @@
 // basic_raw_socket.hpp
 // ~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -22,7 +22,10 @@
 #include "asio/detail/throw_error.hpp"
 #include "asio/detail/type_traits.hpp"
 #include "asio/error.hpp"
-#include "asio/raw_socket_service.hpp"
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+# include "asio/raw_socket_service.hpp"
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
 
 #include "asio/detail/push_options.hpp"
 
@@ -37,14 +40,19 @@ namespace asio {
  * @e Distinct @e objects: Safe.@n
  * @e Shared @e objects: Unsafe.
  */
-template <typename Protocol,
-    typename RawSocketService = raw_socket_service<Protocol> >
+template <typename Protocol
+    ASIO_SVC_TPARAM_DEF1(= raw_socket_service<Protocol>)>
 class basic_raw_socket
-  : public basic_socket<Protocol, RawSocketService>
+  : public basic_socket<Protocol ASIO_SVC_TARG>
 {
 public:
   /// The native representation of a socket.
-  typedef typename RawSocketService::native_handle_type native_handle_type;
+#if defined(GENERATING_DOCUMENTATION)
+  typedef implementation_defined native_handle_type;
+#else
+  typedef typename basic_socket<
+    Protocol ASIO_SVC_TARG>::native_handle_type native_handle_type;
+#endif
 
   /// The protocol type.
   typedef Protocol protocol_type;
@@ -57,12 +65,12 @@ public:
    * This constructor creates a raw socket without opening it. The open()
    * function must be called before data can be sent or received on the socket.
    *
-   * @param io_service The io_service object that the raw socket will use
+   * @param io_context The io_context object that the raw socket will use
    * to dispatch handlers for any asynchronous operations performed on the
    * socket.
    */
-  explicit basic_raw_socket(asio::io_service& io_service)
-    : basic_socket<Protocol, RawSocketService>(io_service)
+  explicit basic_raw_socket(asio::io_context& io_context)
+    : basic_socket<Protocol ASIO_SVC_TARG>(io_context)
   {
   }
 
@@ -70,7 +78,7 @@ public:
   /**
    * This constructor creates and opens a raw socket.
    *
-   * @param io_service The io_service object that the raw socket will use
+   * @param io_context The io_context object that the raw socket will use
    * to dispatch handlers for any asynchronous operations performed on the
    * socket.
    *
@@ -78,9 +86,9 @@ public:
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_raw_socket(asio::io_service& io_service,
+  basic_raw_socket(asio::io_context& io_context,
       const protocol_type& protocol)
-    : basic_socket<Protocol, RawSocketService>(io_service, protocol)
+    : basic_socket<Protocol ASIO_SVC_TARG>(io_context, protocol)
   {
   }
 
@@ -91,7 +99,7 @@ public:
    * to the specified endpoint on the local machine. The protocol used is the
    * protocol associated with the given endpoint.
    *
-   * @param io_service The io_service object that the raw socket will use
+   * @param io_context The io_context object that the raw socket will use
    * to dispatch handlers for any asynchronous operations performed on the
    * socket.
    *
@@ -100,9 +108,9 @@ public:
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_raw_socket(asio::io_service& io_service,
+  basic_raw_socket(asio::io_context& io_context,
       const endpoint_type& endpoint)
-    : basic_socket<Protocol, RawSocketService>(io_service, endpoint)
+    : basic_socket<Protocol ASIO_SVC_TARG>(io_context, endpoint)
   {
   }
 
@@ -111,7 +119,7 @@ public:
    * This constructor creates a raw socket object to hold an existing
    * native socket.
    *
-   * @param io_service The io_service object that the raw socket will use
+   * @param io_context The io_context object that the raw socket will use
    * to dispatch handlers for any asynchronous operations performed on the
    * socket.
    *
@@ -121,10 +129,10 @@ public:
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_raw_socket(asio::io_service& io_service,
+  basic_raw_socket(asio::io_context& io_context,
       const protocol_type& protocol, const native_handle_type& native_socket)
-    : basic_socket<Protocol, RawSocketService>(
-        io_service, protocol, native_socket)
+    : basic_socket<Protocol ASIO_SVC_TARG>(
+        io_context, protocol, native_socket)
   {
   }
 
@@ -137,11 +145,10 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_raw_socket(io_service&) constructor.
+   * constructed using the @c basic_raw_socket(io_context&) constructor.
    */
   basic_raw_socket(basic_raw_socket&& other)
-    : basic_socket<Protocol, RawSocketService>(
-        ASIO_MOVE_CAST(basic_raw_socket)(other))
+    : basic_socket<Protocol ASIO_SVC_TARG>(std::move(other))
   {
   }
 
@@ -153,12 +160,11 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_raw_socket(io_service&) constructor.
+   * constructed using the @c basic_raw_socket(io_context&) constructor.
    */
   basic_raw_socket& operator=(basic_raw_socket&& other)
   {
-    basic_socket<Protocol, RawSocketService>::operator=(
-        ASIO_MOVE_CAST(basic_raw_socket)(other));
+    basic_socket<Protocol ASIO_SVC_TARG>::operator=(std::move(other));
     return *this;
   }
 
@@ -170,14 +176,12 @@ public:
    * occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_raw_socket(io_service&) constructor.
+   * constructed using the @c basic_raw_socket(io_context&) constructor.
    */
-  template <typename Protocol1, typename RawSocketService1>
-  basic_raw_socket(basic_raw_socket<Protocol1, RawSocketService1>&& other,
+  template <typename Protocol1 ASIO_SVC_TPARAM1>
+  basic_raw_socket(basic_raw_socket<Protocol1 ASIO_SVC_TARG1>&& other,
       typename enable_if<is_convertible<Protocol1, Protocol>::value>::type* = 0)
-    : basic_socket<Protocol, RawSocketService>(
-        ASIO_MOVE_CAST2(basic_raw_socket<
-          Protocol1, RawSocketService1>)(other))
+    : basic_socket<Protocol ASIO_SVC_TARG>(std::move(other))
   {
   }
 
@@ -189,20 +193,27 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_raw_socket(io_service&) constructor.
+   * constructed using the @c basic_raw_socket(io_context&) constructor.
    */
-  template <typename Protocol1, typename RawSocketService1>
+  template <typename Protocol1 ASIO_SVC_TPARAM1>
   typename enable_if<is_convertible<Protocol1, Protocol>::value,
       basic_raw_socket>::type& operator=(
-        basic_raw_socket<Protocol1, RawSocketService1>&& other)
+        basic_raw_socket<Protocol1 ASIO_SVC_TARG1>&& other)
   {
-    basic_socket<Protocol, RawSocketService>::operator=(
-        ASIO_MOVE_CAST2(basic_raw_socket<
-          Protocol1, RawSocketService1>)(other));
+    basic_socket<Protocol ASIO_SVC_TARG>::operator=(std::move(other));
     return *this;
   }
 #endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
 
+  /// Destroys the socket.
+  /**
+   * This function destroys the socket, cancelling any outstanding asynchronous
+   * operations associated with the socket as if by calling @c cancel.
+   */
+  ~basic_raw_socket()
+  {
+  }
+
   /// Send some data on a connected socket.
   /**
    * This function is used to send data on the raw socket. The function call
@@ -305,7 +316,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The async_send operation can only be used with a connected socket.
    * Use the async_send_to function to send data on an unconnected raw
@@ -330,8 +341,18 @@ public:
     // not meet the documented type requirements for a WriteHandler.
     ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_send(this->get_implementation(),
         buffers, 0, ASIO_MOVE_CAST(WriteHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<WriteHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_send(this->get_implementation(),
+        buffers, 0, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Start an asynchronous send on a connected socket.
@@ -356,7 +377,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The async_send operation can only be used with a connected socket.
    * Use the async_send_to function to send data on an unconnected raw
@@ -373,8 +394,18 @@ public:
     // not meet the documented type requirements for a WriteHandler.
     ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_send(this->get_implementation(),
         buffers, flags, ASIO_MOVE_CAST(WriteHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<WriteHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_send(this->get_implementation(),
+        buffers, flags, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Send raw data to the specified endpoint.
@@ -488,7 +519,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @par Example
    * To send a single data buffer use the @ref buffer function as follows:
@@ -513,8 +544,18 @@ public:
     // not meet the documented type requirements for a WriteHandler.
     ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_send_to(this->get_implementation(),
         buffers, destination, 0, ASIO_MOVE_CAST(WriteHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<WriteHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_send_to(this->get_implementation(),
+        buffers, destination, 0, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Start an asynchronous send.
@@ -542,7 +583,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    */
   template <typename ConstBufferSequence, typename WriteHandler>
   ASIO_INITFN_RESULT_TYPE(WriteHandler,
@@ -555,9 +596,20 @@ public:
     // not meet the documented type requirements for a WriteHandler.
     ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_send_to(
         this->get_implementation(), buffers, destination, flags,
         ASIO_MOVE_CAST(WriteHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<WriteHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_send_to(
+        this->get_implementation(), buffers, destination, flags,
+        init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Receive some data on a connected socket.
@@ -669,7 +721,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The async_receive operation can only be used with a connected socket.
    * Use the async_receive_from function to receive data on an unconnected
@@ -695,8 +747,18 @@ public:
     // not meet the documented type requirements for a ReadHandler.
     ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_receive(this->get_implementation(),
         buffers, 0, ASIO_MOVE_CAST(ReadHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<ReadHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_receive(this->get_implementation(),
+        buffers, 0, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Start an asynchronous receive on a connected socket.
@@ -721,7 +783,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The async_receive operation can only be used with a connected socket.
    * Use the async_receive_from function to receive data on an unconnected
@@ -738,8 +800,18 @@ public:
     // not meet the documented type requirements for a ReadHandler.
     ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_receive(this->get_implementation(),
         buffers, flags, ASIO_MOVE_CAST(ReadHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<ReadHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_receive(this->get_implementation(),
+        buffers, flags, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Receive raw data with the endpoint of the sender.
@@ -856,7 +928,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @par Example
    * To receive into a single data buffer use the @ref buffer function as
@@ -878,9 +950,20 @@ public:
     // not meet the documented type requirements for a ReadHandler.
     ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_receive_from(
         this->get_implementation(), buffers, sender_endpoint, 0,
         ASIO_MOVE_CAST(ReadHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<ReadHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_receive_from(
+        this->get_implementation(), buffers, sender_endpoint, 0,
+        init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Start an asynchronous receive.
@@ -910,7 +993,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    */
   template <typename MutableBufferSequence, typename ReadHandler>
   ASIO_INITFN_RESULT_TYPE(ReadHandler,
@@ -923,9 +1006,20 @@ public:
     // not meet the documented type requirements for a ReadHandler.
     ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_receive_from(
         this->get_implementation(), buffers, sender_endpoint, flags,
         ASIO_MOVE_CAST(ReadHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<ReadHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_receive_from(
+        this->get_implementation(), buffers, sender_endpoint, flags,
+        init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 };
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_seq_packet_socket.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_seq_packet_socket.hpp
index a05716f..ca992ec 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_seq_packet_socket.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_seq_packet_socket.hpp
@@ -2,7 +2,7 @@
 // basic_seq_packet_socket.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -21,7 +21,10 @@
 #include "asio/detail/handler_type_requirements.hpp"
 #include "asio/detail/throw_error.hpp"
 #include "asio/error.hpp"
-#include "asio/seq_packet_socket_service.hpp"
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+# include "asio/seq_packet_socket_service.hpp"
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
 
 #include "asio/detail/push_options.hpp"
 
@@ -36,15 +39,19 @@ namespace asio {
  * @e Distinct @e objects: Safe.@n
  * @e Shared @e objects: Unsafe.
  */
-template <typename Protocol,
-    typename SeqPacketSocketService = seq_packet_socket_service<Protocol> >
+template <typename Protocol
+    ASIO_SVC_TPARAM_DEF1(= seq_packet_socket_service<Protocol>)>
 class basic_seq_packet_socket
-  : public basic_socket<Protocol, SeqPacketSocketService>
+  : public basic_socket<Protocol ASIO_SVC_TARG>
 {
 public:
   /// The native representation of a socket.
-  typedef typename SeqPacketSocketService::native_handle_type
-    native_handle_type;
+#if defined(GENERATING_DOCUMENTATION)
+  typedef implementation_defined native_handle_type;
+#else
+  typedef typename basic_socket<
+    Protocol ASIO_SVC_TARG>::native_handle_type native_handle_type;
+#endif
 
   /// The protocol type.
   typedef Protocol protocol_type;
@@ -58,12 +65,12 @@ public:
    * socket needs to be opened and then connected or accepted before data can
    * be sent or received on it.
    *
-   * @param io_service The io_service object that the sequenced packet socket
+   * @param io_context The io_context object that the sequenced packet socket
    * will use to dispatch handlers for any asynchronous operations performed on
    * the socket.
    */
-  explicit basic_seq_packet_socket(asio::io_service& io_service)
-    : basic_socket<Protocol, SeqPacketSocketService>(io_service)
+  explicit basic_seq_packet_socket(asio::io_context& io_context)
+    : basic_socket<Protocol ASIO_SVC_TARG>(io_context)
   {
   }
 
@@ -73,7 +80,7 @@ public:
    * needs to be connected or accepted before data can be sent or received on
    * it.
    *
-   * @param io_service The io_service object that the sequenced packet socket
+   * @param io_context The io_context object that the sequenced packet socket
    * will use to dispatch handlers for any asynchronous operations performed on
    * the socket.
    *
@@ -81,9 +88,9 @@ public:
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_seq_packet_socket(asio::io_service& io_service,
+  basic_seq_packet_socket(asio::io_context& io_context,
       const protocol_type& protocol)
-    : basic_socket<Protocol, SeqPacketSocketService>(io_service, protocol)
+    : basic_socket<Protocol ASIO_SVC_TARG>(io_context, protocol)
   {
   }
 
@@ -94,7 +101,7 @@ public:
    * it bound to the specified endpoint on the local machine. The protocol used
    * is the protocol associated with the given endpoint.
    *
-   * @param io_service The io_service object that the sequenced packet socket
+   * @param io_context The io_context object that the sequenced packet socket
    * will use to dispatch handlers for any asynchronous operations performed on
    * the socket.
    *
@@ -103,9 +110,9 @@ public:
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_seq_packet_socket(asio::io_service& io_service,
+  basic_seq_packet_socket(asio::io_context& io_context,
       const endpoint_type& endpoint)
-    : basic_socket<Protocol, SeqPacketSocketService>(io_service, endpoint)
+    : basic_socket<Protocol ASIO_SVC_TARG>(io_context, endpoint)
   {
   }
 
@@ -114,7 +121,7 @@ public:
    * This constructor creates a sequenced packet socket object to hold an
    * existing native socket.
    *
-   * @param io_service The io_service object that the sequenced packet socket
+   * @param io_context The io_context object that the sequenced packet socket
    * will use to dispatch handlers for any asynchronous operations performed on
    * the socket.
    *
@@ -124,10 +131,10 @@ public:
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_seq_packet_socket(asio::io_service& io_service,
+  basic_seq_packet_socket(asio::io_context& io_context,
       const protocol_type& protocol, const native_handle_type& native_socket)
-    : basic_socket<Protocol, SeqPacketSocketService>(
-        io_service, protocol, native_socket)
+    : basic_socket<Protocol ASIO_SVC_TARG>(
+        io_context, protocol, native_socket)
   {
   }
 
@@ -141,11 +148,10 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_seq_packet_socket(io_service&) constructor.
+   * constructed using the @c basic_seq_packet_socket(io_context&) constructor.
    */
   basic_seq_packet_socket(basic_seq_packet_socket&& other)
-    : basic_socket<Protocol, SeqPacketSocketService>(
-        ASIO_MOVE_CAST(basic_seq_packet_socket)(other))
+    : basic_socket<Protocol ASIO_SVC_TARG>(std::move(other))
   {
   }
 
@@ -158,12 +164,11 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_seq_packet_socket(io_service&) constructor.
+   * constructed using the @c basic_seq_packet_socket(io_context&) constructor.
    */
   basic_seq_packet_socket& operator=(basic_seq_packet_socket&& other)
   {
-    basic_socket<Protocol, SeqPacketSocketService>::operator=(
-        ASIO_MOVE_CAST(basic_seq_packet_socket)(other));
+    basic_socket<Protocol ASIO_SVC_TARG>::operator=(std::move(other));
     return *this;
   }
 
@@ -177,15 +182,13 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_seq_packet_socket(io_service&) constructor.
+   * constructed using the @c basic_seq_packet_socket(io_context&) constructor.
    */
-  template <typename Protocol1, typename SeqPacketSocketService1>
+  template <typename Protocol1 ASIO_SVC_TPARAM1>
   basic_seq_packet_socket(
-      basic_seq_packet_socket<Protocol1, SeqPacketSocketService1>&& other,
+      basic_seq_packet_socket<Protocol1 ASIO_SVC_TARG1>&& other,
       typename enable_if<is_convertible<Protocol1, Protocol>::value>::type* = 0)
-    : basic_socket<Protocol, SeqPacketSocketService>(
-        ASIO_MOVE_CAST2(basic_seq_packet_socket<
-          Protocol1, SeqPacketSocketService1>)(other))
+    : basic_socket<Protocol ASIO_SVC_TARG>(std::move(other))
   {
   }
 
@@ -199,20 +202,27 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_seq_packet_socket(io_service&) constructor.
+   * constructed using the @c basic_seq_packet_socket(io_context&) constructor.
    */
-  template <typename Protocol1, typename SeqPacketSocketService1>
+  template <typename Protocol1 ASIO_SVC_TPARAM1>
   typename enable_if<is_convertible<Protocol1, Protocol>::value,
       basic_seq_packet_socket>::type& operator=(
-        basic_seq_packet_socket<Protocol1, SeqPacketSocketService1>&& other)
+        basic_seq_packet_socket<Protocol1 ASIO_SVC_TARG1>&& other)
   {
-    basic_socket<Protocol, SeqPacketSocketService>::operator=(
-        ASIO_MOVE_CAST2(basic_seq_packet_socket<
-          Protocol1, SeqPacketSocketService1>)(other));
+    basic_socket<Protocol ASIO_SVC_TARG>::operator=(std::move(other));
     return *this;
   }
 #endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
 
+  /// Destroys the socket.
+  /**
+   * This function destroys the socket, cancelling any outstanding asynchronous
+   * operations associated with the socket as if by calling @c cancel.
+   */
+  ~basic_seq_packet_socket()
+  {
+  }
+
   /// Send some data on the socket.
   /**
    * This function is used to send data on the sequenced packet socket. The
@@ -295,7 +305,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @par Example
    * To send a single data buffer use the @ref buffer function as follows:
@@ -317,8 +327,18 @@ public:
     // not meet the documented type requirements for a WriteHandler.
     ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_send(this->get_implementation(),
         buffers, flags, ASIO_MOVE_CAST(WriteHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<WriteHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_send(this->get_implementation(),
+        buffers, flags, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Receive some data on the socket.
@@ -355,8 +375,13 @@ public:
       socket_base::message_flags& out_flags)
   {
     asio::error_code ec;
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     std::size_t s = this->get_service().receive(
         this->get_implementation(), buffers, 0, out_flags, ec);
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    std::size_t s = this->get_service().receive_with_flags(
+        this->get_implementation(), buffers, 0, out_flags, ec);
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
     asio::detail::throw_error(ec, "receive");
     return s;
   }
@@ -402,8 +427,13 @@ public:
       socket_base::message_flags& out_flags)
   {
     asio::error_code ec;
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     std::size_t s = this->get_service().receive(
         this->get_implementation(), buffers, in_flags, out_flags, ec);
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    std::size_t s = this->get_service().receive_with_flags(
+        this->get_implementation(), buffers, in_flags, out_flags, ec);
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
     asio::detail::throw_error(ec, "receive");
     return s;
   }
@@ -436,8 +466,13 @@ public:
       socket_base::message_flags in_flags,
       socket_base::message_flags& out_flags, asio::error_code& ec)
   {
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().receive(this->get_implementation(),
         buffers, in_flags, out_flags, ec);
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    return this->get_service().receive_with_flags(this->get_implementation(),
+        buffers, in_flags, out_flags, ec);
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Start an asynchronous receive.
@@ -466,7 +501,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @par Example
    * To receive into a single data buffer use the @ref buffer function as
@@ -489,9 +524,20 @@ public:
     // not meet the documented type requirements for a ReadHandler.
     ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_receive(
         this->get_implementation(), buffers, 0, out_flags,
         ASIO_MOVE_CAST(ReadHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<ReadHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_receive_with_flags(
+        this->get_implementation(), buffers, 0, out_flags,
+        init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Start an asynchronous receive.
@@ -522,7 +568,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @par Example
    * To receive into a single data buffer use the @ref buffer function as
@@ -548,9 +594,20 @@ public:
     // not meet the documented type requirements for a ReadHandler.
     ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_receive(
         this->get_implementation(), buffers, in_flags, out_flags,
         ASIO_MOVE_CAST(ReadHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<ReadHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_receive_with_flags(
+        this->get_implementation(), buffers, in_flags, out_flags,
+        init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 };
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_serial_port.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_serial_port.hpp
index 125565f..b6ac51e 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_serial_port.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_serial_port.hpp
@@ -2,7 +2,7 @@
 // basic_serial_port.hpp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -18,6 +18,8 @@
 
 #include "asio/detail/config.hpp"
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #if defined(ASIO_HAS_SERIAL_PORT) \
   || defined(GENERATING_DOCUMENTATION)
 
@@ -58,11 +60,11 @@ public:
   /**
    * This constructor creates a serial port without opening it.
    *
-   * @param io_service The io_service object that the serial port will use to
+   * @param io_context The io_context object that the serial port will use to
    * dispatch handlers for any asynchronous operations performed on the port.
    */
-  explicit basic_serial_port(asio::io_service& io_service)
-    : basic_io_object<SerialPortService>(io_service)
+  explicit basic_serial_port(asio::io_context& io_context)
+    : basic_io_object<SerialPortService>(io_context)
   {
   }
 
@@ -71,15 +73,15 @@ public:
    * This constructor creates and opens a serial port for the specified device
    * name.
    *
-   * @param io_service The io_service object that the serial port will use to
+   * @param io_context The io_context object that the serial port will use to
    * dispatch handlers for any asynchronous operations performed on the port.
    *
    * @param device The platform-specific device name for this serial
    * port.
    */
-  explicit basic_serial_port(asio::io_service& io_service,
+  explicit basic_serial_port(asio::io_context& io_context,
       const char* device)
-    : basic_io_object<SerialPortService>(io_service)
+    : basic_io_object<SerialPortService>(io_context)
   {
     asio::error_code ec;
     this->get_service().open(this->get_implementation(), device, ec);
@@ -91,15 +93,15 @@ public:
    * This constructor creates and opens a serial port for the specified device
    * name.
    *
-   * @param io_service The io_service object that the serial port will use to
+   * @param io_context The io_context object that the serial port will use to
    * dispatch handlers for any asynchronous operations performed on the port.
    *
    * @param device The platform-specific device name for this serial
    * port.
    */
-  explicit basic_serial_port(asio::io_service& io_service,
+  explicit basic_serial_port(asio::io_context& io_context,
       const std::string& device)
-    : basic_io_object<SerialPortService>(io_service)
+    : basic_io_object<SerialPortService>(io_context)
   {
     asio::error_code ec;
     this->get_service().open(this->get_implementation(), device, ec);
@@ -111,16 +113,16 @@ public:
    * This constructor creates a serial port object to hold an existing native
    * serial port.
    *
-   * @param io_service The io_service object that the serial port will use to
+   * @param io_context The io_context object that the serial port will use to
    * dispatch handlers for any asynchronous operations performed on the port.
    *
    * @param native_serial_port A native serial port.
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_serial_port(asio::io_service& io_service,
+  basic_serial_port(asio::io_context& io_context,
       const native_handle_type& native_serial_port)
-    : basic_io_object<SerialPortService>(io_service)
+    : basic_io_object<SerialPortService>(io_context)
   {
     asio::error_code ec;
     this->get_service().assign(this->get_implementation(),
@@ -137,7 +139,7 @@ public:
    * occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_serial_port(io_service&) constructor.
+   * constructed using the @c basic_serial_port(io_context&) constructor.
    */
   basic_serial_port(basic_serial_port&& other)
     : basic_io_object<SerialPortService>(
@@ -153,7 +155,7 @@ public:
    * occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_serial_port(io_service&) constructor.
+   * constructed using the @c basic_serial_port(io_context&) constructor.
    */
   basic_serial_port& operator=(basic_serial_port&& other)
   {
@@ -215,10 +217,11 @@ public:
    *
    * @param ec Set the indicate what error occurred, if any.
    */
-  asio::error_code open(const std::string& device,
+  ASIO_SYNC_OP_VOID open(const std::string& device,
       asio::error_code& ec)
   {
-    return this->get_service().open(this->get_implementation(), device, ec);
+    this->get_service().open(this->get_implementation(), device, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Assign an existing native serial port to the serial port.
@@ -245,11 +248,12 @@ public:
    *
    * @param ec Set to indicate what error occurred, if any.
    */
-  asio::error_code assign(const native_handle_type& native_serial_port,
+  ASIO_SYNC_OP_VOID assign(const native_handle_type& native_serial_port,
       asio::error_code& ec)
   {
-    return this->get_service().assign(this->get_implementation(),
+    this->get_service().assign(this->get_implementation(),
         native_serial_port, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Determine whether the serial port is open.
@@ -281,9 +285,10 @@ public:
    *
    * @param ec Set to indicate what error occurred, if any.
    */
-  asio::error_code close(asio::error_code& ec)
+  ASIO_SYNC_OP_VOID close(asio::error_code& ec)
   {
-    return this->get_service().close(this->get_implementation(), ec);
+    this->get_service().close(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the native serial port representation.
@@ -320,9 +325,10 @@ public:
    *
    * @param ec Set to indicate what error occurred, if any.
    */
-  asio::error_code cancel(asio::error_code& ec)
+  ASIO_SYNC_OP_VOID cancel(asio::error_code& ec)
   {
-    return this->get_service().cancel(this->get_implementation(), ec);
+    this->get_service().cancel(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Send a break sequence to the serial port.
@@ -346,9 +352,10 @@ public:
    *
    * @param ec Set to indicate what error occurred, if any.
    */
-  asio::error_code send_break(asio::error_code& ec)
+  ASIO_SYNC_OP_VOID send_break(asio::error_code& ec)
   {
-    return this->get_service().send_break(this->get_implementation(), ec);
+    this->get_service().send_break(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Set an option on the serial port.
@@ -390,11 +397,11 @@ public:
    * asio::serial_port_base::character_size
    */
   template <typename SettableSerialPortOption>
-  asio::error_code set_option(const SettableSerialPortOption& option,
+  ASIO_SYNC_OP_VOID set_option(const SettableSerialPortOption& option,
       asio::error_code& ec)
   {
-    return this->get_service().set_option(
-        this->get_implementation(), option, ec);
+    this->get_service().set_option(this->get_implementation(), option, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get an option from the serial port.
@@ -428,7 +435,7 @@ public:
    *
    * @param option The option value to be obtained from the serial port.
    *
-   * @param ec Set to indicate what error occured, if any.
+   * @param ec Set to indicate what error occurred, if any.
    *
    * @sa GettableSerialPortOption @n
    * asio::serial_port_base::baud_rate @n
@@ -438,11 +445,11 @@ public:
    * asio::serial_port_base::character_size
    */
   template <typename GettableSerialPortOption>
-  asio::error_code get_option(GettableSerialPortOption& option,
+  ASIO_SYNC_OP_VOID get_option(GettableSerialPortOption& option,
       asio::error_code& ec)
   {
-    return this->get_service().get_option(
-        this->get_implementation(), option, ec);
+    this->get_service().get_option(this->get_implementation(), option, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Write some data to the serial port.
@@ -526,7 +533,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The write operation may not transmit all of the data to the peer.
    * Consider using the @ref async_write function if you need to ensure that all
@@ -638,7 +645,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The read operation may not read all of the requested number of bytes.
    * Consider using the @ref async_read function if you need to ensure that the
@@ -676,4 +683,6 @@ public:
 #endif // defined(ASIO_HAS_SERIAL_PORT)
        //   || defined(GENERATING_DOCUMENTATION)
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_BASIC_SERIAL_PORT_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_signal_set.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_signal_set.hpp
index 117b25f..6f1d07e 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_signal_set.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_signal_set.hpp
@@ -2,7 +2,7 @@
 // basic_signal_set.hpp
 // ~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,6 +17,8 @@
 
 #include "asio/detail/config.hpp"
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #include "asio/basic_io_object.hpp"
 #include "asio/detail/handler_type_requirements.hpp"
 #include "asio/detail/throw_error.hpp"
@@ -54,7 +56,7 @@ namespace asio {
  * ...
  *
  * // Construct a signal set registered for process termination.
- * asio::signal_set signals(io_service, SIGINT, SIGTERM);
+ * asio::signal_set signals(io_context, SIGINT, SIGTERM);
  *
  * // Start an asynchronous wait for one of the signals to occur.
  * signals.async_wait(handler);
@@ -98,11 +100,11 @@ public:
   /**
    * This constructor creates a signal set without registering for any signals.
    *
-   * @param io_service The io_service object that the signal set will use to
+   * @param io_context The io_context object that the signal set will use to
    * dispatch handlers for any asynchronous operations performed on the set.
    */
-  explicit basic_signal_set(asio::io_service& io_service)
-    : basic_io_object<SignalSetService>(io_service)
+  explicit basic_signal_set(asio::io_context& io_context)
+    : basic_io_object<SignalSetService>(io_context)
   {
   }
 
@@ -110,17 +112,17 @@ public:
   /**
    * This constructor creates a signal set and registers for one signal.
    *
-   * @param io_service The io_service object that the signal set will use to
+   * @param io_context The io_context object that the signal set will use to
    * dispatch handlers for any asynchronous operations performed on the set.
    *
    * @param signal_number_1 The signal number to be added.
    *
    * @note This constructor is equivalent to performing:
-   * @code asio::signal_set signals(io_service);
+   * @code asio::signal_set signals(io_context);
    * signals.add(signal_number_1); @endcode
    */
-  basic_signal_set(asio::io_service& io_service, int signal_number_1)
-    : basic_io_object<SignalSetService>(io_service)
+  basic_signal_set(asio::io_context& io_context, int signal_number_1)
+    : basic_io_object<SignalSetService>(io_context)
   {
     asio::error_code ec;
     this->get_service().add(this->get_implementation(), signal_number_1, ec);
@@ -131,7 +133,7 @@ public:
   /**
    * This constructor creates a signal set and registers for two signals.
    *
-   * @param io_service The io_service object that the signal set will use to
+   * @param io_context The io_context object that the signal set will use to
    * dispatch handlers for any asynchronous operations performed on the set.
    *
    * @param signal_number_1 The first signal number to be added.
@@ -139,13 +141,13 @@ public:
    * @param signal_number_2 The second signal number to be added.
    *
    * @note This constructor is equivalent to performing:
-   * @code asio::signal_set signals(io_service);
+   * @code asio::signal_set signals(io_context);
    * signals.add(signal_number_1);
    * signals.add(signal_number_2); @endcode
    */
-  basic_signal_set(asio::io_service& io_service, int signal_number_1,
+  basic_signal_set(asio::io_context& io_context, int signal_number_1,
       int signal_number_2)
-    : basic_io_object<SignalSetService>(io_service)
+    : basic_io_object<SignalSetService>(io_context)
   {
     asio::error_code ec;
     this->get_service().add(this->get_implementation(), signal_number_1, ec);
@@ -158,7 +160,7 @@ public:
   /**
    * This constructor creates a signal set and registers for three signals.
    *
-   * @param io_service The io_service object that the signal set will use to
+   * @param io_context The io_context object that the signal set will use to
    * dispatch handlers for any asynchronous operations performed on the set.
    *
    * @param signal_number_1 The first signal number to be added.
@@ -168,14 +170,14 @@ public:
    * @param signal_number_3 The third signal number to be added.
    *
    * @note This constructor is equivalent to performing:
-   * @code asio::signal_set signals(io_service);
+   * @code asio::signal_set signals(io_context);
    * signals.add(signal_number_1);
    * signals.add(signal_number_2);
    * signals.add(signal_number_3); @endcode
    */
-  basic_signal_set(asio::io_service& io_service, int signal_number_1,
+  basic_signal_set(asio::io_context& io_context, int signal_number_1,
       int signal_number_2, int signal_number_3)
-    : basic_io_object<SignalSetService>(io_service)
+    : basic_io_object<SignalSetService>(io_context)
   {
     asio::error_code ec;
     this->get_service().add(this->get_implementation(), signal_number_1, ec);
@@ -211,11 +213,10 @@ public:
    *
    * @param ec Set to indicate what error occurred, if any.
    */
-  asio::error_code add(int signal_number,
-      asio::error_code& ec)
+  ASIO_SYNC_OP_VOID add(int signal_number, asio::error_code& ec)
   {
-    return this->get_service().add(
-        this->get_implementation(), signal_number, ec);
+    this->get_service().add(this->get_implementation(), signal_number, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Remove a signal from a signal_set.
@@ -249,11 +250,11 @@ public:
    * @note Removes any notifications that have been queued for the specified
    * signal number.
    */
-  asio::error_code remove(int signal_number,
+  ASIO_SYNC_OP_VOID remove(int signal_number,
       asio::error_code& ec)
   {
-    return this->get_service().remove(
-        this->get_implementation(), signal_number, ec);
+    this->get_service().remove(this->get_implementation(), signal_number, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Remove all signals from a signal_set.
@@ -281,9 +282,10 @@ public:
    *
    * @note Removes all queued notifications.
    */
-  asio::error_code clear(asio::error_code& ec)
+  ASIO_SYNC_OP_VOID clear(asio::error_code& ec)
   {
-    return this->get_service().clear(this->get_implementation(), ec);
+    this->get_service().clear(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Cancel all operations associated with the signal set.
@@ -335,9 +337,10 @@ public:
    * These handlers can no longer be cancelled, and therefore are passed an
    * error code that indicates the successful completion of the wait operation.
    */
-  asio::error_code cancel(asio::error_code& ec)
+  ASIO_SYNC_OP_VOID cancel(asio::error_code& ec)
   {
-    return this->get_service().cancel(this->get_implementation(), ec);
+    this->get_service().cancel(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Start an asynchronous operation to wait for a signal to be delivered.
@@ -363,7 +366,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    */
   template <typename SignalHandler>
   ASIO_INITFN_RESULT_TYPE(SignalHandler,
@@ -383,4 +386,6 @@ public:
 
 #include "asio/detail/pop_options.hpp"
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_BASIC_SIGNAL_SET_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_socket.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_socket.hpp
index 8ff13de..a1e7b81 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_socket.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_socket.hpp
@@ -2,7 +2,7 @@
 // basic_socket.hpp
 // ~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -25,6 +25,23 @@
 #include "asio/post.hpp"
 #include "asio/socket_base.hpp"
 
+#if defined(ASIO_HAS_MOVE)
+# include <utility>
+#endif // defined(ASIO_HAS_MOVE)
+
+#if !defined(ASIO_ENABLE_OLD_SERVICES)
+# if defined(ASIO_WINDOWS_RUNTIME)
+#  include "asio/detail/winrt_ssocket_service.hpp"
+#  define ASIO_SVC_T detail::winrt_ssocket_service<Protocol>
+# elif defined(ASIO_HAS_IOCP)
+#  include "asio/detail/win_iocp_socket_service.hpp"
+#  define ASIO_SVC_T detail::win_iocp_socket_service<Protocol>
+# else
+#  include "asio/detail/reactive_socket_service.hpp"
+#  define ASIO_SVC_T detail::reactive_socket_service<Protocol>
+# endif
+#endif // !defined(ASIO_ENABLE_OLD_SERVICES)
+
 #include "asio/detail/push_options.hpp"
 
 namespace asio {
@@ -38,14 +55,21 @@ namespace asio {
  * @e Distinct @e objects: Safe.@n
  * @e Shared @e objects: Unsafe.
  */
-template <typename Protocol, typename SocketService>
+template <typename Protocol ASIO_SVC_TPARAM>
 class basic_socket
-  : public basic_io_object<SocketService>,
+  : ASIO_SVC_ACCESS basic_io_object<ASIO_SVC_T>,
     public socket_base
 {
 public:
+  /// The type of the executor associated with the object.
+  typedef io_context::executor_type executor_type;
+
   /// The native representation of a socket.
-  typedef typename SocketService::native_handle_type native_handle_type;
+#if defined(GENERATING_DOCUMENTATION)
+  typedef implementation_defined native_handle_type;
+#else
+  typedef typename ASIO_SVC_T::native_handle_type native_handle_type;
+#endif
 
   /// The protocol type.
   typedef Protocol protocol_type;
@@ -53,18 +77,20 @@ public:
   /// The endpoint type.
   typedef typename Protocol::endpoint endpoint_type;
 
+#if !defined(ASIO_NO_EXTENSIONS)
   /// A basic_socket is always the lowest layer.
-  typedef basic_socket<Protocol, SocketService> lowest_layer_type;
+  typedef basic_socket<Protocol ASIO_SVC_TARG> lowest_layer_type;
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
   /// Construct a basic_socket without opening it.
   /**
    * This constructor creates a socket without opening it.
    *
-   * @param io_service The io_service object that the socket will use to
+   * @param io_context The io_context object that the socket will use to
    * dispatch handlers for any asynchronous operations performed on the socket.
    */
-  explicit basic_socket(asio::io_service& io_service)
-    : basic_io_object<SocketService>(io_service)
+  explicit basic_socket(asio::io_context& io_context)
+    : basic_io_object<ASIO_SVC_T>(io_context)
   {
   }
 
@@ -72,16 +98,16 @@ public:
   /**
    * This constructor creates and opens a socket.
    *
-   * @param io_service The io_service object that the socket will use to
+   * @param io_context The io_context object that the socket will use to
    * dispatch handlers for any asynchronous operations performed on the socket.
    *
    * @param protocol An object specifying protocol parameters to be used.
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_socket(asio::io_service& io_service,
+  basic_socket(asio::io_context& io_context,
       const protocol_type& protocol)
-    : basic_io_object<SocketService>(io_service)
+    : basic_io_object<ASIO_SVC_T>(io_context)
   {
     asio::error_code ec;
     this->get_service().open(this->get_implementation(), protocol, ec);
@@ -95,7 +121,7 @@ public:
    * specified endpoint on the local machine. The protocol used is the protocol
    * associated with the given endpoint.
    *
-   * @param io_service The io_service object that the socket will use to
+   * @param io_context The io_context object that the socket will use to
    * dispatch handlers for any asynchronous operations performed on the socket.
    *
    * @param endpoint An endpoint on the local machine to which the socket will
@@ -103,9 +129,9 @@ public:
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_socket(asio::io_service& io_service,
+  basic_socket(asio::io_context& io_context,
       const endpoint_type& endpoint)
-    : basic_io_object<SocketService>(io_service)
+    : basic_io_object<ASIO_SVC_T>(io_context)
   {
     asio::error_code ec;
     const protocol_type protocol = endpoint.protocol();
@@ -119,7 +145,7 @@ public:
   /**
    * This constructor creates a socket object to hold an existing native socket.
    *
-   * @param io_service The io_service object that the socket will use to
+   * @param io_context The io_context object that the socket will use to
    * dispatch handlers for any asynchronous operations performed on the socket.
    *
    * @param protocol An object specifying protocol parameters to be used.
@@ -128,9 +154,9 @@ public:
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_socket(asio::io_service& io_service,
+  basic_socket(asio::io_context& io_context,
       const protocol_type& protocol, const native_handle_type& native_socket)
-    : basic_io_object<SocketService>(io_service)
+    : basic_io_object<ASIO_SVC_T>(io_context)
   {
     asio::error_code ec;
     this->get_service().assign(this->get_implementation(),
@@ -147,11 +173,10 @@ public:
    * occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_socket(io_service&) constructor.
+   * constructed using the @c basic_socket(io_context&) constructor.
    */
   basic_socket(basic_socket&& other)
-    : basic_io_object<SocketService>(
-        ASIO_MOVE_CAST(basic_socket)(other))
+    : basic_io_object<ASIO_SVC_T>(std::move(other))
   {
   }
 
@@ -163,17 +188,16 @@ public:
    * occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_socket(io_service&) constructor.
+   * constructed using the @c basic_socket(io_context&) constructor.
    */
   basic_socket& operator=(basic_socket&& other)
   {
-    basic_io_object<SocketService>::operator=(
-        ASIO_MOVE_CAST(basic_socket)(other));
+    basic_io_object<ASIO_SVC_T>::operator=(std::move(other));
     return *this;
   }
 
   // All sockets have access to each other's implementations.
-  template <typename Protocol1, typename SocketService1>
+  template <typename Protocol1 ASIO_SVC_TPARAM1>
   friend class basic_socket;
 
   /// Move-construct a basic_socket from a socket of another protocol type.
@@ -184,12 +208,12 @@ public:
    * occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_socket(io_service&) constructor.
+   * constructed using the @c basic_socket(io_context&) constructor.
    */
-  template <typename Protocol1, typename SocketService1>
-  basic_socket(basic_socket<Protocol1, SocketService1>&& other,
+  template <typename Protocol1 ASIO_SVC_TPARAM1>
+  basic_socket(basic_socket<Protocol1 ASIO_SVC_TARG1>&& other,
       typename enable_if<is_convertible<Protocol1, Protocol>::value>::type* = 0)
-    : basic_io_object<SocketService>(other.get_service().get_io_service())
+    : basic_io_object<ASIO_SVC_T>(other.get_service().get_io_context())
   {
     this->get_service().template converting_move_construct<Protocol1>(
         this->get_implementation(), other.get_implementation());
@@ -203,21 +227,60 @@ public:
    * occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_socket(io_service&) constructor.
+   * constructed using the @c basic_socket(io_context&) constructor.
    */
-  template <typename Protocol1, typename SocketService1>
+  template <typename Protocol1 ASIO_SVC_TPARAM1>
   typename enable_if<is_convertible<Protocol1, Protocol>::value,
       basic_socket>::type& operator=(
-        basic_socket<Protocol1, SocketService1>&& other)
+        basic_socket<Protocol1 ASIO_SVC_TARG1>&& other)
   {
-    basic_socket tmp(ASIO_MOVE_CAST2(basic_socket<
-            Protocol1, SocketService1>)(other));
-    basic_io_object<SocketService>::operator=(
-        ASIO_MOVE_CAST(basic_socket)(tmp));
+    basic_socket tmp(std::move(other));
+    basic_io_object<ASIO_SVC_T>::operator=(std::move(tmp));
     return *this;
   }
 #endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+  // These functions are provided by basic_io_object<>.
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_context()
+  {
+    return basic_io_object<ASIO_SVC_T>::get_io_context();
+  }
+
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_service()
+  {
+    return basic_io_object<ASIO_SVC_T>::get_io_service();
+  }
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// Get the executor associated with the object.
+  executor_type get_executor() ASIO_NOEXCEPT
+  {
+    return basic_io_object<ASIO_SVC_T>::get_executor();
+  }
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
+#if !defined(ASIO_NO_EXTENSIONS)
   /// Get a reference to the lowest layer.
   /**
    * This function returns a reference to the lowest layer in a stack of
@@ -245,6 +308,7 @@ public:
   {
     return *this;
   }
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
   /// Open the socket using the specified protocol.
   /**
@@ -256,7 +320,7 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * socket.open(asio::ip::tcp::v4());
    * @endcode
    */
@@ -277,7 +341,7 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * asio::error_code ec;
    * socket.open(asio::ip::tcp::v4(), ec);
    * if (ec)
@@ -286,10 +350,11 @@ public:
    * }
    * @endcode
    */
-  asio::error_code open(const protocol_type& protocol,
+  ASIO_SYNC_OP_VOID open(const protocol_type& protocol,
       asio::error_code& ec)
   {
-    return this->get_service().open(this->get_implementation(), protocol, ec);
+    this->get_service().open(this->get_implementation(), protocol, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Assign an existing native socket to the socket.
@@ -321,11 +386,12 @@ public:
    *
    * @param ec Set to indicate what error occurred, if any.
    */
-  asio::error_code assign(const protocol_type& protocol,
+  ASIO_SYNC_OP_VOID assign(const protocol_type& protocol,
       const native_handle_type& native_socket, asio::error_code& ec)
   {
-    return this->get_service().assign(this->get_implementation(),
+    this->get_service().assign(this->get_implementation(),
         protocol, native_socket, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Determine whether the socket is open.
@@ -364,7 +430,7 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * ...
    * asio::error_code ec;
    * socket.close(ec);
@@ -377,9 +443,10 @@ public:
    * @note For portable behaviour with respect to graceful closure of a
    * connected socket, call shutdown() before closing the socket.
    */
-  asio::error_code close(asio::error_code& ec)
+  ASIO_SYNC_OP_VOID close(asio::error_code& ec)
   {
-    return this->get_service().close(this->get_implementation(), ec);
+    this->get_service().close(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the native socket representation.
@@ -482,9 +549,10 @@ public:
         "operation_not_supported when used on Windows XP, Windows Server 2003, "
         "or earlier. Consult documentation for details."))
 #endif
-  asio::error_code cancel(asio::error_code& ec)
+  ASIO_SYNC_OP_VOID cancel(asio::error_code& ec)
   {
-    return this->get_service().cancel(this->get_implementation(), ec);
+    this->get_service().cancel(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Determine whether the socket is at the out-of-band data mark.
@@ -566,7 +634,7 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * socket.open(asio::ip::tcp::v4());
    * socket.bind(asio::ip::tcp::endpoint(
    *       asio::ip::tcp::v4(), 12345));
@@ -591,7 +659,7 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * socket.open(asio::ip::tcp::v4());
    * asio::error_code ec;
    * socket.bind(asio::ip::tcp::endpoint(
@@ -602,10 +670,11 @@ public:
    * }
    * @endcode
    */
-  asio::error_code bind(const endpoint_type& endpoint,
+  ASIO_SYNC_OP_VOID bind(const endpoint_type& endpoint,
       asio::error_code& ec)
   {
-    return this->get_service().bind(this->get_implementation(), endpoint, ec);
+    this->get_service().bind(this->get_implementation(), endpoint, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Connect the socket to the specified endpoint.
@@ -625,7 +694,7 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * asio::ip::tcp::endpoint endpoint(
    *     asio::ip::address::from_string("1.2.3.4"), 12345);
    * socket.connect(endpoint);
@@ -661,7 +730,7 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * asio::ip::tcp::endpoint endpoint(
    *     asio::ip::address::from_string("1.2.3.4"), 12345);
    * asio::error_code ec;
@@ -672,20 +741,21 @@ public:
    * }
    * @endcode
    */
-  asio::error_code connect(const endpoint_type& peer_endpoint,
+  ASIO_SYNC_OP_VOID connect(const endpoint_type& peer_endpoint,
       asio::error_code& ec)
   {
     if (!is_open())
     {
-      if (this->get_service().open(this->get_implementation(),
-            peer_endpoint.protocol(), ec))
+      this->get_service().open(this->get_implementation(),
+            peer_endpoint.protocol(), ec);
+      if (ec)
       {
-        return ec;
+        ASIO_SYNC_OP_VOID_RETURN(ec);
       }
     }
 
-    return this->get_service().connect(
-        this->get_implementation(), peer_endpoint, ec);
+    this->get_service().connect(this->get_implementation(), peer_endpoint, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Start an asynchronous connect.
@@ -709,7 +779,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @par Example
    * @code
@@ -723,7 +793,7 @@ public:
    *
    * ...
    *
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * asio::ip::tcp::endpoint endpoint(
    *     asio::ip::address::from_string("1.2.3.4"), 12345);
    * socket.async_connect(endpoint, connect_handler);
@@ -743,7 +813,8 @@ public:
     {
       asio::error_code ec;
       const protocol_type protocol = peer_endpoint.protocol();
-      if (this->get_service().open(this->get_implementation(), protocol, ec))
+      this->get_service().open(this->get_implementation(), protocol, ec);
+      if (ec)
       {
         async_completion<ConnectHandler,
           void (asio::error_code)> init(handler);
@@ -752,14 +823,24 @@ public:
             asio::detail::bind_handler(
               ASIO_MOVE_CAST(ASIO_HANDLER_TYPE(
                 ConnectHandler, void (asio::error_code)))(
-                  init.handler), ec));
+                  init.completion_handler), ec));
 
         return init.result.get();
       }
     }
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_connect(this->get_implementation(),
         peer_endpoint, ASIO_MOVE_CAST(ConnectHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<ConnectHandler,
+      void (asio::error_code)> init(handler);
+
+    this->get_service().async_connect(
+        this->get_implementation(), peer_endpoint, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Set an option on the socket.
@@ -790,7 +871,7 @@ public:
    * @par Example
    * Setting the IPPROTO_TCP/TCP_NODELAY option:
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * ...
    * asio::ip::tcp::no_delay option(true);
    * socket.set_option(option);
@@ -832,7 +913,7 @@ public:
    * @par Example
    * Setting the IPPROTO_TCP/TCP_NODELAY option:
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * ...
    * asio::ip::tcp::no_delay option(true);
    * asio::error_code ec;
@@ -844,11 +925,11 @@ public:
    * @endcode
    */
   template <typename SettableSocketOption>
-  asio::error_code set_option(const SettableSocketOption& option,
+  ASIO_SYNC_OP_VOID set_option(const SettableSocketOption& option,
       asio::error_code& ec)
   {
-    return this->get_service().set_option(
-        this->get_implementation(), option, ec);
+    this->get_service().set_option(this->get_implementation(), option, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get an option from the socket.
@@ -879,7 +960,7 @@ public:
    * @par Example
    * Getting the value of the SOL_SOCKET/SO_KEEPALIVE option:
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * ...
    * asio::ip::tcp::socket::keep_alive option;
    * socket.get_option(option);
@@ -922,7 +1003,7 @@ public:
    * @par Example
    * Getting the value of the SOL_SOCKET/SO_KEEPALIVE option:
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * ...
    * asio::ip::tcp::socket::keep_alive option;
    * asio::error_code ec;
@@ -935,11 +1016,11 @@ public:
    * @endcode
    */
   template <typename GettableSocketOption>
-  asio::error_code get_option(GettableSocketOption& option,
+  ASIO_SYNC_OP_VOID get_option(GettableSocketOption& option,
       asio::error_code& ec) const
   {
-    return this->get_service().get_option(
-        this->get_implementation(), option, ec);
+    this->get_service().get_option(this->get_implementation(), option, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Perform an IO control command on the socket.
@@ -957,7 +1038,7 @@ public:
    * @par Example
    * Getting the number of bytes ready to read:
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * ...
    * asio::ip::tcp::socket::bytes_readable command;
    * socket.io_control(command);
@@ -987,7 +1068,7 @@ public:
    * @par Example
    * Getting the number of bytes ready to read:
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * ...
    * asio::ip::tcp::socket::bytes_readable command;
    * asio::error_code ec;
@@ -1000,11 +1081,11 @@ public:
    * @endcode
    */
   template <typename IoControlCommand>
-  asio::error_code io_control(IoControlCommand& command,
+  ASIO_SYNC_OP_VOID io_control(IoControlCommand& command,
       asio::error_code& ec)
   {
-    return this->get_service().io_control(
-        this->get_implementation(), command, ec);
+    this->get_service().io_control(this->get_implementation(), command, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Gets the non-blocking mode of the socket.
@@ -1056,11 +1137,11 @@ public:
    * operations. Asynchronous operations will never fail with the error
    * asio::error::would_block.
    */
-  asio::error_code non_blocking(
+  ASIO_SYNC_OP_VOID non_blocking(
       bool mode, asio::error_code& ec)
   {
-    return this->get_service().non_blocking(
-        this->get_implementation(), mode, ec);
+    this->get_service().non_blocking(this->get_implementation(), mode, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Gets the non-blocking mode of the native socket implementation.
@@ -1330,11 +1411,12 @@ public:
    *   sock.async_wait(tcp::socket::wait_write, op);
    * } @endcode
    */
-  asio::error_code native_non_blocking(
+  ASIO_SYNC_OP_VOID native_non_blocking(
       bool mode, asio::error_code& ec)
   {
-    return this->get_service().native_non_blocking(
+    this->get_service().native_non_blocking(
         this->get_implementation(), mode, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the local endpoint of the socket.
@@ -1347,7 +1429,7 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * ...
    * asio::ip::tcp::endpoint endpoint = socket.local_endpoint();
    * @endcode
@@ -1372,7 +1454,7 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * ...
    * asio::error_code ec;
    * asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
@@ -1397,7 +1479,7 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * ...
    * asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();
    * @endcode
@@ -1422,7 +1504,7 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * ...
    * asio::error_code ec;
    * asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
@@ -1449,7 +1531,7 @@ public:
    * @par Example
    * Shutting down the send side of the socket:
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * ...
    * socket.shutdown(asio::ip::tcp::socket::shutdown_send);
    * @endcode
@@ -1473,7 +1555,7 @@ public:
    * @par Example
    * Shutting down the send side of the socket:
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * ...
    * asio::error_code ec;
    * socket.shutdown(asio::ip::tcp::socket::shutdown_send, ec);
@@ -1483,10 +1565,11 @@ public:
    * }
    * @endcode
    */
-  asio::error_code shutdown(shutdown_type what,
+  ASIO_SYNC_OP_VOID shutdown(shutdown_type what,
       asio::error_code& ec)
   {
-    return this->get_service().shutdown(this->get_implementation(), what, ec);
+    this->get_service().shutdown(this->get_implementation(), what, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Wait for the socket to become ready to read, ready to write, or to have
@@ -1500,7 +1583,7 @@ public:
    * @par Example
    * Waiting for a socket to become readable.
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * ...
    * socket.wait(asio::ip::tcp::socket::wait_read);
    * @endcode
@@ -1525,15 +1608,16 @@ public:
    * @par Example
    * Waiting for a socket to become readable.
    * @code
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * ...
    * asio::error_code ec;
    * socket.wait(asio::ip::tcp::socket::wait_read, ec);
    * @endcode
    */
-  asio::error_code wait(wait_type w, asio::error_code& ec)
+  ASIO_SYNC_OP_VOID wait(wait_type w, asio::error_code& ec)
   {
-    return this->get_service().wait(this->get_implementation(), w, ec);
+    this->get_service().wait(this->get_implementation(), w, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Asynchronously wait for the socket to become ready to read, ready to
@@ -1553,7 +1637,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @par Example
    * @code
@@ -1567,7 +1651,7 @@ public:
    *
    * ...
    *
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * ...
    * socket.async_wait(asio::ip::tcp::socket::wait_read, wait_handler);
    * @endcode
@@ -1581,19 +1665,42 @@ public:
     // not meet the documented type requirements for a WaitHandler.
     ASIO_WAIT_HANDLER_CHECK(WaitHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_wait(this->get_implementation(),
         w, ASIO_MOVE_CAST(WaitHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<WaitHandler,
+      void (asio::error_code)> init(handler);
+
+    this->get_service().async_wait(this->get_implementation(),
+        w, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
 protected:
   /// Protected destructor to prevent deletion through this type.
+  /**
+   * This function destroys the socket, cancelling any outstanding asynchronous
+   * operations associated with the socket as if by calling @c cancel.
+   */
   ~basic_socket()
   {
   }
+
+private:
+  // Disallow copying and assignment.
+  basic_socket(const basic_socket&) ASIO_DELETED;
+  basic_socket& operator=(const basic_socket&) ASIO_DELETED;
 };
 
 } // namespace asio
 
 #include "asio/detail/pop_options.hpp"
 
+#if !defined(ASIO_ENABLE_OLD_SERVICES)
+# undef ASIO_SVC_T
+#endif // !defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_BASIC_SOCKET_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_socket_acceptor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_socket_acceptor.hpp
index 5e3109e..9554bb9 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_socket_acceptor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_socket_acceptor.hpp
@@ -2,7 +2,7 @@
 // basic_socket_acceptor.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -22,9 +22,27 @@
 #include "asio/detail/throw_error.hpp"
 #include "asio/detail/type_traits.hpp"
 #include "asio/error.hpp"
-#include "asio/socket_acceptor_service.hpp"
 #include "asio/socket_base.hpp"
 
+#if defined(ASIO_HAS_MOVE)
+# include <utility>
+#endif // defined(ASIO_HAS_MOVE)
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+# include "asio/socket_acceptor_service.hpp"
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+# if defined(ASIO_WINDOWS_RUNTIME)
+#  include "asio/detail/null_socket_service.hpp"
+#  define ASIO_SVC_T detail::null_socket_service<Protocol>
+# elif defined(ASIO_HAS_IOCP)
+#  include "asio/detail/win_iocp_socket_service.hpp"
+#  define ASIO_SVC_T detail::win_iocp_socket_service<Protocol>
+# else
+#  include "asio/detail/reactive_socket_service.hpp"
+#  define ASIO_SVC_T detail::reactive_socket_service<Protocol>
+# endif
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #include "asio/detail/push_options.hpp"
 
 namespace asio {
@@ -41,7 +59,7 @@ namespace asio {
  * @par Example
  * Opening a socket acceptor with the SO_REUSEADDR option enabled:
  * @code
- * asio::ip::tcp::acceptor acceptor(io_service);
+ * asio::ip::tcp::acceptor acceptor(io_context);
  * asio::ip::tcp::endpoint endpoint(asio::ip::tcp::v4(), port);
  * acceptor.open(endpoint.protocol());
  * acceptor.set_option(asio::ip::tcp::acceptor::reuse_address(true));
@@ -49,15 +67,22 @@ namespace asio {
  * acceptor.listen();
  * @endcode
  */
-template <typename Protocol,
-    typename SocketAcceptorService = socket_acceptor_service<Protocol> >
+template <typename Protocol
+    ASIO_SVC_TPARAM_DEF1(= socket_acceptor_service<Protocol>)>
 class basic_socket_acceptor
-  : public basic_io_object<SocketAcceptorService>,
+  : ASIO_SVC_ACCESS basic_io_object<ASIO_SVC_T>,
     public socket_base
 {
 public:
+  /// The type of the executor associated with the object.
+  typedef io_context::executor_type executor_type;
+
   /// The native representation of an acceptor.
-  typedef typename SocketAcceptorService::native_handle_type native_handle_type;
+#if defined(GENERATING_DOCUMENTATION)
+  typedef implementation_defined native_handle_type;
+#else
+  typedef typename ASIO_SVC_T::native_handle_type native_handle_type;
+#endif
 
   /// The protocol type.
   typedef Protocol protocol_type;
@@ -71,12 +96,12 @@ public:
    * connections. The open() function must be called before the acceptor can
    * accept new socket connections.
    *
-   * @param io_service The io_service object that the acceptor will use to
+   * @param io_context The io_context object that the acceptor will use to
    * dispatch handlers for any asynchronous operations performed on the
    * acceptor.
    */
-  explicit basic_socket_acceptor(asio::io_service& io_service)
-    : basic_io_object<SocketAcceptorService>(io_service)
+  explicit basic_socket_acceptor(asio::io_context& io_context)
+    : basic_io_object<ASIO_SVC_T>(io_context)
   {
   }
 
@@ -84,7 +109,7 @@ public:
   /**
    * This constructor creates an acceptor and automatically opens it.
    *
-   * @param io_service The io_service object that the acceptor will use to
+   * @param io_context The io_context object that the acceptor will use to
    * dispatch handlers for any asynchronous operations performed on the
    * acceptor.
    *
@@ -92,9 +117,9 @@ public:
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_socket_acceptor(asio::io_service& io_service,
+  basic_socket_acceptor(asio::io_context& io_context,
       const protocol_type& protocol)
-    : basic_io_object<SocketAcceptorService>(io_service)
+    : basic_io_object<ASIO_SVC_T>(io_context)
   {
     asio::error_code ec;
     this->get_service().open(this->get_implementation(), protocol, ec);
@@ -106,7 +131,7 @@ public:
    * This constructor creates an acceptor and automatically opens it to listen
    * for new connections on the specified endpoint.
    *
-   * @param io_service The io_service object that the acceptor will use to
+   * @param io_context The io_context object that the acceptor will use to
    * dispatch handlers for any asynchronous operations performed on the
    * acceptor.
    *
@@ -120,7 +145,7 @@ public:
    *
    * @note This constructor is equivalent to the following code:
    * @code
-   * basic_socket_acceptor<Protocol> acceptor(io_service);
+   * basic_socket_acceptor<Protocol> acceptor(io_context);
    * acceptor.open(endpoint.protocol());
    * if (reuse_addr)
    *   acceptor.set_option(socket_base::reuse_address(true));
@@ -128,9 +153,9 @@ public:
    * acceptor.listen(listen_backlog);
    * @endcode
    */
-  basic_socket_acceptor(asio::io_service& io_service,
+  basic_socket_acceptor(asio::io_context& io_context,
       const endpoint_type& endpoint, bool reuse_addr = true)
-    : basic_io_object<SocketAcceptorService>(io_service)
+    : basic_io_object<ASIO_SVC_T>(io_context)
   {
     asio::error_code ec;
     const protocol_type protocol = endpoint.protocol();
@@ -145,7 +170,7 @@ public:
     this->get_service().bind(this->get_implementation(), endpoint, ec);
     asio::detail::throw_error(ec, "bind");
     this->get_service().listen(this->get_implementation(),
-        socket_base::max_connections, ec);
+        socket_base::max_listen_connections, ec);
     asio::detail::throw_error(ec, "listen");
   }
 
@@ -154,7 +179,7 @@ public:
    * This constructor creates an acceptor object to hold an existing native
    * acceptor.
    *
-   * @param io_service The io_service object that the acceptor will use to
+   * @param io_context The io_context object that the acceptor will use to
    * dispatch handlers for any asynchronous operations performed on the
    * acceptor.
    *
@@ -164,9 +189,9 @@ public:
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_socket_acceptor(asio::io_service& io_service,
+  basic_socket_acceptor(asio::io_context& io_context,
       const protocol_type& protocol, const native_handle_type& native_acceptor)
-    : basic_io_object<SocketAcceptorService>(io_service)
+    : basic_io_object<ASIO_SVC_T>(io_context)
   {
     asio::error_code ec;
     this->get_service().assign(this->get_implementation(),
@@ -183,11 +208,10 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_socket_acceptor(io_service&) constructor.
+   * constructed using the @c basic_socket_acceptor(io_context&) constructor.
    */
   basic_socket_acceptor(basic_socket_acceptor&& other)
-    : basic_io_object<SocketAcceptorService>(
-        ASIO_MOVE_CAST(basic_socket_acceptor)(other))
+    : basic_io_object<ASIO_SVC_T>(std::move(other))
   {
   }
 
@@ -199,17 +223,16 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_socket_acceptor(io_service&) constructor.
+   * constructed using the @c basic_socket_acceptor(io_context&) constructor.
    */
   basic_socket_acceptor& operator=(basic_socket_acceptor&& other)
   {
-    basic_io_object<SocketAcceptorService>::operator=(
-        ASIO_MOVE_CAST(basic_socket_acceptor)(other));
+    basic_io_object<ASIO_SVC_T>::operator=(std::move(other));
     return *this;
   }
 
   // All socket acceptors have access to each other's implementations.
-  template <typename Protocol1, typename SocketAcceptorService1>
+  template <typename Protocol1 ASIO_SVC_TPARAM1>
   friend class basic_socket_acceptor;
 
   /// Move-construct a basic_socket_acceptor from an acceptor of another
@@ -221,14 +244,14 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_socket(io_service&) constructor.
+   * constructed using the @c basic_socket(io_context&) constructor.
    */
-  template <typename Protocol1, typename SocketAcceptorService1>
+  template <typename Protocol1 ASIO_SVC_TPARAM1>
   basic_socket_acceptor(
-      basic_socket_acceptor<Protocol1, SocketAcceptorService1>&& other,
+      basic_socket_acceptor<Protocol1 ASIO_SVC_TARG1>&& other,
       typename enable_if<is_convertible<Protocol1, Protocol>::value>::type* = 0)
-    : basic_io_object<SocketAcceptorService>(
-        other.get_service().get_io_service())
+    : basic_io_object<ASIO_SVC_T>(
+        other.get_service().get_io_context())
   {
     this->get_service().template converting_move_construct<Protocol1>(
         this->get_implementation(), other.get_implementation());
@@ -243,21 +266,69 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_socket(io_service&) constructor.
+   * constructed using the @c basic_socket(io_context&) constructor.
    */
-  template <typename Protocol1, typename SocketAcceptorService1>
+  template <typename Protocol1 ASIO_SVC_TPARAM1>
   typename enable_if<is_convertible<Protocol1, Protocol>::value,
       basic_socket_acceptor>::type& operator=(
-        basic_socket_acceptor<Protocol1, SocketAcceptorService1>&& other)
+        basic_socket_acceptor<Protocol1 ASIO_SVC_TARG1>&& other)
   {
-    basic_socket_acceptor tmp(ASIO_MOVE_CAST2(basic_socket_acceptor<
-            Protocol1, SocketAcceptorService1>)(other));
-    basic_io_object<SocketAcceptorService>::operator=(
-        ASIO_MOVE_CAST(basic_socket_acceptor)(tmp));
+    basic_socket_acceptor tmp(std::move(other));
+    basic_io_object<ASIO_SVC_T>::operator=(std::move(tmp));
     return *this;
   }
 #endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
 
+  /// Destroys the acceptor.
+  /**
+   * This function destroys the acceptor, cancelling any outstanding
+   * asynchronous operations associated with the acceptor as if by calling
+   * @c cancel.
+   */
+  ~basic_socket_acceptor()
+  {
+  }
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+  // These functions are provided by basic_io_object<>.
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_context()
+  {
+    return basic_io_object<ASIO_SVC_T>::get_io_context();
+  }
+
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_service()
+  {
+    return basic_io_object<ASIO_SVC_T>::get_io_service();
+  }
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// Get the executor associated with the object.
+  executor_type get_executor() ASIO_NOEXCEPT
+  {
+    return basic_io_object<ASIO_SVC_T>::get_executor();
+  }
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
   /// Open the acceptor using the specified protocol.
   /**
    * This function opens the socket acceptor so that it will use the specified
@@ -269,7 +340,7 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * acceptor.open(asio::ip::tcp::v4());
    * @endcode
    */
@@ -291,7 +362,7 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * asio::error_code ec;
    * acceptor.open(asio::ip::tcp::v4(), ec);
    * if (ec)
@@ -300,10 +371,11 @@ public:
    * }
    * @endcode
    */
-  asio::error_code open(const protocol_type& protocol,
+  ASIO_SYNC_OP_VOID open(const protocol_type& protocol,
       asio::error_code& ec)
   {
-    return this->get_service().open(this->get_implementation(), protocol, ec);
+    this->get_service().open(this->get_implementation(), protocol, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Assigns an existing native acceptor to the acceptor.
@@ -335,11 +407,12 @@ public:
    *
    * @param ec Set to indicate what error occurred, if any.
    */
-  asio::error_code assign(const protocol_type& protocol,
+  ASIO_SYNC_OP_VOID assign(const protocol_type& protocol,
       const native_handle_type& native_acceptor, asio::error_code& ec)
   {
-    return this->get_service().assign(this->get_implementation(),
+    this->get_service().assign(this->get_implementation(),
         protocol, native_acceptor, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Determine whether the acceptor is open.
@@ -360,7 +433,7 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * asio::ip::tcp::endpoint endpoint(asio::ip::tcp::v4(), 12345);
    * acceptor.open(endpoint.protocol());
    * acceptor.bind(endpoint);
@@ -385,7 +458,7 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * asio::ip::tcp::endpoint endpoint(asio::ip::tcp::v4(), 12345);
    * acceptor.open(endpoint.protocol());
    * asio::error_code ec;
@@ -396,10 +469,11 @@ public:
    * }
    * @endcode
    */
-  asio::error_code bind(const endpoint_type& endpoint,
+  ASIO_SYNC_OP_VOID bind(const endpoint_type& endpoint,
       asio::error_code& ec)
   {
-    return this->get_service().bind(this->get_implementation(), endpoint, ec);
+    this->get_service().bind(this->get_implementation(), endpoint, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Place the acceptor into the state where it will listen for new
@@ -412,7 +486,7 @@ public:
    *
    * @throws asio::system_error Thrown on failure.
    */
-  void listen(int backlog = socket_base::max_connections)
+  void listen(int backlog = socket_base::max_listen_connections)
   {
     asio::error_code ec;
     this->get_service().listen(this->get_implementation(), backlog, ec);
@@ -431,19 +505,20 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * ...
    * asio::error_code ec;
-   * acceptor.listen(asio::socket_base::max_connections, ec);
+   * acceptor.listen(asio::socket_base::max_listen_connections, ec);
    * if (ec)
    * {
    *   // An error occurred.
    * }
    * @endcode
    */
-  asio::error_code listen(int backlog, asio::error_code& ec)
+  ASIO_SYNC_OP_VOID listen(int backlog, asio::error_code& ec)
   {
-    return this->get_service().listen(this->get_implementation(), backlog, ec);
+    this->get_service().listen(this->get_implementation(), backlog, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Close the acceptor.
@@ -475,7 +550,7 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * ...
    * asio::error_code ec;
    * acceptor.close(ec);
@@ -485,9 +560,10 @@ public:
    * }
    * @endcode
    */
-  asio::error_code close(asio::error_code& ec)
+  ASIO_SYNC_OP_VOID close(asio::error_code& ec)
   {
-    return this->get_service().close(this->get_implementation(), ec);
+    this->get_service().close(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the native acceptor representation.
@@ -524,9 +600,10 @@ public:
    *
    * @param ec Set to indicate what error occurred, if any.
    */
-  asio::error_code cancel(asio::error_code& ec)
+  ASIO_SYNC_OP_VOID cancel(asio::error_code& ec)
   {
-    return this->get_service().cancel(this->get_implementation(), ec);
+    this->get_service().cancel(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Set an option on the acceptor.
@@ -544,7 +621,7 @@ public:
    * @par Example
    * Setting the SOL_SOCKET/SO_REUSEADDR option:
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * ...
    * asio::ip::tcp::acceptor::reuse_address option(true);
    * acceptor.set_option(option);
@@ -573,7 +650,7 @@ public:
    * @par Example
    * Setting the SOL_SOCKET/SO_REUSEADDR option:
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * ...
    * asio::ip::tcp::acceptor::reuse_address option(true);
    * asio::error_code ec;
@@ -585,11 +662,11 @@ public:
    * @endcode
    */
   template <typename SettableSocketOption>
-  asio::error_code set_option(const SettableSocketOption& option,
+  ASIO_SYNC_OP_VOID set_option(const SettableSocketOption& option,
       asio::error_code& ec)
   {
-    return this->get_service().set_option(
-        this->get_implementation(), option, ec);
+    this->get_service().set_option(this->get_implementation(), option, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get an option from the acceptor.
@@ -607,7 +684,7 @@ public:
    * @par Example
    * Getting the value of the SOL_SOCKET/SO_REUSEADDR option:
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * ...
    * asio::ip::tcp::acceptor::reuse_address option;
    * acceptor.get_option(option);
@@ -637,7 +714,7 @@ public:
    * @par Example
    * Getting the value of the SOL_SOCKET/SO_REUSEADDR option:
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * ...
    * asio::ip::tcp::acceptor::reuse_address option;
    * asio::error_code ec;
@@ -650,11 +727,11 @@ public:
    * @endcode
    */
   template <typename GettableSocketOption>
-  asio::error_code get_option(GettableSocketOption& option,
+  ASIO_SYNC_OP_VOID get_option(GettableSocketOption& option,
       asio::error_code& ec)
   {
-    return this->get_service().get_option(
-        this->get_implementation(), option, ec);
+    this->get_service().get_option(this->get_implementation(), option, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Perform an IO control command on the acceptor.
@@ -671,7 +748,7 @@ public:
    * @par Example
    * Getting the number of bytes ready to read:
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * ...
    * asio::ip::tcp::acceptor::non_blocking_io command(true);
    * socket.io_control(command);
@@ -699,7 +776,7 @@ public:
    * @par Example
    * Getting the number of bytes ready to read:
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * ...
    * asio::ip::tcp::acceptor::non_blocking_io command(true);
    * asio::error_code ec;
@@ -711,11 +788,11 @@ public:
    * @endcode
    */
   template <typename IoControlCommand>
-  asio::error_code io_control(IoControlCommand& command,
+  ASIO_SYNC_OP_VOID io_control(IoControlCommand& command,
       asio::error_code& ec)
   {
-    return this->get_service().io_control(
-        this->get_implementation(), command, ec);
+    this->get_service().io_control(this->get_implementation(), command, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Gets the non-blocking mode of the acceptor.
@@ -767,11 +844,11 @@ public:
    * operations. Asynchronous operations will never fail with the error
    * asio::error::would_block.
    */
-  asio::error_code non_blocking(
+  ASIO_SYNC_OP_VOID non_blocking(
       bool mode, asio::error_code& ec)
   {
-    return this->get_service().non_blocking(
-        this->get_implementation(), mode, ec);
+    this->get_service().non_blocking(this->get_implementation(), mode, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Gets the non-blocking mode of the native acceptor implementation.
@@ -831,11 +908,12 @@ public:
    * function fails with asio::error::invalid_argument, as the
    * combination does not make sense.
    */
-  asio::error_code native_non_blocking(
+  ASIO_SYNC_OP_VOID native_non_blocking(
       bool mode, asio::error_code& ec)
   {
-    return this->get_service().native_non_blocking(
+    this->get_service().native_non_blocking(
         this->get_implementation(), mode, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the local endpoint of the acceptor.
@@ -848,7 +926,7 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * ...
    * asio::ip::tcp::endpoint endpoint = acceptor.local_endpoint();
    * @endcode
@@ -874,7 +952,7 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * ...
    * asio::error_code ec;
    * asio::ip::tcp::endpoint endpoint = acceptor.local_endpoint(ec);
@@ -900,7 +978,7 @@ public:
    * @par Example
    * Waiting for an acceptor to become readable.
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * ...
    * acceptor.wait(asio::ip::tcp::acceptor::wait_read);
    * @endcode
@@ -925,15 +1003,16 @@ public:
    * @par Example
    * Waiting for an acceptor to become readable.
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * ...
    * asio::error_code ec;
    * acceptor.wait(asio::ip::tcp::acceptor::wait_read, ec);
    * @endcode
    */
-  asio::error_code wait(wait_type w, asio::error_code& ec)
+  ASIO_SYNC_OP_VOID wait(wait_type w, asio::error_code& ec)
   {
-    return this->get_service().wait(this->get_implementation(), w, ec);
+    this->get_service().wait(this->get_implementation(), w, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Asynchronously wait for the acceptor to become ready to read, ready to
@@ -953,7 +1032,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @par Example
    * @code
@@ -967,7 +1046,7 @@ public:
    *
    * ...
    *
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * ...
    * acceptor.async_wait(
    *     asio::ip::tcp::acceptor::wait_read,
@@ -983,10 +1062,21 @@ public:
     // not meet the documented type requirements for a WaitHandler.
     ASIO_WAIT_HANDLER_CHECK(WaitHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_wait(this->get_implementation(),
         w, ASIO_MOVE_CAST(WaitHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<WaitHandler,
+      void (asio::error_code)> init(handler);
+
+    this->get_service().async_wait(this->get_implementation(),
+        w, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
+#if !defined(ASIO_NO_EXTENSIONS)
   /// Accept a new connection.
   /**
    * This function is used to accept a new connection from a peer into the
@@ -999,15 +1089,21 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * ...
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * acceptor.accept(socket);
    * @endcode
    */
+#if defined(ASIO_ENABLE_OLD_SERVICES)
   template <typename Protocol1, typename SocketService>
   void accept(basic_socket<Protocol1, SocketService>& peer,
       typename enable_if<is_convertible<Protocol, Protocol1>::value>::type* = 0)
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+  template <typename Protocol1>
+  void accept(basic_socket<Protocol1>& peer,
+      typename enable_if<is_convertible<Protocol, Protocol1>::value>::type* = 0)
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   {
     asio::error_code ec;
     this->get_service().accept(this->get_implementation(),
@@ -1027,9 +1123,9 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * ...
-   * asio::ip::tcp::soocket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * asio::error_code ec;
    * acceptor.accept(socket, ec);
    * if (ec)
@@ -1038,14 +1134,22 @@ public:
    * }
    * @endcode
    */
+#if defined(ASIO_ENABLE_OLD_SERVICES)
   template <typename Protocol1, typename SocketService>
-  asio::error_code accept(
+  ASIO_SYNC_OP_VOID accept(
       basic_socket<Protocol1, SocketService>& peer,
       asio::error_code& ec,
       typename enable_if<is_convertible<Protocol, Protocol1>::value>::type* = 0)
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+  template <typename Protocol1>
+  ASIO_SYNC_OP_VOID accept(
+      basic_socket<Protocol1>& peer, asio::error_code& ec,
+      typename enable_if<is_convertible<Protocol, Protocol1>::value>::type* = 0)
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   {
-    return this->get_service().accept(this->get_implementation(),
+    this->get_service().accept(this->get_implementation(),
         peer, static_cast<endpoint_type*>(0), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Start an asynchronous accept.
@@ -1066,7 +1170,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @par Example
    * @code
@@ -1080,26 +1184,45 @@ public:
    *
    * ...
    *
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * ...
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * acceptor.async_accept(socket, accept_handler);
    * @endcode
    */
+#if defined(ASIO_ENABLE_OLD_SERVICES)
   template <typename Protocol1, typename SocketService, typename AcceptHandler>
   ASIO_INITFN_RESULT_TYPE(AcceptHandler,
       void (asio::error_code))
   async_accept(basic_socket<Protocol1, SocketService>& peer,
       ASIO_MOVE_ARG(AcceptHandler) handler,
       typename enable_if<is_convertible<Protocol, Protocol1>::value>::type* = 0)
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+  template <typename Protocol1, typename AcceptHandler>
+  ASIO_INITFN_RESULT_TYPE(AcceptHandler,
+      void (asio::error_code))
+  async_accept(basic_socket<Protocol1>& peer,
+      ASIO_MOVE_ARG(AcceptHandler) handler,
+      typename enable_if<is_convertible<Protocol, Protocol1>::value>::type* = 0)
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   {
     // If you get an error on the following line it means that your handler does
     // not meet the documented type requirements for a AcceptHandler.
     ASIO_ACCEPT_HANDLER_CHECK(AcceptHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_accept(this->get_implementation(),
         peer, static_cast<endpoint_type*>(0),
         ASIO_MOVE_CAST(AcceptHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<AcceptHandler,
+      void (asio::error_code)> init(handler);
+
+    this->get_service().async_accept(this->get_implementation(),
+        peer, static_cast<endpoint_type*>(0), init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Accept a new connection and obtain the endpoint of the peer
@@ -1118,16 +1241,20 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * ...
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * asio::ip::tcp::endpoint endpoint;
    * acceptor.accept(socket, endpoint);
    * @endcode
    */
+#if defined(ASIO_ENABLE_OLD_SERVICES)
   template <typename SocketService>
   void accept(basic_socket<protocol_type, SocketService>& peer,
       endpoint_type& peer_endpoint)
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+  void accept(basic_socket<protocol_type>& peer, endpoint_type& peer_endpoint)
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   {
     asio::error_code ec;
     this->get_service().accept(this->get_implementation(),
@@ -1151,9 +1278,9 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
+   * asio::ip::tcp::acceptor acceptor(io_context);
    * ...
-   * asio::ip::tcp::socket socket(io_service);
+   * asio::ip::tcp::socket socket(io_context);
    * asio::ip::tcp::endpoint endpoint;
    * asio::error_code ec;
    * acceptor.accept(socket, endpoint, ec);
@@ -1163,13 +1290,19 @@ public:
    * }
    * @endcode
    */
+#if defined(ASIO_ENABLE_OLD_SERVICES)
   template <typename SocketService>
-  asio::error_code accept(
+  ASIO_SYNC_OP_VOID accept(
       basic_socket<protocol_type, SocketService>& peer,
       endpoint_type& peer_endpoint, asio::error_code& ec)
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+  ASIO_SYNC_OP_VOID accept(basic_socket<protocol_type>& peer,
+      endpoint_type& peer_endpoint, asio::error_code& ec)
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   {
-    return this->get_service().accept(
+    this->get_service().accept(
         this->get_implementation(), peer, &peer_endpoint, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Start an asynchronous accept.
@@ -1196,25 +1329,608 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    */
+#if defined(ASIO_ENABLE_OLD_SERVICES)
   template <typename SocketService, typename AcceptHandler>
   ASIO_INITFN_RESULT_TYPE(AcceptHandler,
       void (asio::error_code))
   async_accept(basic_socket<protocol_type, SocketService>& peer,
       endpoint_type& peer_endpoint, ASIO_MOVE_ARG(AcceptHandler) handler)
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+  template <typename AcceptHandler>
+  ASIO_INITFN_RESULT_TYPE(AcceptHandler,
+      void (asio::error_code))
+  async_accept(basic_socket<protocol_type>& peer,
+      endpoint_type& peer_endpoint, ASIO_MOVE_ARG(AcceptHandler) handler)
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   {
     // If you get an error on the following line it means that your handler does
     // not meet the documented type requirements for a AcceptHandler.
     ASIO_ACCEPT_HANDLER_CHECK(AcceptHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_accept(this->get_implementation(), peer,
         &peer_endpoint, ASIO_MOVE_CAST(AcceptHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<AcceptHandler,
+      void (asio::error_code)> init(handler);
+
+    this->get_service().async_accept(this->get_implementation(),
+        peer, &peer_endpoint, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+  }
+#endif // !defined(ASIO_NO_EXTENSIONS)
+
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+  /// Accept a new connection.
+  /**
+   * This function is used to accept a new connection from a peer. The function
+   * call will block until a new connection has been accepted successfully or
+   * an error occurs.
+   *
+   * This overload requires that the Protocol template parameter satisfy the
+   * AcceptableProtocol type requirements.
+   *
+   * @returns A socket object representing the newly accepted connection.
+   *
+   * @throws asio::system_error Thrown on failure.
+   *
+   * @par Example
+   * @code
+   * asio::ip::tcp::acceptor acceptor(io_context);
+   * ...
+   * asio::ip::tcp::socket socket(acceptor.accept());
+   * @endcode
+   */
+  typename Protocol::socket accept()
+  {
+    asio::error_code ec;
+    typename Protocol::socket peer(
+        this->get_service().accept(
+          this->get_implementation(), 0, 0, ec));
+    asio::detail::throw_error(ec, "accept");
+    return peer;
+  }
+
+  /// Accept a new connection.
+  /**
+   * This function is used to accept a new connection from a peer. The function
+   * call will block until a new connection has been accepted successfully or
+   * an error occurs.
+   *
+   * This overload requires that the Protocol template parameter satisfy the
+   * AcceptableProtocol type requirements.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @returns On success, a socket object representing the newly accepted
+   * connection. On error, a socket object where is_open() is false.
+   *
+   * @par Example
+   * @code
+   * asio::ip::tcp::acceptor acceptor(io_context);
+   * ...
+   * asio::ip::tcp::socket socket(acceptor.accept(ec));
+   * if (ec)
+   * {
+   *   // An error occurred.
+   * }
+   * @endcode
+   */
+  typename Protocol::socket accept(asio::error_code& ec)
+  {
+    return this->get_service().accept(this->get_implementation(), 0, 0, ec);
+  }
+
+  /// Start an asynchronous accept.
+  /**
+   * This function is used to asynchronously accept a new connection. The
+   * function call always returns immediately.
+   *
+   * This overload requires that the Protocol template parameter satisfy the
+   * AcceptableProtocol type requirements.
+   *
+   * @param handler The handler to be called when the accept operation
+   * completes. Copies will be made of the handler as required. The function
+   * signature of the handler must be:
+   * @code void handler(
+   *   const asio::error_code& error, // Result of operation.
+   *   typename Protocol::socket peer // On success, the newly accepted socket.
+   * ); @endcode
+   * Regardless of whether the asynchronous operation completes immediately or
+   * not, the handler will not be invoked from within this function. Invocation
+   * of the handler will be performed in a manner equivalent to using
+   * asio::io_context::post().
+   *
+   * @par Example
+   * @code
+   * void accept_handler(const asio::error_code& error,
+   *     asio::ip::tcp::socket peer)
+   * {
+   *   if (!error)
+   *   {
+   *     // Accept succeeded.
+   *   }
+   * }
+   *
+   * ...
+   *
+   * asio::ip::tcp::acceptor acceptor(io_context);
+   * ...
+   * acceptor.async_accept(accept_handler);
+   * @endcode
+   */
+  template <typename MoveAcceptHandler>
+  ASIO_INITFN_RESULT_TYPE(MoveAcceptHandler,
+      void (asio::error_code, typename Protocol::socket))
+  async_accept(ASIO_MOVE_ARG(MoveAcceptHandler) handler)
+  {
+    // If you get an error on the following line it means that your handler does
+    // not meet the documented type requirements for a MoveAcceptHandler.
+    ASIO_MOVE_ACCEPT_HANDLER_CHECK(MoveAcceptHandler,
+        handler, typename Protocol::socket) type_check;
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+    return this->get_service().async_accept(
+        this->get_implementation(), static_cast<asio::io_context*>(0),
+        static_cast<endpoint_type*>(0),
+        ASIO_MOVE_CAST(MoveAcceptHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<MoveAcceptHandler,
+      void (asio::error_code,
+        typename Protocol::socket)> init(handler);
+
+    this->get_service().async_accept(
+        this->get_implementation(), static_cast<asio::io_context*>(0),
+        static_cast<endpoint_type*>(0), init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+  }
+
+  /// Accept a new connection.
+  /**
+   * This function is used to accept a new connection from a peer. The function
+   * call will block until a new connection has been accepted successfully or
+   * an error occurs.
+   *
+   * This overload requires that the Protocol template parameter satisfy the
+   * AcceptableProtocol type requirements.
+   *
+   * @param io_context The io_context object to be used for the newly accepted
+   * socket.
+   *
+   * @returns A socket object representing the newly accepted connection.
+   *
+   * @throws asio::system_error Thrown on failure.
+   *
+   * @par Example
+   * @code
+   * asio::ip::tcp::acceptor acceptor(io_context);
+   * ...
+   * asio::ip::tcp::socket socket(acceptor.accept());
+   * @endcode
+   */
+  typename Protocol::socket accept(asio::io_context& io_context)
+  {
+    asio::error_code ec;
+    typename Protocol::socket peer(
+        this->get_service().accept(this->get_implementation(),
+          &io_context, static_cast<endpoint_type*>(0), ec));
+    asio::detail::throw_error(ec, "accept");
+    return peer;
+  }
+
+  /// Accept a new connection.
+  /**
+   * This function is used to accept a new connection from a peer. The function
+   * call will block until a new connection has been accepted successfully or
+   * an error occurs.
+   *
+   * This overload requires that the Protocol template parameter satisfy the
+   * AcceptableProtocol type requirements.
+   *
+   * @param io_context The io_context object to be used for the newly accepted
+   * socket.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @returns On success, a socket object representing the newly accepted
+   * connection. On error, a socket object where is_open() is false.
+   *
+   * @par Example
+   * @code
+   * asio::ip::tcp::acceptor acceptor(io_context);
+   * ...
+   * asio::ip::tcp::socket socket(acceptor.accept(io_context2, ec));
+   * if (ec)
+   * {
+   *   // An error occurred.
+   * }
+   * @endcode
+   */
+  typename Protocol::socket accept(
+      asio::io_context& io_context, asio::error_code& ec)
+  {
+    return this->get_service().accept(this->get_implementation(),
+        &io_context, static_cast<endpoint_type*>(0), ec);
+  }
+
+  /// Start an asynchronous accept.
+  /**
+   * This function is used to asynchronously accept a new connection. The
+   * function call always returns immediately.
+   *
+   * This overload requires that the Protocol template parameter satisfy the
+   * AcceptableProtocol type requirements.
+   *
+   * @param io_context The io_context object to be used for the newly accepted
+   * socket.
+   *
+   * @param handler The handler to be called when the accept operation
+   * completes. Copies will be made of the handler as required. The function
+   * signature of the handler must be:
+   * @code void handler(
+   *   const asio::error_code& error, // Result of operation.
+   *   typename Protocol::socket peer // On success, the newly accepted socket.
+   * ); @endcode
+   * Regardless of whether the asynchronous operation completes immediately or
+   * not, the handler will not be invoked from within this function. Invocation
+   * of the handler will be performed in a manner equivalent to using
+   * asio::io_context::post().
+   *
+   * @par Example
+   * @code
+   * void accept_handler(const asio::error_code& error,
+   *     asio::ip::tcp::socket peer)
+   * {
+   *   if (!error)
+   *   {
+   *     // Accept succeeded.
+   *   }
+   * }
+   *
+   * ...
+   *
+   * asio::ip::tcp::acceptor acceptor(io_context);
+   * ...
+   * acceptor.async_accept(io_context2, accept_handler);
+   * @endcode
+   */
+  template <typename MoveAcceptHandler>
+  ASIO_INITFN_RESULT_TYPE(MoveAcceptHandler,
+      void (asio::error_code, typename Protocol::socket))
+  async_accept(asio::io_context& io_context,
+      ASIO_MOVE_ARG(MoveAcceptHandler) handler)
+  {
+    // If you get an error on the following line it means that your handler does
+    // not meet the documented type requirements for a MoveAcceptHandler.
+    ASIO_MOVE_ACCEPT_HANDLER_CHECK(MoveAcceptHandler,
+        handler, typename Protocol::socket) type_check;
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+    return this->get_service().async_accept(this->get_implementation(),
+        &io_context, static_cast<endpoint_type*>(0),
+        ASIO_MOVE_CAST(MoveAcceptHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<MoveAcceptHandler,
+      void (asio::error_code,
+        typename Protocol::socket)> init(handler);
+
+    this->get_service().async_accept(this->get_implementation(),
+        &io_context, static_cast<endpoint_type*>(0), init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+  }
+
+  /// Accept a new connection.
+  /**
+   * This function is used to accept a new connection from a peer. The function
+   * call will block until a new connection has been accepted successfully or
+   * an error occurs.
+   *
+   * This overload requires that the Protocol template parameter satisfy the
+   * AcceptableProtocol type requirements.
+   *
+   * @param peer_endpoint An endpoint object into which the endpoint of the
+   * remote peer will be written.
+   *
+   * @returns A socket object representing the newly accepted connection.
+   *
+   * @throws asio::system_error Thrown on failure.
+   *
+   * @par Example
+   * @code
+   * asio::ip::tcp::acceptor acceptor(io_context);
+   * ...
+   * asio::ip::tcp::endpoint endpoint;
+   * asio::ip::tcp::socket socket(acceptor.accept(endpoint));
+   * @endcode
+   */
+  typename Protocol::socket accept(endpoint_type& peer_endpoint)
+  {
+    asio::error_code ec;
+    typename Protocol::socket peer(
+        this->get_service().accept(this->get_implementation(),
+          static_cast<asio::io_context*>(0), &peer_endpoint, ec));
+    asio::detail::throw_error(ec, "accept");
+    return peer;
   }
+
+  /// Accept a new connection.
+  /**
+   * This function is used to accept a new connection from a peer. The function
+   * call will block until a new connection has been accepted successfully or
+   * an error occurs.
+   *
+   * This overload requires that the Protocol template parameter satisfy the
+   * AcceptableProtocol type requirements.
+   *
+   * @param peer_endpoint An endpoint object into which the endpoint of the
+   * remote peer will be written.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @returns On success, a socket object representing the newly accepted
+   * connection. On error, a socket object where is_open() is false.
+   *
+   * @par Example
+   * @code
+   * asio::ip::tcp::acceptor acceptor(io_context);
+   * ...
+   * asio::ip::tcp::endpoint endpoint;
+   * asio::ip::tcp::socket socket(acceptor.accept(endpoint, ec));
+   * if (ec)
+   * {
+   *   // An error occurred.
+   * }
+   * @endcode
+   */
+  typename Protocol::socket accept(
+      endpoint_type& peer_endpoint, asio::error_code& ec)
+  {
+    return this->get_service().accept(this->get_implementation(),
+        static_cast<asio::io_context*>(0), &peer_endpoint, ec);
+  }
+
+  /// Start an asynchronous accept.
+  /**
+   * This function is used to asynchronously accept a new connection. The
+   * function call always returns immediately.
+   *
+   * This overload requires that the Protocol template parameter satisfy the
+   * AcceptableProtocol type requirements.
+   *
+   * @param peer_endpoint An endpoint object into which the endpoint of the
+   * remote peer will be written. Ownership of the peer_endpoint object is
+   * retained by the caller, which must guarantee that it is valid until the
+   * handler is called.
+   *
+   * @param handler The handler to be called when the accept operation
+   * completes. Copies will be made of the handler as required. The function
+   * signature of the handler must be:
+   * @code void handler(
+   *   const asio::error_code& error, // Result of operation.
+   *   typename Protocol::socket peer // On success, the newly accepted socket.
+   * ); @endcode
+   * Regardless of whether the asynchronous operation completes immediately or
+   * not, the handler will not be invoked from within this function. Invocation
+   * of the handler will be performed in a manner equivalent to using
+   * asio::io_context::post().
+   *
+   * @par Example
+   * @code
+   * void accept_handler(const asio::error_code& error,
+   *     asio::ip::tcp::socket peer)
+   * {
+   *   if (!error)
+   *   {
+   *     // Accept succeeded.
+   *   }
+   * }
+   *
+   * ...
+   *
+   * asio::ip::tcp::acceptor acceptor(io_context);
+   * ...
+   * asio::ip::tcp::endpoint endpoint;
+   * acceptor.async_accept(endpoint, accept_handler);
+   * @endcode
+   */
+  template <typename MoveAcceptHandler>
+  ASIO_INITFN_RESULT_TYPE(MoveAcceptHandler,
+      void (asio::error_code, typename Protocol::socket))
+  async_accept(endpoint_type& peer_endpoint,
+      ASIO_MOVE_ARG(MoveAcceptHandler) handler)
+  {
+    // If you get an error on the following line it means that your handler does
+    // not meet the documented type requirements for a MoveAcceptHandler.
+    ASIO_MOVE_ACCEPT_HANDLER_CHECK(MoveAcceptHandler,
+        handler, typename Protocol::socket) type_check;
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+    return this->get_service().async_accept(this->get_implementation(),
+        static_cast<asio::io_context*>(0), &peer_endpoint,
+        ASIO_MOVE_CAST(MoveAcceptHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<MoveAcceptHandler,
+      void (asio::error_code,
+        typename Protocol::socket)> init(handler);
+
+    this->get_service().async_accept(this->get_implementation(),
+        static_cast<asio::io_context*>(0), &peer_endpoint,
+        init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+  }
+
+  /// Accept a new connection.
+  /**
+   * This function is used to accept a new connection from a peer. The function
+   * call will block until a new connection has been accepted successfully or
+   * an error occurs.
+   *
+   * This overload requires that the Protocol template parameter satisfy the
+   * AcceptableProtocol type requirements.
+   *
+   * @param io_context The io_context object to be used for the newly accepted
+   * socket.
+   *
+   * @param peer_endpoint An endpoint object into which the endpoint of the
+   * remote peer will be written.
+   *
+   * @returns A socket object representing the newly accepted connection.
+   *
+   * @throws asio::system_error Thrown on failure.
+   *
+   * @par Example
+   * @code
+   * asio::ip::tcp::acceptor acceptor(io_context);
+   * ...
+   * asio::ip::tcp::endpoint endpoint;
+   * asio::ip::tcp::socket socket(
+   *     acceptor.accept(io_context2, endpoint));
+   * @endcode
+   */
+  typename Protocol::socket accept(
+      asio::io_context& io_context, endpoint_type& peer_endpoint)
+  {
+    asio::error_code ec;
+    typename Protocol::socket peer(
+        this->get_service().accept(this->get_implementation(),
+          &io_context, &peer_endpoint, ec));
+    asio::detail::throw_error(ec, "accept");
+    return peer;
+  }
+
+  /// Accept a new connection.
+  /**
+   * This function is used to accept a new connection from a peer. The function
+   * call will block until a new connection has been accepted successfully or
+   * an error occurs.
+   *
+   * This overload requires that the Protocol template parameter satisfy the
+   * AcceptableProtocol type requirements.
+   *
+   * @param io_context The io_context object to be used for the newly accepted
+   * socket.
+   *
+   * @param peer_endpoint An endpoint object into which the endpoint of the
+   * remote peer will be written.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @returns On success, a socket object representing the newly accepted
+   * connection. On error, a socket object where is_open() is false.
+   *
+   * @par Example
+   * @code
+   * asio::ip::tcp::acceptor acceptor(io_context);
+   * ...
+   * asio::ip::tcp::endpoint endpoint;
+   * asio::ip::tcp::socket socket(
+   *     acceptor.accept(io_context2, endpoint, ec));
+   * if (ec)
+   * {
+   *   // An error occurred.
+   * }
+   * @endcode
+   */
+  typename Protocol::socket accept(asio::io_context& io_context,
+      endpoint_type& peer_endpoint, asio::error_code& ec)
+  {
+    return this->get_service().accept(this->get_implementation(),
+        &io_context, &peer_endpoint, ec);
+  }
+
+  /// Start an asynchronous accept.
+  /**
+   * This function is used to asynchronously accept a new connection. The
+   * function call always returns immediately.
+   *
+   * This overload requires that the Protocol template parameter satisfy the
+   * AcceptableProtocol type requirements.
+   *
+   * @param io_context The io_context object to be used for the newly accepted
+   * socket.
+   *
+   * @param peer_endpoint An endpoint object into which the endpoint of the
+   * remote peer will be written. Ownership of the peer_endpoint object is
+   * retained by the caller, which must guarantee that it is valid until the
+   * handler is called.
+   *
+   * @param handler The handler to be called when the accept operation
+   * completes. Copies will be made of the handler as required. The function
+   * signature of the handler must be:
+   * @code void handler(
+   *   const asio::error_code& error, // Result of operation.
+   *   typename Protocol::socket peer // On success, the newly accepted socket.
+   * ); @endcode
+   * Regardless of whether the asynchronous operation completes immediately or
+   * not, the handler will not be invoked from within this function. Invocation
+   * of the handler will be performed in a manner equivalent to using
+   * asio::io_context::post().
+   *
+   * @par Example
+   * @code
+   * void accept_handler(const asio::error_code& error,
+   *     asio::ip::tcp::socket peer)
+   * {
+   *   if (!error)
+   *   {
+   *     // Accept succeeded.
+   *   }
+   * }
+   *
+   * ...
+   *
+   * asio::ip::tcp::acceptor acceptor(io_context);
+   * ...
+   * asio::ip::tcp::endpoint endpoint;
+   * acceptor.async_accept(io_context2, endpoint, accept_handler);
+   * @endcode
+   */
+  template <typename MoveAcceptHandler>
+  ASIO_INITFN_RESULT_TYPE(MoveAcceptHandler,
+      void (asio::error_code, typename Protocol::socket))
+  async_accept(asio::io_context& io_context,
+      endpoint_type& peer_endpoint,
+      ASIO_MOVE_ARG(MoveAcceptHandler) handler)
+  {
+    // If you get an error on the following line it means that your handler does
+    // not meet the documented type requirements for a MoveAcceptHandler.
+    ASIO_MOVE_ACCEPT_HANDLER_CHECK(MoveAcceptHandler,
+        handler, typename Protocol::socket) type_check;
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+    return this->get_service().async_accept(
+        this->get_implementation(), &io_context, &peer_endpoint,
+        ASIO_MOVE_CAST(MoveAcceptHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<MoveAcceptHandler,
+      void (asio::error_code,
+        typename Protocol::socket)> init(handler);
+
+    this->get_service().async_accept(this->get_implementation(),
+        &io_context, &peer_endpoint, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+  }
+#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
 };
 
 } // namespace asio
 
 #include "asio/detail/pop_options.hpp"
 
+#if !defined(ASIO_ENABLE_OLD_SERVICES)
+# undef ASIO_SVC_T
+#endif // !defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_BASIC_SOCKET_ACCEPTOR_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_socket_iostream.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_socket_iostream.hpp
index 12a008b..ad4759b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_socket_iostream.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_socket_iostream.hpp
@@ -2,7 +2,7 @@
 // basic_socket_iostream.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -22,7 +22,10 @@
 #include <istream>
 #include <ostream>
 #include "asio/basic_socket_streambuf.hpp"
-#include "asio/stream_socket_service.hpp"
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+# include "asio/stream_socket_service.hpp"
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
 
 #if !defined(ASIO_HAS_VARIADIC_TEMPLATES)
 
@@ -33,8 +36,8 @@
 //   explicit basic_socket_iostream(T1 x1, ..., Tn xn)
 //     : std::basic_iostream<char>(
 //         &this->detail::socket_iostream_base<
-//           Protocol, StreamSocketService, Time,
-//           TimeTraits, TimerService>::streambuf_)
+//           Protocol ASIO_SVC_TARG, Clock,
+//           WaitTraits ASIO_SVC_TARG1>::streambuf_)
 //   {
 //     if (rdbuf()->connect(x1, ..., xn) == 0)
 //       this->setstate(std::ios_base::failbit);
@@ -46,8 +49,8 @@
   explicit basic_socket_iostream(ASIO_VARIADIC_BYVAL_PARAMS(n)) \
     : std::basic_iostream<char>( \
         &this->detail::socket_iostream_base< \
-          Protocol, StreamSocketService, Time, \
-          TimeTraits, TimerService>::streambuf_) \
+          Protocol ASIO_SVC_TARG, Clock, \
+          WaitTraits ASIO_SVC_TARG1>::streambuf_) \
   { \
     this->setf(std::ios_base::unitbuf); \
     if (rdbuf()->connect(ASIO_VARIADIC_BYVAL_ARGS(n)) == 0) \
@@ -82,60 +85,103 @@ namespace detail {
 
 // A separate base class is used to ensure that the streambuf is initialised
 // prior to the basic_socket_iostream's basic_iostream base class.
-template <typename Protocol, typename StreamSocketService,
-    typename Time, typename TimeTraits, typename TimerService>
+template <typename Protocol ASIO_SVC_TPARAM,
+    typename Clock, typename WaitTraits ASIO_SVC_TPARAM1>
 class socket_iostream_base
 {
 protected:
-  basic_socket_streambuf<Protocol, StreamSocketService,
-    Time, TimeTraits, TimerService> streambuf_;
+  socket_iostream_base()
+  {
+  }
+
+#if defined(ASIO_HAS_MOVE)
+  socket_iostream_base(socket_iostream_base&& other)
+    : streambuf_(std::move(other.streambuf_))
+  {
+  }
+
+  socket_iostream_base(basic_stream_socket<Protocol> s)
+    : streambuf_(std::move(s))
+  {
+  }
+
+  socket_iostream_base& operator=(socket_iostream_base&& other)
+  {
+    streambuf_ = std::move(other.streambuf_);
+    return *this;
+  }
+#endif // defined(ASIO_HAS_MOVE)
+
+  basic_socket_streambuf<Protocol ASIO_SVC_TARG,
+    Clock, WaitTraits ASIO_SVC_TARG1> streambuf_;
 };
 
-}
+} // namespace detail
 
-/// Iostream interface for a socket.
-template <typename Protocol,
-    typename StreamSocketService = stream_socket_service<Protocol>,
-#if defined(ASIO_HAS_BOOST_DATE_TIME) \
-  || defined(GENERATING_DOCUMENTATION)
-    typename Time = boost::posix_time::ptime,
-    typename TimeTraits = asio::time_traits<Time>,
-    typename TimerService = deadline_timer_service<Time, TimeTraits> >
+#if !defined(ASIO_BASIC_SOCKET_IOSTREAM_FWD_DECL)
+#define ASIO_BASIC_SOCKET_IOSTREAM_FWD_DECL
+
+// Forward declaration with defaulted arguments.
+template <typename Protocol
+    ASIO_SVC_TPARAM_DEF1(= stream_socket_service<Protocol>),
+#if defined(ASIO_HAS_BOOST_DATE_TIME)
+    typename Clock = boost::posix_time::ptime,
+    typename WaitTraits = time_traits<Clock>
+    ASIO_SVC_TPARAM1_DEF2(= deadline_timer_service<Clock, WaitTraits>)>
 #else
-    typename Time = steady_timer::clock_type,
-    typename TimeTraits = steady_timer::traits_type,
-    typename TimerService = steady_timer::service_type>
+    typename Clock = chrono::steady_clock,
+    typename WaitTraits = wait_traits<Clock>
+    ASIO_SVC_TPARAM1_DEF1(= steady_timer::service_type)>
 #endif
+class basic_socket_iostream;
+
+#endif // !defined(ASIO_BASIC_SOCKET_IOSTREAM_FWD_DECL)
+
+/// Iostream interface for a socket.
+#if defined(GENERATING_DOCUMENTATION)
+template <typename Protocol,
+    typename Clock = chrono::steady_clock,
+    typename WaitTraits = wait_traits<Clock> >
+#else // defined(GENERATING_DOCUMENTATION)
+template <typename Protocol ASIO_SVC_TPARAM,
+    typename Clock, typename WaitTraits ASIO_SVC_TPARAM1>
+#endif // defined(GENERATING_DOCUMENTATION)
 class basic_socket_iostream
-  : private detail::socket_iostream_base<Protocol,
-        StreamSocketService, Time, TimeTraits, TimerService>,
+  : private detail::socket_iostream_base<Protocol
+        ASIO_SVC_TARG, Clock, WaitTraits ASIO_SVC_TARG1>,
     public std::basic_iostream<char>
 {
 private:
   // These typedefs are intended keep this class's implementation independent
-  // of whether it's using Boost.DateTime, Boost.Chrono or std::chrono.
+  // of whether it's using Boost.DateClock, Boost.Chrono or std::chrono.
 #if defined(ASIO_HAS_BOOST_DATE_TIME)
-  typedef TimeTraits traits_helper;
+  typedef WaitTraits traits_helper;
 #else
-  typedef detail::chrono_time_traits<Time, TimeTraits> traits_helper;
+  typedef detail::chrono_time_traits<Clock, WaitTraits> traits_helper;
 #endif
 
 public:
+  /// The protocol type.
+  typedef Protocol protocol_type;
+
   /// The endpoint type.
   typedef typename Protocol::endpoint endpoint_type;
 
+  /// The clock type.
+  typedef Clock clock_type;
+
 #if defined(GENERATING_DOCUMENTATION)
   /// (Deprecated: Use time_point.) The time type.
-  typedef typename TimeTraits::time_type time_type;
+  typedef typename WaitTraits::time_type time_type;
 
   /// The time type.
-  typedef typename TimeTraits::time_point time_point;
+  typedef typename WaitTraits::time_point time_point;
 
   /// (Deprecated: Use duration.) The duration type.
-  typedef typename TimeTraits::duration_type duration_type;
+  typedef typename WaitTraits::duration_type duration_type;
 
   /// The duration type.
-  typedef typename TimeTraits::duration duration;
+  typedef typename WaitTraits::duration duration;
 #else
 # if !defined(ASIO_NO_DEPRECATED)
   typedef typename traits_helper::time_type time_type;
@@ -149,12 +195,49 @@ public:
   basic_socket_iostream()
     : std::basic_iostream<char>(
         &this->detail::socket_iostream_base<
-          Protocol, StreamSocketService, Time,
-          TimeTraits, TimerService>::streambuf_)
+          Protocol ASIO_SVC_TARG, Clock,
+          WaitTraits ASIO_SVC_TARG1>::streambuf_)
+  {
+    this->setf(std::ios_base::unitbuf);
+  }
+
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+  /// Construct a basic_socket_iostream from the supplied socket.
+  explicit basic_socket_iostream(basic_stream_socket<protocol_type> s)
+    : detail::socket_iostream_base<
+        Protocol ASIO_SVC_TARG, Clock,
+        WaitTraits ASIO_SVC_TARG1>(std::move(s)),
+      std::basic_iostream<char>(
+        &this->detail::socket_iostream_base<
+          Protocol ASIO_SVC_TARG, Clock,
+          WaitTraits ASIO_SVC_TARG1>::streambuf_)
   {
     this->setf(std::ios_base::unitbuf);
   }
 
+  /// Move-construct a basic_socket_iostream from another.
+  basic_socket_iostream(basic_socket_iostream&& other)
+    : detail::socket_iostream_base<
+        Protocol ASIO_SVC_TARG, Clock,
+        WaitTraits ASIO_SVC_TARG1>(std::move(other)),
+      std::basic_iostream<char>(std::move(other))
+  {
+    this->set_rdbuf(&this->detail::socket_iostream_base<
+          Protocol ASIO_SVC_TARG, Clock,
+          WaitTraits ASIO_SVC_TARG1>::streambuf_);
+  }
+
+  /// Move-assign a basic_socket_iostream from another.
+  basic_socket_iostream& operator=(basic_socket_iostream&& other)
+  {
+    std::basic_iostream<char>::operator=(std::move(other));
+    detail::socket_iostream_base<
+        Protocol ASIO_SVC_TARG, Clock,
+        WaitTraits ASIO_SVC_TARG1>::operator=(std::move(other));
+    return *this;
+  }
+#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+
 #if defined(GENERATING_DOCUMENTATION)
   /// Establish a connection to an endpoint corresponding to a resolver query.
   /**
@@ -169,8 +252,8 @@ public:
   explicit basic_socket_iostream(T... x)
     : std::basic_iostream<char>(
         &this->detail::socket_iostream_base<
-          Protocol, StreamSocketService, Time,
-          TimeTraits, TimerService>::streambuf_)
+          Protocol ASIO_SVC_TARG, Clock,
+          WaitTraits ASIO_SVC_TARG1>::streambuf_)
   {
     this->setf(std::ios_base::unitbuf);
     if (rdbuf()->connect(x...) == 0)
@@ -208,14 +291,20 @@ public:
   }
 
   /// Return a pointer to the underlying streambuf.
-  basic_socket_streambuf<Protocol, StreamSocketService,
-    Time, TimeTraits, TimerService>* rdbuf() const
+  basic_socket_streambuf<Protocol ASIO_SVC_TARG,
+    Clock, WaitTraits ASIO_SVC_TARG1>* rdbuf() const
   {
-    return const_cast<basic_socket_streambuf<Protocol, StreamSocketService,
-      Time, TimeTraits, TimerService>*>(
+    return const_cast<basic_socket_streambuf<Protocol ASIO_SVC_TARG,
+      Clock, WaitTraits ASIO_SVC_TARG1>*>(
         &this->detail::socket_iostream_base<
-          Protocol, StreamSocketService, Time,
-          TimeTraits, TimerService>::streambuf_);
+          Protocol ASIO_SVC_TARG, Clock,
+          WaitTraits ASIO_SVC_TARG1>::streambuf_);
+  }
+
+  /// Get a reference to the underlying socket.
+  basic_socket<Protocol ASIO_SVC_TARG>& socket()
+  {
+    return rdbuf()->socket();
   }
 
   /// Get the last error associated with the stream.
@@ -232,7 +321,7 @@ public:
    */
   const asio::error_code& error() const
   {
-    return rdbuf()->puberror();
+    return rdbuf()->error();
   }
 
 #if !defined(ASIO_NO_DEPRECATED)
@@ -309,6 +398,12 @@ public:
     rdbuf()->expires_from_now(expiry_time);
   }
 #endif // !defined(ASIO_NO_DEPRECATED)
+
+private:
+  // Disallow copying and assignment.
+  basic_socket_iostream(const basic_socket_iostream&) ASIO_DELETED;
+  basic_socket_iostream& operator=(
+      const basic_socket_iostream&) ASIO_DELETED;
 };
 
 } // namespace asio
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_socket_streambuf.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_socket_streambuf.hpp
index d9300a2..42fb3ca 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_socket_streambuf.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_socket_streambuf.hpp
@@ -2,7 +2,7 @@
 // basic_socket_streambuf.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -20,15 +20,24 @@
 #if !defined(ASIO_NO_IOSTREAM)
 
 #include <streambuf>
+#include <vector>
 #include "asio/basic_socket.hpp"
-#include "asio/deadline_timer_service.hpp"
-#include "asio/detail/array.hpp"
+#include "asio/basic_stream_socket.hpp"
+#include "asio/detail/buffer_sequence_adapter.hpp"
+#include "asio/detail/memory.hpp"
 #include "asio/detail/throw_error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/stream_socket_service.hpp"
+#include "asio/io_context.hpp"
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+# include "asio/stream_socket_service.hpp"
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
 
 #if defined(ASIO_HAS_BOOST_DATE_TIME)
-# include "asio/deadline_timer.hpp"
+# if defined(ASIO_ENABLE_OLD_SERVICES)
+#  include "asio/deadline_timer_service.hpp"
+# else // defined(ASIO_ENABLE_OLD_SERVICES)
+#  include "asio/detail/deadline_timer_service.hpp"
+# endif // defined(ASIO_ENABLE_OLD_SERVICES)
 #else
 # include "asio/steady_timer.hpp"
 #endif
@@ -39,96 +48,144 @@
 
 // A macro that should expand to:
 //   template <typename T1, ..., typename Tn>
-//   basic_socket_streambuf<Protocol, StreamSocketService,
-//     Time, TimeTraits, TimerService>* connect(
-//       T1 x1, ..., Tn xn)
+//   basic_socket_streambuf* connect(T1 x1, ..., Tn xn)
 //   {
 //     init_buffers();
-//     this->basic_socket<Protocol, StreamSocketService>::close(ec_);
 //     typedef typename Protocol::resolver resolver_type;
-//     typedef typename resolver_type::query resolver_query;
-//     resolver_query query(x1, ..., xn);
-//     resolve_and_connect(query);
+//     resolver_type resolver(socket().get_executor().context());
+//     connect_to_endpoints(
+//         resolver.resolve(x1, ..., xn, ec_));
 //     return !ec_ ? this : 0;
 //   }
 // This macro should only persist within this file.
 
 # define ASIO_PRIVATE_CONNECT_DEF(n) \
   template <ASIO_VARIADIC_TPARAMS(n)> \
-  basic_socket_streambuf<Protocol, StreamSocketService, \
-    Time, TimeTraits, TimerService>* connect( \
-      ASIO_VARIADIC_BYVAL_PARAMS(n)) \
+  basic_socket_streambuf* connect(ASIO_VARIADIC_BYVAL_PARAMS(n)) \
   { \
     init_buffers(); \
-    this->basic_socket<Protocol, StreamSocketService>::close(ec_); \
     typedef typename Protocol::resolver resolver_type; \
-    typedef typename resolver_type::query resolver_query; \
-    resolver_query query(ASIO_VARIADIC_BYVAL_ARGS(n)); \
-    resolve_and_connect(query); \
+    resolver_type resolver(socket().get_executor().context()); \
+    connect_to_endpoints( \
+        resolver.resolve(ASIO_VARIADIC_BYVAL_ARGS(n), ec_)); \
     return !ec_ ? this : 0; \
   } \
   /**/
 
 #endif // !defined(ASIO_HAS_VARIADIC_TEMPLATES)
 
+#if !defined(ASIO_ENABLE_OLD_SERVICES)
+# define ASIO_SVC_T1 detail::deadline_timer_service<traits_helper>
+#endif // !defined(ASIO_ENABLE_OLD_SERVICES)
+
 #include "asio/detail/push_options.hpp"
 
 namespace asio {
 namespace detail {
 
-// A separate base class is used to ensure that the io_service is initialised
-// prior to the basic_socket_streambuf's basic_socket base class.
-class socket_streambuf_base
+// A separate base class is used to ensure that the io_context member is
+// initialised prior to the basic_socket_streambuf's basic_socket base class.
+class socket_streambuf_io_context
 {
 protected:
-  io_service io_service_;
+  socket_streambuf_io_context(io_context* ctx)
+    : default_io_context_(ctx)
+  {
+  }
+
+  shared_ptr<io_context> default_io_context_;
+};
+
+// A separate base class is used to ensure that the dynamically allocated
+// buffers are constructed prior to the basic_socket_streambuf's basic_socket
+// base class. This makes moving the socket is the last potentially throwing
+// step in the streambuf's move constructor, giving the constructor a strong
+// exception safety guarantee.
+class socket_streambuf_buffers
+{
+protected:
+  socket_streambuf_buffers()
+    : get_buffer_(buffer_size),
+      put_buffer_(buffer_size)
+  {
+  }
+
+  enum { buffer_size = 512 };
+  std::vector<char> get_buffer_;
+  std::vector<char> put_buffer_;
 };
 
 } // namespace detail
 
-/// Iostream streambuf for a socket.
-template <typename Protocol,
-    typename StreamSocketService = stream_socket_service<Protocol>,
-#if defined(ASIO_HAS_BOOST_DATE_TIME) \
-  || defined(GENERATING_DOCUMENTATION)
-    typename Time = boost::posix_time::ptime,
-    typename TimeTraits = asio::time_traits<Time>,
-    typename TimerService = deadline_timer_service<Time, TimeTraits> >
+#if !defined(ASIO_BASIC_SOCKET_STREAMBUF_FWD_DECL)
+#define ASIO_BASIC_SOCKET_STREAMBUF_FWD_DECL
+
+// Forward declaration with defaulted arguments.
+template <typename Protocol
+    ASIO_SVC_TPARAM_DEF1(= stream_socket_service<Protocol>),
+#if defined(ASIO_HAS_BOOST_DATE_TIME)
+    typename Clock = boost::posix_time::ptime,
+    typename WaitTraits = time_traits<Clock>
+    ASIO_SVC_TPARAM1_DEF2(= deadline_timer_service<Clock, WaitTraits>)>
 #else
-    typename Time = steady_timer::clock_type,
-    typename TimeTraits = steady_timer::traits_type,
-    typename TimerService = steady_timer::service_type>
+    typename Clock = chrono::steady_clock,
+    typename WaitTraits = wait_traits<Clock>
+    ASIO_SVC_TPARAM1_DEF1(= steady_timer::service_type)>
 #endif
+class basic_socket_streambuf;
+
+#endif // !defined(ASIO_BASIC_SOCKET_STREAMBUF_FWD_DECL)
+
+/// Iostream streambuf for a socket.
+#if defined(GENERATING_DOCUMENTATION)
+template <typename Protocol,
+    typename Clock = chrono::steady_clock,
+    typename WaitTraits = wait_traits<Clock> >
+#else // defined(GENERATING_DOCUMENTATION)
+template <typename Protocol ASIO_SVC_TPARAM,
+    typename Clock, typename WaitTraits ASIO_SVC_TPARAM1>
+#endif // defined(GENERATING_DOCUMENTATION)
 class basic_socket_streambuf
   : public std::streambuf,
-    private detail::socket_streambuf_base,
-    public basic_socket<Protocol, StreamSocketService>
+    private detail::socket_streambuf_io_context,
+    private detail::socket_streambuf_buffers,
+#if defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
+    private basic_socket<Protocol ASIO_SVC_TARG>
+#else // defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
+    public basic_socket<Protocol ASIO_SVC_TARG>
+#endif // defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
 {
 private:
   // These typedefs are intended keep this class's implementation independent
-  // of whether it's using Boost.DateTime, Boost.Chrono or std::chrono.
+  // of whether it's using Boost.DateClock, Boost.Chrono or std::chrono.
 #if defined(ASIO_HAS_BOOST_DATE_TIME)
-  typedef TimeTraits traits_helper;
+  typedef WaitTraits traits_helper;
 #else
-  typedef detail::chrono_time_traits<Time, TimeTraits> traits_helper;
+  typedef detail::chrono_time_traits<Clock, WaitTraits> traits_helper;
 #endif
 
 public:
+  /// The protocol type.
+  typedef Protocol protocol_type;
+
   /// The endpoint type.
   typedef typename Protocol::endpoint endpoint_type;
 
+  /// The clock type.
+  typedef Clock clock_type;
+
 #if defined(GENERATING_DOCUMENTATION)
   /// (Deprecated: Use time_point.) The time type.
-  typedef typename TimeTraits::time_type time_type;
+  typedef typename WaitTraits::time_type time_type;
 
   /// The time type.
-  typedef typename TimeTraits::time_point time_point;
+  typedef typename WaitTraits::time_point time_point;
 
   /// (Deprecated: Use duration.) The duration type.
-  typedef typename TimeTraits::duration_type duration_type;
+  typedef typename WaitTraits::duration_type duration_type;
 
   /// The duration type.
-  typedef typename TimeTraits::duration duration;
+  typedef typename WaitTraits::duration duration;
 #else
 # if !defined(ASIO_NO_DEPRECATED)
   typedef typename traits_helper::time_type time_type;
@@ -140,22 +197,64 @@ public:
 
   /// Construct a basic_socket_streambuf without establishing a connection.
   basic_socket_streambuf()
-    : basic_socket<Protocol, StreamSocketService>(
-        this->detail::socket_streambuf_base::io_service_),
-      unbuffered_(false),
-      timer_service_(0),
-      timer_state_(no_timer)
+    : detail::socket_streambuf_io_context(new io_context),
+      basic_socket<Protocol ASIO_SVC_TARG>(*default_io_context_),
+      expiry_time_(max_expiry_time())
+  {
+    init_buffers();
+  }
+
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+  /// Construct a basic_socket_streambuf from the supplied socket.
+  explicit basic_socket_streambuf(basic_stream_socket<protocol_type> s)
+    : detail::socket_streambuf_io_context(0),
+      basic_socket<Protocol ASIO_SVC_TARG>(std::move(s)),
+      expiry_time_(max_expiry_time())
   {
     init_buffers();
   }
 
+  /// Move-construct a basic_socket_streambuf from another.
+  basic_socket_streambuf(basic_socket_streambuf&& other)
+    : detail::socket_streambuf_io_context(other),
+      basic_socket<Protocol ASIO_SVC_TARG>(std::move(other.socket())),
+      ec_(other.ec_),
+      expiry_time_(other.expiry_time_)
+  {
+    get_buffer_.swap(other.get_buffer_);
+    put_buffer_.swap(other.put_buffer_);
+    setg(other.eback(), other.gptr(), other.egptr());
+    setp(other.pptr(), other.epptr());
+    other.ec_ = asio::error_code();
+    other.expiry_time_ = max_expiry_time();
+    other.init_buffers();
+  }
+
+  /// Move-assign a basic_socket_streambuf from another.
+  basic_socket_streambuf& operator=(basic_socket_streambuf&& other)
+  {
+    this->close();
+    socket() = std::move(other.socket());
+    detail::socket_streambuf_io_context::operator=(other);
+    ec_ = other.ec_;
+    expiry_time_ = other.expiry_time_;
+    get_buffer_.swap(other.get_buffer_);
+    put_buffer_.swap(other.put_buffer_);
+    setg(other.eback(), other.gptr(), other.egptr());
+    setp(other.pptr(), other.epptr());
+    other.ec_ = asio::error_code();
+    other.expiry_time_ = max_expiry_time();
+    other.put_buffer_.resize(buffer_size);
+    other.init_buffers();
+    return *this;
+  }
+#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+
   /// Destructor flushes buffered data.
   virtual ~basic_socket_streambuf()
   {
     if (pptr() != pbase())
       overflow(traits_type::eof());
-
-    destroy_timer();
   }
 
   /// Establish a connection.
@@ -165,29 +264,11 @@ public:
    * @return \c this if a connection was successfully established, a null
    * pointer otherwise.
    */
-  basic_socket_streambuf<Protocol, StreamSocketService,
-    Time, TimeTraits, TimerService>* connect(
-      const endpoint_type& endpoint)
+  basic_socket_streambuf* connect(const endpoint_type& endpoint)
   {
     init_buffers();
-
-    this->basic_socket<Protocol, StreamSocketService>::close(ec_);
-
-    if (timer_state_ == timer_has_expired)
-    {
-      ec_ = asio::error::operation_aborted;
-      return 0;
-    }
-
-    io_handler handler = { this };
-    this->basic_socket<Protocol, StreamSocketService>::async_connect(
-        endpoint, handler);
-
-    ec_ = asio::error::would_block;
-    this->get_service().get_io_service().restart();
-    do this->get_service().get_io_service().run_one();
-    while (ec_ == asio::error::would_block);
-
+    ec_ = asio::error_code();
+    this->connect_to_endpoints(&endpoint, &endpoint + 1);
     return !ec_ ? this : 0;
   }
 
@@ -202,19 +283,15 @@ public:
    * pointer otherwise.
    */
   template <typename T1, ..., typename TN>
-  basic_socket_streambuf<Protocol, StreamSocketService>* connect(
-      T1 t1, ..., TN tn);
+  basic_socket_streambuf* connect(T1 t1, ..., TN tn);
 #elif defined(ASIO_HAS_VARIADIC_TEMPLATES)
   template <typename... T>
-  basic_socket_streambuf<Protocol, StreamSocketService,
-    Time, TimeTraits, TimerService>* connect(T... x)
+  basic_socket_streambuf* connect(T... x)
   {
     init_buffers();
-    this->basic_socket<Protocol, StreamSocketService>::close(ec_);
     typedef typename Protocol::resolver resolver_type;
-    typedef typename resolver_type::query resolver_query;
-    resolver_query query(x...);
-    resolve_and_connect(query);
+    resolver_type resolver(socket().get_executor().context());
+    connect_to_endpoints(resolver.resolve(x..., ec_));
     return !ec_ ? this : 0;
   }
 #else
@@ -226,27 +303,43 @@ public:
    * @return \c this if a connection was successfully established, a null
    * pointer otherwise.
    */
-  basic_socket_streambuf<Protocol, StreamSocketService,
-    Time, TimeTraits, TimerService>* close()
+  basic_socket_streambuf* close()
   {
     sync();
-    this->basic_socket<Protocol, StreamSocketService>::close(ec_);
+    socket().close(ec_);
     if (!ec_)
       init_buffers();
     return !ec_ ? this : 0;
   }
 
+  /// Get a reference to the underlying socket.
+  basic_socket<Protocol ASIO_SVC_TARG>& socket()
+  {
+    return *this;
+  }
+
   /// Get the last error associated with the stream buffer.
   /**
    * @return An \c error_code corresponding to the last error from the stream
    * buffer.
    */
+  const asio::error_code& error() const
+  {
+    return ec_;
+  }
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use error().) Get the last error associated with the stream
+  /// buffer.
+  /**
+   * @return An \c error_code corresponding to the last error from the stream
+   * buffer.
+   */
   const asio::error_code& puberror() const
   {
     return error();
   }
 
-#if !defined(ASIO_NO_DEPRECATED)
   /// (Deprecated: Use expiry().) Get the stream buffer's expiry time as an
   /// absolute time.
   /**
@@ -255,9 +348,7 @@ public:
    */
   time_point expires_at() const
   {
-    return timer_service_
-      ? timer_service_->expires_at(timer_implementation_)
-      : time_point();
+    return expiry_time_;
   }
 #endif // !defined(ASIO_NO_DEPRECATED)
 
@@ -268,13 +359,7 @@ public:
    */
   time_point expiry() const
   {
-    return timer_service_
-#if defined(ASIO_HAS_BOOST_DATE_TIME)
-      ? timer_service_->expires_at(timer_implementation_)
-#else // defined(ASIO_HAS_BOOST_DATE_TIME)
-      ? timer_service_->expiry(timer_implementation_)
-#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
-      : time_point();
+    return expiry_time_;
   }
 
   /// Set the stream buffer's expiry time as an absolute time.
@@ -288,33 +373,7 @@ public:
    */
   void expires_at(const time_point& expiry_time)
   {
-    construct_timer();
-
-    asio::error_code ec;
-    timer_service_->expires_at(timer_implementation_, expiry_time, ec);
-    asio::detail::throw_error(ec, "expires_at");
-
-    start_timer();
-  }
-
-  /// Set the stream buffer's expiry time relative to now.
-  /**
-   * This function sets the expiry time associated with the stream. Stream
-   * operations performed after this time (where the operations cannot be
-   * completed using the internal buffers) will fail with the error
-   * asio::error::operation_aborted.
-   *
-   * @param expiry_time The expiry time to be used for the timer.
-   */
-  void expires_at(const duration& expiry_time)
-  {
-    construct_timer();
-
-    asio::error_code ec;
-    timer_service_->expires_from_now(timer_implementation_, expiry_time, ec);
-    asio::detail::throw_error(ec, "expires_from_now");
-
-    start_timer();
+    expiry_time_ = expiry_time;
   }
 
   /// Set the stream buffer's expiry time relative to now.
@@ -328,17 +387,7 @@ public:
    */
   void expires_after(const duration& expiry_time)
   {
-    construct_timer();
-
-    asio::error_code ec;
-#if defined(ASIO_HAS_BOOST_DATE_TIME)
-    timer_service_->expires_from_now(timer_implementation_, expiry_time, ec);
-#else // defined(ASIO_HAS_BOOST_DATE_TIME)
-    timer_service_->expires_after(timer_implementation_, expiry_time, ec);
-#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
-    asio::detail::throw_error(ec, "after");
-
-    start_timer();
+    expiry_time_ = traits_helper::add(traits_helper::now(), expiry_time);
   }
 
 #if !defined(ASIO_NO_DEPRECATED)
@@ -364,108 +413,124 @@ public:
    */
   void expires_from_now(const duration& expiry_time)
   {
-    construct_timer();
-
-    asio::error_code ec;
-    timer_service_->expires_from_now(timer_implementation_, expiry_time, ec);
-    asio::detail::throw_error(ec, "expires_from_now");
-
-    start_timer();
+    expiry_time_ = traits_helper::add(traits_helper::now(), expiry_time);
   }
 #endif // !defined(ASIO_NO_DEPRECATED)
 
 protected:
   int_type underflow()
   {
-    if (gptr() == egptr())
+#if defined(ASIO_WINDOWS_RUNTIME)
+    ec_ = asio::error::operation_not_supported;
+    return traits_type::eof();
+#else // defined(ASIO_WINDOWS_RUNTIME)
+    if (gptr() != egptr())
+      return traits_type::eof();
+
+    for (;;)
     {
-      if (timer_state_ == timer_has_expired)
+      // Check if we are past the expiry time.
+      if (traits_helper::less_than(expiry_time_, traits_helper::now()))
       {
-        ec_ = asio::error::operation_aborted;
+        ec_ = asio::error::timed_out;
         return traits_type::eof();
       }
 
-      io_handler handler = { this };
-      this->get_service().async_receive(this->get_implementation(),
-          asio::buffer(asio::buffer(get_buffer_) + putback_max),
-          0, handler);
+      // Try to complete the operation without blocking.
+      if (!socket().native_non_blocking())
+        socket().native_non_blocking(true, ec_);
+      detail::buffer_sequence_adapter<mutable_buffer, mutable_buffer>
+        bufs(asio::buffer(get_buffer_) + putback_max);
+      detail::signed_size_type bytes = detail::socket_ops::recv(
+          socket().native_handle(), bufs.buffers(), bufs.count(), 0, ec_);
 
-      ec_ = asio::error::would_block;
-      this->get_service().get_io_service().restart();
-      do this->get_service().get_io_service().run_one();
-      while (ec_ == asio::error::would_block);
-      if (ec_)
+      // Check if operation succeeded.
+      if (bytes > 0)
+      {
+        setg(&get_buffer_[0], &get_buffer_[0] + putback_max,
+            &get_buffer_[0] + putback_max + bytes);
+        return traits_type::to_int_type(*gptr());
+      }
+
+      // Check for EOF.
+      if (bytes == 0)
+      {
+        ec_ = asio::error::eof;
         return traits_type::eof();
+      }
 
-      setg(&get_buffer_[0], &get_buffer_[0] + putback_max,
-          &get_buffer_[0] + putback_max + bytes_transferred_);
-      return traits_type::to_int_type(*gptr());
-    }
-    else
-    {
-      return traits_type::eof();
+      // Operation failed.
+      if (ec_ != asio::error::would_block
+          && ec_ != asio::error::try_again)
+        return traits_type::eof();
+
+      // Wait for socket to become ready.
+      if (detail::socket_ops::poll_read(
+            socket().native_handle(), 0, timeout(), ec_) < 0)
+        return traits_type::eof();
     }
+#endif // defined(ASIO_WINDOWS_RUNTIME)
   }
 
   int_type overflow(int_type c)
   {
-    if (unbuffered_)
+#if defined(ASIO_WINDOWS_RUNTIME)
+    ec_ = asio::error::operation_not_supported;
+    return traits_type::eof();
+#else // defined(ASIO_WINDOWS_RUNTIME)
+    char_type ch = traits_type::to_char_type(c);
+
+    // Determine what needs to be sent.
+    const_buffer output_buffer;
+    if (put_buffer_.empty())
     {
       if (traits_type::eq_int_type(c, traits_type::eof()))
+        return traits_type::not_eof(c); // Nothing to do.
+      output_buffer = asio::buffer(&ch, sizeof(char_type));
+    }
+    else
+    {
+      output_buffer = asio::buffer(pbase(),
+          (pptr() - pbase()) * sizeof(char_type));
+    }
+
+    while (output_buffer.size() > 0)
+    {
+      // Check if we are past the expiry time.
+      if (traits_helper::less_than(expiry_time_, traits_helper::now()))
       {
-        // Nothing to do.
-        return traits_type::not_eof(c);
+        ec_ = asio::error::timed_out;
+        return traits_type::eof();
       }
-      else
+
+      // Try to complete the operation without blocking.
+      if (!socket().native_non_blocking())
+        socket().native_non_blocking(true, ec_);
+      detail::buffer_sequence_adapter<
+        const_buffer, const_buffer> bufs(output_buffer);
+      detail::signed_size_type bytes = detail::socket_ops::send(
+          socket().native_handle(), bufs.buffers(), bufs.count(), 0, ec_);
+
+      // Check if operation succeeded.
+      if (bytes > 0)
       {
-        if (timer_state_ == timer_has_expired)
-        {
-          ec_ = asio::error::operation_aborted;
-          return traits_type::eof();
-        }
-
-        // Send the single character immediately.
-        char_type ch = traits_type::to_char_type(c);
-        io_handler handler = { this };
-        this->get_service().async_send(this->get_implementation(),
-            asio::buffer(&ch, sizeof(char_type)), 0, handler);
-
-        ec_ = asio::error::would_block;
-        this->get_service().get_io_service().restart();
-        do this->get_service().get_io_service().run_one();
-        while (ec_ == asio::error::would_block);
-        if (ec_)
-          return traits_type::eof();
-
-        return c;
+        output_buffer += static_cast<std::size_t>(bytes);
+        continue;
       }
+
+      // Operation failed.
+      if (ec_ != asio::error::would_block
+          && ec_ != asio::error::try_again)
+        return traits_type::eof();
+
+      // Wait for socket to become ready.
+      if (detail::socket_ops::poll_write(
+            socket().native_handle(), 0, timeout(), ec_) < 0)
+        return traits_type::eof();
     }
-    else
+
+    if (!put_buffer_.empty())
     {
-      // Send all data in the output buffer.
-      asio::const_buffer buffer =
-        asio::buffer(pbase(), pptr() - pbase());
-      while (asio::buffer_size(buffer) > 0)
-      {
-        if (timer_state_ == timer_has_expired)
-        {
-          ec_ = asio::error::operation_aborted;
-          return traits_type::eof();
-        }
-
-        io_handler handler = { this };
-        this->get_service().async_send(this->get_implementation(),
-            asio::buffer(buffer), 0, handler);
-
-        ec_ = asio::error::would_block;
-        this->get_service().get_io_service().restart();
-        do this->get_service().get_io_service().run_one();
-        while (ec_ == asio::error::would_block);
-        if (ec_)
-          return traits_type::eof();
-
-        buffer = buffer + bytes_transferred_;
-      }
       setp(&put_buffer_[0], &put_buffer_[0] + put_buffer_.size());
 
       // If the new character is eof then our work here is done.
@@ -473,10 +538,12 @@ protected:
         return traits_type::not_eof(c);
 
       // Add the new character to the output buffer.
-      *pptr() = traits_type::to_char_type(c);
+      *pptr() = ch;
       pbump(1);
-      return c;
     }
+
+    return c;
+#endif // defined(ASIO_WINDOWS_RUNTIME)
   }
 
   int sync()
@@ -488,159 +555,137 @@ protected:
   {
     if (pptr() == pbase() && s == 0 && n == 0)
     {
-      unbuffered_ = true;
+      put_buffer_.clear();
       setp(0, 0);
+      sync();
       return this;
     }
 
     return 0;
   }
 
-  /// Get the last error associated with the stream buffer.
-  /**
-   * @return An \c error_code corresponding to the last error from the stream
-   * buffer.
-   */
-  virtual const asio::error_code& error() const
-  {
-    return ec_;
-  }
-
 private:
+  // Disallow copying and assignment.
+  basic_socket_streambuf(const basic_socket_streambuf&) ASIO_DELETED;
+  basic_socket_streambuf& operator=(
+      const basic_socket_streambuf&) ASIO_DELETED;
+
   void init_buffers()
   {
     setg(&get_buffer_[0],
         &get_buffer_[0] + putback_max,
         &get_buffer_[0] + putback_max);
-    if (unbuffered_)
+
+    if (put_buffer_.empty())
       setp(0, 0);
     else
       setp(&put_buffer_[0], &put_buffer_[0] + put_buffer_.size());
   }
 
-  template <typename ResolverQuery>
-  void resolve_and_connect(const ResolverQuery& query)
+  int timeout() const
   {
-    typedef typename Protocol::resolver resolver_type;
-    typedef typename resolver_type::iterator iterator_type;
-    resolver_type resolver(detail::socket_streambuf_base::io_service_);
-    iterator_type i = resolver.resolve(query, ec_);
-    if (!ec_)
-    {
-      iterator_type end;
-      ec_ = asio::error::host_not_found;
-      while (ec_ && i != end)
-      {
-        this->basic_socket<Protocol, StreamSocketService>::close(ec_);
-
-        if (timer_state_ == timer_has_expired)
-        {
-          ec_ = asio::error::operation_aborted;
-          return;
-        }
-
-        io_handler handler = { this };
-        this->basic_socket<Protocol, StreamSocketService>::async_connect(
-            *i, handler);
-
-        ec_ = asio::error::would_block;
-        this->get_service().get_io_service().restart();
-        do this->get_service().get_io_service().run_one();
-        while (ec_ == asio::error::would_block);
-
-        ++i;
-      }
-    }
+    int64_t msec = traits_helper::to_posix_duration(
+        traits_helper::subtract(expiry_time_,
+          traits_helper::now())).total_milliseconds();
+    if (msec > (std::numeric_limits<int>::max)())
+      msec = (std::numeric_limits<int>::max)();
+    else if (msec < 0)
+      msec = 0;
+    return static_cast<int>(msec);
   }
 
-  struct io_handler;
-  friend struct io_handler;
-  struct io_handler
+  template <typename EndpointSequence>
+  void connect_to_endpoints(const EndpointSequence& endpoints)
   {
-    basic_socket_streambuf* this_;
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred = 0)
-    {
-      this_->ec_ = ec;
-      this_->bytes_transferred_ = bytes_transferred;
-    }
-  };
+    this->connect_to_endpoints(endpoints.begin(), endpoints.end());
+  }
 
-  struct timer_handler;
-  friend struct timer_handler;
-  struct timer_handler
+  template <typename EndpointIterator>
+  void connect_to_endpoints(EndpointIterator begin, EndpointIterator end)
   {
-    basic_socket_streambuf* this_;
-
-    void operator()(const asio::error_code&)
+#if defined(ASIO_WINDOWS_RUNTIME)
+    ec_ = asio::error::operation_not_supported;
+#else // defined(ASIO_WINDOWS_RUNTIME)
+    if (ec_)
+      return;
+
+    ec_ = asio::error::not_found;
+    for (EndpointIterator i = begin; i != end; ++i)
     {
-      time_point now = traits_helper::now();
-
-#if defined(ASIO_HAS_BOOST_DATE_TIME)
-      time_point expiry_time = this_->timer_service_->expires_at(
-            this_->timer_implementation_);
-#else // defined(ASIO_HAS_BOOST_DATE_TIME)
-      time_point expiry_time = this_->timer_service_->expiry(
-            this_->timer_implementation_);
-#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
-
-      if (traits_helper::less_than(now, expiry_time))
-      {
-        this_->timer_state_ = timer_is_pending;
-        this_->timer_service_->async_wait(this_->timer_implementation_, *this);
-      }
-      else
+      // Check if we are past the expiry time.
+      if (traits_helper::less_than(expiry_time_, traits_helper::now()))
       {
-        this_->timer_state_ = timer_has_expired;
-        asio::error_code ec;
-        this_->basic_socket<Protocol, StreamSocketService>::close(ec);
+        ec_ = asio::error::timed_out;
+        return;
       }
-    }
-  };
 
-  void construct_timer()
-  {
-    if (timer_service_ == 0)
-    {
-      TimerService& timer_service = use_service<TimerService>(
-          detail::socket_streambuf_base::io_service_);
-      timer_service.construct(timer_implementation_);
-      timer_service_ = &timer_service;
+      // Close and reopen the socket.
+      typename Protocol::endpoint ep(*i);
+      socket().close(ec_);
+      socket().open(ep.protocol(), ec_);
+      if (ec_)
+        continue;
+
+      // Try to complete the operation without blocking.
+      if (!socket().native_non_blocking())
+        socket().native_non_blocking(true, ec_);
+      detail::socket_ops::connect(socket().native_handle(),
+          ep.data(), ep.size(), ec_);
+
+      // Check if operation succeeded.
+      if (!ec_)
+        return;
+
+      // Operation failed.
+      if (ec_ != asio::error::in_progress
+          && ec_ != asio::error::would_block)
+        continue;
+
+      // Wait for socket to become ready.
+      if (detail::socket_ops::poll_connect(
+            socket().native_handle(), timeout(), ec_) < 0)
+        continue;
+
+      // Get the error code from the connect operation.
+      int connect_error = 0;
+      size_t connect_error_len = sizeof(connect_error);
+      if (detail::socket_ops::getsockopt(socket().native_handle(), 0,
+            SOL_SOCKET, SO_ERROR, &connect_error, &connect_error_len, ec_)
+          == detail::socket_error_retval)
+        return;
+
+      // Check the result of the connect operation.
+      ec_ = asio::error_code(connect_error,
+          asio::error::get_system_category());
+      if (!ec_)
+        return;
     }
+#endif // defined(ASIO_WINDOWS_RUNTIME)
   }
 
-  void destroy_timer()
+  // Helper function to get the maximum expiry time.
+  static time_point max_expiry_time()
   {
-    if (timer_service_)
-      timer_service_->destroy(timer_implementation_);
-  }
-
-  void start_timer()
-  {
-    if (timer_state_ != timer_is_pending)
-    {
-      timer_handler handler = { this };
-      handler(asio::error_code());
-    }
+#if defined(ASIO_HAS_BOOST_DATE_TIME)
+    return boost::posix_time::pos_infin;
+#else // defined(ASIO_HAS_BOOST_DATE_TIME)
+    return (time_point::max)();
+#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
   }
 
   enum { putback_max = 8 };
-  enum { buffer_size = 512 };
-  asio::detail::array<char, buffer_size> get_buffer_;
-  asio::detail::array<char, buffer_size> put_buffer_;
-  bool unbuffered_;
   asio::error_code ec_;
-  std::size_t bytes_transferred_;
-  TimerService* timer_service_;
-  typename TimerService::implementation_type timer_implementation_;
-  enum state { no_timer, timer_is_pending, timer_has_expired } timer_state_;
+  time_point expiry_time_;
 };
 
 } // namespace asio
 
 #include "asio/detail/pop_options.hpp"
 
+#if !defined(ASIO_ENABLE_OLD_SERVICES)
+# undef ASIO_SVC_T1
+#endif // !defined(ASIO_ENABLE_OLD_SERVICES)
+
 #if !defined(ASIO_HAS_VARIADIC_TEMPLATES)
 # undef ASIO_PRIVATE_CONNECT_DEF
 #endif // !defined(ASIO_HAS_VARIADIC_TEMPLATES)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_stream_socket.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_stream_socket.hpp
index c29827b..31e6850 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_stream_socket.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_stream_socket.hpp
@@ -2,7 +2,7 @@
 // basic_stream_socket.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -22,7 +22,10 @@
 #include "asio/detail/handler_type_requirements.hpp"
 #include "asio/detail/throw_error.hpp"
 #include "asio/error.hpp"
-#include "asio/stream_socket_service.hpp"
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+# include "asio/stream_socket_service.hpp"
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
 
 #include "asio/detail/push_options.hpp"
 
@@ -40,14 +43,19 @@ namespace asio {
  * @par Concepts:
  * AsyncReadStream, AsyncWriteStream, Stream, SyncReadStream, SyncWriteStream.
  */
-template <typename Protocol,
-    typename StreamSocketService = stream_socket_service<Protocol> >
+template <typename Protocol
+    ASIO_SVC_TPARAM_DEF1(= stream_socket_service<Protocol>)>
 class basic_stream_socket
-  : public basic_socket<Protocol, StreamSocketService>
+  : public basic_socket<Protocol ASIO_SVC_TARG>
 {
 public:
   /// The native representation of a socket.
-  typedef typename StreamSocketService::native_handle_type native_handle_type;
+#if defined(GENERATING_DOCUMENTATION)
+  typedef implementation_defined native_handle_type;
+#else
+  typedef typename basic_socket<
+    Protocol ASIO_SVC_TARG>::native_handle_type native_handle_type;
+#endif
 
   /// The protocol type.
   typedef Protocol protocol_type;
@@ -61,11 +69,11 @@ public:
    * needs to be opened and then connected or accepted before data can be sent
    * or received on it.
    *
-   * @param io_service The io_service object that the stream socket will use to
+   * @param io_context The io_context object that the stream socket will use to
    * dispatch handlers for any asynchronous operations performed on the socket.
    */
-  explicit basic_stream_socket(asio::io_service& io_service)
-    : basic_socket<Protocol, StreamSocketService>(io_service)
+  explicit basic_stream_socket(asio::io_context& io_context)
+    : basic_socket<Protocol ASIO_SVC_TARG>(io_context)
   {
   }
 
@@ -74,16 +82,16 @@ public:
    * This constructor creates and opens a stream socket. The socket needs to be
    * connected or accepted before data can be sent or received on it.
    *
-   * @param io_service The io_service object that the stream socket will use to
+   * @param io_context The io_context object that the stream socket will use to
    * dispatch handlers for any asynchronous operations performed on the socket.
    *
    * @param protocol An object specifying protocol parameters to be used.
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_stream_socket(asio::io_service& io_service,
+  basic_stream_socket(asio::io_context& io_context,
       const protocol_type& protocol)
-    : basic_socket<Protocol, StreamSocketService>(io_service, protocol)
+    : basic_socket<Protocol ASIO_SVC_TARG>(io_context, protocol)
   {
   }
 
@@ -94,7 +102,7 @@ public:
    * to the specified endpoint on the local machine. The protocol used is the
    * protocol associated with the given endpoint.
    *
-   * @param io_service The io_service object that the stream socket will use to
+   * @param io_context The io_context object that the stream socket will use to
    * dispatch handlers for any asynchronous operations performed on the socket.
    *
    * @param endpoint An endpoint on the local machine to which the stream
@@ -102,9 +110,9 @@ public:
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_stream_socket(asio::io_service& io_service,
+  basic_stream_socket(asio::io_context& io_context,
       const endpoint_type& endpoint)
-    : basic_socket<Protocol, StreamSocketService>(io_service, endpoint)
+    : basic_socket<Protocol ASIO_SVC_TARG>(io_context, endpoint)
   {
   }
 
@@ -113,7 +121,7 @@ public:
    * This constructor creates a stream socket object to hold an existing native
    * socket.
    *
-   * @param io_service The io_service object that the stream socket will use to
+   * @param io_context The io_context object that the stream socket will use to
    * dispatch handlers for any asynchronous operations performed on the socket.
    *
    * @param protocol An object specifying protocol parameters to be used.
@@ -122,10 +130,10 @@ public:
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_stream_socket(asio::io_service& io_service,
+  basic_stream_socket(asio::io_context& io_context,
       const protocol_type& protocol, const native_handle_type& native_socket)
-    : basic_socket<Protocol, StreamSocketService>(
-        io_service, protocol, native_socket)
+    : basic_socket<Protocol ASIO_SVC_TARG>(
+        io_context, protocol, native_socket)
   {
   }
 
@@ -138,11 +146,10 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_stream_socket(io_service&) constructor.
+   * constructed using the @c basic_stream_socket(io_context&) constructor.
    */
   basic_stream_socket(basic_stream_socket&& other)
-    : basic_socket<Protocol, StreamSocketService>(
-        ASIO_MOVE_CAST(basic_stream_socket)(other))
+    : basic_socket<Protocol ASIO_SVC_TARG>(std::move(other))
   {
   }
 
@@ -154,12 +161,11 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_stream_socket(io_service&) constructor.
+   * constructed using the @c basic_stream_socket(io_context&) constructor.
    */
   basic_stream_socket& operator=(basic_stream_socket&& other)
   {
-    basic_socket<Protocol, StreamSocketService>::operator=(
-        ASIO_MOVE_CAST(basic_stream_socket)(other));
+    basic_socket<Protocol ASIO_SVC_TARG>::operator=(std::move(other));
     return *this;
   }
 
@@ -172,15 +178,13 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_stream_socket(io_service&) constructor.
+   * constructed using the @c basic_stream_socket(io_context&) constructor.
    */
-  template <typename Protocol1, typename StreamSocketService1>
+  template <typename Protocol1 ASIO_SVC_TPARAM1>
   basic_stream_socket(
-      basic_stream_socket<Protocol1, StreamSocketService1>&& other,
+      basic_stream_socket<Protocol1 ASIO_SVC_TARG1>&& other,
       typename enable_if<is_convertible<Protocol1, Protocol>::value>::type* = 0)
-    : basic_socket<Protocol, StreamSocketService>(
-        ASIO_MOVE_CAST2(basic_stream_socket<
-          Protocol1, StreamSocketService1>)(other))
+    : basic_socket<Protocol ASIO_SVC_TARG>(std::move(other))
   {
   }
 
@@ -192,20 +196,27 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_stream_socket(io_service&) constructor.
+   * constructed using the @c basic_stream_socket(io_context&) constructor.
    */
-  template <typename Protocol1, typename StreamSocketService1>
+  template <typename Protocol1 ASIO_SVC_TPARAM1>
   typename enable_if<is_convertible<Protocol1, Protocol>::value,
       basic_stream_socket>::type& operator=(
-        basic_stream_socket<Protocol1, StreamSocketService1>&& other)
+        basic_stream_socket<Protocol1 ASIO_SVC_TARG1>&& other)
   {
-    basic_socket<Protocol, StreamSocketService>::operator=(
-        ASIO_MOVE_CAST2(basic_stream_socket<
-          Protocol1, StreamSocketService1>)(other));
+    basic_socket<Protocol ASIO_SVC_TARG>::operator=(std::move(other));
     return *this;
   }
 #endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
 
+  /// Destroys the socket.
+  /**
+   * This function destroys the socket, cancelling any outstanding asynchronous
+   * operations associated with the socket as if by calling @c cancel.
+   */
+  ~basic_stream_socket()
+  {
+  }
+
   /// Send some data on the socket.
   /**
    * This function is used to send data on the stream socket. The function
@@ -325,7 +336,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The send operation may not transmit all of the data to the peer.
    * Consider using the @ref async_write function if you need to ensure that all
@@ -350,9 +361,20 @@ public:
     // not meet the documented type requirements for a WriteHandler.
     ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_send(
         this->get_implementation(), buffers, 0,
         ASIO_MOVE_CAST(WriteHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<WriteHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_send(
+        this->get_implementation(), buffers, 0,
+        init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Start an asynchronous send.
@@ -377,7 +399,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The send operation may not transmit all of the data to the peer.
    * Consider using the @ref async_write function if you need to ensure that all
@@ -403,9 +425,20 @@ public:
     // not meet the documented type requirements for a WriteHandler.
     ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_send(
         this->get_implementation(), buffers, flags,
         ASIO_MOVE_CAST(WriteHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<WriteHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_send(
+        this->get_implementation(), buffers, flags,
+        init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Receive some data on the socket.
@@ -533,7 +566,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The receive operation may not receive all of the requested number of
    * bytes. Consider using the @ref async_read function if you need to ensure
@@ -560,8 +593,18 @@ public:
     // not meet the documented type requirements for a ReadHandler.
     ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_receive(this->get_implementation(),
         buffers, 0, ASIO_MOVE_CAST(ReadHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<ReadHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_receive(this->get_implementation(),
+        buffers, 0, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Start an asynchronous receive.
@@ -586,7 +629,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The receive operation may not receive all of the requested number of
    * bytes. Consider using the @ref async_read function if you need to ensure
@@ -614,8 +657,18 @@ public:
     // not meet the documented type requirements for a ReadHandler.
     ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_receive(this->get_implementation(),
         buffers, flags, ASIO_MOVE_CAST(ReadHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<ReadHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_receive(this->get_implementation(),
+        buffers, flags, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Write some data to the socket.
@@ -698,7 +751,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The write operation may not transmit all of the data to the peer.
    * Consider using the @ref async_write function if you need to ensure that all
@@ -723,8 +776,18 @@ public:
     // not meet the documented type requirements for a WriteHandler.
     ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_send(this->get_implementation(),
         buffers, 0, ASIO_MOVE_CAST(WriteHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<WriteHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_send(this->get_implementation(),
+        buffers, 0, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Read some data from the socket.
@@ -810,7 +873,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The read operation may not read all of the requested number of bytes.
    * Consider using the @ref async_read function if you need to ensure that the
@@ -836,8 +899,18 @@ public:
     // not meet the documented type requirements for a ReadHandler.
     ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_receive(this->get_implementation(),
         buffers, 0, ASIO_MOVE_CAST(ReadHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<ReadHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_receive(this->get_implementation(),
+        buffers, 0, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 };
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_streambuf.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_streambuf.hpp
index 5b7c5dc..0f06032 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_streambuf.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_streambuf.hpp
@@ -2,7 +2,7 @@
 // basic_streambuf.hpp
 // ~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -119,8 +119,8 @@ public:
   /// The type used to represent the output sequence as a list of buffers.
   typedef implementation_defined mutable_buffers_type;
 #else
-  typedef asio::const_buffers_1 const_buffers_type;
-  typedef asio::mutable_buffers_1 mutable_buffers_type;
+  typedef ASIO_CONST_BUFFER const_buffers_type;
+  typedef ASIO_MUTABLE_BUFFER mutable_buffers_type;
 #endif
 
   /// Construct a basic_streambuf object.
@@ -151,7 +151,7 @@ public:
    * while (i != bufs.end())
    * {
    *   const_buffer buf(*i++);
-   *   s += buffer_size(buf);
+   *   s += buf.size();
    * }
    * @endcode
    */
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_streambuf_fwd.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_streambuf_fwd.hpp
index d3b3406..361997b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_streambuf_fwd.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_streambuf_fwd.hpp
@@ -2,7 +2,7 @@
 // basic_streambuf_fwd.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_waitable_timer.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_waitable_timer.hpp
index d83bb51..6e9a3e1 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_waitable_timer.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/basic_waitable_timer.hpp
@@ -2,7 +2,7 @@
 // basic_waitable_timer.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -22,12 +22,36 @@
 #include "asio/detail/throw_error.hpp"
 #include "asio/error.hpp"
 #include "asio/wait_traits.hpp"
-#include "asio/waitable_timer_service.hpp"
+
+#if defined(ASIO_HAS_MOVE)
+# include <utility>
+#endif // defined(ASIO_HAS_MOVE)
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+# include "asio/waitable_timer_service.hpp"
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+# include "asio/detail/chrono_time_traits.hpp"
+# include "asio/detail/deadline_timer_service.hpp"
+# define ASIO_SVC_T \
+    detail::deadline_timer_service< \
+      detail::chrono_time_traits<Clock, WaitTraits> >
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
 
 #include "asio/detail/push_options.hpp"
 
 namespace asio {
 
+#if !defined(ASIO_BASIC_WAITABLE_TIMER_FWD_DECL)
+#define ASIO_BASIC_WAITABLE_TIMER_FWD_DECL
+
+// Forward declaration with defaulted arguments.
+template <typename Clock,
+    typename WaitTraits = asio::wait_traits<Clock>
+    ASIO_SVC_TPARAM_DEF2(= waitable_timer_service<Clock, WaitTraits>)>
+class basic_waitable_timer;
+
+#endif // !defined(ASIO_BASIC_WAITABLE_TIMER_FWD_DECL)
+
 /// Provides waitable timer functionality.
 /**
  * The basic_waitable_timer class template provides the ability to perform a
@@ -51,7 +75,7 @@ namespace asio {
  * Performing a blocking wait (C++11):
  * @code
  * // Construct a timer without setting an expiry time.
- * asio::steady_timer timer(io_service);
+ * asio::steady_timer timer(io_context);
  *
  * // Set an expiry time relative to now.
  * timer.expires_after(std::chrono::seconds(5));
@@ -74,7 +98,7 @@ namespace asio {
  * ...
  *
  * // Construct a timer with an absolute expiry time.
- * asio::steady_timer timer(io_service,
+ * asio::steady_timer timer(io_context,
  *     std::chrono::steady_clock::now() + std::chrono::seconds(60));
  *
  * // Start an asynchronous wait.
@@ -120,13 +144,14 @@ namespace asio {
  * @li If a wait handler is cancelled, the asio::error_code passed to
  * it contains the value asio::error::operation_aborted.
  */
-template <typename Clock,
-    typename WaitTraits = asio::wait_traits<Clock>,
-    typename WaitableTimerService = waitable_timer_service<Clock, WaitTraits> >
+template <typename Clock, typename WaitTraits ASIO_SVC_TPARAM>
 class basic_waitable_timer
-  : public basic_io_object<WaitableTimerService>
+  : ASIO_SVC_ACCESS basic_io_object<ASIO_SVC_T>
 {
 public:
+  /// The type of the executor associated with the object.
+  typedef io_context::executor_type executor_type;
+
   /// The clock type.
   typedef Clock clock_type;
 
@@ -145,11 +170,11 @@ public:
    * expires_at() or expires_after() functions must be called to set an expiry
    * time before the timer can be waited on.
    *
-   * @param io_service The io_service object that the timer will use to dispatch
+   * @param io_context The io_context object that the timer will use to dispatch
    * handlers for any asynchronous operations performed on the timer.
    */
-  explicit basic_waitable_timer(asio::io_service& io_service)
-    : basic_io_object<WaitableTimerService>(io_service)
+  explicit basic_waitable_timer(asio::io_context& io_context)
+    : basic_io_object<ASIO_SVC_T>(io_context)
   {
   }
 
@@ -157,15 +182,15 @@ public:
   /**
    * This constructor creates a timer and sets the expiry time.
    *
-   * @param io_service The io_service object that the timer will use to dispatch
+   * @param io_context The io_context object that the timer will use to dispatch
    * handlers for any asynchronous operations performed on the timer.
    *
    * @param expiry_time The expiry time to be used for the timer, expressed
    * as an absolute time.
    */
-  basic_waitable_timer(asio::io_service& io_service,
+  basic_waitable_timer(asio::io_context& io_context,
       const time_point& expiry_time)
-    : basic_io_object<WaitableTimerService>(io_service)
+    : basic_io_object<ASIO_SVC_T>(io_context)
   {
     asio::error_code ec;
     this->get_service().expires_at(this->get_implementation(), expiry_time, ec);
@@ -176,15 +201,15 @@ public:
   /**
    * This constructor creates a timer and sets the expiry time.
    *
-   * @param io_service The io_service object that the timer will use to dispatch
+   * @param io_context The io_context object that the timer will use to dispatch
    * handlers for any asynchronous operations performed on the timer.
    *
    * @param expiry_time The expiry time to be used for the timer, relative to
    * now.
    */
-  basic_waitable_timer(asio::io_service& io_service,
+  basic_waitable_timer(asio::io_context& io_context,
       const duration& expiry_time)
-    : basic_io_object<WaitableTimerService>(io_service)
+    : basic_io_object<ASIO_SVC_T>(io_context)
   {
     asio::error_code ec;
     this->get_service().expires_after(
@@ -201,32 +226,80 @@ public:
    * occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_waitable_timer(io_service&) constructor.
+   * constructed using the @c basic_waitable_timer(io_context&) constructor.
    */
   basic_waitable_timer(basic_waitable_timer&& other)
-    : basic_io_object<WaitableTimerService>(
-        ASIO_MOVE_CAST(basic_waitable_timer)(other))
+    : basic_io_object<ASIO_SVC_T>(std::move(other))
   {
   }
 
   /// Move-assign a basic_waitable_timer from another.
   /**
-   * This assignment operator moves a timer from one object to another.
+   * This assignment operator moves a timer from one object to another. Cancels
+   * any outstanding asynchronous operations associated with the target object.
    *
    * @param other The other basic_waitable_timer object from which the move will
    * occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_waitable_timer(io_service&) constructor.
+   * constructed using the @c basic_waitable_timer(io_context&) constructor.
    */
   basic_waitable_timer& operator=(basic_waitable_timer&& other)
   {
-    basic_io_object<WaitableTimerService>::operator=(
-        ASIO_MOVE_CAST(basic_waitable_timer)(other));
+    basic_io_object<ASIO_SVC_T>::operator=(std::move(other));
     return *this;
   }
 #endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
 
+  /// Destroys the timer.
+  /**
+   * This function destroys the timer, cancelling any outstanding asynchronous
+   * wait operations associated with the timer as if by calling @c cancel.
+   */
+  ~basic_waitable_timer()
+  {
+  }
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+  // These functions are provided by basic_io_object<>.
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_context()
+  {
+    return basic_io_object<ASIO_SVC_T>::get_io_context();
+  }
+
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_service()
+  {
+    return basic_io_object<ASIO_SVC_T>::get_io_service();
+  }
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// Get the executor associated with the object.
+  executor_type get_executor() ASIO_NOEXCEPT
+  {
+    return basic_io_object<ASIO_SVC_T>::get_executor();
+  }
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
   /// Cancel any asynchronous operations that are waiting on the timer.
   /**
    * This function forces the completion of any pending asynchronous wait
@@ -257,7 +330,9 @@ public:
     return s;
   }
 
-  /// Cancel any asynchronous operations that are waiting on the timer.
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use non-error_code overload.) Cancel any asynchronous
+  /// operations that are waiting on the timer.
   /**
    * This function forces the completion of any pending asynchronous wait
    * operations against the timer. The handler for each cancelled operation will
@@ -283,6 +358,7 @@ public:
   {
     return this->get_service().cancel(this->get_implementation(), ec);
   }
+#endif // !defined(ASIO_NO_DEPRECATED)
 
   /// Cancels one asynchronous operation that is waiting on the timer.
   /**
@@ -317,7 +393,9 @@ public:
     return s;
   }
 
-  /// Cancels one asynchronous operation that is waiting on the timer.
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use non-error_code overload.) Cancels one asynchronous
+  /// operation that is waiting on the timer.
   /**
    * This function forces the completion of one pending asynchronous wait
    * operation against the timer. Handlers are cancelled in FIFO order. The
@@ -346,7 +424,6 @@ public:
     return this->get_service().cancel_one(this->get_implementation(), ec);
   }
 
-#if !defined(ASIO_NO_DEPRECATED)
   /// (Deprecated: Use expiry().) Get the timer's expiry time as an absolute
   /// time.
   /**
@@ -400,7 +477,9 @@ public:
     return s;
   }
 
-  /// Set the timer's expiry time as an absolute time.
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use non-error_code overload.) Set the timer's expiry time as
+  /// an absolute time.
   /**
    * This function sets the expiry time. Any pending asynchronous wait
    * operations will be cancelled. The handler for each cancelled operation will
@@ -428,6 +507,7 @@ public:
     return this->get_service().expires_at(
         this->get_implementation(), expiry_time, ec);
   }
+#endif // !defined(ASIO_NO_DEPRECATED)
 
   /// Set the timer's expiry time relative to now.
   /**
@@ -460,35 +540,6 @@ public:
     return s;
   }
 
-  /// Set the timer's expiry time relative to now.
-  /**
-   * This function sets the expiry time. Any pending asynchronous wait
-   * operations will be cancelled. The handler for each cancelled operation will
-   * be invoked with the asio::error::operation_aborted error code.
-   *
-   * @param expiry_time The expiry time to be used for the timer.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @return The number of asynchronous operations that were cancelled.
-   *
-   * @note If the timer has already expired when expires_after() is called,
-   * then the handlers for asynchronous wait operations will:
-   *
-   * @li have already been invoked; or
-   *
-   * @li have been queued for invocation in the near future.
-   *
-   * These handlers can no longer be cancelled, and therefore are passed an
-   * error code that indicates the successful completion of the wait operation.
-   */
-  std::size_t expires_after(const duration& expiry_time,
-      asio::error_code& ec)
-  {
-    return this->get_service().expires_after(
-        this->get_implementation(), expiry_time, ec);
-  }
-
 #if !defined(ASIO_NO_DEPRECATED)
   /// (Deprecated: Use expiry().) Get the timer's expiry time relative to now.
   /**
@@ -611,7 +662,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    */
   template <typename WaitHandler>
   ASIO_INITFN_RESULT_TYPE(WaitHandler,
@@ -622,13 +673,33 @@ public:
     // not meet the documented type requirements for a WaitHandler.
     ASIO_WAIT_HANDLER_CHECK(WaitHandler, handler) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_wait(this->get_implementation(),
         ASIO_MOVE_CAST(WaitHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    async_completion<WaitHandler,
+      void (asio::error_code)> init(handler);
+
+    this->get_service().async_wait(this->get_implementation(),
+        init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
+
+private:
+  // Disallow copying and assignment.
+  basic_waitable_timer(const basic_waitable_timer&) ASIO_DELETED;
+  basic_waitable_timer& operator=(
+      const basic_waitable_timer&) ASIO_DELETED;
 };
 
 } // namespace asio
 
 #include "asio/detail/pop_options.hpp"
 
+#if !defined(ASIO_ENABLE_OLD_SERVICES)
+# undef ASIO_SVC_T
+#endif // !defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_BASIC_WAITABLE_TIMER_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/bind_executor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/bind_executor.hpp
new file mode 100644
index 0000000..3ed890d
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/bind_executor.hpp
@@ -0,0 +1,611 @@
+//
+// bind_executor.hpp
+// ~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_BIND_EXECUTOR_HPP
+#define ASIO_BIND_EXECUTOR_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+#include "asio/detail/type_traits.hpp"
+#include "asio/detail/variadic_templates.hpp"
+#include "asio/associated_executor.hpp"
+#include "asio/associated_allocator.hpp"
+#include "asio/async_result.hpp"
+#include "asio/execution_context.hpp"
+#include "asio/is_executor.hpp"
+#include "asio/uses_executor.hpp"
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+namespace detail {
+
+template <typename T>
+struct executor_binder_check
+{
+  typedef void type;
+};
+
+// Helper to automatically define nested typedef result_type.
+
+template <typename T, typename = void>
+struct executor_binder_result_type
+{
+protected:
+  typedef void result_type_or_void;
+};
+
+template <typename T>
+struct executor_binder_result_type<T,
+  typename executor_binder_check<typename T::result_type>::type>
+{
+  typedef typename T::result_type result_type;
+protected:
+  typedef result_type result_type_or_void;
+};
+
+template <typename R>
+struct executor_binder_result_type<R(*)()>
+{
+  typedef R result_type;
+protected:
+  typedef result_type result_type_or_void;
+};
+
+template <typename R>
+struct executor_binder_result_type<R(&)()>
+{
+  typedef R result_type;
+protected:
+  typedef result_type result_type_or_void;
+};
+
+template <typename R, typename A1>
+struct executor_binder_result_type<R(*)(A1)>
+{
+  typedef R result_type;
+protected:
+  typedef result_type result_type_or_void;
+};
+
+template <typename R, typename A1>
+struct executor_binder_result_type<R(&)(A1)>
+{
+  typedef R result_type;
+protected:
+  typedef result_type result_type_or_void;
+};
+
+template <typename R, typename A1, typename A2>
+struct executor_binder_result_type<R(*)(A1, A2)>
+{
+  typedef R result_type;
+protected:
+  typedef result_type result_type_or_void;
+};
+
+template <typename R, typename A1, typename A2>
+struct executor_binder_result_type<R(&)(A1, A2)>
+{
+  typedef R result_type;
+protected:
+  typedef result_type result_type_or_void;
+};
+
+// Helper to automatically define nested typedef argument_type.
+
+template <typename T, typename = void>
+struct executor_binder_argument_type {};
+
+template <typename T>
+struct executor_binder_argument_type<T,
+  typename executor_binder_check<typename T::argument_type>::type>
+{
+  typedef typename T::argument_type argument_type;
+};
+
+template <typename R, typename A1>
+struct executor_binder_argument_type<R(*)(A1)>
+{
+  typedef A1 argument_type;
+};
+
+template <typename R, typename A1>
+struct executor_binder_argument_type<R(&)(A1)>
+{
+  typedef A1 argument_type;
+};
+
+// Helper to automatically define nested typedefs first_argument_type and
+// second_argument_type.
+
+template <typename T, typename = void>
+struct executor_binder_argument_types {};
+
+template <typename T>
+struct executor_binder_argument_types<T,
+  typename executor_binder_check<typename T::first_argument_type>::type>
+{
+  typedef typename T::first_argument_type first_argument_type;
+  typedef typename T::second_argument_type second_argument_type;
+};
+
+template <typename R, typename A1, typename A2>
+struct executor_binder_argument_type<R(*)(A1, A2)>
+{
+  typedef A1 first_argument_type;
+  typedef A2 second_argument_type;
+};
+
+template <typename R, typename A1, typename A2>
+struct executor_binder_argument_type<R(&)(A1, A2)>
+{
+  typedef A1 first_argument_type;
+  typedef A2 second_argument_type;
+};
+
+// Helper to:
+// - Apply the empty base optimisation to the executor.
+// - Perform uses_executor construction of the target type, if required.
+
+template <typename T, typename Executor, bool UsesExecutor>
+class executor_binder_base;
+
+template <typename T, typename Executor>
+class executor_binder_base<T, Executor, true>
+  : protected Executor
+{
+protected:
+  template <typename E, typename U>
+  executor_binder_base(ASIO_MOVE_ARG(E) e, ASIO_MOVE_ARG(U) u)
+    : executor_(ASIO_MOVE_CAST(E)(e)),
+      target_(executor_arg_t(), executor_, ASIO_MOVE_CAST(U)(u))
+  {
+  }
+
+  Executor executor_;
+  T target_;
+};
+
+template <typename T, typename Executor>
+class executor_binder_base<T, Executor, false>
+{
+protected:
+  template <typename E, typename U>
+  executor_binder_base(ASIO_MOVE_ARG(E) e, ASIO_MOVE_ARG(U) u)
+    : executor_(ASIO_MOVE_CAST(E)(e)),
+      target_(ASIO_MOVE_CAST(U)(u))
+  {
+  }
+
+  Executor executor_;
+  T target_;
+};
+
+// Helper to enable SFINAE on zero-argument operator() below.
+
+template <typename T, typename = void>
+struct executor_binder_result_of0
+{
+  typedef void type;
+};
+
+template <typename T>
+struct executor_binder_result_of0<T,
+  typename executor_binder_check<typename result_of<T()>::type>::type>
+{
+  typedef typename result_of<T()>::type type;
+};
+
+} // namespace detail
+
+/// A call wrapper type to bind an executor of type @c Executor to an object of
+/// type @c T.
+template <typename T, typename Executor>
+class executor_binder
+#if !defined(GENERATING_DOCUMENTATION)
+  : public detail::executor_binder_result_type<T>,
+    public detail::executor_binder_argument_type<T>,
+    public detail::executor_binder_argument_types<T>,
+    private detail::executor_binder_base<
+      T, Executor, uses_executor<T, Executor>::value>
+#endif // !defined(GENERATING_DOCUMENTATION)
+{
+public:
+  /// The type of the target object.
+  typedef T target_type;
+
+  /// The type of the associated executor.
+  typedef Executor executor_type;
+
+#if defined(GENERATING_DOCUMENTATION)
+  /// The return type if a function.
+  /**
+   * The type of @c result_type is based on the type @c T of the wrapper's
+   * target object:
+   *
+   * @li if @c T is a pointer to function type, @c result_type is a synonym for
+   * the return type of @c T;
+   *
+   * @li if @c T is a class type with a member type @c result_type, then @c
+   * result_type is a synonym for @c T::result_type;
+   *
+   * @li otherwise @c result_type is not defined.
+   */
+  typedef see_below result_type;
+
+  /// The type of the function's argument.
+  /**
+   * The type of @c argument_type is based on the type @c T of the wrapper's
+   * target object:
+   *
+   * @li if @c T is a pointer to a function type accepting a single argument,
+   * @c argument_type is a synonym for the return type of @c T;
+   *
+   * @li if @c T is a class type with a member type @c argument_type, then @c
+   * argument_type is a synonym for @c T::argument_type;
+   *
+   * @li otherwise @c argument_type is not defined.
+   */
+  typedef see_below argument_type;
+
+  /// The type of the function's first argument.
+  /**
+   * The type of @c first_argument_type is based on the type @c T of the
+   * wrapper's target object:
+   *
+   * @li if @c T is a pointer to a function type accepting two arguments, @c
+   * first_argument_type is a synonym for the return type of @c T;
+   *
+   * @li if @c T is a class type with a member type @c first_argument_type,
+   * then @c first_argument_type is a synonym for @c T::first_argument_type;
+   *
+   * @li otherwise @c first_argument_type is not defined.
+   */
+  typedef see_below first_argument_type;
+
+  /// The type of the function's second argument.
+  /**
+   * The type of @c second_argument_type is based on the type @c T of the
+   * wrapper's target object:
+   *
+   * @li if @c T is a pointer to a function type accepting two arguments, @c
+   * second_argument_type is a synonym for the return type of @c T;
+   *
+   * @li if @c T is a class type with a member type @c first_argument_type,
+   * then @c second_argument_type is a synonym for @c T::second_argument_type;
+   *
+   * @li otherwise @c second_argument_type is not defined.
+   */
+  typedef see_below second_argument_type;
+#endif // defined(GENERATING_DOCUMENTATION)
+
+  /// Construct an executor wrapper for the specified object.
+  /**
+   * This constructor is only valid if the type @c T is constructible from type
+   * @c U.
+   */
+  template <typename U>
+  executor_binder(executor_arg_t, const executor_type& e,
+      ASIO_MOVE_ARG(U) u)
+    : base_type(e, ASIO_MOVE_CAST(U)(u))
+  {
+  }
+
+  /// Copy constructor.
+  executor_binder(const executor_binder& other)
+    : base_type(other.get_executor(), other.get())
+  {
+  }
+
+  /// Construct a copy, but specify a different executor.
+  executor_binder(executor_arg_t, const executor_type& e,
+      const executor_binder& other)
+    : base_type(e, other.get())
+  {
+  }
+
+  /// Construct a copy of a different executor wrapper type.
+  /**
+   * This constructor is only valid if the @c Executor type is constructible
+   * from type @c OtherExecutor, and the type @c T is constructible from type
+   * @c U.
+   */
+  template <typename U, typename OtherExecutor>
+  executor_binder(const executor_binder<U, OtherExecutor>& other)
+    : base_type(other.get_executor(), other.get())
+  {
+  }
+
+  /// Construct a copy of a different executor wrapper type, but specify a
+  /// different executor.
+  /**
+   * This constructor is only valid if the type @c T is constructible from type
+   * @c U.
+   */
+  template <typename U, typename OtherExecutor>
+  executor_binder(executor_arg_t, const executor_type& e,
+      const executor_binder<U, OtherExecutor>& other)
+    : base_type(e, other.get())
+  {
+  }
+
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+
+  /// Move constructor.
+  executor_binder(executor_binder&& other)
+    : base_type(ASIO_MOVE_CAST(executor_type)(other.get_executor()),
+        ASIO_MOVE_CAST(T)(other.get()))
+  {
+  }
+
+  /// Move construct the target object, but specify a different executor.
+  executor_binder(executor_arg_t, const executor_type& e,
+      executor_binder&& other)
+    : base_type(e, ASIO_MOVE_CAST(T)(other.get()))
+  {
+  }
+
+  /// Move construct from a different executor wrapper type.
+  template <typename U, typename OtherExecutor>
+  executor_binder(executor_binder<U, OtherExecutor>&& other)
+    : base_type(ASIO_MOVE_CAST(OtherExecutor)(other.get_executor()),
+        ASIO_MOVE_CAST(U)(other.get()))
+  {
+  }
+
+  /// Move construct from a different executor wrapper type, but specify a
+  /// different executor.
+  template <typename U, typename OtherExecutor>
+  executor_binder(executor_arg_t, const executor_type& e,
+      executor_binder<U, OtherExecutor>&& other)
+    : base_type(e, ASIO_MOVE_CAST(U)(other.get()))
+  {
+  }
+
+#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+
+  /// Destructor.
+  ~executor_binder()
+  {
+  }
+
+  /// Obtain a reference to the target object.
+  target_type& get() ASIO_NOEXCEPT
+  {
+    return this->target_;
+  }
+
+  /// Obtain a reference to the target object.
+  const target_type& get() const ASIO_NOEXCEPT
+  {
+    return this->target_;
+  }
+
+  /// Obtain the associated executor.
+  executor_type get_executor() const ASIO_NOEXCEPT
+  {
+    return this->executor_;
+  }
+
+#if defined(GENERATING_DOCUMENTATION)
+
+  template <typename... Args> auto operator()(Args&& ...);
+  template <typename... Args> auto operator()(Args&& ...) const;
+
+#elif defined(ASIO_HAS_VARIADIC_TEMPLATES)
+
+  /// Forwarding function call operator.
+  template <typename... Args>
+  typename result_of<T(Args...)>::type operator()(
+      ASIO_MOVE_ARG(Args)... args)
+  {
+    return this->target_(ASIO_MOVE_CAST(Args)(args)...);
+  }
+
+  /// Forwarding function call operator.
+  template <typename... Args>
+  typename result_of<T(Args...)>::type operator()(
+      ASIO_MOVE_ARG(Args)... args) const
+  {
+    return this->target_(ASIO_MOVE_CAST(Args)(args)...);
+  }
+
+#elif defined(ASIO_HAS_STD_TYPE_TRAITS) && !defined(_MSC_VER)
+
+  typename detail::executor_binder_result_of0<T>::type operator()()
+  {
+    return this->target_();
+  }
+
+  typename detail::executor_binder_result_of0<T>::type operator()() const
+  {
+    return this->target_();
+  }
+
+#define ASIO_PRIVATE_BIND_EXECUTOR_CALL_DEF(n) \
+  template <ASIO_VARIADIC_TPARAMS(n)> \
+  typename result_of<T(ASIO_VARIADIC_TARGS(n))>::type operator()( \
+      ASIO_VARIADIC_MOVE_PARAMS(n)) \
+  { \
+    return this->target_(ASIO_VARIADIC_MOVE_ARGS(n)); \
+  } \
+  \
+  template <ASIO_VARIADIC_TPARAMS(n)> \
+  typename result_of<T(ASIO_VARIADIC_TARGS(n))>::type operator()( \
+      ASIO_VARIADIC_MOVE_PARAMS(n)) const \
+  { \
+    return this->target_(ASIO_VARIADIC_MOVE_ARGS(n)); \
+  } \
+  /**/
+  ASIO_VARIADIC_GENERATE(ASIO_PRIVATE_BIND_EXECUTOR_CALL_DEF)
+#undef ASIO_PRIVATE_BIND_EXECUTOR_CALL_DEF
+
+#else // defined(ASIO_HAS_STD_TYPE_TRAITS) && !defined(_MSC_VER)
+
+  typedef typename detail::executor_binder_result_type<T>::result_type_or_void
+    result_type_or_void;
+
+  result_type_or_void operator()()
+  {
+    return this->target_();
+  }
+
+  result_type_or_void operator()() const
+  {
+    return this->target_();
+  }
+
+#define ASIO_PRIVATE_BIND_EXECUTOR_CALL_DEF(n) \
+  template <ASIO_VARIADIC_TPARAMS(n)> \
+  result_type_or_void operator()( \
+      ASIO_VARIADIC_MOVE_PARAMS(n)) \
+  { \
+    return this->target_(ASIO_VARIADIC_MOVE_ARGS(n)); \
+  } \
+  \
+  template <ASIO_VARIADIC_TPARAMS(n)> \
+  result_type_or_void operator()( \
+      ASIO_VARIADIC_MOVE_PARAMS(n)) const \
+  { \
+    return this->target_(ASIO_VARIADIC_MOVE_ARGS(n)); \
+  } \
+  /**/
+  ASIO_VARIADIC_GENERATE(ASIO_PRIVATE_BIND_EXECUTOR_CALL_DEF)
+#undef ASIO_PRIVATE_BIND_EXECUTOR_CALL_DEF
+
+#endif // defined(ASIO_HAS_STD_TYPE_TRAITS) && !defined(_MSC_VER)
+
+private:
+  typedef detail::executor_binder_base<T, Executor,
+    uses_executor<T, Executor>::value> base_type;
+};
+
+/// Associate an object of type @c T with an executor of type @c Executor.
+template <typename Executor, typename T>
+inline executor_binder<typename decay<T>::type, Executor>
+bind_executor(const Executor& ex, ASIO_MOVE_ARG(T) t,
+    typename enable_if<is_executor<Executor>::value>::type* = 0)
+{
+  return executor_binder<typename decay<T>::type, Executor>(
+      executor_arg_t(), ex, ASIO_MOVE_CAST(T)(t));
+}
+
+/// Associate an object of type @c T with an execution context's executor.
+template <typename ExecutionContext, typename T>
+inline executor_binder<typename decay<T>::type,
+  typename ExecutionContext::executor_type>
+bind_executor(ExecutionContext& ctx, ASIO_MOVE_ARG(T) t,
+    typename enable_if<is_convertible<
+      ExecutionContext&, execution_context&>::value>::type* = 0)
+{
+  return executor_binder<typename decay<T>::type,
+    typename ExecutionContext::executor_type>(
+      executor_arg_t(), ctx.get_executor(), ASIO_MOVE_CAST(T)(t));
+}
+
+#if !defined(GENERATING_DOCUMENTATION)
+
+template <typename T, typename Executor>
+struct uses_executor<executor_binder<T, Executor>, Executor>
+  : true_type {};
+
+template <typename T, typename Executor, typename Signature>
+class async_result<executor_binder<T, Executor>, Signature>
+{
+public:
+  typedef executor_binder<
+    typename async_result<T, Signature>::completion_handler_type, Executor>
+      completion_handler_type;
+
+  typedef typename async_result<T, Signature>::return_type return_type;
+
+  explicit async_result(executor_binder<T, Executor>& b)
+    : target_(b.get())
+  {
+  }
+
+  return_type get()
+  {
+    return target_.get();
+  }
+
+private:
+  async_result(const async_result&) ASIO_DELETED;
+  async_result& operator=(const async_result&) ASIO_DELETED;
+
+  async_result<T, Signature> target_;
+};
+
+#if !defined(ASIO_NO_DEPRECATED)
+
+template <typename T, typename Executor, typename Signature>
+struct handler_type<executor_binder<T, Executor>, Signature>
+{
+  typedef executor_binder<
+    typename handler_type<T, Signature>::type, Executor> type;
+};
+
+template <typename T, typename Executor>
+class async_result<executor_binder<T, Executor> >
+{
+public:
+  typedef typename async_result<T>::type type;
+
+  explicit async_result(executor_binder<T, Executor>& b)
+    : target_(b.get())
+  {
+  }
+
+  type get()
+  {
+    return target_.get();
+  }
+
+private:
+  async_result<T> target_;
+};
+
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+template <typename T, typename Executor, typename Allocator>
+struct associated_allocator<executor_binder<T, Executor>, Allocator>
+{
+  typedef typename associated_allocator<T, Allocator>::type type;
+
+  static type get(const executor_binder<T, Executor>& b,
+      const Allocator& a = Allocator()) ASIO_NOEXCEPT
+  {
+    return associated_allocator<T, Allocator>::get(b.get(), a);
+  }
+};
+
+template <typename T, typename Executor, typename Executor1>
+struct associated_executor<executor_binder<T, Executor>, Executor1>
+{
+  typedef Executor type;
+
+  static type get(const executor_binder<T, Executor>& b,
+      const Executor1& = Executor1()) ASIO_NOEXCEPT
+  {
+    return b.get_executor();
+  }
+};
+
+#endif // !defined(GENERATING_DOCUMENTATION)
+
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // ASIO_BIND_EXECUTOR_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/buffer.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/buffer.hpp
index ba984b6..7d53dde 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/buffer.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/buffer.hpp
@@ -2,7 +2,7 @@
 // buffer.hpp
 // ~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -24,6 +24,7 @@
 #include <vector>
 #include "asio/detail/array_fwd.hpp"
 #include "asio/detail/is_buffer_sequence.hpp"
+#include "asio/detail/string_view.hpp"
 #include "asio/detail/throw_exception.hpp"
 #include "asio/detail/type_traits.hpp"
 
@@ -67,13 +68,6 @@ namespace asio {
 class mutable_buffer;
 class const_buffer;
 
-namespace detail {
-void* buffer_cast_helper(const mutable_buffer&);
-const void* buffer_cast_helper(const const_buffer&);
-std::size_t buffer_size_helper(const mutable_buffer&);
-std::size_t buffer_size_helper(const const_buffer&);
-} // namespace detail
-
 /// Holds a buffer that can be modified.
 /**
  * The mutable_buffer class provides a safe representation of a buffer that can
@@ -82,29 +76,29 @@ std::size_t buffer_size_helper(const const_buffer&);
  *
  * @par Accessing Buffer Contents
  *
- * The contents of a buffer may be accessed using the @ref buffer_size
- * and @ref buffer_cast functions:
+ * The contents of a buffer may be accessed using the @c data() and @c size()
+ * member functions:
  *
  * @code asio::mutable_buffer b1 = ...;
- * std::size_t s1 = asio::buffer_size(b1);
- * unsigned char* p1 = asio::buffer_cast<unsigned char*>(b1);
+ * std::size_t s1 = b1.size();
+ * unsigned char* p1 = static_cast<unsigned char*>(b1.data());
  * @endcode
  *
- * The asio::buffer_cast function permits violations of type safety, so
- * uses of it in application code should be carefully considered.
+ * The @c data() member function permits violations of type safety, so uses of
+ * it in application code should be carefully considered.
  */
 class mutable_buffer
 {
 public:
   /// Construct an empty buffer.
-  mutable_buffer()
+  mutable_buffer() ASIO_NOEXCEPT
     : data_(0),
       size_(0)
   {
   }
 
   /// Construct a buffer to represent a given memory range.
-  mutable_buffer(void* data, std::size_t size)
+  mutable_buffer(void* data, std::size_t size) ASIO_NOEXCEPT
     : data_(data),
       size_(size)
   {
@@ -125,12 +119,32 @@ public:
   }
 #endif // ASIO_ENABLE_BUFFER_DEBUGGING
 
-private:
-  friend void* asio::detail::buffer_cast_helper(
-      const mutable_buffer& b);
-  friend std::size_t asio::detail::buffer_size_helper(
-      const mutable_buffer& b);
+  /// Get a pointer to the beginning of the memory range.
+  void* data() const ASIO_NOEXCEPT
+  {
+#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
+    if (size_ && debug_check_)
+      debug_check_();
+#endif // ASIO_ENABLE_BUFFER_DEBUGGING
+    return data_;
+  }
+
+  /// Get the size of the memory range.
+  std::size_t size() const ASIO_NOEXCEPT
+  {
+    return size_;
+  }
+
+  /// Move the start of the buffer by the specified number of bytes.
+  mutable_buffer& operator+=(std::size_t n) ASIO_NOEXCEPT
+  {
+    std::size_t offset = n < size_ ? n : size_;
+    data_ = static_cast<char*>(data_) + offset;
+    size_ -= offset;
+    return *this;
+  }
 
+private:
   void* data_;
   std::size_t size_;
 
@@ -139,26 +153,10 @@ private:
 #endif // ASIO_ENABLE_BUFFER_DEBUGGING
 };
 
-namespace detail {
-
-inline void* buffer_cast_helper(const mutable_buffer& b)
-{
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-  if (b.size_ && b.debug_check_)
-    b.debug_check_();
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-  return b.data_;
-}
-
-inline std::size_t buffer_size_helper(const mutable_buffer& b)
-{
-  return b.size_;
-}
-
-} // namespace detail
+#if !defined(ASIO_NO_DEPRECATED)
 
-/// Adapts a single modifiable buffer so that it meets the requirements of the
-/// MutableBufferSequence concept.
+/// (Deprecated: Use mutable_buffer.) Adapts a single modifiable buffer so that
+/// it meets the requirements of the MutableBufferSequence concept.
 class mutable_buffers_1
   : public mutable_buffer
 {
@@ -170,30 +168,40 @@ public:
   typedef const mutable_buffer* const_iterator;
 
   /// Construct to represent a given memory range.
-  mutable_buffers_1(void* data, std::size_t size)
+  mutable_buffers_1(void* data, std::size_t size) ASIO_NOEXCEPT
     : mutable_buffer(data, size)
   {
   }
 
+#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
+  mutable_buffers_1(void* data, std::size_t size,
+      asio::detail::function<void()> debug_check)
+    : mutable_buffer(data, size, debug_check)
+  {
+  }
+#endif // ASIO_ENABLE_BUFFER_DEBUGGING
+
   /// Construct to represent a single modifiable buffer.
-  explicit mutable_buffers_1(const mutable_buffer& b)
+  explicit mutable_buffers_1(const mutable_buffer& b) ASIO_NOEXCEPT
     : mutable_buffer(b)
   {
   }
 
   /// Get a random-access iterator to the first element.
-  const_iterator begin() const
+  const_iterator begin() const ASIO_NOEXCEPT
   {
     return this;
   }
 
   /// Get a random-access iterator for one past the last element.
-  const_iterator end() const
+  const_iterator end() const ASIO_NOEXCEPT
   {
     return begin() + 1;
   }
 };
 
+#endif // !defined(ASIO_NO_DEPRECATED)
+
 /// Holds a buffer that cannot be modified.
 /**
  * The const_buffer class provides a safe representation of a buffer that cannot
@@ -202,38 +210,38 @@ public:
  *
  * @par Accessing Buffer Contents
  *
- * The contents of a buffer may be accessed using the @ref buffer_size
- * and @ref buffer_cast functions:
+ * The contents of a buffer may be accessed using the @c data() and @c size()
+ * member functions:
  *
  * @code asio::const_buffer b1 = ...;
- * std::size_t s1 = asio::buffer_size(b1);
- * const unsigned char* p1 = asio::buffer_cast<const unsigned char*>(b1);
+ * std::size_t s1 = b1.size();
+ * const unsigned char* p1 = static_cast<const unsigned char*>(b1.data());
  * @endcode
  *
- * The asio::buffer_cast function permits violations of type safety, so
- * uses of it in application code should be carefully considered.
+ * The @c data() member function permits violations of type safety, so uses of
+ * it in application code should be carefully considered.
  */
 class const_buffer
 {
 public:
   /// Construct an empty buffer.
-  const_buffer()
+  const_buffer() ASIO_NOEXCEPT
     : data_(0),
       size_(0)
   {
   }
 
   /// Construct a buffer to represent a given memory range.
-  const_buffer(const void* data, std::size_t size)
+  const_buffer(const void* data, std::size_t size) ASIO_NOEXCEPT
     : data_(data),
       size_(size)
   {
   }
 
   /// Construct a non-modifiable buffer from a modifiable one.
-  const_buffer(const mutable_buffer& b)
-    : data_(asio::detail::buffer_cast_helper(b)),
-      size_(asio::detail::buffer_size_helper(b))
+  const_buffer(const mutable_buffer& b) ASIO_NOEXCEPT
+    : data_(b.data()),
+      size_(b.size())
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
       , debug_check_(b.get_debug_check())
 #endif // ASIO_ENABLE_BUFFER_DEBUGGING
@@ -255,12 +263,32 @@ public:
   }
 #endif // ASIO_ENABLE_BUFFER_DEBUGGING
 
-private:
-  friend const void* asio::detail::buffer_cast_helper(
-      const const_buffer& b);
-  friend std::size_t asio::detail::buffer_size_helper(
-      const const_buffer& b);
+  /// Get a pointer to the beginning of the memory range.
+  const void* data() const ASIO_NOEXCEPT
+  {
+#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
+    if (size_ && debug_check_)
+      debug_check_();
+#endif // ASIO_ENABLE_BUFFER_DEBUGGING
+    return data_;
+  }
+
+  /// Get the size of the memory range.
+  std::size_t size() const ASIO_NOEXCEPT
+  {
+    return size_;
+  }
+
+  /// Move the start of the buffer by the specified number of bytes.
+  const_buffer& operator+=(std::size_t n) ASIO_NOEXCEPT
+  {
+    std::size_t offset = n < size_ ? n : size_;
+    data_ = static_cast<const char*>(data_) + offset;
+    size_ -= offset;
+    return *this;
+  }
 
+private:
   const void* data_;
   std::size_t size_;
 
@@ -269,26 +297,10 @@ private:
 #endif // ASIO_ENABLE_BUFFER_DEBUGGING
 };
 
-namespace detail {
-
-inline const void* buffer_cast_helper(const const_buffer& b)
-{
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-  if (b.size_ && b.debug_check_)
-    b.debug_check_();
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-  return b.data_;
-}
-
-inline std::size_t buffer_size_helper(const const_buffer& b)
-{
-  return b.size_;
-}
-
-} // namespace detail
+#if !defined(ASIO_NO_DEPRECATED)
 
-/// Adapts a single non-modifiable buffer so that it meets the requirements of
-/// the ConstBufferSequence concept.
+/// (Deprecated: Use const_buffer.) Adapts a single non-modifiable buffer so
+/// that it meets the requirements of the ConstBufferSequence concept.
 class const_buffers_1
   : public const_buffer
 {
@@ -300,30 +312,40 @@ public:
   typedef const const_buffer* const_iterator;
 
   /// Construct to represent a given memory range.
-  const_buffers_1(const void* data, std::size_t size)
+  const_buffers_1(const void* data, std::size_t size) ASIO_NOEXCEPT
     : const_buffer(data, size)
   {
   }
 
+#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
+  const_buffers_1(const void* data, std::size_t size,
+      asio::detail::function<void()> debug_check)
+    : const_buffer(data, size, debug_check)
+  {
+  }
+#endif // ASIO_ENABLE_BUFFER_DEBUGGING
+
   /// Construct to represent a single non-modifiable buffer.
-  explicit const_buffers_1(const const_buffer& b)
+  explicit const_buffers_1(const const_buffer& b) ASIO_NOEXCEPT
     : const_buffer(b)
   {
   }
 
   /// Get a random-access iterator to the first element.
-  const_iterator begin() const
+  const_iterator begin() const ASIO_NOEXCEPT
   {
     return this;
   }
 
   /// Get a random-access iterator for one past the last element.
-  const_iterator end() const
+  const_iterator end() const ASIO_NOEXCEPT
   {
     return begin() + 1;
   }
 };
 
+#endif // !defined(ASIO_NO_DEPRECATED)
+
 /// Trait to determine whether a type satisfies the MutableBufferSequence
 /// requirements.
 template <typename T>
@@ -348,14 +370,13 @@ struct is_const_buffer_sequence
 {
 };
 
-/// Trait to determine whether a type satisfies the DynamicBufferSequence
-/// requirements.
+/// Trait to determine whether a type satisfies the DynamicBuffer requirements.
 template <typename T>
-struct is_dynamic_buffer_sequence
+struct is_dynamic_buffer
 #if defined(GENERATING_DOCUMENTATION)
   : integral_constant<bool, automatically_determined>
 #else // defined(GENERATING_DOCUMENTATION)
-  : asio::detail::is_dynamic_buffer_sequence<T>
+  : asio::detail::is_dynamic_buffer<T>
 #endif // defined(GENERATING_DOCUMENTATION)
 {
 };
@@ -373,13 +394,13 @@ public:
   typedef const mutable_buffer* const_iterator;
 
   /// Get a random-access iterator to the first element.
-  const_iterator begin() const
+  const_iterator begin() const ASIO_NOEXCEPT
   {
     return &buf_;
   }
 
   /// Get a random-access iterator for one past the last element.
-  const_iterator end() const
+  const_iterator end() const ASIO_NOEXCEPT
   {
     return &buf_;
   }
@@ -388,64 +409,189 @@ private:
   mutable_buffer buf_;
 };
 
-/** @defgroup buffer_size asio::buffer_size
+/** @defgroup buffer_sequence_begin asio::buffer_sequence_begin
  *
- * @brief The asio::buffer_size function determines the total number of
- * bytes in a buffer or buffer sequence.
+ * @brief The asio::buffer_sequence_begin function returns an iterator
+ * pointing to the first element in a buffer sequence.
  */
 /*@{*/
 
-/// Get the number of bytes in a modifiable buffer.
-inline std::size_t buffer_size(const mutable_buffer& b)
+/// Get an iterator to the first element in a buffer sequence.
+inline const mutable_buffer* buffer_sequence_begin(const mutable_buffer& b)
 {
-  return detail::buffer_size_helper(b);
+  return &b;
 }
 
-/// Get the number of bytes in a modifiable buffer.
-inline std::size_t buffer_size(const mutable_buffers_1& b)
+/// Get an iterator to the first element in a buffer sequence.
+inline const const_buffer* buffer_sequence_begin(const const_buffer& b)
 {
-  return detail::buffer_size_helper(b);
+  return &b;
 }
 
-/// Get the number of bytes in a non-modifiable buffer.
-inline std::size_t buffer_size(const const_buffer& b)
+#if defined(ASIO_HAS_DECLTYPE) || defined(GENERATING_DOCUMENTATION)
+
+/// Get an iterator to the first element in a buffer sequence.
+template <typename C>
+inline auto buffer_sequence_begin(C& c) -> decltype(c.begin())
 {
-  return detail::buffer_size_helper(b);
+  return c.begin();
 }
 
-/// Get the number of bytes in a non-modifiable buffer.
-inline std::size_t buffer_size(const const_buffers_1& b)
+/// Get an iterator to the first element in a buffer sequence.
+template <typename C>
+inline auto buffer_sequence_begin(const C& c) -> decltype(c.begin())
 {
-  return detail::buffer_size_helper(b);
+  return c.begin();
 }
 
-/// Get the total number of bytes in a buffer sequence.
-/** 
- * The @c BufferSequence template parameter may meet either of the @c
- * ConstBufferSequence or @c MutableBufferSequence type requirements.
+#else // defined(ASIO_HAS_DECLTYPE) || defined(GENERATING_DOCUMENTATION)
+
+template <typename C>
+inline typename C::iterator buffer_sequence_begin(C& c)
+{
+  return c.begin();
+}
+
+template <typename C>
+inline typename C::const_iterator buffer_sequence_begin(const C& c)
+{
+  return c.begin();
+}
+
+#endif // defined(ASIO_HAS_DECLTYPE) || defined(GENERATING_DOCUMENTATION)
+
+/*@}*/
+
+/** @defgroup buffer_sequence_end asio::buffer_sequence_end
+ *
+ * @brief The asio::buffer_sequence_end function returns an iterator
+ * pointing to one past the end element in a buffer sequence.
  */
+/*@{*/
+
+/// Get an iterator to one past the end element in a buffer sequence.
+inline const mutable_buffer* buffer_sequence_end(const mutable_buffer& b)
+{
+  return &b + 1;
+}
+
+/// Get an iterator to one past the end element in a buffer sequence.
+inline const const_buffer* buffer_sequence_end(const const_buffer& b)
+{
+  return &b + 1;
+}
+
+#if defined(ASIO_HAS_DECLTYPE) || defined(GENERATING_DOCUMENTATION)
+
+/// Get an iterator to one past the end element in a buffer sequence.
+template <typename C>
+inline auto buffer_sequence_end(C& c) -> decltype(c.end())
+{
+  return c.end();
+}
+
+/// Get an iterator to one past the end element in a buffer sequence.
+template <typename C>
+inline auto buffer_sequence_end(const C& c) -> decltype(c.end())
+{
+  return c.end();
+}
+
+#else // defined(ASIO_HAS_DECLTYPE) || defined(GENERATING_DOCUMENTATION)
+
+template <typename C>
+inline typename C::iterator buffer_sequence_end(C& c)
+{
+  return c.end();
+}
+
+template <typename C>
+inline typename C::const_iterator buffer_sequence_end(const C& c)
+{
+  return c.end();
+}
+
+#endif // defined(ASIO_HAS_DECLTYPE) || defined(GENERATING_DOCUMENTATION)
+
+/*@}*/
+
+namespace detail {
+
+// Tag types used to select appropriately optimised overloads.
+struct one_buffer {};
+struct multiple_buffers {};
+
+// Helper trait to detect single buffers.
 template <typename BufferSequence>
-inline std::size_t buffer_size(const BufferSequence& b,
-    typename enable_if<
-      is_const_buffer_sequence<BufferSequence>::value
-    >::type* = 0)
+struct buffer_sequence_cardinality :
+  conditional<
+    is_same<BufferSequence, mutable_buffer>::value
+#if !defined(ASIO_NO_DEPRECATED)
+      || is_same<BufferSequence, mutable_buffers_1>::value
+      || is_same<BufferSequence, const_buffers_1>::value
+#endif // !defined(ASIO_NO_DEPRECATED)
+      || is_same<BufferSequence, const_buffer>::value,
+    one_buffer, multiple_buffers>::type {};
+
+template <typename Iterator>
+inline std::size_t buffer_size(one_buffer,
+    Iterator begin, Iterator) ASIO_NOEXCEPT
+{
+  return const_buffer(*begin).size();
+}
+
+template <typename Iterator>
+inline std::size_t buffer_size(multiple_buffers,
+    Iterator begin, Iterator end) ASIO_NOEXCEPT
 {
   std::size_t total_buffer_size = 0;
 
-  typename BufferSequence::const_iterator iter = b.begin();
-  typename BufferSequence::const_iterator end = b.end();
+  Iterator iter = begin;
   for (; iter != end; ++iter)
-    total_buffer_size += detail::buffer_size_helper(*iter);
+  {
+    const_buffer b(*iter);
+    total_buffer_size += b.size();
+  }
 
   return total_buffer_size;
 }
 
-/*@}*/
+} // namespace detail
+
+/// Get the total number of bytes in a buffer sequence.
+/**
+ * The @c buffer_size function determines the total size of all buffers in the
+ * buffer sequence, as if computed as follows:
+ *
+ * @code size_t total_size = 0;
+ * auto i = asio::buffer_sequence_begin(buffers);
+ * auto end = asio::buffer_sequence_end(buffers);
+ * for (; i != end; ++i)
+ * {
+ *   const_buffer b(*i);
+ *   total_size += b.size();
+ * }
+ * return total_size; @endcode
+ *
+ * The @c BufferSequence template parameter may meet either of the @c
+ * ConstBufferSequence or @c MutableBufferSequence type requirements.
+ */
+template <typename BufferSequence>
+inline std::size_t buffer_size(const BufferSequence& b) ASIO_NOEXCEPT
+{
+  return detail::buffer_size(
+      detail::buffer_sequence_cardinality<BufferSequence>(),
+      asio::buffer_sequence_begin(b),
+      asio::buffer_sequence_end(b));
+}
+
+#if !defined(ASIO_NO_DEPRECATED)
 
 /** @defgroup buffer_cast asio::buffer_cast
  *
- * @brief The asio::buffer_cast function is used to obtain a pointer to
- * the underlying memory region associated with a buffer.
+ * @brief (Deprecated: Use the @c data() member function.) The
+ * asio::buffer_cast function is used to obtain a pointer to the
+ * underlying memory region associated with a buffer.
  *
  * @par Examples:
  *
@@ -466,30 +612,32 @@ inline std::size_t buffer_size(const BufferSequence& b,
 
 /// Cast a non-modifiable buffer to a specified pointer to POD type.
 template <typename PointerToPodType>
-inline PointerToPodType buffer_cast(const mutable_buffer& b)
+inline PointerToPodType buffer_cast(const mutable_buffer& b) ASIO_NOEXCEPT
 {
-  return static_cast<PointerToPodType>(detail::buffer_cast_helper(b));
+  return static_cast<PointerToPodType>(b.data());
 }
 
 /// Cast a non-modifiable buffer to a specified pointer to POD type.
 template <typename PointerToPodType>
-inline PointerToPodType buffer_cast(const const_buffer& b)
+inline PointerToPodType buffer_cast(const const_buffer& b) ASIO_NOEXCEPT
 {
-  return static_cast<PointerToPodType>(detail::buffer_cast_helper(b));
+  return static_cast<PointerToPodType>(b.data());
 }
 
 /*@}*/
 
+#endif // !defined(ASIO_NO_DEPRECATED)
+
 /// Create a new modifiable buffer that is offset from the start of another.
 /**
  * @relates mutable_buffer
  */
-inline mutable_buffer operator+(const mutable_buffer& b, std::size_t start)
+inline mutable_buffer operator+(const mutable_buffer& b,
+    std::size_t n) ASIO_NOEXCEPT
 {
-  if (start > buffer_size(b))
-    return mutable_buffer();
-  char* new_data = buffer_cast<char*>(b) + start;
-  std::size_t new_size = buffer_size(b) - start;
+  std::size_t offset = n < b.size() ? n : b.size();
+  char* new_data = static_cast<char*>(b.data()) + offset;
+  std::size_t new_size = b.size() - offset;
   return mutable_buffer(new_data, new_size
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
       , b.get_debug_check()
@@ -501,29 +649,22 @@ inline mutable_buffer operator+(const mutable_buffer& b, std::size_t start)
 /**
  * @relates mutable_buffer
  */
-inline mutable_buffer operator+(std::size_t start, const mutable_buffer& b)
+inline mutable_buffer operator+(std::size_t n,
+    const mutable_buffer& b) ASIO_NOEXCEPT
 {
-  if (start > buffer_size(b))
-    return mutable_buffer();
-  char* new_data = buffer_cast<char*>(b) + start;
-  std::size_t new_size = buffer_size(b) - start;
-  return mutable_buffer(new_data, new_size
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-      , b.get_debug_check()
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-      );
+  return b + n;
 }
 
 /// Create a new non-modifiable buffer that is offset from the start of another.
 /**
  * @relates const_buffer
  */
-inline const_buffer operator+(const const_buffer& b, std::size_t start)
+inline const_buffer operator+(const const_buffer& b,
+    std::size_t n) ASIO_NOEXCEPT
 {
-  if (start > buffer_size(b))
-    return const_buffer();
-  const char* new_data = buffer_cast<const char*>(b) + start;
-  std::size_t new_size = buffer_size(b) - start;
+  std::size_t offset = n < b.size() ? n : b.size();
+  const char* new_data = static_cast<const char*>(b.data()) + offset;
+  std::size_t new_size = b.size() - offset;
   return const_buffer(new_data, new_size
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
       , b.get_debug_check()
@@ -535,17 +676,10 @@ inline const_buffer operator+(const const_buffer& b, std::size_t start)
 /**
  * @relates const_buffer
  */
-inline const_buffer operator+(std::size_t start, const const_buffer& b)
+inline const_buffer operator+(std::size_t n,
+    const const_buffer& b) ASIO_NOEXCEPT
 {
-  if (start > buffer_size(b))
-    return const_buffer();
-  const char* new_data = buffer_cast<const char*>(b) + start;
-  std::size_t new_size = buffer_size(b) - start;
-  return const_buffer(new_data, new_size
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-      , b.get_debug_check()
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-      );
+  return b + n;
 }
 
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
@@ -630,32 +764,33 @@ private:
  *
  * @par Accessing Buffer Contents
  *
- * The contents of a buffer may be accessed using the @ref buffer_size and
- * @ref buffer_cast functions:
+ * The contents of a buffer may be accessed using the @c data() and @c size()
+ * member functions:
  *
  * @code asio::mutable_buffer b1 = ...;
- * std::size_t s1 = asio::buffer_size(b1);
- * unsigned char* p1 = asio::buffer_cast<unsigned char*>(b1);
+ * std::size_t s1 = b1.size();
+ * unsigned char* p1 = static_cast<unsigned char*>(b1.data());
  *
  * asio::const_buffer b2 = ...;
- * std::size_t s2 = asio::buffer_size(b2);
- * const void* p2 = asio::buffer_cast<const void*>(b2); @endcode
+ * std::size_t s2 = b2.size();
+ * const void* p2 = b2.data(); @endcode
  *
- * The asio::buffer_cast function permits violations of type safety, so
+ * The @c data() member function permits violations of type safety, so
  * uses of it in application code should be carefully considered.
  *
- * For convenience, the @ref buffer_size function also works on buffer
- * sequences (that is, types meeting the ConstBufferSequence or
- * MutableBufferSequence type requirements). In this case, the function returns
- * the total size of all buffers in the sequence.
+ * For convenience, a @ref buffer_size function is provided that works with
+ * both buffers and buffer sequences (that is, types meeting the
+ * ConstBufferSequence or MutableBufferSequence type requirements). In this
+ * case, the function returns the total size of all buffers in the sequence.
  *
  * @par Buffer Copying
  *
  * The @ref buffer_copy function may be used to copy raw bytes between
  * individual buffers and buffer sequences.
- *
- * In particular, when used with the @ref buffer_size, the @ref buffer_copy
- * function can be used to linearise a sequence of buffers. For example:
+*
+ * In particular, when used with the @ref buffer_size function, the @ref
+ * buffer_copy function can be used to linearise a sequence of buffers. For
+ * example:
  *
  * @code vector<const_buffer> buffers = ...;
  *
@@ -744,29 +879,38 @@ private:
  */
 /*@{*/
 
+#if defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
+# define ASIO_MUTABLE_BUFFER mutable_buffer
+# define ASIO_CONST_BUFFER const_buffer
+#else // defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
+# define ASIO_MUTABLE_BUFFER mutable_buffers_1
+# define ASIO_CONST_BUFFER const_buffers_1
+#endif // defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)
+
 /// Create a new modifiable buffer from an existing buffer.
 /**
- * @returns <tt>mutable_buffers_1(b)</tt>.
+ * @returns <tt>mutable_buffer(b)</tt>.
  */
-inline mutable_buffers_1 buffer(const mutable_buffer& b)
+inline ASIO_MUTABLE_BUFFER buffer(
+    const mutable_buffer& b) ASIO_NOEXCEPT
 {
-  return mutable_buffers_1(b);
+  return ASIO_MUTABLE_BUFFER(b);
 }
 
 /// Create a new modifiable buffer from an existing buffer.
 /**
- * @returns A mutable_buffers_1 value equivalent to:
- * @code mutable_buffers_1(
- *     buffer_cast<void*>(b),
- *     min(buffer_size(b), max_size_in_bytes)); @endcode
+ * @returns A mutable_buffer value equivalent to:
+ * @code mutable_buffer(
+ *     b.data(),
+ *     min(b.size(), max_size_in_bytes)); @endcode
  */
-inline mutable_buffers_1 buffer(const mutable_buffer& b,
-    std::size_t max_size_in_bytes)
+inline ASIO_MUTABLE_BUFFER buffer(const mutable_buffer& b,
+    std::size_t max_size_in_bytes) ASIO_NOEXCEPT
 {
-  return mutable_buffers_1(
-      mutable_buffer(buffer_cast<void*>(b),
-        buffer_size(b) < max_size_in_bytes
-        ? buffer_size(b) : max_size_in_bytes
+  return ASIO_MUTABLE_BUFFER(
+      mutable_buffer(b.data(),
+        b.size() < max_size_in_bytes
+        ? b.size() : max_size_in_bytes
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
         , b.get_debug_check()
 #endif // ASIO_ENABLE_BUFFER_DEBUGGING
@@ -775,110 +919,110 @@ inline mutable_buffers_1 buffer(const mutable_buffer& b,
 
 /// Create a new non-modifiable buffer from an existing buffer.
 /**
- * @returns <tt>const_buffers_1(b)</tt>.
+ * @returns <tt>const_buffer(b)</tt>.
  */
-inline const_buffers_1 buffer(const const_buffer& b)
+inline ASIO_CONST_BUFFER buffer(
+    const const_buffer& b) ASIO_NOEXCEPT
 {
-  return const_buffers_1(b);
+  return ASIO_CONST_BUFFER(b);
 }
 
 /// Create a new non-modifiable buffer from an existing buffer.
 /**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
- *     buffer_cast<const void*>(b),
- *     min(buffer_size(b), max_size_in_bytes)); @endcode
+ * @returns A const_buffer value equivalent to:
+ * @code const_buffer(
+ *     b.data(),
+ *     min(b.size(), max_size_in_bytes)); @endcode
  */
-inline const_buffers_1 buffer(const const_buffer& b,
-    std::size_t max_size_in_bytes)
+inline ASIO_CONST_BUFFER buffer(const const_buffer& b,
+    std::size_t max_size_in_bytes) ASIO_NOEXCEPT
 {
-  return const_buffers_1(
-      const_buffer(buffer_cast<const void*>(b),
-        buffer_size(b) < max_size_in_bytes
-        ? buffer_size(b) : max_size_in_bytes
+  return ASIO_CONST_BUFFER(b.data(),
+      b.size() < max_size_in_bytes
+      ? b.size() : max_size_in_bytes
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-        , b.get_debug_check()
+      , b.get_debug_check()
 #endif // ASIO_ENABLE_BUFFER_DEBUGGING
-        ));
+      );
 }
 
 /// Create a new modifiable buffer that represents the given memory range.
 /**
- * @returns <tt>mutable_buffers_1(data, size_in_bytes)</tt>.
+ * @returns <tt>mutable_buffer(data, size_in_bytes)</tt>.
  */
-inline mutable_buffers_1 buffer(void* data, std::size_t size_in_bytes)
+inline ASIO_MUTABLE_BUFFER buffer(void* data,
+    std::size_t size_in_bytes) ASIO_NOEXCEPT
 {
-  return mutable_buffers_1(mutable_buffer(data, size_in_bytes));
+  return ASIO_MUTABLE_BUFFER(data, size_in_bytes);
 }
 
 /// Create a new non-modifiable buffer that represents the given memory range.
 /**
- * @returns <tt>const_buffers_1(data, size_in_bytes)</tt>.
+ * @returns <tt>const_buffer(data, size_in_bytes)</tt>.
  */
-inline const_buffers_1 buffer(const void* data,
-    std::size_t size_in_bytes)
+inline ASIO_CONST_BUFFER buffer(const void* data,
+    std::size_t size_in_bytes) ASIO_NOEXCEPT
 {
-  return const_buffers_1(const_buffer(data, size_in_bytes));
+  return ASIO_CONST_BUFFER(data, size_in_bytes);
 }
 
 /// Create a new modifiable buffer that represents the given POD array.
 /**
- * @returns A mutable_buffers_1 value equivalent to:
- * @code mutable_buffers_1(
+ * @returns A mutable_buffer value equivalent to:
+ * @code mutable_buffer(
  *     static_cast<void*>(data),
  *     N * sizeof(PodType)); @endcode
  */
 template <typename PodType, std::size_t N>
-inline mutable_buffers_1 buffer(PodType (&data)[N])
+inline ASIO_MUTABLE_BUFFER buffer(PodType (&data)[N]) ASIO_NOEXCEPT
 {
-  return mutable_buffers_1(mutable_buffer(data, N * sizeof(PodType)));
+  return ASIO_MUTABLE_BUFFER(data, N * sizeof(PodType));
 }
  
 /// Create a new modifiable buffer that represents the given POD array.
 /**
- * @returns A mutable_buffers_1 value equivalent to:
- * @code mutable_buffers_1(
+ * @returns A mutable_buffer value equivalent to:
+ * @code mutable_buffer(
  *     static_cast<void*>(data),
  *     min(N * sizeof(PodType), max_size_in_bytes)); @endcode
  */
 template <typename PodType, std::size_t N>
-inline mutable_buffers_1 buffer(PodType (&data)[N],
-    std::size_t max_size_in_bytes)
+inline ASIO_MUTABLE_BUFFER buffer(PodType (&data)[N],
+    std::size_t max_size_in_bytes) ASIO_NOEXCEPT
 {
-  return mutable_buffers_1(
-      mutable_buffer(data,
-        N * sizeof(PodType) < max_size_in_bytes
-        ? N * sizeof(PodType) : max_size_in_bytes));
+  return ASIO_MUTABLE_BUFFER(data,
+      N * sizeof(PodType) < max_size_in_bytes
+      ? N * sizeof(PodType) : max_size_in_bytes);
 }
  
 /// Create a new non-modifiable buffer that represents the given POD array.
 /**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
+ * @returns A const_buffer value equivalent to:
+ * @code const_buffer(
  *     static_cast<const void*>(data),
  *     N * sizeof(PodType)); @endcode
  */
 template <typename PodType, std::size_t N>
-inline const_buffers_1 buffer(const PodType (&data)[N])
+inline ASIO_CONST_BUFFER buffer(
+    const PodType (&data)[N]) ASIO_NOEXCEPT
 {
-  return const_buffers_1(const_buffer(data, N * sizeof(PodType)));
+  return ASIO_CONST_BUFFER(data, N * sizeof(PodType));
 }
 
 /// Create a new non-modifiable buffer that represents the given POD array.
 /**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
+ * @returns A const_buffer value equivalent to:
+ * @code const_buffer(
  *     static_cast<const void*>(data),
  *     min(N * sizeof(PodType), max_size_in_bytes)); @endcode
  */
 template <typename PodType, std::size_t N>
-inline const_buffers_1 buffer(const PodType (&data)[N],
-    std::size_t max_size_in_bytes)
+inline ASIO_CONST_BUFFER buffer(const PodType (&data)[N],
+    std::size_t max_size_in_bytes) ASIO_NOEXCEPT
 {
-  return const_buffers_1(
-      const_buffer(data,
-        N * sizeof(PodType) < max_size_in_bytes
-        ? N * sizeof(PodType) : max_size_in_bytes));
+  return ASIO_CONST_BUFFER(data,
+      N * sizeof(PodType) < max_size_in_bytes
+      ? N * sizeof(PodType) : max_size_in_bytes);
 }
 
 #if defined(ASIO_ENABLE_ARRAY_BUFFER_WORKAROUND)
@@ -904,14 +1048,14 @@ template <>
 struct buffer_types_base<false>
 {
   typedef mutable_buffer buffer_type;
-  typedef mutable_buffers_1 container_type;
+  typedef ASIO_MUTABLE_BUFFER container_type;
 };
 
 template <>
 struct buffer_types_base<true>
 {
   typedef const_buffer buffer_type;
-  typedef const_buffers_1 container_type;
+  typedef ASIO_CONST_BUFFER container_type;
 };
 
 template <typename PodType>
@@ -924,7 +1068,7 @@ struct buffer_types
 
 template <typename PodType, std::size_t N>
 inline typename detail::buffer_types<PodType>::container_type
-buffer(boost::array<PodType, N>& data)
+buffer(boost::array<PodType, N>& data) ASIO_NOEXCEPT
 {
   typedef typename asio::detail::buffer_types<PodType>::buffer_type
     buffer_type;
@@ -936,7 +1080,8 @@ buffer(boost::array<PodType, N>& data)
 
 template <typename PodType, std::size_t N>
 inline typename detail::buffer_types<PodType>::container_type
-buffer(boost::array<PodType, N>& data, std::size_t max_size_in_bytes)
+buffer(boost::array<PodType, N>& data,
+    std::size_t max_size_in_bytes) ASIO_NOEXCEPT
 {
   typedef typename asio::detail::buffer_types<PodType>::buffer_type
     buffer_type;
@@ -952,200 +1097,195 @@ buffer(boost::array<PodType, N>& data, std::size_t max_size_in_bytes)
 
 /// Create a new modifiable buffer that represents the given POD array.
 /**
- * @returns A mutable_buffers_1 value equivalent to:
- * @code mutable_buffers_1(
+ * @returns A mutable_buffer value equivalent to:
+ * @code mutable_buffer(
  *     data.data(),
  *     data.size() * sizeof(PodType)); @endcode
  */
 template <typename PodType, std::size_t N>
-inline mutable_buffers_1 buffer(boost::array<PodType, N>& data)
+inline ASIO_MUTABLE_BUFFER buffer(
+    boost::array<PodType, N>& data) ASIO_NOEXCEPT
 {
-  return mutable_buffers_1(
-      mutable_buffer(data.c_array(), data.size() * sizeof(PodType)));
+  return ASIO_MUTABLE_BUFFER(
+      data.c_array(), data.size() * sizeof(PodType));
 }
 
 /// Create a new modifiable buffer that represents the given POD array.
 /**
- * @returns A mutable_buffers_1 value equivalent to:
- * @code mutable_buffers_1(
+ * @returns A mutable_buffer value equivalent to:
+ * @code mutable_buffer(
  *     data.data(),
  *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
  */
 template <typename PodType, std::size_t N>
-inline mutable_buffers_1 buffer(boost::array<PodType, N>& data,
-    std::size_t max_size_in_bytes)
+inline ASIO_MUTABLE_BUFFER buffer(boost::array<PodType, N>& data,
+    std::size_t max_size_in_bytes) ASIO_NOEXCEPT
 {
-  return mutable_buffers_1(
-      mutable_buffer(data.c_array(),
-        data.size() * sizeof(PodType) < max_size_in_bytes
-        ? data.size() * sizeof(PodType) : max_size_in_bytes));
+  return ASIO_MUTABLE_BUFFER(data.c_array(),
+      data.size() * sizeof(PodType) < max_size_in_bytes
+      ? data.size() * sizeof(PodType) : max_size_in_bytes);
 }
 
 /// Create a new non-modifiable buffer that represents the given POD array.
 /**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
+ * @returns A const_buffer value equivalent to:
+ * @code const_buffer(
  *     data.data(),
  *     data.size() * sizeof(PodType)); @endcode
  */
 template <typename PodType, std::size_t N>
-inline const_buffers_1 buffer(boost::array<const PodType, N>& data)
+inline ASIO_CONST_BUFFER buffer(
+    boost::array<const PodType, N>& data) ASIO_NOEXCEPT
 {
-  return const_buffers_1(
-      const_buffer(data.data(), data.size() * sizeof(PodType)));
+  return ASIO_CONST_BUFFER(data.data(), data.size() * sizeof(PodType));
 }
 
 /// Create a new non-modifiable buffer that represents the given POD array.
 /**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
+ * @returns A const_buffer value equivalent to:
+ * @code const_buffer(
  *     data.data(),
  *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
  */
 template <typename PodType, std::size_t N>
-inline const_buffers_1 buffer(boost::array<const PodType, N>& data,
-    std::size_t max_size_in_bytes)
+inline ASIO_CONST_BUFFER buffer(boost::array<const PodType, N>& data,
+    std::size_t max_size_in_bytes) ASIO_NOEXCEPT
 {
-  return const_buffers_1(
-      const_buffer(data.data(),
-        data.size() * sizeof(PodType) < max_size_in_bytes
-        ? data.size() * sizeof(PodType) : max_size_in_bytes));
+  return ASIO_CONST_BUFFER(data.data(),
+      data.size() * sizeof(PodType) < max_size_in_bytes
+      ? data.size() * sizeof(PodType) : max_size_in_bytes);
 }
 
 #endif // defined(ASIO_ENABLE_ARRAY_BUFFER_WORKAROUND)
 
 /// Create a new non-modifiable buffer that represents the given POD array.
 /**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
+ * @returns A const_buffer value equivalent to:
+ * @code const_buffer(
  *     data.data(),
  *     data.size() * sizeof(PodType)); @endcode
  */
 template <typename PodType, std::size_t N>
-inline const_buffers_1 buffer(const boost::array<PodType, N>& data)
+inline ASIO_CONST_BUFFER buffer(
+    const boost::array<PodType, N>& data) ASIO_NOEXCEPT
 {
-  return const_buffers_1(
-      const_buffer(data.data(), data.size() * sizeof(PodType)));
+  return ASIO_CONST_BUFFER(data.data(), data.size() * sizeof(PodType));
 }
 
 /// Create a new non-modifiable buffer that represents the given POD array.
 /**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
+ * @returns A const_buffer value equivalent to:
+ * @code const_buffer(
  *     data.data(),
  *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
  */
 template <typename PodType, std::size_t N>
-inline const_buffers_1 buffer(const boost::array<PodType, N>& data,
-    std::size_t max_size_in_bytes)
+inline ASIO_CONST_BUFFER buffer(const boost::array<PodType, N>& data,
+    std::size_t max_size_in_bytes) ASIO_NOEXCEPT
 {
-  return const_buffers_1(
-      const_buffer(data.data(),
-        data.size() * sizeof(PodType) < max_size_in_bytes
-        ? data.size() * sizeof(PodType) : max_size_in_bytes));
+  return ASIO_CONST_BUFFER(data.data(),
+      data.size() * sizeof(PodType) < max_size_in_bytes
+      ? data.size() * sizeof(PodType) : max_size_in_bytes);
 }
 
 #if defined(ASIO_HAS_STD_ARRAY) || defined(GENERATING_DOCUMENTATION)
 
 /// Create a new modifiable buffer that represents the given POD array.
 /**
- * @returns A mutable_buffers_1 value equivalent to:
- * @code mutable_buffers_1(
+ * @returns A mutable_buffer value equivalent to:
+ * @code mutable_buffer(
  *     data.data(),
  *     data.size() * sizeof(PodType)); @endcode
  */
 template <typename PodType, std::size_t N>
-inline mutable_buffers_1 buffer(std::array<PodType, N>& data)
+inline ASIO_MUTABLE_BUFFER buffer(
+    std::array<PodType, N>& data) ASIO_NOEXCEPT
 {
-  return mutable_buffers_1(
-      mutable_buffer(data.data(), data.size() * sizeof(PodType)));
+  return ASIO_MUTABLE_BUFFER(data.data(), data.size() * sizeof(PodType));
 }
 
 /// Create a new modifiable buffer that represents the given POD array.
 /**
- * @returns A mutable_buffers_1 value equivalent to:
- * @code mutable_buffers_1(
+ * @returns A mutable_buffer value equivalent to:
+ * @code mutable_buffer(
  *     data.data(),
  *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
  */
 template <typename PodType, std::size_t N>
-inline mutable_buffers_1 buffer(std::array<PodType, N>& data,
-    std::size_t max_size_in_bytes)
+inline ASIO_MUTABLE_BUFFER buffer(std::array<PodType, N>& data,
+    std::size_t max_size_in_bytes) ASIO_NOEXCEPT
 {
-  return mutable_buffers_1(
-      mutable_buffer(data.data(),
-        data.size() * sizeof(PodType) < max_size_in_bytes
-        ? data.size() * sizeof(PodType) : max_size_in_bytes));
+  return ASIO_MUTABLE_BUFFER(data.data(),
+      data.size() * sizeof(PodType) < max_size_in_bytes
+      ? data.size() * sizeof(PodType) : max_size_in_bytes);
 }
 
 /// Create a new non-modifiable buffer that represents the given POD array.
 /**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
+ * @returns A const_buffer value equivalent to:
+ * @code const_buffer(
  *     data.data(),
  *     data.size() * sizeof(PodType)); @endcode
  */
 template <typename PodType, std::size_t N>
-inline const_buffers_1 buffer(std::array<const PodType, N>& data)
+inline ASIO_CONST_BUFFER buffer(
+    std::array<const PodType, N>& data) ASIO_NOEXCEPT
 {
-  return const_buffers_1(
-      const_buffer(data.data(), data.size() * sizeof(PodType)));
+  return ASIO_CONST_BUFFER(data.data(), data.size() * sizeof(PodType));
 }
 
 /// Create a new non-modifiable buffer that represents the given POD array.
 /**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
+ * @returns A const_buffer value equivalent to:
+ * @code const_buffer(
  *     data.data(),
  *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
  */
 template <typename PodType, std::size_t N>
-inline const_buffers_1 buffer(std::array<const PodType, N>& data,
-    std::size_t max_size_in_bytes)
+inline ASIO_CONST_BUFFER buffer(std::array<const PodType, N>& data,
+    std::size_t max_size_in_bytes) ASIO_NOEXCEPT
 {
-  return const_buffers_1(
-      const_buffer(data.data(),
-        data.size() * sizeof(PodType) < max_size_in_bytes
-        ? data.size() * sizeof(PodType) : max_size_in_bytes));
+  return ASIO_CONST_BUFFER(data.data(),
+      data.size() * sizeof(PodType) < max_size_in_bytes
+      ? data.size() * sizeof(PodType) : max_size_in_bytes);
 }
 
 /// Create a new non-modifiable buffer that represents the given POD array.
 /**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
+ * @returns A const_buffer value equivalent to:
+ * @code const_buffer(
  *     data.data(),
  *     data.size() * sizeof(PodType)); @endcode
  */
 template <typename PodType, std::size_t N>
-inline const_buffers_1 buffer(const std::array<PodType, N>& data)
+inline ASIO_CONST_BUFFER buffer(
+    const std::array<PodType, N>& data) ASIO_NOEXCEPT
 {
-  return const_buffers_1(
-      const_buffer(data.data(), data.size() * sizeof(PodType)));
+  return ASIO_CONST_BUFFER(data.data(), data.size() * sizeof(PodType));
 }
 
 /// Create a new non-modifiable buffer that represents the given POD array.
 /**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
+ * @returns A const_buffer value equivalent to:
+ * @code const_buffer(
  *     data.data(),
  *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
  */
 template <typename PodType, std::size_t N>
-inline const_buffers_1 buffer(const std::array<PodType, N>& data,
-    std::size_t max_size_in_bytes)
+inline ASIO_CONST_BUFFER buffer(const std::array<PodType, N>& data,
+    std::size_t max_size_in_bytes) ASIO_NOEXCEPT
 {
-  return const_buffers_1(
-      const_buffer(data.data(),
-        data.size() * sizeof(PodType) < max_size_in_bytes
-        ? data.size() * sizeof(PodType) : max_size_in_bytes));
+  return ASIO_CONST_BUFFER(data.data(),
+      data.size() * sizeof(PodType) < max_size_in_bytes
+      ? data.size() * sizeof(PodType) : max_size_in_bytes);
 }
 
 #endif // defined(ASIO_HAS_STD_ARRAY) || defined(GENERATING_DOCUMENTATION)
 
 /// Create a new modifiable buffer that represents the given POD vector.
 /**
- * @returns A mutable_buffers_1 value equivalent to:
- * @code mutable_buffers_1(
+ * @returns A mutable_buffer value equivalent to:
+ * @code mutable_buffer(
  *     data.size() ? &data[0] : 0,
  *     data.size() * sizeof(PodType)); @endcode
  *
@@ -1153,22 +1293,23 @@ inline const_buffers_1 buffer(const std::array<PodType, N>& data,
  * invalidate iterators.
  */
 template <typename PodType, typename Allocator>
-inline mutable_buffers_1 buffer(std::vector<PodType, Allocator>& data)
+inline ASIO_MUTABLE_BUFFER buffer(
+    std::vector<PodType, Allocator>& data) ASIO_NOEXCEPT
 {
-  return mutable_buffers_1(
-      mutable_buffer(data.size() ? &data[0] : 0, data.size() * sizeof(PodType)
+  return ASIO_MUTABLE_BUFFER(
+      data.size() ? &data[0] : 0, data.size() * sizeof(PodType)
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-        , detail::buffer_debug_check<
-            typename std::vector<PodType, Allocator>::iterator
-          >(data.begin())
+      , detail::buffer_debug_check<
+          typename std::vector<PodType, Allocator>::iterator
+        >(data.begin())
 #endif // ASIO_ENABLE_BUFFER_DEBUGGING
-        ));
+      );
 }
 
 /// Create a new modifiable buffer that represents the given POD vector.
 /**
- * @returns A mutable_buffers_1 value equivalent to:
- * @code mutable_buffers_1(
+ * @returns A mutable_buffer value equivalent to:
+ * @code mutable_buffer(
  *     data.size() ? &data[0] : 0,
  *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
  *
@@ -1176,25 +1317,24 @@ inline mutable_buffers_1 buffer(std::vector<PodType, Allocator>& data)
  * invalidate iterators.
  */
 template <typename PodType, typename Allocator>
-inline mutable_buffers_1 buffer(std::vector<PodType, Allocator>& data,
-    std::size_t max_size_in_bytes)
+inline ASIO_MUTABLE_BUFFER buffer(std::vector<PodType, Allocator>& data,
+    std::size_t max_size_in_bytes) ASIO_NOEXCEPT
 {
-  return mutable_buffers_1(
-      mutable_buffer(data.size() ? &data[0] : 0,
-        data.size() * sizeof(PodType) < max_size_in_bytes
-        ? data.size() * sizeof(PodType) : max_size_in_bytes
+  return ASIO_MUTABLE_BUFFER(data.size() ? &data[0] : 0,
+      data.size() * sizeof(PodType) < max_size_in_bytes
+      ? data.size() * sizeof(PodType) : max_size_in_bytes
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-        , detail::buffer_debug_check<
-            typename std::vector<PodType, Allocator>::iterator
-          >(data.begin())
+      , detail::buffer_debug_check<
+          typename std::vector<PodType, Allocator>::iterator
+        >(data.begin())
 #endif // ASIO_ENABLE_BUFFER_DEBUGGING
-        ));
+      );
 }
 
 /// Create a new non-modifiable buffer that represents the given POD vector.
 /**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
+ * @returns A const_buffer value equivalent to:
+ * @code const_buffer(
  *     data.size() ? &data[0] : 0,
  *     data.size() * sizeof(PodType)); @endcode
  *
@@ -1202,23 +1342,23 @@ inline mutable_buffers_1 buffer(std::vector<PodType, Allocator>& data,
  * invalidate iterators.
  */
 template <typename PodType, typename Allocator>
-inline const_buffers_1 buffer(
-    const std::vector<PodType, Allocator>& data)
+inline ASIO_CONST_BUFFER buffer(
+    const std::vector<PodType, Allocator>& data) ASIO_NOEXCEPT
 {
-  return const_buffers_1(
-      const_buffer(data.size() ? &data[0] : 0, data.size() * sizeof(PodType)
+  return ASIO_CONST_BUFFER(
+      data.size() ? &data[0] : 0, data.size() * sizeof(PodType)
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-        , detail::buffer_debug_check<
-            typename std::vector<PodType, Allocator>::const_iterator
-          >(data.begin())
+      , detail::buffer_debug_check<
+          typename std::vector<PodType, Allocator>::const_iterator
+        >(data.begin())
 #endif // ASIO_ENABLE_BUFFER_DEBUGGING
-        ));
+      );
 }
 
 /// Create a new non-modifiable buffer that represents the given POD vector.
 /**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
+ * @returns A const_buffer value equivalent to:
+ * @code const_buffer(
  *     data.size() ? &data[0] : 0,
  *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
  *
@@ -1226,47 +1366,47 @@ inline const_buffers_1 buffer(
  * invalidate iterators.
  */
 template <typename PodType, typename Allocator>
-inline const_buffers_1 buffer(
-    const std::vector<PodType, Allocator>& data, std::size_t max_size_in_bytes)
+inline ASIO_CONST_BUFFER buffer(
+    const std::vector<PodType, Allocator>& data,
+    std::size_t max_size_in_bytes) ASIO_NOEXCEPT
 {
-  return const_buffers_1(
-      const_buffer(data.size() ? &data[0] : 0,
-        data.size() * sizeof(PodType) < max_size_in_bytes
-        ? data.size() * sizeof(PodType) : max_size_in_bytes
+  return ASIO_CONST_BUFFER(data.size() ? &data[0] : 0,
+      data.size() * sizeof(PodType) < max_size_in_bytes
+      ? data.size() * sizeof(PodType) : max_size_in_bytes
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-        , detail::buffer_debug_check<
-            typename std::vector<PodType, Allocator>::const_iterator
-          >(data.begin())
+      , detail::buffer_debug_check<
+          typename std::vector<PodType, Allocator>::const_iterator
+        >(data.begin())
 #endif // ASIO_ENABLE_BUFFER_DEBUGGING
-        ));
+      );
 }
 
 /// Create a new modifiable buffer that represents the given string.
 /**
- * @returns <tt>mutable_buffers_1(data.size() ? &data[0] : 0,
+ * @returns <tt>mutable_buffer(data.size() ? &data[0] : 0,
  * data.size() * sizeof(Elem))</tt>.
  *
  * @note The buffer is invalidated by any non-const operation called on the
  * given string object.
  */
 template <typename Elem, typename Traits, typename Allocator>
-inline mutable_buffers_1 buffer(
-    std::basic_string<Elem, Traits, Allocator>& data)
+inline ASIO_MUTABLE_BUFFER buffer(
+    std::basic_string<Elem, Traits, Allocator>& data) ASIO_NOEXCEPT
 {
-  return mutable_buffers_1(mutable_buffer(data.size() ? &data[0] : 0,
-        data.size() * sizeof(Elem)
+  return ASIO_MUTABLE_BUFFER(data.size() ? &data[0] : 0,
+      data.size() * sizeof(Elem)
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-        , detail::buffer_debug_check<
-            typename std::basic_string<Elem, Traits, Allocator>::iterator
-          >(data.begin())
+      , detail::buffer_debug_check<
+          typename std::basic_string<Elem, Traits, Allocator>::iterator
+        >(data.begin())
 #endif // ASIO_ENABLE_BUFFER_DEBUGGING
-        ));
+      );
 }
 
 /// Create a new non-modifiable buffer that represents the given string.
 /**
- * @returns A mutable_buffers_1 value equivalent to:
- * @code mutable_buffers_1(
+ * @returns A mutable_buffer value equivalent to:
+ * @code mutable_buffer(
  *     data.size() ? &data[0] : 0,
  *     min(data.size() * sizeof(Elem), max_size_in_bytes)); @endcode
  *
@@ -1274,46 +1414,45 @@ inline mutable_buffers_1 buffer(
  * given string object.
  */
 template <typename Elem, typename Traits, typename Allocator>
-inline mutable_buffers_1 buffer(
+inline ASIO_MUTABLE_BUFFER buffer(
     std::basic_string<Elem, Traits, Allocator>& data,
-    std::size_t max_size_in_bytes)
+    std::size_t max_size_in_bytes) ASIO_NOEXCEPT
 {
-  return mutable_buffers_1(
-      mutable_buffer(data.size() ? &data[0] : 0,
-        data.size() * sizeof(Elem) < max_size_in_bytes
-        ? data.size() * sizeof(Elem) : max_size_in_bytes
+  return ASIO_MUTABLE_BUFFER(data.size() ? &data[0] : 0,
+      data.size() * sizeof(Elem) < max_size_in_bytes
+      ? data.size() * sizeof(Elem) : max_size_in_bytes
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-        , detail::buffer_debug_check<
-            typename std::basic_string<Elem, Traits, Allocator>::iterator
-          >(data.begin())
+      , detail::buffer_debug_check<
+          typename std::basic_string<Elem, Traits, Allocator>::iterator
+        >(data.begin())
 #endif // ASIO_ENABLE_BUFFER_DEBUGGING
-        ));
+      );
 }
 
 /// Create a new non-modifiable buffer that represents the given string.
 /**
- * @returns <tt>const_buffers_1(data.data(), data.size() * sizeof(Elem))</tt>.
+ * @returns <tt>const_buffer(data.data(), data.size() * sizeof(Elem))</tt>.
  *
  * @note The buffer is invalidated by any non-const operation called on the
  * given string object.
  */
 template <typename Elem, typename Traits, typename Allocator>
-inline const_buffers_1 buffer(
-    const std::basic_string<Elem, Traits, Allocator>& data)
+inline ASIO_CONST_BUFFER buffer(
+    const std::basic_string<Elem, Traits, Allocator>& data) ASIO_NOEXCEPT
 {
-  return const_buffers_1(const_buffer(data.data(), data.size() * sizeof(Elem)
+  return ASIO_CONST_BUFFER(data.data(), data.size() * sizeof(Elem)
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-        , detail::buffer_debug_check<
-            typename std::basic_string<Elem, Traits, Allocator>::const_iterator
-          >(data.begin())
+      , detail::buffer_debug_check<
+          typename std::basic_string<Elem, Traits, Allocator>::const_iterator
+        >(data.begin())
 #endif // ASIO_ENABLE_BUFFER_DEBUGGING
-        ));
+      );
 }
 
 /// Create a new non-modifiable buffer that represents the given string.
 /**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
+ * @returns A const_buffer value equivalent to:
+ * @code const_buffer(
  *     data.data(),
  *     min(data.size() * sizeof(Elem), max_size_in_bytes)); @endcode
  *
@@ -1321,25 +1460,72 @@ inline const_buffers_1 buffer(
  * given string object.
  */
 template <typename Elem, typename Traits, typename Allocator>
-inline const_buffers_1 buffer(
+inline ASIO_CONST_BUFFER buffer(
     const std::basic_string<Elem, Traits, Allocator>& data,
-    std::size_t max_size_in_bytes)
+    std::size_t max_size_in_bytes) ASIO_NOEXCEPT
 {
-  return const_buffers_1(
-      const_buffer(data.data(),
-        data.size() * sizeof(Elem) < max_size_in_bytes
-        ? data.size() * sizeof(Elem) : max_size_in_bytes
+  return ASIO_CONST_BUFFER(data.data(),
+      data.size() * sizeof(Elem) < max_size_in_bytes
+      ? data.size() * sizeof(Elem) : max_size_in_bytes
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-        , detail::buffer_debug_check<
-            typename std::basic_string<Elem, Traits, Allocator>::const_iterator
-          >(data.begin())
+      , detail::buffer_debug_check<
+          typename std::basic_string<Elem, Traits, Allocator>::const_iterator
+        >(data.begin())
 #endif // ASIO_ENABLE_BUFFER_DEBUGGING
-        ));
+      );
+}
+
+#if defined(ASIO_HAS_STD_STRING_VIEW) \
+  || defined(GENERATING_DOCUMENTATION)
+
+/// Create a new modifiable buffer that represents the given string_view.
+/**
+ * @returns <tt>mutable_buffer(data.size() ? &data[0] : 0,
+ * data.size() * sizeof(Elem))</tt>.
+ */
+template <typename Elem, typename Traits>
+inline ASIO_CONST_BUFFER buffer(
+    basic_string_view<Elem, Traits> data) ASIO_NOEXCEPT
+{
+  return ASIO_CONST_BUFFER(data.size() ? &data[0] : 0,
+      data.size() * sizeof(Elem)
+#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
+      , detail::buffer_debug_check<
+          typename basic_string_view<Elem, Traits>::iterator
+        >(data.begin())
+#endif // ASIO_ENABLE_BUFFER_DEBUGGING
+      );
+}
+
+/// Create a new non-modifiable buffer that represents the given string.
+/**
+ * @returns A mutable_buffer value equivalent to:
+ * @code mutable_buffer(
+ *     data.size() ? &data[0] : 0,
+ *     min(data.size() * sizeof(Elem), max_size_in_bytes)); @endcode
+ */
+template <typename Elem, typename Traits>
+inline ASIO_CONST_BUFFER buffer(
+    basic_string_view<Elem, Traits> data,
+    std::size_t max_size_in_bytes) ASIO_NOEXCEPT
+{
+  return ASIO_CONST_BUFFER(data.size() ? &data[0] : 0,
+      data.size() * sizeof(Elem) < max_size_in_bytes
+      ? data.size() * sizeof(Elem) : max_size_in_bytes
+#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
+      , detail::buffer_debug_check<
+          typename basic_string_view<Elem, Traits>::iterator
+        >(data.begin())
+#endif // ASIO_ENABLE_BUFFER_DEBUGGING
+      );
 }
 
+#endif // defined(ASIO_HAS_STD_STRING_VIEW)
+       //  || defined(GENERATING_DOCUMENTATION)
+
 /*@}*/
 
-/// Adapt a basic_string to the DynamicBufferSequence requirements.
+/// Adapt a basic_string to the DynamicBuffer requirements.
 /**
  * Requires that <tt>sizeof(Elem) == 1</tt>.
  */
@@ -1348,10 +1534,10 @@ class dynamic_string_buffer
 {
 public:
   /// The type used to represent the input sequence as a list of buffers.
-  typedef const_buffers_1 const_buffers_type;
+  typedef ASIO_CONST_BUFFER const_buffers_type;
 
   /// The type used to represent the output sequence as a list of buffers.
-  typedef mutable_buffers_1 mutable_buffers_type;
+  typedef ASIO_MUTABLE_BUFFER mutable_buffers_type;
 
   /// Construct a dynamic buffer from a string.
   /**
@@ -1364,7 +1550,8 @@ public:
    * @param maximum_size Specifies a maximum size for the buffer, in bytes.
    */
   explicit dynamic_string_buffer(std::basic_string<Elem, Traits, Allocator>& s,
-      std::size_t maximum_size = (std::numeric_limits<std::size_t>::max)())
+      std::size_t maximum_size =
+        (std::numeric_limits<std::size_t>::max)()) ASIO_NOEXCEPT
     : string_(s),
       size_(string_.size()),
       max_size_(maximum_size)
@@ -1373,7 +1560,7 @@ public:
 
 #if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
   /// Move construct a dynamic buffer.
-  dynamic_string_buffer(dynamic_string_buffer&& other)
+  dynamic_string_buffer(dynamic_string_buffer&& other) ASIO_NOEXCEPT
     : string_(other.string_),
       size_(other.size_),
       max_size_(other.max_size_)
@@ -1419,7 +1606,7 @@ public:
    */
   const_buffers_type data() const ASIO_NOEXCEPT
   {
-    return asio::buffer(string_, size_);
+    return const_buffers_type(asio::buffer(string_, size_));
   }
 
   /// Get a list of buffers that represents the output sequence, with the given
@@ -1479,7 +1666,7 @@ public:
   void consume(std::size_t n)
   {
     std::size_t consume_length = (std::min)(n, size_);
-    string_.erase(consume_length);
+    string_.erase(0, consume_length);
     size_ -= consume_length;
   }
 
@@ -1489,7 +1676,7 @@ private:
   const std::size_t max_size_;
 };
 
-/// Adapt a vector to the DynamicBufferSequence requirements.
+/// Adapt a vector to the DynamicBuffer requirements.
 /**
  * Requires that <tt>sizeof(Elem) == 1</tt>.
  */
@@ -1498,10 +1685,10 @@ class dynamic_vector_buffer
 {
 public:
   /// The type used to represent the input sequence as a list of buffers.
-  typedef const_buffers_1 const_buffers_type;
+  typedef ASIO_CONST_BUFFER const_buffers_type;
 
   /// The type used to represent the output sequence as a list of buffers.
-  typedef mutable_buffers_1 mutable_buffers_type;
+  typedef ASIO_MUTABLE_BUFFER mutable_buffers_type;
 
   /// Construct a dynamic buffer from a string.
   /**
@@ -1514,7 +1701,8 @@ public:
    * @param maximum_size Specifies a maximum size for the buffer, in bytes.
    */
   explicit dynamic_vector_buffer(std::vector<Elem, Allocator>& v,
-      std::size_t maximum_size = (std::numeric_limits<std::size_t>::max)())
+      std::size_t maximum_size =
+        (std::numeric_limits<std::size_t>::max)()) ASIO_NOEXCEPT
     : vector_(v),
       size_(vector_.size()),
       max_size_(maximum_size)
@@ -1523,7 +1711,7 @@ public:
 
 #if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
   /// Move construct a dynamic buffer.
-  dynamic_vector_buffer(dynamic_vector_buffer&& other)
+  dynamic_vector_buffer(dynamic_vector_buffer&& other) ASIO_NOEXCEPT
     : vector_(other.vector_),
       size_(other.size_),
       max_size_(other.max_size_)
@@ -1569,7 +1757,7 @@ public:
    */
   const_buffers_type data() const ASIO_NOEXCEPT
   {
-    return asio::buffer(vector_, size_);
+    return const_buffers_type(asio::buffer(vector_, size_));
   }
 
   /// Get a list of buffers that represents the output sequence, with the given
@@ -1629,7 +1817,7 @@ public:
   void consume(std::size_t n)
   {
     std::size_t consume_length = (std::min)(n, size_);
-    vector_.erase(consume_length);
+    vector_.erase(vector_.begin(), vector_.begin() + consume_length);
     size_ -= consume_length;
   }
 
@@ -1652,7 +1840,7 @@ private:
  */
 template <typename Elem, typename Traits, typename Allocator>
 inline dynamic_string_buffer<Elem, Traits, Allocator> dynamic_buffer(
-    std::basic_string<Elem, Traits, Allocator>& data)
+    std::basic_string<Elem, Traits, Allocator>& data) ASIO_NOEXCEPT
 {
   return dynamic_string_buffer<Elem, Traits, Allocator>(data);
 }
@@ -1664,7 +1852,8 @@ inline dynamic_string_buffer<Elem, Traits, Allocator> dynamic_buffer(
  */
 template <typename Elem, typename Traits, typename Allocator>
 inline dynamic_string_buffer<Elem, Traits, Allocator> dynamic_buffer(
-    std::basic_string<Elem, Traits, Allocator>& data, std::size_t max_size)
+    std::basic_string<Elem, Traits, Allocator>& data,
+    std::size_t max_size) ASIO_NOEXCEPT
 {
   return dynamic_string_buffer<Elem, Traits, Allocator>(data, max_size);
 }
@@ -1675,7 +1864,7 @@ inline dynamic_string_buffer<Elem, Traits, Allocator> dynamic_buffer(
  */
 template <typename Elem, typename Allocator>
 inline dynamic_vector_buffer<Elem, Allocator> dynamic_buffer(
-    std::vector<Elem, Allocator>& data)
+    std::vector<Elem, Allocator>& data) ASIO_NOEXCEPT
 {
   return dynamic_vector_buffer<Elem, Allocator>(data);
 }
@@ -1686,7 +1875,8 @@ inline dynamic_vector_buffer<Elem, Allocator> dynamic_buffer(
  */
 template <typename Elem, typename Allocator>
 inline dynamic_vector_buffer<Elem, Allocator> dynamic_buffer(
-    std::vector<Elem, Allocator>& data, std::size_t max_size)
+    std::vector<Elem, Allocator>& data,
+    std::size_t max_size) ASIO_NOEXCEPT
 {
   return dynamic_vector_buffer<Elem, Allocator>(data, max_size);
 }
@@ -1721,400 +1911,184 @@ inline dynamic_vector_buffer<Elem, Allocator> dynamic_buffer(
  */
 /*@{*/
 
-/// Copies bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffer& target,
+namespace detail {
+
+inline std::size_t buffer_copy_1(const mutable_buffer& target,
     const const_buffer& source)
 {
   using namespace std; // For memcpy.
-  std::size_t target_size = buffer_size(target);
-  std::size_t source_size = buffer_size(source);
+  std::size_t target_size = target.size();
+  std::size_t source_size = source.size();
   std::size_t n = target_size < source_size ? target_size : source_size;
-  memcpy(buffer_cast<void*>(target), buffer_cast<const void*>(source), n);
+  memcpy(target.data(), source.data(), n);
   return n;
 }
 
-/// Copies bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffer& target,
-    const const_buffers_1& source)
+template <typename TargetIterator, typename SourceIterator>
+inline std::size_t buffer_copy(one_buffer, one_buffer,
+    TargetIterator target_begin, TargetIterator,
+    SourceIterator source_begin, SourceIterator) ASIO_NOEXCEPT
 {
-  return buffer_copy(target, static_cast<const const_buffer&>(source));
+  return (buffer_copy_1)(*target_begin, *source_begin);
 }
 
-/// Copies bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffer& target,
-    const mutable_buffer& source)
+template <typename TargetIterator, typename SourceIterator>
+inline std::size_t buffer_copy(one_buffer, one_buffer,
+    TargetIterator target_begin, TargetIterator,
+    SourceIterator source_begin, SourceIterator,
+    std::size_t max_bytes_to_copy) ASIO_NOEXCEPT
 {
-  return buffer_copy(target, const_buffer(source));
+  return (buffer_copy_1)(*target_begin,
+      asio::buffer(*source_begin, max_bytes_to_copy));
 }
 
-/// Copies bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffer& target,
-    const mutable_buffers_1& source)
-{
-  return buffer_copy(target, const_buffer(source));
-}
-
-/// Copies bytes from a source buffer sequence to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer sequence representing the memory
- * regions from which the bytes will be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename ConstBufferSequence>
-std::size_t buffer_copy(const mutable_buffer& target,
-    const ConstBufferSequence& source,
-    typename enable_if<
-      is_const_buffer_sequence<ConstBufferSequence>::value
-    >::type* = 0)
+template <typename TargetIterator, typename SourceIterator>
+std::size_t buffer_copy(one_buffer, multiple_buffers,
+    TargetIterator target_begin, TargetIterator,
+    SourceIterator source_begin, SourceIterator source_end,
+    std::size_t max_bytes_to_copy
+      = (std::numeric_limits<std::size_t>::max)()) ASIO_NOEXCEPT
 {
   std::size_t total_bytes_copied = 0;
+  SourceIterator source_iter = source_begin;
 
-  typename ConstBufferSequence::const_iterator source_iter = source.begin();
-  typename ConstBufferSequence::const_iterator source_end = source.end();
-
-  for (mutable_buffer target_buffer(target);
-      buffer_size(target_buffer) && source_iter != source_end; ++source_iter)
+  for (mutable_buffer target_buffer(
+        asio::buffer(*target_begin, max_bytes_to_copy));
+      target_buffer.size() && source_iter != source_end; ++source_iter)
   {
     const_buffer source_buffer(*source_iter);
-    std::size_t bytes_copied = buffer_copy(target_buffer, source_buffer);
+    std::size_t bytes_copied = (buffer_copy_1)(target_buffer, source_buffer);
     total_bytes_copied += bytes_copied;
-    target_buffer = target_buffer + bytes_copied;
+    target_buffer += bytes_copied;
   }
 
   return total_bytes_copied;
 }
 
-/// Copies bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffers_1& target,
-    const const_buffer& source)
+template <typename TargetIterator, typename SourceIterator>
+std::size_t buffer_copy(multiple_buffers, one_buffer,
+    TargetIterator target_begin, TargetIterator target_end,
+    SourceIterator source_begin, SourceIterator,
+    std::size_t max_bytes_to_copy
+      = (std::numeric_limits<std::size_t>::max)()) ASIO_NOEXCEPT
 {
-  return buffer_copy(static_cast<const mutable_buffer&>(target), source);
-}
+  std::size_t total_bytes_copied = 0;
+  TargetIterator target_iter = target_begin;
 
-/// Copies bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffers_1& target,
-    const const_buffers_1& source)
-{
-  return buffer_copy(static_cast<const mutable_buffer&>(target),
-      static_cast<const const_buffer&>(source));
-}
+  for (const_buffer source_buffer(
+        asio::buffer(*source_begin, max_bytes_to_copy));
+      source_buffer.size() && target_iter != target_end; ++target_iter)
+  {
+    mutable_buffer target_buffer(*target_iter);
+    std::size_t bytes_copied = (buffer_copy_1)(target_buffer, source_buffer);
+    total_bytes_copied += bytes_copied;
+    source_buffer += bytes_copied;
+  }
 
-/// Copies bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffers_1& target,
-    const mutable_buffer& source)
-{
-  return buffer_copy(static_cast<const mutable_buffer&>(target),
-      const_buffer(source));
+  return total_bytes_copied;
 }
 
-/// Copies bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffers_1& target,
-    const mutable_buffers_1& source)
+template <typename TargetIterator, typename SourceIterator>
+std::size_t buffer_copy(multiple_buffers, multiple_buffers,
+    TargetIterator target_begin, TargetIterator target_end,
+    SourceIterator source_begin, SourceIterator source_end) ASIO_NOEXCEPT
 {
-  return buffer_copy(static_cast<const mutable_buffer&>(target),
-      const_buffer(source));
-}
+  std::size_t total_bytes_copied = 0;
 
-/// Copies bytes from a source buffer sequence to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer sequence representing the memory
- * regions from which the bytes will be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename ConstBufferSequence>
-inline std::size_t buffer_copy(const mutable_buffers_1& target,
-    const ConstBufferSequence& source,
-    typename enable_if<
-      is_const_buffer_sequence<ConstBufferSequence>::value
-    >::type* = 0)
-{
-  return buffer_copy(static_cast<const mutable_buffer&>(target), source);
+  TargetIterator target_iter = target_begin;
+  std::size_t target_buffer_offset = 0;
+
+  SourceIterator source_iter = source_begin;
+  std::size_t source_buffer_offset = 0;
+
+  while (target_iter != target_end && source_iter != source_end)
+  {
+    mutable_buffer target_buffer =
+      mutable_buffer(*target_iter) + target_buffer_offset;
+
+    const_buffer source_buffer =
+      const_buffer(*source_iter) + source_buffer_offset;
+
+    std::size_t bytes_copied = (buffer_copy_1)(target_buffer, source_buffer);
+    total_bytes_copied += bytes_copied;
+
+    if (bytes_copied == target_buffer.size())
+    {
+      ++target_iter;
+      target_buffer_offset = 0;
+    }
+    else
+      target_buffer_offset += bytes_copied;
+
+    if (bytes_copied == source_buffer.size())
+    {
+      ++source_iter;
+      source_buffer_offset = 0;
+    }
+    else
+      source_buffer_offset += bytes_copied;
+  }
+
+  return total_bytes_copied;
 }
 
-/// Copies bytes from a source buffer to a target buffer sequence.
-/**
- * @param target A modifiable buffer sequence representing the memory regions to
- * which the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename MutableBufferSequence>
-std::size_t buffer_copy(const MutableBufferSequence& target,
-    const const_buffer& source,
-    typename enable_if<
-      is_mutable_buffer_sequence<MutableBufferSequence>::value
-    >::type* = 0)
+template <typename TargetIterator, typename SourceIterator>
+std::size_t buffer_copy(multiple_buffers, multiple_buffers,
+    TargetIterator target_begin, TargetIterator target_end,
+    SourceIterator source_begin, SourceIterator source_end,
+    std::size_t max_bytes_to_copy) ASIO_NOEXCEPT
 {
   std::size_t total_bytes_copied = 0;
 
-  typename MutableBufferSequence::const_iterator target_iter = target.begin();
-  typename MutableBufferSequence::const_iterator target_end = target.end();
+  TargetIterator target_iter = target_begin;
+  std::size_t target_buffer_offset = 0;
+
+  SourceIterator source_iter = source_begin;
+  std::size_t source_buffer_offset = 0;
 
-  for (const_buffer source_buffer(source);
-      buffer_size(source_buffer) && target_iter != target_end; ++target_iter)
+  while (total_bytes_copied != max_bytes_to_copy
+      && target_iter != target_end && source_iter != source_end)
   {
-    mutable_buffer target_buffer(*target_iter);
-    std::size_t bytes_copied = buffer_copy(target_buffer, source_buffer);
+    mutable_buffer target_buffer =
+      mutable_buffer(*target_iter) + target_buffer_offset;
+
+    const_buffer source_buffer =
+      const_buffer(*source_iter) + source_buffer_offset;
+
+    std::size_t bytes_copied = (buffer_copy_1)(
+        target_buffer, asio::buffer(source_buffer,
+          max_bytes_to_copy - total_bytes_copied));
     total_bytes_copied += bytes_copied;
-    source_buffer = source_buffer + bytes_copied;
+
+    if (bytes_copied == target_buffer.size())
+    {
+      ++target_iter;
+      target_buffer_offset = 0;
+    }
+    else
+      target_buffer_offset += bytes_copied;
+
+    if (bytes_copied == source_buffer.size())
+    {
+      ++source_iter;
+      source_buffer_offset = 0;
+    }
+    else
+      source_buffer_offset += bytes_copied;
   }
 
   return total_bytes_copied;
 }
 
-/// Copies bytes from a source buffer to a target buffer sequence.
-/**
- * @param target A modifiable buffer sequence representing the memory regions to
- * which the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename MutableBufferSequence>
-inline std::size_t buffer_copy(const MutableBufferSequence& target,
-    const const_buffers_1& source,
-    typename enable_if<
-      is_mutable_buffer_sequence<MutableBufferSequence>::value
-    >::type* = 0)
-{
-  return buffer_copy(target, static_cast<const const_buffer&>(source));
-}
-
-/// Copies bytes from a source buffer to a target buffer sequence.
-/**
- * @param target A modifiable buffer sequence representing the memory regions to
- * which the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename MutableBufferSequence>
-inline std::size_t buffer_copy(const MutableBufferSequence& target,
-    const mutable_buffer& source,
-    typename enable_if<
-      is_mutable_buffer_sequence<MutableBufferSequence>::value
-    >::type* = 0)
-{
-  return buffer_copy(target, const_buffer(source));
-}
+} // namespace detail
 
-/// Copies bytes from a source buffer to a target buffer sequence.
+/// Copies bytes from a source buffer sequence to a target buffer sequence.
 /**
  * @param target A modifiable buffer sequence representing the memory regions to
  * which the bytes will be copied.
  *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
+ * @param source A non-modifiable buffer sequence representing the memory
+ * regions from which the bytes will be copied.
  *
  * @returns The number of bytes copied.
  *
@@ -2127,17 +2101,21 @@ inline std::size_t buffer_copy(const MutableBufferSequence& target,
  * This function is implemented in terms of @c memcpy, and consequently it
  * cannot be used to copy between overlapping memory regions.
  */
-template <typename MutableBufferSequence>
+template <typename MutableBufferSequence, typename ConstBufferSequence>
 inline std::size_t buffer_copy(const MutableBufferSequence& target,
-    const mutable_buffers_1& source,
-    typename enable_if<
-      is_mutable_buffer_sequence<MutableBufferSequence>::value
-    >::type* = 0)
+    const ConstBufferSequence& source) ASIO_NOEXCEPT
 {
-  return buffer_copy(target, const_buffer(source));
+  return detail::buffer_copy(
+      detail::buffer_sequence_cardinality<MutableBufferSequence>(),
+      detail::buffer_sequence_cardinality<ConstBufferSequence>(),
+      asio::buffer_sequence_begin(target),
+      asio::buffer_sequence_end(target),
+      asio::buffer_sequence_begin(source),
+      asio::buffer_sequence_end(source));
 }
 
-/// Copies bytes from a source buffer sequence to a target buffer sequence.
+/// Copies a limited number of bytes from a source buffer sequence to a target
+/// buffer sequence.
 /**
  * @param target A modifiable buffer sequence representing the memory regions to
  * which the bytes will be copied.
@@ -2145,6 +2123,8 @@ inline std::size_t buffer_copy(const MutableBufferSequence& target,
  * @param source A non-modifiable buffer sequence representing the memory
  * regions from which the bytes will be copied.
  *
+ * @param max_bytes_to_copy The maximum number of bytes to be copied.
+ *
  * @returns The number of bytes copied.
  *
  * @note The number of bytes copied is the lesser of:
@@ -2153,573 +2133,23 @@ inline std::size_t buffer_copy(const MutableBufferSequence& target,
  *
  * @li @c buffer_size(source)
  *
+ * @li @c max_bytes_to_copy
+ *
  * This function is implemented in terms of @c memcpy, and consequently it
  * cannot be used to copy between overlapping memory regions.
  */
 template <typename MutableBufferSequence, typename ConstBufferSequence>
-std::size_t buffer_copy(const MutableBufferSequence& target,
+inline std::size_t buffer_copy(const MutableBufferSequence& target,
     const ConstBufferSequence& source,
-    typename enable_if<
-      is_mutable_buffer_sequence<MutableBufferSequence>::value &&
-      is_const_buffer_sequence<ConstBufferSequence>::value
-    >::type* = 0)
-{
-  std::size_t total_bytes_copied = 0;
-
-  typename MutableBufferSequence::const_iterator target_iter = target.begin();
-  typename MutableBufferSequence::const_iterator target_end = target.end();
-  std::size_t target_buffer_offset = 0;
-
-  typename ConstBufferSequence::const_iterator source_iter = source.begin();
-  typename ConstBufferSequence::const_iterator source_end = source.end();
-  std::size_t source_buffer_offset = 0;
-
-  while (target_iter != target_end && source_iter != source_end)
-  {
-    mutable_buffer target_buffer =
-      mutable_buffer(*target_iter) + target_buffer_offset;
-
-    const_buffer source_buffer =
-      const_buffer(*source_iter) + source_buffer_offset;
-
-    std::size_t bytes_copied = buffer_copy(target_buffer, source_buffer);
-    total_bytes_copied += bytes_copied;
-
-    if (bytes_copied == buffer_size(target_buffer))
-    {
-      ++target_iter;
-      target_buffer_offset = 0;
-    }
-    else
-      target_buffer_offset += bytes_copied;
-
-    if (bytes_copied == buffer_size(source_buffer))
-    {
-      ++source_iter;
-      source_buffer_offset = 0;
-    }
-    else
-      source_buffer_offset += bytes_copied;
-  }
-
-  return total_bytes_copied;
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffer& target,
-    const const_buffer& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(buffer(target, max_bytes_to_copy), source);
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffer& target,
-    const const_buffers_1& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(buffer(target, max_bytes_to_copy), source);
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffer& target,
-    const mutable_buffer& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(buffer(target, max_bytes_to_copy), source);
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffer& target,
-    const mutable_buffers_1& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(buffer(target, max_bytes_to_copy), source);
-}
-
-/// Copies a limited number of bytes from a source buffer sequence to a target
-/// buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer sequence representing the memory
- * regions from which the bytes will be copied.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename ConstBufferSequence>
-inline std::size_t buffer_copy(const mutable_buffer& target,
-    const ConstBufferSequence& source, std::size_t max_bytes_to_copy,
-    typename enable_if<
-      is_const_buffer_sequence<ConstBufferSequence>::value
-    >::type* = 0)
-{
-  return buffer_copy(buffer(target, max_bytes_to_copy), source);
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffers_1& target,
-    const const_buffer& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(buffer(target, max_bytes_to_copy), source);
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffers_1& target,
-    const const_buffers_1& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(buffer(target, max_bytes_to_copy), source);
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffers_1& target,
-    const mutable_buffer& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(buffer(target, max_bytes_to_copy), source);
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffers_1& target,
-    const mutable_buffers_1& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(buffer(target, max_bytes_to_copy), source);
-}
-
-/// Copies a limited number of bytes from a source buffer sequence to a target
-/// buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer sequence representing the memory
- * regions from which the bytes will be copied.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename ConstBufferSequence>
-inline std::size_t buffer_copy(const mutable_buffers_1& target,
-    const ConstBufferSequence& source, std::size_t max_bytes_to_copy,
-    typename enable_if<
-      is_const_buffer_sequence<ConstBufferSequence>::value
-    >::type* = 0)
-{
-  return buffer_copy(buffer(target, max_bytes_to_copy), source);
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer
-/// sequence.
-/**
- * @param target A modifiable buffer sequence representing the memory regions to
- * which the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename MutableBufferSequence>
-inline std::size_t buffer_copy(const MutableBufferSequence& target,
-    const const_buffer& source, std::size_t max_bytes_to_copy,
-    typename enable_if<
-      is_mutable_buffer_sequence<MutableBufferSequence>::value
-    >::type* = 0)
-{
-  return buffer_copy(target, buffer(source, max_bytes_to_copy));
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer
-/// sequence.
-/**
- * @param target A modifiable buffer sequence representing the memory regions to
- * which the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename MutableBufferSequence>
-inline std::size_t buffer_copy(const MutableBufferSequence& target,
-    const const_buffers_1& source, std::size_t max_bytes_to_copy,
-    typename enable_if<
-      is_mutable_buffer_sequence<MutableBufferSequence>::value
-    >::type* = 0)
-{
-  return buffer_copy(target, buffer(source, max_bytes_to_copy));
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer
-/// sequence.
-/**
- * @param target A modifiable buffer sequence representing the memory regions to
- * which the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename MutableBufferSequence>
-inline std::size_t buffer_copy(const MutableBufferSequence& target,
-    const mutable_buffer& source, std::size_t max_bytes_to_copy,
-    typename enable_if<
-      is_mutable_buffer_sequence<MutableBufferSequence>::value
-    >::type* = 0)
-{
-  return buffer_copy(target, buffer(source, max_bytes_to_copy));
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer
-/// sequence.
-/**
- * @param target A modifiable buffer sequence representing the memory regions to
- * which the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename MutableBufferSequence>
-inline std::size_t buffer_copy(const MutableBufferSequence& target,
-    const mutable_buffers_1& source, std::size_t max_bytes_to_copy,
-    typename enable_if<
-      is_mutable_buffer_sequence<MutableBufferSequence>::value
-    >::type* = 0)
-{
-  return buffer_copy(target, buffer(source, max_bytes_to_copy));
-}
-
-/// Copies a limited number of bytes from a source buffer sequence to a target
-/// buffer sequence.
-/**
- * @param target A modifiable buffer sequence representing the memory regions to
- * which the bytes will be copied.
- *
- * @param source A non-modifiable buffer sequence representing the memory
- * regions from which the bytes will be copied.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename MutableBufferSequence, typename ConstBufferSequence>
-std::size_t buffer_copy(const MutableBufferSequence& target,
-    const ConstBufferSequence& source, std::size_t max_bytes_to_copy,
-    typename enable_if<
-      is_mutable_buffer_sequence<MutableBufferSequence>::value &&
-      is_const_buffer_sequence<ConstBufferSequence>::value
-    >::type* = 0)
-{
-  std::size_t total_bytes_copied = 0;
-
-  typename MutableBufferSequence::const_iterator target_iter = target.begin();
-  typename MutableBufferSequence::const_iterator target_end = target.end();
-  std::size_t target_buffer_offset = 0;
-
-  typename ConstBufferSequence::const_iterator source_iter = source.begin();
-  typename ConstBufferSequence::const_iterator source_end = source.end();
-  std::size_t source_buffer_offset = 0;
-
-  while (total_bytes_copied != max_bytes_to_copy
-      && target_iter != target_end && source_iter != source_end)
-  {
-    mutable_buffer target_buffer =
-      mutable_buffer(*target_iter) + target_buffer_offset;
-
-    const_buffer source_buffer =
-      const_buffer(*source_iter) + source_buffer_offset;
-
-    std::size_t bytes_copied = buffer_copy(target_buffer,
-        source_buffer, max_bytes_to_copy - total_bytes_copied);
-    total_bytes_copied += bytes_copied;
-
-    if (bytes_copied == buffer_size(target_buffer))
-    {
-      ++target_iter;
-      target_buffer_offset = 0;
-    }
-    else
-      target_buffer_offset += bytes_copied;
-
-    if (bytes_copied == buffer_size(source_buffer))
-    {
-      ++source_iter;
-      source_buffer_offset = 0;
-    }
-    else
-      source_buffer_offset += bytes_copied;
-  }
-
-  return total_bytes_copied;
+    std::size_t max_bytes_to_copy) ASIO_NOEXCEPT
+{
+  return detail::buffer_copy(
+      detail::buffer_sequence_cardinality<MutableBufferSequence>(),
+      detail::buffer_sequence_cardinality<ConstBufferSequence>(),
+      asio::buffer_sequence_begin(target),
+      asio::buffer_sequence_end(target),
+      asio::buffer_sequence_begin(source),
+      asio::buffer_sequence_end(source), max_bytes_to_copy);
 }
 
 /*@}*/
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_read_stream.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_read_stream.hpp
index 1a87b81..908dd37 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_read_stream.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_read_stream.hpp
@@ -2,7 +2,7 @@
 // buffered_read_stream.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -26,7 +26,7 @@
 #include "asio/detail/noncopyable.hpp"
 #include "asio/detail/type_traits.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -55,6 +55,9 @@ public:
   /// The type of the lowest layer.
   typedef typename next_layer_type::lowest_layer_type lowest_layer_type;
 
+  /// The type of the executor associated with the object.
+  typedef typename lowest_layer_type::executor_type executor_type;
+
 #if defined(GENERATING_DOCUMENTATION)
   /// The default buffer size.
   static const std::size_t default_buffer_size = implementation_defined;
@@ -96,11 +99,27 @@ public:
     return next_layer_.lowest_layer();
   }
 
-  /// Get the io_service associated with the object.
-  asio::io_service& get_io_service()
+  /// Get the executor associated with the object.
+  executor_type get_executor() ASIO_NOEXCEPT
+  {
+    return next_layer_.lowest_layer().get_executor();
+  }
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  asio::io_context& get_io_context()
+  {
+    return next_layer_.get_io_context();
+  }
+
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  asio::io_context& get_io_service()
   {
     return next_layer_.get_io_service();
   }
+#endif // !defined(ASIO_NO_DEPRECATED)
 
   /// Close the stream.
   void close()
@@ -109,9 +128,10 @@ public:
   }
 
   /// Close the stream.
-  asio::error_code close(asio::error_code& ec)
+  ASIO_SYNC_OP_VOID close(asio::error_code& ec)
   {
-    return next_layer_.close(ec);
+    next_layer_.close(ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Write the given data to the stream. Returns the number of bytes written.
@@ -139,14 +159,8 @@ public:
   async_write_some(const ConstBufferSequence& buffers,
       ASIO_MOVE_ARG(WriteHandler) handler)
   {
-    async_completion<WriteHandler,
-      void (asio::error_code, std::size_t)> init(handler);
-
-    next_layer_.async_write_some(buffers,
-        ASIO_MOVE_CAST(ASIO_HANDLER_TYPE(WriteHandler,
-            void (asio::error_code, std::size_t)))(init.handler));
-
-    return init.result.get();
+    return next_layer_.async_write_some(buffers,
+        ASIO_MOVE_CAST(WriteHandler)(handler));
   }
 
   /// Fill the buffer with some data. Returns the number of bytes placed in the
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_read_stream_fwd.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_read_stream_fwd.hpp
index 58664c9..3f1646a 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_read_stream_fwd.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_read_stream_fwd.hpp
@@ -2,7 +2,7 @@
 // buffered_read_stream_fwd.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_stream.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_stream.hpp
index 6a35da9..cabab60 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_stream.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_stream.hpp
@@ -2,7 +2,7 @@
 // buffered_stream.hpp
 // ~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -23,7 +23,7 @@
 #include "asio/buffered_stream_fwd.hpp"
 #include "asio/detail/noncopyable.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -52,6 +52,9 @@ public:
   /// The type of the lowest layer.
   typedef typename next_layer_type::lowest_layer_type lowest_layer_type;
 
+  /// The type of the executor associated with the object.
+  typedef typename lowest_layer_type::executor_type executor_type;
+
   /// Construct, passing the specified argument to initialise the next layer.
   template <typename Arg>
   explicit buffered_stream(Arg& a)
@@ -87,11 +90,27 @@ public:
     return stream_impl_.lowest_layer();
   }
 
-  /// Get the io_service associated with the object.
-  asio::io_service& get_io_service()
+  /// Get the executor associated with the object.
+  executor_type get_executor() ASIO_NOEXCEPT
+  {
+    return stream_impl_.lowest_layer().get_executor();
+  }
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  asio::io_context& get_io_context()
+  {
+    return stream_impl_.get_io_context();
+  }
+
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  asio::io_context& get_io_service()
   {
     return stream_impl_.get_io_service();
   }
+#endif // !defined(ASIO_NO_DEPRECATED)
 
   /// Close the stream.
   void close()
@@ -100,9 +119,10 @@ public:
   }
 
   /// Close the stream.
-  asio::error_code close(asio::error_code& ec)
+  ASIO_SYNC_OP_VOID close(asio::error_code& ec)
   {
-    return stream_impl_.close(ec);
+    stream_impl_.close(ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Flush all data from the buffer to the next layer. Returns the number of
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_stream_fwd.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_stream_fwd.hpp
index 1bad0a8..cc445d2 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_stream_fwd.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_stream_fwd.hpp
@@ -2,7 +2,7 @@
 // buffered_stream_fwd.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_write_stream.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_write_stream.hpp
index 7572fc5..9cdab8b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_write_stream.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_write_stream.hpp
@@ -2,7 +2,7 @@
 // buffered_write_stream.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -25,7 +25,7 @@
 #include "asio/detail/noncopyable.hpp"
 #include "asio/detail/type_traits.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/write.hpp"
 
 #include "asio/detail/push_options.hpp"
@@ -55,6 +55,9 @@ public:
   /// The type of the lowest layer.
   typedef typename next_layer_type::lowest_layer_type lowest_layer_type;
 
+  /// The type of the executor associated with the object.
+  typedef typename lowest_layer_type::executor_type executor_type;
+
 #if defined(GENERATING_DOCUMENTATION)
   /// The default buffer size.
   static const std::size_t default_buffer_size = implementation_defined;
@@ -96,11 +99,27 @@ public:
     return next_layer_.lowest_layer();
   }
 
-  /// Get the io_service associated with the object.
-  asio::io_service& get_io_service()
+  /// Get the executor associated with the object.
+  executor_type get_executor() ASIO_NOEXCEPT
+  {
+    return next_layer_.lowest_layer().get_executor();
+  }
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  asio::io_context& get_io_context()
+  {
+    return next_layer_.get_io_context();
+  }
+
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  asio::io_context& get_io_service()
   {
     return next_layer_.get_io_service();
   }
+#endif // !defined(ASIO_NO_DEPRECATED)
 
   /// Close the stream.
   void close()
@@ -109,9 +128,10 @@ public:
   }
 
   /// Close the stream.
-  asio::error_code close(asio::error_code& ec)
+  ASIO_SYNC_OP_VOID close(asio::error_code& ec)
   {
-    return next_layer_.close(ec);
+    next_layer_.close(ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Flush all data from the buffer to the next layer. Returns the number of
@@ -174,14 +194,8 @@ public:
   async_read_some(const MutableBufferSequence& buffers,
       ASIO_MOVE_ARG(ReadHandler) handler)
   {
-    async_completion<ReadHandler,
-      void (asio::error_code, std::size_t)> init(handler);
-
-    next_layer_.async_read_some(buffers,
-        ASIO_MOVE_CAST(ASIO_HANDLER_TYPE(ReadHandler,
-            void (asio::error_code, std::size_t)))(init.handler));
-
-    return init.result.get();
+    return next_layer_.async_read_some(buffers,
+        ASIO_MOVE_CAST(ReadHandler)(handler));
   }
 
   /// Peek at the incoming data on the stream. Returns the number of bytes read.
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_write_stream_fwd.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_write_stream_fwd.hpp
index 027382d..88f93a4 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_write_stream_fwd.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/buffered_write_stream_fwd.hpp
@@ -2,7 +2,7 @@
 // buffered_write_stream_fwd.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/buffers_iterator.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/buffers_iterator.hpp
index 0404b12..9080915 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/buffers_iterator.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/buffers_iterator.hpp
@@ -2,7 +2,7 @@
 // buffers_iterator.hpp
 // ~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -65,7 +65,44 @@ namespace detail
     typedef buffers_iterator_types_helper<is_mutable> helper;
     typedef typename helper::buffer_type buffer_type;
     typedef typename helper::template byte_type<ByteType>::type byte_type;
+    typedef typename BufferSequence::const_iterator const_iterator;
   };
+
+  template <typename ByteType>
+  struct buffers_iterator_types<mutable_buffer, ByteType>
+  {
+    typedef mutable_buffer buffer_type;
+    typedef ByteType byte_type;
+    typedef const mutable_buffer* const_iterator;
+  };
+
+  template <typename ByteType>
+  struct buffers_iterator_types<const_buffer, ByteType>
+  {
+    typedef const_buffer buffer_type;
+    typedef typename add_const<ByteType>::type byte_type;
+    typedef const const_buffer* const_iterator;
+  };
+
+#if !defined(ASIO_NO_DEPRECATED)
+
+  template <typename ByteType>
+  struct buffers_iterator_types<mutable_buffers_1, ByteType>
+  {
+    typedef mutable_buffer buffer_type;
+    typedef ByteType byte_type;
+    typedef const mutable_buffer* const_iterator;
+  };
+
+  template <typename ByteType>
+  struct buffers_iterator_types<const_buffers_1, ByteType>
+  {
+    typedef const_buffer buffer_type;
+    typedef typename add_const<ByteType>::type byte_type;
+    typedef const const_buffer* const_iterator;
+  };
+
+#endif // !defined(ASIO_NO_DEPRECATED)
 }
 
 /// A random access iterator over the bytes in a buffer sequence.
@@ -76,6 +113,9 @@ private:
   typedef typename detail::buffers_iterator_types<
       BufferSequence, ByteType>::buffer_type buffer_type;
 
+  typedef typename detail::buffers_iterator_types<BufferSequence,
+          ByteType>::const_iterator buffer_sequence_iterator_type;
+
 public:
   /// The type used for the distance between two iterators.
   typedef std::ptrdiff_t difference_type;
@@ -130,13 +170,13 @@ public:
 #endif // defined(__GNUC__) && (__GNUC__ == 4) && (__GNUC_MINOR__ == 3)
   {
     buffers_iterator new_iter;
-    new_iter.begin_ = buffers.begin();
-    new_iter.current_ = buffers.begin();
-    new_iter.end_ = buffers.end();
+    new_iter.begin_ = asio::buffer_sequence_begin(buffers);
+    new_iter.current_ = asio::buffer_sequence_begin(buffers);
+    new_iter.end_ = asio::buffer_sequence_end(buffers);
     while (new_iter.current_ != new_iter.end_)
     {
       new_iter.current_buffer_ = *new_iter.current_;
-      if (asio::buffer_size(new_iter.current_buffer_) > 0)
+      if (new_iter.current_buffer_.size() > 0)
         break;
       ++new_iter.current_;
     }
@@ -150,13 +190,13 @@ public:
 #endif // defined(__GNUC__) && (__GNUC__ == 4) && (__GNUC_MINOR__ == 3)
   {
     buffers_iterator new_iter;
-    new_iter.begin_ = buffers.begin();
-    new_iter.current_ = buffers.begin();
-    new_iter.end_ = buffers.end();
+    new_iter.begin_ = asio::buffer_sequence_begin(buffers);
+    new_iter.current_ = asio::buffer_sequence_begin(buffers);
+    new_iter.end_ = asio::buffer_sequence_end(buffers);
     while (new_iter.current_ != new_iter.end_)
     {
       buffer_type buffer = *new_iter.current_;
-      new_iter.position_ += asio::buffer_size(buffer);
+      new_iter.position_ += buffer.size();
       ++new_iter.current_;
     }
     return new_iter;
@@ -300,7 +340,8 @@ private:
   // Dereference the iterator.
   reference dereference() const
   {
-    return buffer_cast<pointer>(current_buffer_)[current_buffer_position_];
+    return static_cast<pointer>(
+        current_buffer_.data())[current_buffer_position_];
   }
 
   // Compare two iterators for equality.
@@ -317,7 +358,7 @@ private:
 
     // Check if the increment can be satisfied by the current buffer.
     ++current_buffer_position_;
-    if (current_buffer_position_ != asio::buffer_size(current_buffer_))
+    if (current_buffer_position_ != current_buffer_.size())
       return;
 
     // Find the next non-empty buffer.
@@ -326,7 +367,7 @@ private:
     while (current_ != end_)
     {
       current_buffer_ = *current_;
-      if (asio::buffer_size(current_buffer_) > 0)
+      if (current_buffer_.size() > 0)
         return;
       ++current_;
     }
@@ -346,12 +387,12 @@ private:
     }
 
     // Find the previous non-empty buffer.
-    typename BufferSequence::const_iterator iter = current_;
+    buffer_sequence_iterator_type iter = current_;
     while (iter != begin_)
     {
       --iter;
       buffer_type buffer = *iter;
-      std::size_t buffer_size = asio::buffer_size(buffer);
+      std::size_t buffer_size = buffer.size();
       if (buffer_size > 0)
       {
         current_ = iter;
@@ -371,8 +412,7 @@ private:
       for (;;)
       {
         std::ptrdiff_t current_buffer_balance
-          = asio::buffer_size(current_buffer_)
-          - current_buffer_position_;
+          = current_buffer_.size() - current_buffer_position_;
 
         // Check if the advance can be satisfied by the current buffer.
         if (current_buffer_balance > n)
@@ -426,12 +466,12 @@ private:
         }
 
         // Find the previous non-empty buffer.
-        typename BufferSequence::const_iterator iter = current_;
+        buffer_sequence_iterator_type iter = current_;
         while (iter != begin_)
         {
           --iter;
           buffer_type buffer = *iter;
-          std::size_t buffer_size = asio::buffer_size(buffer);
+          std::size_t buffer_size = buffer.size();
           if (buffer_size > 0)
           {
             current_ = iter;
@@ -452,9 +492,9 @@ private:
 
   buffer_type current_buffer_;
   std::size_t current_buffer_position_;
-  typename BufferSequence::const_iterator begin_;
-  typename BufferSequence::const_iterator current_;
-  typename BufferSequence::const_iterator end_;
+  buffer_sequence_iterator_type begin_;
+  buffer_sequence_iterator_type current_;
+  buffer_sequence_iterator_type end_;
   std::size_t position_;
 };
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/completion_condition.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/completion_condition.hpp
index b17b44a..cb22ddd 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/completion_condition.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/completion_condition.hpp
@@ -2,7 +2,7 @@
 // completion_condition.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/connect.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/connect.hpp
index 14f29b1..7dba932 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/connect.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/connect.hpp
@@ -2,7 +2,7 @@
 // connect.hpp
 // ~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -18,12 +18,43 @@
 #include "asio/detail/config.hpp"
 #include "asio/async_result.hpp"
 #include "asio/basic_socket.hpp"
+#include "asio/detail/type_traits.hpp"
 #include "asio/error.hpp"
 
 #include "asio/detail/push_options.hpp"
 
 namespace asio {
 
+namespace detail
+{
+  char (&has_iterator_helper(...))[2];
+
+  template <typename T>
+  char has_iterator_helper(T*, typename T::iterator* = 0);
+
+  template <typename T>
+  struct has_iterator_typedef
+  {
+    enum { value = (sizeof((has_iterator_helper)((T*)(0))) == 1) };
+  };
+} // namespace detail
+
+/// Type trait used to determine whether a type is an endpoint sequence that can
+/// be used with with @c connect and @c async_connect.
+template <typename T>
+struct is_endpoint_sequence
+{
+#if defined(GENERATING_DOCUMENTATION)
+  /// The value member is true if the type may be used as an endpoint sequence.
+  static const bool value;
+#else
+  enum
+  {
+    value = detail::has_iterator_typedef<T>::value
+  };
+#endif
+};
+
 /**
  * @defgroup connect asio::connect
  *
@@ -41,27 +72,26 @@ namespace asio {
  * @param s The socket to be connected. If the socket is already open, it will
  * be closed.
  *
- * @param begin An iterator pointing to the start of a sequence of endpoints.
+ * @param endpoints A sequence of endpoints.
  *
- * @returns On success, an iterator denoting the successfully connected
- * endpoint. Otherwise, the end iterator.
+ * @returns The successfully connected endpoint.
  *
  * @throws asio::system_error Thrown on failure. If the sequence is
  * empty, the associated @c error_code is asio::error::not_found.
  * Otherwise, contains the error from the last connection attempt.
  *
- * @note This overload assumes that a default constructed object of type @c
- * Iterator represents the end of the sequence. This is a valid assumption for
- * iterator types such as @c asio::ip::tcp::resolver::iterator.
- *
  * @par Example
- * @code tcp::resolver r(io_service);
+ * @code tcp::resolver r(io_context);
  * tcp::resolver::query q("host", "service");
- * tcp::socket s(io_service);
+ * tcp::socket s(io_context);
  * asio::connect(s, r.resolve(q)); @endcode
  */
-template <typename Protocol, typename SocketService, typename Iterator>
-Iterator connect(basic_socket<Protocol, SocketService>& s, Iterator begin);
+template <typename Protocol ASIO_SVC_TPARAM, typename EndpointSequence>
+typename Protocol::endpoint connect(
+    basic_socket<Protocol ASIO_SVC_TARG>& s,
+    const EndpointSequence& endpoints,
+    typename enable_if<is_endpoint_sequence<
+        EndpointSequence>::value>::type* = 0);
 
 /// Establishes a socket connection by trying each endpoint in a sequence.
 /**
@@ -73,23 +103,19 @@ Iterator connect(basic_socket<Protocol, SocketService>& s, Iterator begin);
  * @param s The socket to be connected. If the socket is already open, it will
  * be closed.
  *
- * @param begin An iterator pointing to the start of a sequence of endpoints.
+ * @param endpoints A sequence of endpoints.
  *
  * @param ec Set to indicate what error occurred, if any. If the sequence is
  * empty, set to asio::error::not_found. Otherwise, contains the error
  * from the last connection attempt.
  *
- * @returns On success, an iterator denoting the successfully connected
- * endpoint. Otherwise, the end iterator.
- *
- * @note This overload assumes that a default constructed object of type @c
- * Iterator represents the end of the sequence. This is a valid assumption for
- * iterator types such as @c asio::ip::tcp::resolver::iterator.
+ * @returns On success, the successfully connected endpoint. Otherwise, a
+ * default-constructed endpoint.
  *
  * @par Example
- * @code tcp::resolver r(io_service);
+ * @code tcp::resolver r(io_context);
  * tcp::resolver::query q("host", "service");
- * tcp::socket s(io_service);
+ * tcp::socket s(io_context);
  * asio::error_code ec;
  * asio::connect(s, r.resolve(q), ec);
  * if (ec)
@@ -97,11 +123,16 @@ Iterator connect(basic_socket<Protocol, SocketService>& s, Iterator begin);
  *   // An error occurred.
  * } @endcode
  */
-template <typename Protocol, typename SocketService, typename Iterator>
-Iterator connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, asio::error_code& ec);
+template <typename Protocol ASIO_SVC_TPARAM, typename EndpointSequence>
+typename Protocol::endpoint connect(
+    basic_socket<Protocol ASIO_SVC_TARG>& s,
+    const EndpointSequence& endpoints, asio::error_code& ec,
+    typename enable_if<is_endpoint_sequence<
+        EndpointSequence>::value>::type* = 0);
 
-/// Establishes a socket connection by trying each endpoint in a sequence.
+#if !defined(ASIO_NO_DEPRECATED)
+/// (Deprecated.) Establishes a socket connection by trying each endpoint in a
+/// sequence.
 /**
  * This function attempts to connect a socket to one of a sequence of
  * endpoints. It does this by repeated calls to the socket's @c connect member
@@ -113,24 +144,80 @@ Iterator connect(basic_socket<Protocol, SocketService>& s,
  *
  * @param begin An iterator pointing to the start of a sequence of endpoints.
  *
- * @param end An iterator pointing to the end of a sequence of endpoints.
+ * @returns On success, an iterator denoting the successfully connected
+ * endpoint. Otherwise, the end iterator.
+ *
+ * @throws asio::system_error Thrown on failure. If the sequence is
+ * empty, the associated @c error_code is asio::error::not_found.
+ * Otherwise, contains the error from the last connection attempt.
+ *
+ * @note This overload assumes that a default constructed object of type @c
+ * Iterator represents the end of the sequence. This is a valid assumption for
+ * iterator types such as @c asio::ip::tcp::resolver::iterator.
+ */
+template <typename Protocol ASIO_SVC_TPARAM, typename Iterator>
+Iterator connect(basic_socket<Protocol ASIO_SVC_TARG>& s, Iterator begin,
+    typename enable_if<!is_endpoint_sequence<Iterator>::value>::type* = 0);
+
+/// (Deprecated.) Establishes a socket connection by trying each endpoint in a
+/// sequence.
+/**
+ * This function attempts to connect a socket to one of a sequence of
+ * endpoints. It does this by repeated calls to the socket's @c connect member
+ * function, once for each endpoint in the sequence, until a connection is
+ * successfully established.
+ *
+ * @param s The socket to be connected. If the socket is already open, it will
+ * be closed.
+ *
+ * @param begin An iterator pointing to the start of a sequence of endpoints.
+ *
+ * @param ec Set to indicate what error occurred, if any. If the sequence is
+ * empty, set to asio::error::not_found. Otherwise, contains the error
+ * from the last connection attempt.
  *
  * @returns On success, an iterator denoting the successfully connected
  * endpoint. Otherwise, the end iterator.
  *
+ * @note This overload assumes that a default constructed object of type @c
+ * Iterator represents the end of the sequence. This is a valid assumption for
+ * iterator types such as @c asio::ip::tcp::resolver::iterator.
+ */
+template <typename Protocol ASIO_SVC_TPARAM, typename Iterator>
+Iterator connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
+    Iterator begin, asio::error_code& ec,
+    typename enable_if<!is_endpoint_sequence<Iterator>::value>::type* = 0);
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+/// Establishes a socket connection by trying each endpoint in a sequence.
+/**
+ * This function attempts to connect a socket to one of a sequence of
+ * endpoints. It does this by repeated calls to the socket's @c connect member
+ * function, once for each endpoint in the sequence, until a connection is
+ * successfully established.
+ *
+ * @param s The socket to be connected. If the socket is already open, it will
+ * be closed.
+ *
+ * @param begin An iterator pointing to the start of a sequence of endpoints.
+ *
+ * @param end An iterator pointing to the end of a sequence of endpoints.
+ *
+ * @returns An iterator denoting the successfully connected endpoint.
+ *
  * @throws asio::system_error Thrown on failure. If the sequence is
  * empty, the associated @c error_code is asio::error::not_found.
  * Otherwise, contains the error from the last connection attempt.
  *
  * @par Example
- * @code tcp::resolver r(io_service);
+ * @code tcp::resolver r(io_context);
  * tcp::resolver::query q("host", "service");
- * tcp::resolver::iterator i = r.resolve(q), end;
- * tcp::socket s(io_service);
- * asio::connect(s, i, end); @endcode
+ * tcp::resolver::results_type e = r.resolve(q);
+ * tcp::socket s(io_context);
+ * asio::connect(s, e.begin(), e.end()); @endcode
  */
-template <typename Protocol, typename SocketService, typename Iterator>
-Iterator connect(basic_socket<Protocol, SocketService>& s,
+template <typename Protocol ASIO_SVC_TPARAM, typename Iterator>
+Iterator connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
     Iterator begin, Iterator end);
 
 /// Establishes a socket connection by trying each endpoint in a sequence.
@@ -155,19 +242,19 @@ Iterator connect(basic_socket<Protocol, SocketService>& s,
  * endpoint. Otherwise, the end iterator.
  *
  * @par Example
- * @code tcp::resolver r(io_service);
+ * @code tcp::resolver r(io_context);
  * tcp::resolver::query q("host", "service");
- * tcp::resolver::iterator i = r.resolve(q), end;
- * tcp::socket s(io_service);
+ * tcp::resolver::results_type e = r.resolve(q);
+ * tcp::socket s(io_context);
  * asio::error_code ec;
- * asio::connect(s, i, end, ec);
+ * asio::connect(s, e.begin(), e.end(), ec);
  * if (ec)
  * {
  *   // An error occurred.
  * } @endcode
  */
-template <typename Protocol, typename SocketService, typename Iterator>
-Iterator connect(basic_socket<Protocol, SocketService>& s,
+template <typename Protocol ASIO_SVC_TPARAM, typename Iterator>
+Iterator connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
     Iterator begin, Iterator end, asio::error_code& ec);
 
 /// Establishes a socket connection by trying each endpoint in a sequence.
@@ -180,59 +267,54 @@ Iterator connect(basic_socket<Protocol, SocketService>& s,
  * @param s The socket to be connected. If the socket is already open, it will
  * be closed.
  *
- * @param begin An iterator pointing to the start of a sequence of endpoints.
+ * @param endpoints A sequence of endpoints.
  *
  * @param connect_condition A function object that is called prior to each
  * connection attempt. The signature of the function object must be:
- * @code Iterator connect_condition(
+ * @code bool connect_condition(
  *     const asio::error_code& ec,
- *     Iterator next); @endcode
+ *     const typename Protocol::endpoint& next); @endcode
  * The @c ec parameter contains the result from the most recent connect
  * operation. Before the first connection attempt, @c ec is always set to
- * indicate success. The @c next parameter is an iterator pointing to the next
- * endpoint to be tried. The function object should return the next iterator,
- * but is permitted to return a different iterator so that endpoints may be
- * skipped. The implementation guarantees that the function object will never
- * be called with the end iterator.
+ * indicate success. The @c next parameter is the next endpoint to be tried.
+ * The function object should return true if the next endpoint should be tried,
+ * and false if it should be skipped.
  *
- * @returns On success, an iterator denoting the successfully connected
- * endpoint. Otherwise, the end iterator.
+ * @returns The successfully connected endpoint.
  *
  * @throws asio::system_error Thrown on failure. If the sequence is
  * empty, the associated @c error_code is asio::error::not_found.
  * Otherwise, contains the error from the last connection attempt.
  *
- * @note This overload assumes that a default constructed object of type @c
- * Iterator represents the end of the sequence. This is a valid assumption for
- * iterator types such as @c asio::ip::tcp::resolver::iterator.
- *
  * @par Example
  * The following connect condition function object can be used to output
  * information about the individual connection attempts:
  * @code struct my_connect_condition
  * {
- *   template <typename Iterator>
- *   Iterator operator()(
+ *   bool operator()(
  *       const asio::error_code& ec,
- *       Iterator next)
+ *       const::tcp::endpoint& next)
  *   {
  *     if (ec) std::cout << "Error: " << ec.message() << std::endl;
- *     std::cout << "Trying: " << next->endpoint() << std::endl;
- *     return next;
+ *     std::cout << "Trying: " << next << std::endl;
+ *     return true;
  *   }
  * }; @endcode
  * It would be used with the asio::connect function as follows:
- * @code tcp::resolver r(io_service);
+ * @code tcp::resolver r(io_context);
  * tcp::resolver::query q("host", "service");
- * tcp::socket s(io_service);
- * tcp::resolver::iterator i = asio::connect(
- *     s, r.resolve(q), my_connect_condition());
- * std::cout << "Connected to: " << i->endpoint() << std::endl; @endcode
+ * tcp::socket s(io_context);
+ * tcp::endpoint e = asio::connect(s,
+ *     r.resolve(q), my_connect_condition());
+ * std::cout << "Connected to: " << e << std::endl; @endcode
  */
-template <typename Protocol, typename SocketService,
-    typename Iterator, typename ConnectCondition>
-Iterator connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, ConnectCondition connect_condition);
+template <typename Protocol ASIO_SVC_TPARAM,
+    typename EndpointSequence, typename ConnectCondition>
+typename Protocol::endpoint connect(
+    basic_socket<Protocol ASIO_SVC_TARG>& s,
+    const EndpointSequence& endpoints, ConnectCondition connect_condition,
+    typename enable_if<is_endpoint_sequence<
+        EndpointSequence>::value>::type* = 0);
 
 /// Establishes a socket connection by trying each endpoint in a sequence.
 /**
@@ -244,67 +326,148 @@ Iterator connect(basic_socket<Protocol, SocketService>& s,
  * @param s The socket to be connected. If the socket is already open, it will
  * be closed.
  *
- * @param begin An iterator pointing to the start of a sequence of endpoints.
+ * @param endpoints A sequence of endpoints.
  *
  * @param connect_condition A function object that is called prior to each
  * connection attempt. The signature of the function object must be:
- * @code Iterator connect_condition(
+ * @code bool connect_condition(
  *     const asio::error_code& ec,
- *     Iterator next); @endcode
+ *     const typename Protocol::endpoint& next); @endcode
  * The @c ec parameter contains the result from the most recent connect
  * operation. Before the first connection attempt, @c ec is always set to
- * indicate success. The @c next parameter is an iterator pointing to the next
- * endpoint to be tried. The function object should return the next iterator,
- * but is permitted to return a different iterator so that endpoints may be
- * skipped. The implementation guarantees that the function object will never
- * be called with the end iterator.
+ * indicate success. The @c next parameter is the next endpoint to be tried.
+ * The function object should return true if the next endpoint should be tried,
+ * and false if it should be skipped.
  *
  * @param ec Set to indicate what error occurred, if any. If the sequence is
  * empty, set to asio::error::not_found. Otherwise, contains the error
  * from the last connection attempt.
  *
- * @returns On success, an iterator denoting the successfully connected
- * endpoint. Otherwise, the end iterator.
- *
- * @note This overload assumes that a default constructed object of type @c
- * Iterator represents the end of the sequence. This is a valid assumption for
- * iterator types such as @c asio::ip::tcp::resolver::iterator.
+ * @returns On success, the successfully connected endpoint. Otherwise, a
+ * default-constructed endpoint.
  *
  * @par Example
  * The following connect condition function object can be used to output
  * information about the individual connection attempts:
  * @code struct my_connect_condition
  * {
- *   template <typename Iterator>
- *   Iterator operator()(
+ *   bool operator()(
  *       const asio::error_code& ec,
- *       Iterator next)
+ *       const::tcp::endpoint& next)
  *   {
  *     if (ec) std::cout << "Error: " << ec.message() << std::endl;
- *     std::cout << "Trying: " << next->endpoint() << std::endl;
- *     return next;
+ *     std::cout << "Trying: " << next << std::endl;
+ *     return true;
  *   }
  * }; @endcode
  * It would be used with the asio::connect function as follows:
- * @code tcp::resolver r(io_service);
+ * @code tcp::resolver r(io_context);
  * tcp::resolver::query q("host", "service");
- * tcp::socket s(io_service);
+ * tcp::socket s(io_context);
  * asio::error_code ec;
- * tcp::resolver::iterator i = asio::connect(
- *     s, r.resolve(q), my_connect_condition(), ec);
+ * tcp::endpoint e = asio::connect(s,
+ *     r.resolve(q), my_connect_condition(), ec);
  * if (ec)
  * {
  *   // An error occurred.
  * }
  * else
  * {
- *   std::cout << "Connected to: " << i->endpoint() << std::endl;
+ *   std::cout << "Connected to: " << e << std::endl;
  * } @endcode
  */
-template <typename Protocol, typename SocketService,
+template <typename Protocol ASIO_SVC_TPARAM,
+    typename EndpointSequence, typename ConnectCondition>
+typename Protocol::endpoint connect(
+    basic_socket<Protocol ASIO_SVC_TARG>& s,
+    const EndpointSequence& endpoints, ConnectCondition connect_condition,
+    asio::error_code& ec,
+    typename enable_if<is_endpoint_sequence<
+        EndpointSequence>::value>::type* = 0);
+
+#if !defined(ASIO_NO_DEPRECATED)
+/// (Deprecated.) Establishes a socket connection by trying each endpoint in a
+/// sequence.
+/**
+ * This function attempts to connect a socket to one of a sequence of
+ * endpoints. It does this by repeated calls to the socket's @c connect member
+ * function, once for each endpoint in the sequence, until a connection is
+ * successfully established.
+ *
+ * @param s The socket to be connected. If the socket is already open, it will
+ * be closed.
+ *
+ * @param begin An iterator pointing to the start of a sequence of endpoints.
+ *
+ * @param connect_condition A function object that is called prior to each
+ * connection attempt. The signature of the function object must be:
+ * @code bool connect_condition(
+ *     const asio::error_code& ec,
+ *     const typename Protocol::endpoint& next); @endcode
+ * The @c ec parameter contains the result from the most recent connect
+ * operation. Before the first connection attempt, @c ec is always set to
+ * indicate success. The @c next parameter is the next endpoint to be tried.
+ * The function object should return true if the next endpoint should be tried,
+ * and false if it should be skipped.
+ *
+ * @returns On success, an iterator denoting the successfully connected
+ * endpoint. Otherwise, the end iterator.
+ *
+ * @throws asio::system_error Thrown on failure. If the sequence is
+ * empty, the associated @c error_code is asio::error::not_found.
+ * Otherwise, contains the error from the last connection attempt.
+ *
+ * @note This overload assumes that a default constructed object of type @c
+ * Iterator represents the end of the sequence. This is a valid assumption for
+ * iterator types such as @c asio::ip::tcp::resolver::iterator.
+ */
+template <typename Protocol ASIO_SVC_TPARAM,
     typename Iterator, typename ConnectCondition>
-Iterator connect(basic_socket<Protocol, SocketService>& s, Iterator begin,
-    ConnectCondition connect_condition, asio::error_code& ec);
+Iterator connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
+    Iterator begin, ConnectCondition connect_condition,
+    typename enable_if<!is_endpoint_sequence<Iterator>::value>::type* = 0);
+
+/// (Deprecated.) Establishes a socket connection by trying each endpoint in a
+/// sequence.
+/**
+ * This function attempts to connect a socket to one of a sequence of
+ * endpoints. It does this by repeated calls to the socket's @c connect member
+ * function, once for each endpoint in the sequence, until a connection is
+ * successfully established.
+ *
+ * @param s The socket to be connected. If the socket is already open, it will
+ * be closed.
+ *
+ * @param begin An iterator pointing to the start of a sequence of endpoints.
+ *
+ * @param connect_condition A function object that is called prior to each
+ * connection attempt. The signature of the function object must be:
+ * @code bool connect_condition(
+ *     const asio::error_code& ec,
+ *     const typename Protocol::endpoint& next); @endcode
+ * The @c ec parameter contains the result from the most recent connect
+ * operation. Before the first connection attempt, @c ec is always set to
+ * indicate success. The @c next parameter is the next endpoint to be tried.
+ * The function object should return true if the next endpoint should be tried,
+ * and false if it should be skipped.
+ *
+ * @param ec Set to indicate what error occurred, if any. If the sequence is
+ * empty, set to asio::error::not_found. Otherwise, contains the error
+ * from the last connection attempt.
+ *
+ * @returns On success, an iterator denoting the successfully connected
+ * endpoint. Otherwise, the end iterator.
+ *
+ * @note This overload assumes that a default constructed object of type @c
+ * Iterator represents the end of the sequence. This is a valid assumption for
+ * iterator types such as @c asio::ip::tcp::resolver::iterator.
+ */
+template <typename Protocol ASIO_SVC_TPARAM,
+    typename Iterator, typename ConnectCondition>
+Iterator connect(basic_socket<Protocol ASIO_SVC_TARG>& s, Iterator begin,
+    ConnectCondition connect_condition, asio::error_code& ec,
+    typename enable_if<!is_endpoint_sequence<Iterator>::value>::type* = 0);
+#endif // !defined(ASIO_NO_DEPRECATED)
 
 /// Establishes a socket connection by trying each endpoint in a sequence.
 /**
@@ -322,19 +485,16 @@ Iterator connect(basic_socket<Protocol, SocketService>& s, Iterator begin,
  *
  * @param connect_condition A function object that is called prior to each
  * connection attempt. The signature of the function object must be:
- * @code Iterator connect_condition(
+ * @code bool connect_condition(
  *     const asio::error_code& ec,
- *     Iterator next); @endcode
+ *     const typename Protocol::endpoint& next); @endcode
  * The @c ec parameter contains the result from the most recent connect
  * operation. Before the first connection attempt, @c ec is always set to
- * indicate success. The @c next parameter is an iterator pointing to the next
- * endpoint to be tried. The function object should return the next iterator,
- * but is permitted to return a different iterator so that endpoints may be
- * skipped. The implementation guarantees that the function object will never
- * be called with the end iterator.
+ * indicate success. The @c next parameter is the next endpoint to be tried.
+ * The function object should return true if the next endpoint should be tried,
+ * and false if it should be skipped.
  *
- * @returns On success, an iterator denoting the successfully connected
- * endpoint. Otherwise, the end iterator.
+ * @returns An iterator denoting the successfully connected endpoint.
  *
  * @throws asio::system_error Thrown on failure. If the sequence is
  * empty, the associated @c error_code is asio::error::not_found.
@@ -345,27 +505,27 @@ Iterator connect(basic_socket<Protocol, SocketService>& s, Iterator begin,
  * information about the individual connection attempts:
  * @code struct my_connect_condition
  * {
- *   template <typename Iterator>
- *   Iterator operator()(
+ *   bool operator()(
  *       const asio::error_code& ec,
- *       Iterator next)
+ *       const::tcp::endpoint& next)
  *   {
  *     if (ec) std::cout << "Error: " << ec.message() << std::endl;
- *     std::cout << "Trying: " << next->endpoint() << std::endl;
- *     return next;
+ *     std::cout << "Trying: " << next << std::endl;
+ *     return true;
  *   }
  * }; @endcode
  * It would be used with the asio::connect function as follows:
- * @code tcp::resolver r(io_service);
+ * @code tcp::resolver r(io_context);
  * tcp::resolver::query q("host", "service");
- * tcp::resolver::iterator i = r.resolve(q), end;
- * tcp::socket s(io_service);
- * i = asio::connect(s, i, end, my_connect_condition());
+ * tcp::resolver::results_type e = r.resolve(q);
+ * tcp::socket s(io_context);
+ * tcp::resolver::results_type::iterator i = asio::connect(
+ *     s, e.begin(), e.end(), my_connect_condition());
  * std::cout << "Connected to: " << i->endpoint() << std::endl; @endcode
  */
-template <typename Protocol, typename SocketService,
+template <typename Protocol ASIO_SVC_TPARAM,
     typename Iterator, typename ConnectCondition>
-Iterator connect(basic_socket<Protocol, SocketService>& s, Iterator begin,
+Iterator connect(basic_socket<Protocol ASIO_SVC_TARG>& s, Iterator begin,
     Iterator end, ConnectCondition connect_condition);
 
 /// Establishes a socket connection by trying each endpoint in a sequence.
@@ -384,16 +544,14 @@ Iterator connect(basic_socket<Protocol, SocketService>& s, Iterator begin,
  *
  * @param connect_condition A function object that is called prior to each
  * connection attempt. The signature of the function object must be:
- * @code Iterator connect_condition(
+ * @code bool connect_condition(
  *     const asio::error_code& ec,
- *     Iterator next); @endcode
+ *     const typename Protocol::endpoint& next); @endcode
  * The @c ec parameter contains the result from the most recent connect
  * operation. Before the first connection attempt, @c ec is always set to
- * indicate success. The @c next parameter is an iterator pointing to the next
- * endpoint to be tried. The function object should return the next iterator,
- * but is permitted to return a different iterator so that endpoints may be
- * skipped. The implementation guarantees that the function object will never
- * be called with the end iterator.
+ * indicate success. The @c next parameter is the next endpoint to be tried.
+ * The function object should return true if the next endpoint should be tried,
+ * and false if it should be skipped.
  *
  * @param ec Set to indicate what error occurred, if any. If the sequence is
  * empty, set to asio::error::not_found. Otherwise, contains the error
@@ -407,23 +565,23 @@ Iterator connect(basic_socket<Protocol, SocketService>& s, Iterator begin,
  * information about the individual connection attempts:
  * @code struct my_connect_condition
  * {
- *   template <typename Iterator>
- *   Iterator operator()(
+ *   bool operator()(
  *       const asio::error_code& ec,
- *       Iterator next)
+ *       const::tcp::endpoint& next)
  *   {
  *     if (ec) std::cout << "Error: " << ec.message() << std::endl;
- *     std::cout << "Trying: " << next->endpoint() << std::endl;
- *     return next;
+ *     std::cout << "Trying: " << next << std::endl;
+ *     return true;
  *   }
  * }; @endcode
  * It would be used with the asio::connect function as follows:
- * @code tcp::resolver r(io_service);
+ * @code tcp::resolver r(io_context);
  * tcp::resolver::query q("host", "service");
- * tcp::resolver::iterator i = r.resolve(q), end;
- * tcp::socket s(io_service);
+ * tcp::resolver::results_type e = r.resolve(q);
+ * tcp::socket s(io_context);
  * asio::error_code ec;
- * i = asio::connect(s, i, end, my_connect_condition(), ec);
+ * tcp::resolver::results_type::iterator i = asio::connect(
+ *     s, e.begin(), e.end(), my_connect_condition());
  * if (ec)
  * {
  *   // An error occurred.
@@ -433,9 +591,9 @@ Iterator connect(basic_socket<Protocol, SocketService>& s, Iterator begin,
  *   std::cout << "Connected to: " << i->endpoint() << std::endl;
  * } @endcode
  */
-template <typename Protocol, typename SocketService,
+template <typename Protocol ASIO_SVC_TPARAM,
     typename Iterator, typename ConnectCondition>
-Iterator connect(basic_socket<Protocol, SocketService>& s,
+Iterator connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
     Iterator begin, Iterator end, ConnectCondition connect_condition,
     asio::error_code& ec);
 
@@ -460,7 +618,7 @@ Iterator connect(basic_socket<Protocol, SocketService>& s,
  * @param s The socket to be connected. If the socket is already open, it will
  * be closed.
  *
- * @param begin An iterator pointing to the start of a sequence of endpoints.
+ * @param endpoints A sequence of endpoints.
  *
  * @param handler The handler to be called when the connect operation
  * completes. Copies will be made of the handler as required. The function
@@ -471,23 +629,19 @@ Iterator connect(basic_socket<Protocol, SocketService>& s,
  *   // error from the last connection attempt.
  *   const asio::error_code& error,
  *
- *   // On success, an iterator denoting the successfully
- *   // connected endpoint. Otherwise, the end iterator.
- *   Iterator iterator
+ *   // On success, the successfully connected endpoint.
+ *   // Otherwise, a default-constructed endpoint.
+ *   const typename Protocol::endpoint& endpoint
  * ); @endcode
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation
  * of the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- *
- * @note This overload assumes that a default constructed object of type @c
- * Iterator represents the end of the sequence. This is a valid assumption for
- * iterator types such as @c asio::ip::tcp::resolver::iterator.
+ * asio::io_context::post().
  *
  * @par Example
- * @code tcp::resolver r(io_service);
+ * @code tcp::resolver r(io_context);
  * tcp::resolver::query q("host", "service");
- * tcp::socket s(io_service);
+ * tcp::socket s(io_context);
  *
  * // ...
  *
@@ -497,11 +651,11 @@ Iterator connect(basic_socket<Protocol, SocketService>& s,
  *
  * void resolve_handler(
  *     const asio::error_code& ec,
- *     tcp::resolver::iterator i)
+ *     tcp::resolver::results_type results)
  * {
  *   if (!ec)
  *   {
- *     asio::async_connect(s, i, connect_handler);
+ *     asio::async_connect(s, results, connect_handler);
  *   }
  * }
  *
@@ -509,17 +663,65 @@ Iterator connect(basic_socket<Protocol, SocketService>& s,
  *
  * void connect_handler(
  *     const asio::error_code& ec,
- *     tcp::resolver::iterator i)
+ *     const tcp::endpoint& endpoint)
  * {
  *   // ...
  * } @endcode
  */
-template <typename Protocol, typename SocketService,
-    typename Iterator, typename ComposedConnectHandler>
-ASIO_INITFN_RESULT_TYPE(ComposedConnectHandler,
+template <typename Protocol ASIO_SVC_TPARAM,
+    typename EndpointSequence, typename RangeConnectHandler>
+ASIO_INITFN_RESULT_TYPE(RangeConnectHandler,
+    void (asio::error_code, typename Protocol::endpoint))
+async_connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
+    const EndpointSequence& endpoints,
+    ASIO_MOVE_ARG(RangeConnectHandler) handler,
+    typename enable_if<is_endpoint_sequence<
+        EndpointSequence>::value>::type* = 0);
+
+#if !defined(ASIO_NO_DEPRECATED)
+/// (Deprecated.) Asynchronously establishes a socket connection by trying each
+/// endpoint in a sequence.
+/**
+ * This function attempts to connect a socket to one of a sequence of
+ * endpoints. It does this by repeated calls to the socket's @c async_connect
+ * member function, once for each endpoint in the sequence, until a connection
+ * is successfully established.
+ *
+ * @param s The socket to be connected. If the socket is already open, it will
+ * be closed.
+ *
+ * @param begin An iterator pointing to the start of a sequence of endpoints.
+ *
+ * @param handler The handler to be called when the connect operation
+ * completes. Copies will be made of the handler as required. The function
+ * signature of the handler must be:
+ * @code void handler(
+ *   // Result of operation. if the sequence is empty, set to
+ *   // asio::error::not_found. Otherwise, contains the
+ *   // error from the last connection attempt.
+ *   const asio::error_code& error,
+ *
+ *   // On success, an iterator denoting the successfully
+ *   // connected endpoint. Otherwise, the end iterator.
+ *   Iterator iterator
+ * ); @endcode
+ * Regardless of whether the asynchronous operation completes immediately or
+ * not, the handler will not be invoked from within this function. Invocation
+ * of the handler will be performed in a manner equivalent to using
+ * asio::io_context::post().
+ *
+ * @note This overload assumes that a default constructed object of type @c
+ * Iterator represents the end of the sequence. This is a valid assumption for
+ * iterator types such as @c asio::ip::tcp::resolver::iterator.
+ */
+template <typename Protocol ASIO_SVC_TPARAM,
+    typename Iterator, typename IteratorConnectHandler>
+ASIO_INITFN_RESULT_TYPE(IteratorConnectHandler,
     void (asio::error_code, Iterator))
-async_connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, ASIO_MOVE_ARG(ComposedConnectHandler) handler);
+async_connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
+    Iterator begin, ASIO_MOVE_ARG(IteratorConnectHandler) handler,
+    typename enable_if<!is_endpoint_sequence<Iterator>::value>::type* = 0);
+#endif // !defined(ASIO_NO_DEPRECATED)
 
 /// Asynchronously establishes a socket connection by trying each endpoint in a
 /// sequence.
@@ -552,46 +754,31 @@ async_connect(basic_socket<Protocol, SocketService>& s,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation
  * of the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @par Example
- * @code tcp::resolver r(io_service);
- * tcp::resolver::query q("host", "service");
- * tcp::socket s(io_service);
- *
- * // ...
- *
- * r.async_resolve(q, resolve_handler);
- *
- * // ...
- *
- * void resolve_handler(
- *     const asio::error_code& ec,
- *     tcp::resolver::iterator i)
- * {
- *   if (!ec)
- *   {
- *     tcp::resolver::iterator end;
- *     asio::async_connect(s, i, end, connect_handler);
- *   }
- * }
+ * @code std::vector<tcp::endpoint> endpoints = ...;
+ * tcp::socket s(io_context);
+ * asio::async_connect(s,
+ *     endpoints.begin(), endpoints.end(),
+ *     connect_handler);
  *
  * // ...
  *
  * void connect_handler(
  *     const asio::error_code& ec,
- *     tcp::resolver::iterator i)
+ *     std::vector<tcp::endpoint>::iterator i)
  * {
  *   // ...
  * } @endcode
  */
-template <typename Protocol, typename SocketService,
-    typename Iterator, typename ComposedConnectHandler>
-ASIO_INITFN_RESULT_TYPE(ComposedConnectHandler,
+template <typename Protocol ASIO_SVC_TPARAM,
+    typename Iterator, typename IteratorConnectHandler>
+ASIO_INITFN_RESULT_TYPE(IteratorConnectHandler,
     void (asio::error_code, Iterator))
-async_connect(basic_socket<Protocol, SocketService>& s,
+async_connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
     Iterator begin, Iterator end,
-    ASIO_MOVE_ARG(ComposedConnectHandler) handler);
+    ASIO_MOVE_ARG(IteratorConnectHandler) handler);
 
 /// Asynchronously establishes a socket connection by trying each endpoint in a
 /// sequence.
@@ -604,20 +791,18 @@ async_connect(basic_socket<Protocol, SocketService>& s,
  * @param s The socket to be connected. If the socket is already open, it will
  * be closed.
  *
- * @param begin An iterator pointing to the start of a sequence of endpoints.
+ * @param endpoints A sequence of endpoints.
  *
  * @param connect_condition A function object that is called prior to each
  * connection attempt. The signature of the function object must be:
- * @code Iterator connect_condition(
+ * @code bool connect_condition(
  *     const asio::error_code& ec,
- *     Iterator next); @endcode
+ *     const typename Protocol::endpoint& next); @endcode
  * The @c ec parameter contains the result from the most recent connect
  * operation. Before the first connection attempt, @c ec is always set to
- * indicate success. The @c next parameter is an iterator pointing to the next
- * endpoint to be tried. The function object should return the next iterator,
- * but is permitted to return a different iterator so that endpoints may be
- * skipped. The implementation guarantees that the function object will never
- * be called with the end iterator.
+ * indicate success. The @c next parameter is the next endpoint to be tried.
+ * The function object should return true if the next endpoint should be tried,
+ * and false if it should be skipped.
  *
  * @param handler The handler to be called when the connect operation
  * completes. Copies will be made of the handler as required. The function
@@ -635,31 +820,26 @@ async_connect(basic_socket<Protocol, SocketService>& s,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation
  * of the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- *
- * @note This overload assumes that a default constructed object of type @c
- * Iterator represents the end of the sequence. This is a valid assumption for
- * iterator types such as @c asio::ip::tcp::resolver::iterator.
+ * asio::io_context::post().
  *
  * @par Example
  * The following connect condition function object can be used to output
  * information about the individual connection attempts:
  * @code struct my_connect_condition
  * {
- *   template <typename Iterator>
- *   Iterator operator()(
+ *   bool operator()(
  *       const asio::error_code& ec,
- *       Iterator next)
+ *       const::tcp::endpoint& next)
  *   {
  *     if (ec) std::cout << "Error: " << ec.message() << std::endl;
- *     std::cout << "Trying: " << next->endpoint() << std::endl;
- *     return next;
+ *     std::cout << "Trying: " << next << std::endl;
+ *     return true;
  *   }
  * }; @endcode
  * It would be used with the asio::connect function as follows:
- * @code tcp::resolver r(io_service);
+ * @code tcp::resolver r(io_context);
  * tcp::resolver::query q("host", "service");
- * tcp::socket s(io_service);
+ * tcp::socket s(io_context);
  *
  * // ...
  *
@@ -669,11 +849,11 @@ async_connect(basic_socket<Protocol, SocketService>& s,
  *
  * void resolve_handler(
  *     const asio::error_code& ec,
- *     tcp::resolver::iterator i)
+ *     tcp::resolver::results_type results)
  * {
  *   if (!ec)
  *   {
- *     asio::async_connect(s, i,
+ *     asio::async_connect(s, results,
  *         my_connect_condition(),
  *         connect_handler);
  *   }
@@ -683,7 +863,7 @@ async_connect(basic_socket<Protocol, SocketService>& s,
  *
  * void connect_handler(
  *     const asio::error_code& ec,
- *     tcp::resolver::iterator i)
+ *     const tcp::endpoint& endpoint)
  * {
  *   if (ec)
  *   {
@@ -691,17 +871,76 @@ async_connect(basic_socket<Protocol, SocketService>& s,
  *   }
  *   else
  *   {
- *     std::cout << "Connected to: " << i->endpoint() << std::endl;
+ *     std::cout << "Connected to: " << endpoint << std::endl;
  *   }
  * } @endcode
  */
-template <typename Protocol, typename SocketService, typename Iterator,
-    typename ConnectCondition, typename ComposedConnectHandler>
-ASIO_INITFN_RESULT_TYPE(ComposedConnectHandler,
+template <typename Protocol ASIO_SVC_TPARAM, typename EndpointSequence,
+    typename ConnectCondition, typename RangeConnectHandler>
+ASIO_INITFN_RESULT_TYPE(RangeConnectHandler,
+    void (asio::error_code, typename Protocol::endpoint))
+async_connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
+    const EndpointSequence& endpoints, ConnectCondition connect_condition,
+    ASIO_MOVE_ARG(RangeConnectHandler) handler,
+    typename enable_if<is_endpoint_sequence<
+        EndpointSequence>::value>::type* = 0);
+
+#if !defined(ASIO_NO_DEPRECATED)
+/// (Deprecated.) Asynchronously establishes a socket connection by trying each
+/// endpoint in a sequence.
+/**
+ * This function attempts to connect a socket to one of a sequence of
+ * endpoints. It does this by repeated calls to the socket's @c async_connect
+ * member function, once for each endpoint in the sequence, until a connection
+ * is successfully established.
+ *
+ * @param s The socket to be connected. If the socket is already open, it will
+ * be closed.
+ *
+ * @param begin An iterator pointing to the start of a sequence of endpoints.
+ *
+ * @param connect_condition A function object that is called prior to each
+ * connection attempt. The signature of the function object must be:
+ * @code bool connect_condition(
+ *     const asio::error_code& ec,
+ *     const typename Protocol::endpoint& next); @endcode
+ * The @c ec parameter contains the result from the most recent connect
+ * operation. Before the first connection attempt, @c ec is always set to
+ * indicate success. The @c next parameter is the next endpoint to be tried.
+ * The function object should return true if the next endpoint should be tried,
+ * and false if it should be skipped.
+ *
+ * @param handler The handler to be called when the connect operation
+ * completes. Copies will be made of the handler as required. The function
+ * signature of the handler must be:
+ * @code void handler(
+ *   // Result of operation. if the sequence is empty, set to
+ *   // asio::error::not_found. Otherwise, contains the
+ *   // error from the last connection attempt.
+ *   const asio::error_code& error,
+ *
+ *   // On success, an iterator denoting the successfully
+ *   // connected endpoint. Otherwise, the end iterator.
+ *   Iterator iterator
+ * ); @endcode
+ * Regardless of whether the asynchronous operation completes immediately or
+ * not, the handler will not be invoked from within this function. Invocation
+ * of the handler will be performed in a manner equivalent to using
+ * asio::io_context::post().
+ *
+ * @note This overload assumes that a default constructed object of type @c
+ * Iterator represents the end of the sequence. This is a valid assumption for
+ * iterator types such as @c asio::ip::tcp::resolver::iterator.
+ */
+template <typename Protocol ASIO_SVC_TPARAM, typename Iterator,
+    typename ConnectCondition, typename IteratorConnectHandler>
+ASIO_INITFN_RESULT_TYPE(IteratorConnectHandler,
     void (asio::error_code, Iterator))
-async_connect(basic_socket<Protocol, SocketService>& s, Iterator begin,
+async_connect(basic_socket<Protocol ASIO_SVC_TARG>& s, Iterator begin,
     ConnectCondition connect_condition,
-    ASIO_MOVE_ARG(ComposedConnectHandler) handler);
+    ASIO_MOVE_ARG(IteratorConnectHandler) handler,
+    typename enable_if<!is_endpoint_sequence<Iterator>::value>::type* = 0);
+#endif // !defined(ASIO_NO_DEPRECATED)
 
 /// Asynchronously establishes a socket connection by trying each endpoint in a
 /// sequence.
@@ -720,16 +959,14 @@ async_connect(basic_socket<Protocol, SocketService>& s, Iterator begin,
  *
  * @param connect_condition A function object that is called prior to each
  * connection attempt. The signature of the function object must be:
- * @code Iterator connect_condition(
+ * @code bool connect_condition(
  *     const asio::error_code& ec,
- *     Iterator next); @endcode
+ *     const typename Protocol::endpoint& next); @endcode
  * The @c ec parameter contains the result from the most recent connect
  * operation. Before the first connection attempt, @c ec is always set to
- * indicate success. The @c next parameter is an iterator pointing to the next
- * endpoint to be tried. The function object should return the next iterator,
- * but is permitted to return a different iterator so that endpoints may be
- * skipped. The implementation guarantees that the function object will never
- * be called with the end iterator.
+ * indicate success. The @c next parameter is the next endpoint to be tried.
+ * The function object should return true if the next endpoint should be tried,
+ * and false if it should be skipped.
  *
  * @param handler The handler to be called when the connect operation
  * completes. Copies will be made of the handler as required. The function
@@ -747,27 +984,26 @@ async_connect(basic_socket<Protocol, SocketService>& s, Iterator begin,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation
  * of the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @par Example
  * The following connect condition function object can be used to output
  * information about the individual connection attempts:
  * @code struct my_connect_condition
  * {
- *   template <typename Iterator>
- *   Iterator operator()(
+ *   bool operator()(
  *       const asio::error_code& ec,
- *       Iterator next)
+ *       const::tcp::endpoint& next)
  *   {
  *     if (ec) std::cout << "Error: " << ec.message() << std::endl;
- *     std::cout << "Trying: " << next->endpoint() << std::endl;
- *     return next;
+ *     std::cout << "Trying: " << next << std::endl;
+ *     return true;
  *   }
  * }; @endcode
  * It would be used with the asio::connect function as follows:
- * @code tcp::resolver r(io_service);
+ * @code tcp::resolver r(io_context);
  * tcp::resolver::query q("host", "service");
- * tcp::socket s(io_service);
+ * tcp::socket s(io_context);
  *
  * // ...
  *
@@ -804,13 +1040,13 @@ async_connect(basic_socket<Protocol, SocketService>& s, Iterator begin,
  *   }
  * } @endcode
  */
-template <typename Protocol, typename SocketService, typename Iterator,
-    typename ConnectCondition, typename ComposedConnectHandler>
-ASIO_INITFN_RESULT_TYPE(ComposedConnectHandler,
+template <typename Protocol ASIO_SVC_TPARAM, typename Iterator,
+    typename ConnectCondition, typename IteratorConnectHandler>
+ASIO_INITFN_RESULT_TYPE(IteratorConnectHandler,
     void (asio::error_code, Iterator))
-async_connect(basic_socket<Protocol, SocketService>& s,
+async_connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
     Iterator begin, Iterator end, ConnectCondition connect_condition,
-    ASIO_MOVE_ARG(ComposedConnectHandler) handler);
+    ASIO_MOVE_ARG(IteratorConnectHandler) handler);
 
 /*@}*/
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/coroutine.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/coroutine.hpp
index d9dfaaa..d4a0335 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/coroutine.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/coroutine.hpp
@@ -2,7 +2,7 @@
 // coroutine.hpp
 // ~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -205,7 +205,7 @@ class coroutine_ref;
  * {
  *   do
  *   {
- *     socket_.reset(new tcp::socket(io_service_));
+ *     socket_.reset(new tcp::socket(io_context_));
  *     yield acceptor->async_accept(*socket_, *this);
  *     fork server(*this)();
  *   } while (is_parent());
@@ -227,7 +227,7 @@ class coroutine_ref;
  * Note that @c fork doesn't do the actual forking by itself. It is the
  * application's responsibility to create a clone of the coroutine and call it.
  * The clone can be called immediately, as above, or scheduled for delayed
- * execution using something like io_service::post().
+ * execution using something like io_context::post().
  *
  * @par Alternate macro names
  *
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/datagram_socket_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/datagram_socket_service.hpp
index e1972ab..4b9047d 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/datagram_socket_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/datagram_socket_service.hpp
@@ -2,7 +2,7 @@
 // datagram_socket_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,11 +16,14 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #include <cstddef>
 #include "asio/async_result.hpp"
 #include "asio/detail/type_traits.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 
 #if defined(ASIO_WINDOWS_RUNTIME)
 # include "asio/detail/null_socket_service.hpp"
@@ -38,7 +41,7 @@ namespace asio {
 template <typename Protocol>
 class datagram_socket_service
 #if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
+  : public asio::io_context::service
 #else
   : public asio::detail::service_base<datagram_socket_service<Protocol> >
 #endif
@@ -46,7 +49,7 @@ class datagram_socket_service
 public:
 #if defined(GENERATING_DOCUMENTATION)
   /// The unique service identifier.
-  static asio::io_service::id id;
+  static asio::io_context::id id;
 #endif
 
   /// The protocol type.
@@ -80,11 +83,11 @@ public:
   typedef typename service_impl_type::native_handle_type native_handle_type;
 #endif
 
-  /// Construct a new datagram socket service for the specified io_service.
-  explicit datagram_socket_service(asio::io_service& io_service)
+  /// Construct a new datagram socket service for the specified io_context.
+  explicit datagram_socket_service(asio::io_context& io_context)
     : asio::detail::service_base<
-        datagram_socket_service<Protocol> >(io_service),
-      service_impl_(io_service)
+        datagram_socket_service<Protocol> >(io_context),
+      service_impl_(io_context)
   {
   }
 
@@ -131,22 +134,23 @@ public:
   }
 
   // Open a new datagram socket implementation.
-  asio::error_code open(implementation_type& impl,
+  ASIO_SYNC_OP_VOID open(implementation_type& impl,
       const protocol_type& protocol, asio::error_code& ec)
   {
     if (protocol.type() == ASIO_OS_DEF(SOCK_DGRAM))
       service_impl_.open(impl, protocol, ec);
     else
       ec = asio::error::invalid_argument;
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Assign an existing native socket to a datagram socket.
-  asio::error_code assign(implementation_type& impl,
+  ASIO_SYNC_OP_VOID assign(implementation_type& impl,
       const protocol_type& protocol, const native_handle_type& native_socket,
       asio::error_code& ec)
   {
-    return service_impl_.assign(impl, protocol, native_socket, ec);
+    service_impl_.assign(impl, protocol, native_socket, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Determine whether the socket is open.
@@ -156,10 +160,11 @@ public:
   }
 
   /// Close a datagram socket implementation.
-  asio::error_code close(implementation_type& impl,
+  ASIO_SYNC_OP_VOID close(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.close(impl, ec);
+    service_impl_.close(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the native socket implementation.
@@ -169,10 +174,11 @@ public:
   }
 
   /// Cancel all asynchronous operations associated with the socket.
-  asio::error_code cancel(implementation_type& impl,
+  ASIO_SYNC_OP_VOID cancel(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.cancel(impl, ec);
+    service_impl_.cancel(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Determine whether the socket is at the out-of-band data mark.
@@ -190,17 +196,19 @@ public:
   }
 
   // Bind the datagram socket to the specified local endpoint.
-  asio::error_code bind(implementation_type& impl,
+  ASIO_SYNC_OP_VOID bind(implementation_type& impl,
       const endpoint_type& endpoint, asio::error_code& ec)
   {
-    return service_impl_.bind(impl, endpoint, ec);
+    service_impl_.bind(impl, endpoint, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Connect the datagram socket to the specified endpoint.
-  asio::error_code connect(implementation_type& impl,
+  ASIO_SYNC_OP_VOID connect(implementation_type& impl,
       const endpoint_type& peer_endpoint, asio::error_code& ec)
   {
-    return service_impl_.connect(impl, peer_endpoint, ec);
+    service_impl_.connect(impl, peer_endpoint, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Start an asynchronous connect.
@@ -214,33 +222,36 @@ public:
     async_completion<ConnectHandler,
       void (asio::error_code)> init(handler);
 
-    service_impl_.async_connect(impl, peer_endpoint, init.handler);
+    service_impl_.async_connect(impl, peer_endpoint, init.completion_handler);
 
     return init.result.get();
   }
 
   /// Set a socket option.
   template <typename SettableSocketOption>
-  asio::error_code set_option(implementation_type& impl,
+  ASIO_SYNC_OP_VOID set_option(implementation_type& impl,
       const SettableSocketOption& option, asio::error_code& ec)
   {
-    return service_impl_.set_option(impl, option, ec);
+    service_impl_.set_option(impl, option, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get a socket option.
   template <typename GettableSocketOption>
-  asio::error_code get_option(const implementation_type& impl,
+  ASIO_SYNC_OP_VOID get_option(const implementation_type& impl,
       GettableSocketOption& option, asio::error_code& ec) const
   {
-    return service_impl_.get_option(impl, option, ec);
+    service_impl_.get_option(impl, option, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Perform an IO control command on the socket.
   template <typename IoControlCommand>
-  asio::error_code io_control(implementation_type& impl,
+  ASIO_SYNC_OP_VOID io_control(implementation_type& impl,
       IoControlCommand& command, asio::error_code& ec)
   {
-    return service_impl_.io_control(impl, command, ec);
+    service_impl_.io_control(impl, command, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Gets the non-blocking mode of the socket.
@@ -250,10 +261,11 @@ public:
   }
 
   /// Sets the non-blocking mode of the socket.
-  asio::error_code non_blocking(implementation_type& impl,
+  ASIO_SYNC_OP_VOID non_blocking(implementation_type& impl,
       bool mode, asio::error_code& ec)
   {
-    return service_impl_.non_blocking(impl, mode, ec);
+    service_impl_.non_blocking(impl, mode, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Gets the non-blocking mode of the native socket implementation.
@@ -263,10 +275,11 @@ public:
   }
 
   /// Sets the non-blocking mode of the native socket implementation.
-  asio::error_code native_non_blocking(implementation_type& impl,
+  ASIO_SYNC_OP_VOID native_non_blocking(implementation_type& impl,
       bool mode, asio::error_code& ec)
   {
-    return service_impl_.native_non_blocking(impl, mode, ec);
+    service_impl_.native_non_blocking(impl, mode, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the local endpoint.
@@ -284,18 +297,20 @@ public:
   }
 
   /// Disable sends or receives on the socket.
-  asio::error_code shutdown(implementation_type& impl,
+  ASIO_SYNC_OP_VOID shutdown(implementation_type& impl,
       socket_base::shutdown_type what, asio::error_code& ec)
   {
-    return service_impl_.shutdown(impl, what, ec);
+    service_impl_.shutdown(impl, what, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Wait for the socket to become ready to read, ready to write, or to have
   /// pending error conditions.
-  asio::error_code wait(implementation_type& impl,
+  ASIO_SYNC_OP_VOID wait(implementation_type& impl,
       socket_base::wait_type w, asio::error_code& ec)
   {
-    return service_impl_.wait(impl, w, ec);
+    service_impl_.wait(impl, w, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Asynchronously wait for the socket to become ready to read, ready to
@@ -309,7 +324,7 @@ public:
     async_completion<WaitHandler,
       void (asio::error_code)> init(handler);
 
-    service_impl_.async_wait(impl, w, init.handler);
+    service_impl_.async_wait(impl, w, init.completion_handler);
 
     return init.result.get();
   }
@@ -334,7 +349,7 @@ public:
     async_completion<WriteHandler,
       void (asio::error_code, std::size_t)> init(handler);
 
-    service_impl_.async_send(impl, buffers, flags, init.handler);
+    service_impl_.async_send(impl, buffers, flags, init.completion_handler);
 
     return init.result.get();
   }
@@ -361,7 +376,7 @@ public:
       void (asio::error_code, std::size_t)> init(handler);
 
     service_impl_.async_send_to(impl, buffers,
-        destination, flags, init.handler);
+        destination, flags, init.completion_handler);
 
     return init.result.get();
   }
@@ -387,7 +402,7 @@ public:
     async_completion<ReadHandler,
       void (asio::error_code, std::size_t)> init(handler);
 
-    service_impl_.async_receive(impl, buffers, flags, init.handler);
+    service_impl_.async_receive(impl, buffers, flags, init.completion_handler);
 
     return init.result.get();
   }
@@ -415,16 +430,16 @@ public:
       void (asio::error_code, std::size_t)> init(handler);
 
     service_impl_.async_receive_from(impl, buffers,
-        sender_endpoint, flags, init.handler);
+        sender_endpoint, flags, init.completion_handler);
 
     return init.result.get();
   }
 
 private:
   // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
+  void shutdown()
   {
-    service_impl_.shutdown_service();
+    service_impl_.shutdown();
   }
 
   // The platform-specific implementation.
@@ -435,4 +450,6 @@ private:
 
 #include "asio/detail/pop_options.hpp"
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_DATAGRAM_SOCKET_SERVICE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/deadline_timer.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/deadline_timer.hpp
index 58a61af..1ffbfe5 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/deadline_timer.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/deadline_timer.hpp
@@ -2,7 +2,7 @@
 // deadline_timer.hpp
 // ~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -23,9 +23,7 @@
 #include "asio/detail/socket_types.hpp" // Must come before posix_time.
 #include "asio/basic_deadline_timer.hpp"
 
-#include "asio/detail/push_options.hpp"
 #include <boost/date_time/posix_time/posix_time_types.hpp>
-#include "asio/detail/pop_options.hpp"
 
 namespace asio {
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/deadline_timer_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/deadline_timer_service.hpp
index 57cd599..7acac1c 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/deadline_timer_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/deadline_timer_service.hpp
@@ -2,7 +2,7 @@
 // deadline_timer_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,15 +17,16 @@
 
 #include "asio/detail/config.hpp"
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #if defined(ASIO_HAS_BOOST_DATE_TIME) \
   || defined(GENERATING_DOCUMENTATION)
 
 #include <cstddef>
 #include "asio/async_result.hpp"
 #include "asio/detail/deadline_timer_service.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/time_traits.hpp"
-#include "asio/detail/timer_queue_ptime.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -36,7 +37,7 @@ template <typename TimeType,
     typename TimeTraits = asio::time_traits<TimeType> >
 class deadline_timer_service
 #if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
+  : public asio::io_context::service
 #else
   : public asio::detail::service_base<
       deadline_timer_service<TimeType, TimeTraits> >
@@ -45,7 +46,7 @@ class deadline_timer_service
 public:
 #if defined(GENERATING_DOCUMENTATION)
   /// The unique service identifier.
-  static asio::io_service::id id;
+  static asio::io_context::id id;
 #endif
 
   /// The time traits type.
@@ -69,11 +70,11 @@ public:
   typedef typename service_impl_type::implementation_type implementation_type;
 #endif
 
-  /// Construct a new timer service for the specified io_service.
-  explicit deadline_timer_service(asio::io_service& io_service)
+  /// Construct a new timer service for the specified io_context.
+  explicit deadline_timer_service(asio::io_context& io_context)
     : asio::detail::service_base<
-        deadline_timer_service<TimeType, TimeTraits> >(io_service),
-      service_impl_(io_service)
+        deadline_timer_service<TimeType, TimeTraits> >(io_context),
+      service_impl_(io_context)
   {
   }
 
@@ -144,16 +145,16 @@ public:
     async_completion<WaitHandler,
       void (asio::error_code)> init(handler);
 
-    service_impl_.async_wait(impl, init.handler);
+    service_impl_.async_wait(impl, init.completion_handler);
 
     return init.result.get();
   }
 
 private:
   // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
+  void shutdown()
   {
-    service_impl_.shutdown_service();
+    service_impl_.shutdown();
   }
 
   // The platform-specific implementation.
@@ -167,4 +168,6 @@ private:
 #endif // defined(ASIO_HAS_BOOST_DATE_TIME)
        // || defined(GENERATING_DOCUMENTATION)
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_DEADLINE_TIMER_SERVICE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/defer.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/defer.hpp
index 448364a..5e80614 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/defer.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/defer.hpp
@@ -2,7 +2,7 @@
 // defer.hpp
 // ~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/array.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/array.hpp
index 125f84d..cfb0acc 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/array.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/array.hpp
@@ -2,7 +2,7 @@
 // detail/array.hpp
 // ~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/array_fwd.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/array_fwd.hpp
index b53eca3..6a19a82 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/array_fwd.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/array_fwd.hpp
@@ -2,7 +2,7 @@
 // detail/array_fwd.hpp
 // ~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/assert.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/assert.hpp
index 104c0d1..22bb4b9 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/assert.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/assert.hpp
@@ -2,7 +2,7 @@
 // detail/assert.hpp
 // ~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/atomic_count.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/atomic_count.hpp
index 5956da0..798f915 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/atomic_count.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/atomic_count.hpp
@@ -2,7 +2,7 @@
 // detail/atomic_count.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/base_from_completion_cond.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/base_from_completion_cond.hpp
index a1aa61e..9f5165b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/base_from_completion_cond.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/base_from_completion_cond.hpp
@@ -2,7 +2,7 @@
 // detail/base_from_completion_cond.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/bind_handler.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/bind_handler.hpp
index 7271a79..3752464 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/bind_handler.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/bind_handler.hpp
@@ -2,7 +2,7 @@
 // detail/bind_handler.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -21,6 +21,7 @@
 #include "asio/detail/handler_alloc_helpers.hpp"
 #include "asio/detail/handler_cont_helpers.hpp"
 #include "asio/detail/handler_invoke_helpers.hpp"
+#include "asio/detail/type_traits.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -31,8 +32,9 @@ template <typename Handler, typename Arg1>
 class binder1
 {
 public:
-  binder1(int, ASIO_MOVE_ARG(Handler) handler, const Arg1& arg1)
-    : handler_(ASIO_MOVE_CAST(Handler)(handler)),
+  template <typename T>
+  binder1(int, ASIO_MOVE_ARG(T) handler, const Arg1& arg1)
+    : handler_(ASIO_MOVE_CAST(T)(handler)),
       arg1_(arg1)
   {
   }
@@ -113,10 +115,10 @@ inline void asio_handler_invoke(const Function& function,
 }
 
 template <typename Handler, typename Arg1>
-inline binder1<Handler, Arg1> bind_handler(
+inline binder1<typename decay<Handler>::type, Arg1> bind_handler(
     ASIO_MOVE_ARG(Handler) handler, const Arg1& arg1)
 {
-  return binder1<Handler, Arg1>(0,
+  return binder1<typename decay<Handler>::type, Arg1>(0,
       ASIO_MOVE_CAST(Handler)(handler), arg1);
 }
 
@@ -124,9 +126,10 @@ template <typename Handler, typename Arg1, typename Arg2>
 class binder2
 {
 public:
-  binder2(int, ASIO_MOVE_ARG(Handler) handler,
+  template <typename T>
+  binder2(int, ASIO_MOVE_ARG(T) handler,
       const Arg1& arg1, const Arg2& arg2)
-    : handler_(ASIO_MOVE_CAST(Handler)(handler)),
+    : handler_(ASIO_MOVE_CAST(T)(handler)),
       arg1_(arg1),
       arg2_(arg2)
   {
@@ -213,13 +216,139 @@ inline void asio_handler_invoke(const Function& function,
 }
 
 template <typename Handler, typename Arg1, typename Arg2>
-inline binder2<Handler, Arg1, Arg2> bind_handler(
+inline binder2<typename decay<Handler>::type, Arg1, Arg2> bind_handler(
     ASIO_MOVE_ARG(Handler) handler, const Arg1& arg1, const Arg2& arg2)
 {
-  return binder2<Handler, Arg1, Arg2>(0,
+  return binder2<typename decay<Handler>::type, Arg1, Arg2>(0,
       ASIO_MOVE_CAST(Handler)(handler), arg1, arg2);
 }
 
+#if defined(ASIO_HAS_MOVE)
+
+template <typename Handler, typename Arg1>
+class move_binder1
+{
+public:
+  move_binder1(int, ASIO_MOVE_ARG(Handler) handler,
+      ASIO_MOVE_ARG(Arg1) arg1)
+    : handler_(ASIO_MOVE_CAST(Handler)(handler)),
+      arg1_(ASIO_MOVE_CAST(Arg1)(arg1))
+  {
+  }
+
+  move_binder1(move_binder1&& other)
+    : handler_(ASIO_MOVE_CAST(Handler)(other.handler_)),
+      arg1_(ASIO_MOVE_CAST(Arg1)(other.arg1_))
+  {
+  }
+
+  void operator()()
+  {
+    handler_(ASIO_MOVE_CAST(Arg1)(arg1_));
+  }
+
+//private:
+  Handler handler_;
+  Arg1 arg1_;
+};
+
+template <typename Handler, typename Arg1>
+inline void* asio_handler_allocate(std::size_t size,
+    move_binder1<Handler, Arg1>* this_handler)
+{
+  return asio_handler_alloc_helpers::allocate(
+      size, this_handler->handler_);
+}
+
+template <typename Handler, typename Arg1>
+inline void asio_handler_deallocate(void* pointer, std::size_t size,
+    move_binder1<Handler, Arg1>* this_handler)
+{
+  asio_handler_alloc_helpers::deallocate(
+      pointer, size, this_handler->handler_);
+}
+
+template <typename Handler, typename Arg1>
+inline bool asio_handler_is_continuation(
+    move_binder1<Handler, Arg1>* this_handler)
+{
+  return asio_handler_cont_helpers::is_continuation(
+      this_handler->handler_);
+}
+
+template <typename Function, typename Handler, typename Arg1>
+inline void asio_handler_invoke(ASIO_MOVE_ARG(Function) function,
+    move_binder1<Handler, Arg1>* this_handler)
+{
+  asio_handler_invoke_helpers::invoke(
+      ASIO_MOVE_CAST(Function)(function), this_handler->handler_);
+}
+
+template <typename Handler, typename Arg1, typename Arg2>
+class move_binder2
+{
+public:
+  move_binder2(int, ASIO_MOVE_ARG(Handler) handler,
+      const Arg1& arg1, ASIO_MOVE_ARG(Arg2) arg2)
+    : handler_(ASIO_MOVE_CAST(Handler)(handler)),
+      arg1_(arg1),
+      arg2_(ASIO_MOVE_CAST(Arg2)(arg2))
+  {
+  }
+
+  move_binder2(move_binder2&& other)
+    : handler_(ASIO_MOVE_CAST(Handler)(other.handler_)),
+      arg1_(ASIO_MOVE_CAST(Arg1)(other.arg1_)),
+      arg2_(ASIO_MOVE_CAST(Arg2)(other.arg2_))
+  {
+  }
+
+  void operator()()
+  {
+    handler_(static_cast<const Arg1&>(arg1_),
+        ASIO_MOVE_CAST(Arg2)(arg2_));
+  }
+
+//private:
+  Handler handler_;
+  Arg1 arg1_;
+  Arg2 arg2_;
+};
+
+template <typename Handler, typename Arg1, typename Arg2>
+inline void* asio_handler_allocate(std::size_t size,
+    move_binder2<Handler, Arg1, Arg2>* this_handler)
+{
+  return asio_handler_alloc_helpers::allocate(
+      size, this_handler->handler_);
+}
+
+template <typename Handler, typename Arg1, typename Arg2>
+inline void asio_handler_deallocate(void* pointer, std::size_t size,
+    move_binder2<Handler, Arg1, Arg2>* this_handler)
+{
+  asio_handler_alloc_helpers::deallocate(
+      pointer, size, this_handler->handler_);
+}
+
+template <typename Handler, typename Arg1, typename Arg2>
+inline bool asio_handler_is_continuation(
+    move_binder2<Handler, Arg1, Arg2>* this_handler)
+{
+  return asio_handler_cont_helpers::is_continuation(
+      this_handler->handler_);
+}
+
+template <typename Function, typename Handler, typename Arg1, typename Arg2>
+inline void asio_handler_invoke(ASIO_MOVE_ARG(Function) function,
+    move_binder2<Handler, Arg1, Arg2>* this_handler)
+{
+  asio_handler_invoke_helpers::invoke(
+      ASIO_MOVE_CAST(Function)(function), this_handler->handler_);
+}
+
+#endif // defined(ASIO_HAS_MOVE)
+
 } // namespace detail
 
 template <typename Handler, typename Arg1, typename Allocator>
@@ -270,6 +399,59 @@ struct associated_executor<detail::binder2<Handler, Arg1, Arg2>, Executor>
   }
 };
 
+#if defined(ASIO_HAS_MOVE)
+
+template <typename Handler, typename Arg1, typename Allocator>
+struct associated_allocator<detail::move_binder1<Handler, Arg1>, Allocator>
+{
+  typedef typename associated_allocator<Handler, Allocator>::type type;
+
+  static type get(const detail::move_binder1<Handler, Arg1>& h,
+      const Allocator& a = Allocator()) ASIO_NOEXCEPT
+  {
+    return associated_allocator<Handler, Allocator>::get(h.handler_, a);
+  }
+};
+
+template <typename Handler, typename Arg1, typename Arg2, typename Allocator>
+struct associated_allocator<
+    detail::move_binder2<Handler, Arg1, Arg2>, Allocator>
+{
+  typedef typename associated_allocator<Handler, Allocator>::type type;
+
+  static type get(const detail::move_binder2<Handler, Arg1, Arg2>& h,
+      const Allocator& a = Allocator()) ASIO_NOEXCEPT
+  {
+    return associated_allocator<Handler, Allocator>::get(h.handler_, a);
+  }
+};
+
+template <typename Handler, typename Arg1, typename Executor>
+struct associated_executor<detail::move_binder1<Handler, Arg1>, Executor>
+{
+  typedef typename associated_executor<Handler, Executor>::type type;
+
+  static type get(const detail::move_binder1<Handler, Arg1>& h,
+      const Executor& ex = Executor()) ASIO_NOEXCEPT
+  {
+    return associated_executor<Handler, Executor>::get(h.handler_, ex);
+  }
+};
+
+template <typename Handler, typename Arg1, typename Arg2, typename Executor>
+struct associated_executor<detail::move_binder2<Handler, Arg1, Arg2>, Executor>
+{
+  typedef typename associated_executor<Handler, Executor>::type type;
+
+  static type get(const detail::move_binder2<Handler, Arg1, Arg2>& h,
+      const Executor& ex = Executor()) ASIO_NOEXCEPT
+  {
+    return associated_executor<Handler, Executor>::get(h.handler_, ex);
+  }
+};
+
+#endif // defined(ASIO_HAS_MOVE)
+
 } // namespace asio
 
 #include "asio/detail/pop_options.hpp"
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/buffer_resize_guard.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/buffer_resize_guard.hpp
index 5a33c3f..2768c8a 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/buffer_resize_guard.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/buffer_resize_guard.hpp
@@ -2,7 +2,7 @@
 // detail/buffer_resize_guard.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/buffer_sequence_adapter.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/buffer_sequence_adapter.hpp
index 2f388c6..f81e312 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/buffer_sequence_adapter.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/buffer_sequence_adapter.hpp
@@ -2,7 +2,7 @@
 // detail/buffer_sequence_adapter.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -27,11 +27,12 @@ namespace detail {
 
 class buffer_sequence_adapter_base
 {
-protected:
 #if defined(ASIO_WINDOWS_RUNTIME)
+public:
   // The maximum number of buffers to support in a single operation.
   enum { max_buffers = 1 };
 
+protected:
   typedef Windows::Storage::Streams::IBuffer^ native_buffer_type;
 
   ASIO_DECL static void init_native_buffer(
@@ -42,28 +43,32 @@ protected:
       native_buffer_type& buf,
       const asio::const_buffer& buffer);
 #elif defined(ASIO_WINDOWS) || defined(__CYGWIN__)
+public:
   // The maximum number of buffers to support in a single operation.
   enum { max_buffers = 64 < max_iov_len ? 64 : max_iov_len };
 
+protected:
   typedef WSABUF native_buffer_type;
 
   static void init_native_buffer(WSABUF& buf,
       const asio::mutable_buffer& buffer)
   {
-    buf.buf = asio::buffer_cast<char*>(buffer);
-    buf.len = static_cast<ULONG>(asio::buffer_size(buffer));
+    buf.buf = static_cast<char*>(buffer.data());
+    buf.len = static_cast<ULONG>(buffer.size());
   }
 
   static void init_native_buffer(WSABUF& buf,
       const asio::const_buffer& buffer)
   {
-    buf.buf = const_cast<char*>(asio::buffer_cast<const char*>(buffer));
-    buf.len = static_cast<ULONG>(asio::buffer_size(buffer));
+    buf.buf = const_cast<char*>(static_cast<const char*>(buffer.data()));
+    buf.len = static_cast<ULONG>(buffer.size());
   }
 #else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
+public:
   // The maximum number of buffers to support in a single operation.
   enum { max_buffers = 64 < max_iov_len ? 64 : max_iov_len };
 
+protected:
   typedef iovec native_buffer_type;
 
   static void init_iov_base(void*& base, void* addr)
@@ -80,16 +85,15 @@ protected:
   static void init_native_buffer(iovec& iov,
       const asio::mutable_buffer& buffer)
   {
-    init_iov_base(iov.iov_base, asio::buffer_cast<void*>(buffer));
-    iov.iov_len = asio::buffer_size(buffer);
+    init_iov_base(iov.iov_base, buffer.data());
+    iov.iov_len = buffer.size();
   }
 
   static void init_native_buffer(iovec& iov,
       const asio::const_buffer& buffer)
   {
-    init_iov_base(iov.iov_base, const_cast<void*>(
-          asio::buffer_cast<const void*>(buffer)));
-    iov.iov_len = asio::buffer_size(buffer);
+    init_iov_base(iov.iov_base, const_cast<void*>(buffer.data()));
+    iov.iov_len = buffer.size();
   }
 #endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
 };
@@ -103,14 +107,9 @@ public:
   explicit buffer_sequence_adapter(const Buffers& buffer_sequence)
     : count_(0), total_buffer_size_(0)
   {
-    typename Buffers::const_iterator iter = buffer_sequence.begin();
-    typename Buffers::const_iterator end = buffer_sequence.end();
-    for (; iter != end && count_ < max_buffers; ++iter, ++count_)
-    {
-      Buffer buffer(*iter);
-      init_native_buffer(buffers_[count_], buffer);
-      total_buffer_size_ += asio::buffer_size(buffer);
-    }
+    buffer_sequence_adapter::init(
+        asio::buffer_sequence_begin(buffer_sequence),
+        asio::buffer_sequence_end(buffer_sequence));
   }
 
   native_buffer_type* buffers()
@@ -123,6 +122,11 @@ public:
     return count_;
   }
 
+  std::size_t total_size() const
+  {
+    return total_buffer_size_;
+  }
+
   bool all_empty() const
   {
     return total_buffer_size_ == 0;
@@ -130,46 +134,185 @@ public:
 
   static bool all_empty(const Buffers& buffer_sequence)
   {
-    typename Buffers::const_iterator iter = buffer_sequence.begin();
-    typename Buffers::const_iterator end = buffer_sequence.end();
+    return buffer_sequence_adapter::all_empty(
+        asio::buffer_sequence_begin(buffer_sequence),
+        asio::buffer_sequence_end(buffer_sequence));
+  }
+
+  static void validate(const Buffers& buffer_sequence)
+  {
+    buffer_sequence_adapter::validate(
+        asio::buffer_sequence_begin(buffer_sequence),
+        asio::buffer_sequence_end(buffer_sequence));
+  }
+
+  static Buffer first(const Buffers& buffer_sequence)
+  {
+    return buffer_sequence_adapter::first(
+        asio::buffer_sequence_begin(buffer_sequence),
+        asio::buffer_sequence_end(buffer_sequence));
+  }
+
+private:
+  template <typename Iterator>
+  void init(Iterator begin, Iterator end)
+  {
+    Iterator iter = begin;
+    for (; iter != end && count_ < max_buffers; ++iter, ++count_)
+    {
+      Buffer buffer(*iter);
+      init_native_buffer(buffers_[count_], buffer);
+      total_buffer_size_ += buffer.size();
+    }
+  }
+
+  template <typename Iterator>
+  static bool all_empty(Iterator begin, Iterator end)
+  {
+    Iterator iter = begin;
     std::size_t i = 0;
     for (; iter != end && i < max_buffers; ++iter, ++i)
-      if (asio::buffer_size(Buffer(*iter)) > 0)
+      if (Buffer(*iter).size() > 0)
         return false;
     return true;
   }
 
-  static void validate(const Buffers& buffer_sequence)
+  template <typename Iterator>
+  static void validate(Iterator begin, Iterator end)
   {
-    typename Buffers::const_iterator iter = buffer_sequence.begin();
-    typename Buffers::const_iterator end = buffer_sequence.end();
+    Iterator iter = begin;
     for (; iter != end; ++iter)
     {
       Buffer buffer(*iter);
-      asio::buffer_cast<const void*>(buffer);
+      buffer.data();
     }
   }
 
-  static Buffer first(const Buffers& buffer_sequence)
+  template <typename Iterator>
+  static Buffer first(Iterator begin, Iterator end)
   {
-    typename Buffers::const_iterator iter = buffer_sequence.begin();
-    typename Buffers::const_iterator end = buffer_sequence.end();
+    Iterator iter = begin;
     for (; iter != end; ++iter)
     {
       Buffer buffer(*iter);
-      if (asio::buffer_size(buffer) != 0)
+      if (buffer.size() != 0)
         return buffer;
     }
     return Buffer();
   }
 
-private:
   native_buffer_type buffers_[max_buffers];
   std::size_t count_;
   std::size_t total_buffer_size_;
 };
 
 template <typename Buffer>
+class buffer_sequence_adapter<Buffer, asio::mutable_buffer>
+  : buffer_sequence_adapter_base
+{
+public:
+  explicit buffer_sequence_adapter(
+      const asio::mutable_buffer& buffer_sequence)
+  {
+    init_native_buffer(buffer_, Buffer(buffer_sequence));
+    total_buffer_size_ = buffer_sequence.size();
+  }
+
+  native_buffer_type* buffers()
+  {
+    return &buffer_;
+  }
+
+  std::size_t count() const
+  {
+    return 1;
+  }
+
+  std::size_t total_size() const
+  {
+    return total_buffer_size_;
+  }
+
+  bool all_empty() const
+  {
+    return total_buffer_size_ == 0;
+  }
+
+  static bool all_empty(const asio::mutable_buffer& buffer_sequence)
+  {
+    return buffer_sequence.size() == 0;
+  }
+
+  static void validate(const asio::mutable_buffer& buffer_sequence)
+  {
+    buffer_sequence.data();
+  }
+
+  static Buffer first(const asio::mutable_buffer& buffer_sequence)
+  {
+    return Buffer(buffer_sequence);
+  }
+
+private:
+  native_buffer_type buffer_;
+  std::size_t total_buffer_size_;
+};
+
+template <typename Buffer>
+class buffer_sequence_adapter<Buffer, asio::const_buffer>
+  : buffer_sequence_adapter_base
+{
+public:
+  explicit buffer_sequence_adapter(
+      const asio::const_buffer& buffer_sequence)
+  {
+    init_native_buffer(buffer_, Buffer(buffer_sequence));
+    total_buffer_size_ = buffer_sequence.size();
+  }
+
+  native_buffer_type* buffers()
+  {
+    return &buffer_;
+  }
+
+  std::size_t count() const
+  {
+    return 1;
+  }
+
+  std::size_t total_size() const
+  {
+    return total_buffer_size_;
+  }
+
+  bool all_empty() const
+  {
+    return total_buffer_size_ == 0;
+  }
+
+  static bool all_empty(const asio::const_buffer& buffer_sequence)
+  {
+    return buffer_sequence.size() == 0;
+  }
+
+  static void validate(const asio::const_buffer& buffer_sequence)
+  {
+    buffer_sequence.data();
+  }
+
+  static Buffer first(const asio::const_buffer& buffer_sequence)
+  {
+    return Buffer(buffer_sequence);
+  }
+
+private:
+  native_buffer_type buffer_;
+  std::size_t total_buffer_size_;
+};
+
+#if !defined(ASIO_NO_DEPRECATED)
+
+template <typename Buffer>
 class buffer_sequence_adapter<Buffer, asio::mutable_buffers_1>
   : buffer_sequence_adapter_base
 {
@@ -178,7 +321,7 @@ public:
       const asio::mutable_buffers_1& buffer_sequence)
   {
     init_native_buffer(buffer_, Buffer(buffer_sequence));
-    total_buffer_size_ = asio::buffer_size(buffer_sequence);
+    total_buffer_size_ = buffer_sequence.size();
   }
 
   native_buffer_type* buffers()
@@ -191,6 +334,11 @@ public:
     return 1;
   }
 
+  std::size_t total_size() const
+  {
+    return total_buffer_size_;
+  }
+
   bool all_empty() const
   {
     return total_buffer_size_ == 0;
@@ -198,12 +346,12 @@ public:
 
   static bool all_empty(const asio::mutable_buffers_1& buffer_sequence)
   {
-    return asio::buffer_size(buffer_sequence) == 0;
+    return buffer_sequence.size() == 0;
   }
 
   static void validate(const asio::mutable_buffers_1& buffer_sequence)
   {
-    asio::buffer_cast<const void*>(buffer_sequence);
+    buffer_sequence.data();
   }
 
   static Buffer first(const asio::mutable_buffers_1& buffer_sequence)
@@ -225,7 +373,7 @@ public:
       const asio::const_buffers_1& buffer_sequence)
   {
     init_native_buffer(buffer_, Buffer(buffer_sequence));
-    total_buffer_size_ = asio::buffer_size(buffer_sequence);
+    total_buffer_size_ = buffer_sequence.size();
   }
 
   native_buffer_type* buffers()
@@ -238,6 +386,11 @@ public:
     return 1;
   }
 
+  std::size_t total_size() const
+  {
+    return total_buffer_size_;
+  }
+
   bool all_empty() const
   {
     return total_buffer_size_ == 0;
@@ -245,12 +398,12 @@ public:
 
   static bool all_empty(const asio::const_buffers_1& buffer_sequence)
   {
-    return asio::buffer_size(buffer_sequence) == 0;
+    return buffer_sequence.size() == 0;
   }
 
   static void validate(const asio::const_buffers_1& buffer_sequence)
   {
-    asio::buffer_cast<const void*>(buffer_sequence);
+    buffer_sequence.data();
   }
 
   static Buffer first(const asio::const_buffers_1& buffer_sequence)
@@ -263,6 +416,8 @@ private:
   std::size_t total_buffer_size_;
 };
 
+#endif // !defined(ASIO_NO_DEPRECATED)
+
 template <typename Buffer, typename Elem>
 class buffer_sequence_adapter<Buffer, boost::array<Elem, 2> >
   : buffer_sequence_adapter_base
@@ -273,8 +428,7 @@ public:
   {
     init_native_buffer(buffers_[0], Buffer(buffer_sequence[0]));
     init_native_buffer(buffers_[1], Buffer(buffer_sequence[1]));
-    total_buffer_size_ = asio::buffer_size(buffer_sequence[0])
-      + asio::buffer_size(buffer_sequence[1]);
+    total_buffer_size_ = buffer_sequence[0].size() + buffer_sequence[1].size();
   }
 
   native_buffer_type* buffers()
@@ -287,6 +441,11 @@ public:
     return 2;
   }
 
+  std::size_t total_size() const
+  {
+    return total_buffer_size_;
+  }
+
   bool all_empty() const
   {
     return total_buffer_size_ == 0;
@@ -294,19 +453,18 @@ public:
 
   static bool all_empty(const boost::array<Elem, 2>& buffer_sequence)
   {
-    return asio::buffer_size(buffer_sequence[0]) == 0
-      && asio::buffer_size(buffer_sequence[1]) == 0;
+    return buffer_sequence[0].size() == 0 && buffer_sequence[1].size() == 0;
   }
 
   static void validate(const boost::array<Elem, 2>& buffer_sequence)
   {
-    asio::buffer_cast<const void*>(buffer_sequence[0]);
-    asio::buffer_cast<const void*>(buffer_sequence[1]);
+    buffer_sequence[0].data();
+    buffer_sequence[1].data();
   }
 
   static Buffer first(const boost::array<Elem, 2>& buffer_sequence)
   {
-    return Buffer(asio::buffer_size(buffer_sequence[0]) != 0
+    return Buffer(buffer_sequence[0].size() != 0
         ? buffer_sequence[0] : buffer_sequence[1]);
   }
 
@@ -327,8 +485,7 @@ public:
   {
     init_native_buffer(buffers_[0], Buffer(buffer_sequence[0]));
     init_native_buffer(buffers_[1], Buffer(buffer_sequence[1]));
-    total_buffer_size_ = asio::buffer_size(buffer_sequence[0])
-      + asio::buffer_size(buffer_sequence[1]);
+    total_buffer_size_ = buffer_sequence[0].size() + buffer_sequence[1].size();
   }
 
   native_buffer_type* buffers()
@@ -341,6 +498,11 @@ public:
     return 2;
   }
 
+  std::size_t total_size() const
+  {
+    return total_buffer_size_;
+  }
+
   bool all_empty() const
   {
     return total_buffer_size_ == 0;
@@ -348,19 +510,18 @@ public:
 
   static bool all_empty(const std::array<Elem, 2>& buffer_sequence)
   {
-    return asio::buffer_size(buffer_sequence[0]) == 0
-      && asio::buffer_size(buffer_sequence[1]) == 0;
+    return buffer_sequence[0].size() == 0 && buffer_sequence[1].size() == 0;
   }
 
   static void validate(const std::array<Elem, 2>& buffer_sequence)
   {
-    asio::buffer_cast<const void*>(buffer_sequence[0]);
-    asio::buffer_cast<const void*>(buffer_sequence[1]);
+    buffer_sequence[0].data();
+    buffer_sequence[1].data();
   }
 
   static Buffer first(const std::array<Elem, 2>& buffer_sequence)
   {
-    return Buffer(asio::buffer_size(buffer_sequence[0]) != 0
+    return Buffer(buffer_sequence[0].size() != 0
         ? buffer_sequence[0] : buffer_sequence[1]);
   }
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/buffered_stream_storage.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/buffered_stream_storage.hpp
index 4e6bcd3..a71120d 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/buffered_stream_storage.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/buffered_stream_storage.hpp
@@ -2,7 +2,7 @@
 // detail/buffered_stream_storage.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/call_stack.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/call_stack.hpp
index fa763e6..9835e64 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/call_stack.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/call_stack.hpp
@@ -2,7 +2,7 @@
 // detail/call_stack.hpp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -25,7 +25,7 @@ namespace asio {
 namespace detail {
 
 // Helper class to determine whether or not the current thread is inside an
-// invocation of io_service::run() for a specified io_service object.
+// invocation of io_context::run() for a specified io_context object.
 template <typename Key, typename Value = unsigned char>
 class call_stack
 {
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/chrono.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/chrono.hpp
new file mode 100644
index 0000000..31d6c6e
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/chrono.hpp
@@ -0,0 +1,66 @@
+//
+// detail/chrono.hpp
+// ~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_DETAIL_CHRONO_HPP
+#define ASIO_DETAIL_CHRONO_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+
+#if defined(ASIO_HAS_STD_CHRONO)
+# include <chrono>
+#elif defined(ASIO_HAS_BOOST_CHRONO)
+# include <boost/chrono/system_clocks.hpp>
+#endif // defined(ASIO_HAS_BOOST_CHRONO)
+
+namespace asio {
+namespace chrono {
+
+#if defined(ASIO_HAS_STD_CHRONO)
+using std::chrono::duration;
+using std::chrono::time_point;
+using std::chrono::duration_cast;
+using std::chrono::nanoseconds;
+using std::chrono::microseconds;
+using std::chrono::milliseconds;
+using std::chrono::seconds;
+using std::chrono::minutes;
+using std::chrono::hours;
+using std::chrono::time_point_cast;
+#if defined(ASIO_HAS_STD_CHRONO_MONOTONIC_CLOCK)
+typedef std::chrono::monotonic_clock steady_clock;
+#else // defined(ASIO_HAS_STD_CHRONO_MONOTONIC_CLOCK)
+using std::chrono::steady_clock;
+#endif // defined(ASIO_HAS_STD_CHRONO_MONOTONIC_CLOCK)
+using std::chrono::system_clock;
+using std::chrono::high_resolution_clock;
+#elif defined(ASIO_HAS_BOOST_CHRONO)
+using boost::chrono::duration;
+using boost::chrono::time_point;
+using boost::chrono::duration_cast;
+using boost::chrono::nanoseconds;
+using boost::chrono::microseconds;
+using boost::chrono::milliseconds;
+using boost::chrono::seconds;
+using boost::chrono::minutes;
+using boost::chrono::hours;
+using boost::chrono::time_point_cast;
+using boost::chrono::system_clock;
+using boost::chrono::steady_clock;
+using boost::chrono::high_resolution_clock;
+#endif // defined(ASIO_HAS_BOOST_CHRONO)
+
+} // namespace chrono
+} // namespace asio
+
+#endif // ASIO_DETAIL_CHRONO_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/chrono_time_traits.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/chrono_time_traits.hpp
index 525d551..b6236a5 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/chrono_time_traits.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/chrono_time_traits.hpp
@@ -2,7 +2,7 @@
 // detail/chrono_time_traits.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/completion_handler.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/completion_handler.hpp
index a607505..e510ded 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/completion_handler.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/completion_handler.hpp
@@ -2,7 +2,7 @@
 // detail/completion_handler.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -49,7 +49,7 @@ public:
     ptr p = { asio::detail::addressof(h->handler_), h, h };
     handler_work<Handler> w(h->handler_);
 
-    ASIO_HANDLER_COMPLETION((h));
+    ASIO_HANDLER_COMPLETION((*h));
 
     // Make a copy of the handler so that the memory can be deallocated before
     // the upcall is made. Even if we're not about to make an upcall, a
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/concurrency_hint.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/concurrency_hint.hpp
new file mode 100644
index 0000000..7548093
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/concurrency_hint.hpp
@@ -0,0 +1,88 @@
+//
+// detail/concurrency_hint.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_DETAIL_CONCURRENCY_HINT_HPP
+#define ASIO_DETAIL_CONCURRENCY_HINT_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+#include "asio/detail/noncopyable.hpp"
+
+// The concurrency hint ID and mask are used to identify when a "well-known"
+// concurrency hint value has been passed to the io_context.
+#define ASIO_CONCURRENCY_HINT_ID 0xA5100000u
+#define ASIO_CONCURRENCY_HINT_ID_MASK 0xFFFF0000u
+
+// If set, this bit indicates that the scheduler should perform locking.
+#define ASIO_CONCURRENCY_HINT_LOCKING_SCHEDULER 0x1u
+
+// If set, this bit indicates that the reactor should perform locking.
+#define ASIO_CONCURRENCY_HINT_LOCKING_REACTOR 0x2u
+
+// Helper macro to determine if we have a special concurrency hint.
+#define ASIO_CONCURRENCY_HINT_IS_SPECIAL(hint) \
+  ((static_cast<unsigned>(hint) \
+    & ASIO_CONCURRENCY_HINT_ID_MASK) \
+      == ASIO_CONCURRENCY_HINT_ID)
+
+// Helper macro to determine if locking is enabled for a given facility.
+#define ASIO_CONCURRENCY_HINT_IS_LOCKING(facility, hint) \
+  (((static_cast<unsigned>(hint) \
+    & (ASIO_CONCURRENCY_HINT_ID_MASK \
+      | ASIO_CONCURRENCY_HINT_LOCKING_ ## facility)) \
+        ^ ASIO_CONCURRENCY_HINT_ID) != 0)
+
+// This special concurrency hint disables locking in both the scheduler and
+// reactor I/O. This hint has the following restrictions:
+//
+// - Care must be taken to ensure that all operations on the io_context and any
+//   of its associated I/O objects (such as sockets and timers) occur in only
+//   one thread at a time.
+//
+// - Asynchronous resolve operations fail with operation_not_supported.
+//
+// - If a signal_set is used with the io_context, signal_set objects cannot be
+//   used with any other io_context in the program.
+#define ASIO_CONCURRENCY_HINT_UNSAFE \
+  static_cast<int>(ASIO_CONCURRENCY_HINT_ID)
+
+// This special concurrency hint disables locking in the reactor I/O. This hint
+// has the following restrictions:
+//
+// - Care must be taken to ensure that run functions on the io_context, and all
+//   operations on the io_context's associated I/O objects (such as sockets and
+//   timers), occur in only one thread at a time.
+#define ASIO_CONCURRENCY_HINT_UNSAFE_IO \
+  static_cast<int>(ASIO_CONCURRENCY_HINT_ID \
+      | ASIO_CONCURRENCY_HINT_LOCKING_SCHEDULER)
+
+// The special concurrency hint provides full thread safety.
+#define ASIO_CONCURRENCY_HINT_SAFE \
+  static_cast<int>(ASIO_CONCURRENCY_HINT_ID \
+      | ASIO_CONCURRENCY_HINT_LOCKING_SCHEDULER \
+      | ASIO_CONCURRENCY_HINT_LOCKING_REACTOR)
+
+// This #define may be overridden at compile time to specify a program-wide
+// default concurrency hint, used by the zero-argument io_context constructor.
+#if !defined(ASIO_CONCURRENCY_HINT_DEFAULT)
+# define ASIO_CONCURRENCY_HINT_DEFAULT -1
+#endif // !defined(ASIO_CONCURRENCY_HINT_DEFAULT)
+
+// This #define may be overridden at compile time to specify a program-wide
+// concurrency hint, used by the one-argument io_context constructor when
+// passed a value of 1.
+#if !defined(ASIO_CONCURRENCY_HINT_1)
+# define ASIO_CONCURRENCY_HINT_1 1
+#endif // !defined(ASIO_CONCURRENCY_HINT_DEFAULT)
+
+#endif // ASIO_DETAIL_CONCURRENCY_HINT_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/conditionally_enabled_event.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/conditionally_enabled_event.hpp
new file mode 100644
index 0000000..7ce806a
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/conditionally_enabled_event.hpp
@@ -0,0 +1,112 @@
+//
+// detail/conditionally_enabled_event.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_DETAIL_CONDITIONALLY_ENABLED_EVENT_HPP
+#define ASIO_DETAIL_CONDITIONALLY_ENABLED_EVENT_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+#include "asio/detail/conditionally_enabled_mutex.hpp"
+#include "asio/detail/event.hpp"
+#include "asio/detail/noncopyable.hpp"
+#include "asio/detail/null_event.hpp"
+#include "asio/detail/scoped_lock.hpp"
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+namespace detail {
+
+// Mutex adapter used to conditionally enable or disable locking.
+class conditionally_enabled_event
+  : private noncopyable
+{
+public:
+  // Constructor.
+  conditionally_enabled_event()
+  {
+  }
+
+  // Destructor.
+  ~conditionally_enabled_event()
+  {
+  }
+
+  // Signal the event. (Retained for backward compatibility.)
+  void signal(conditionally_enabled_mutex::scoped_lock& lock)
+  {
+    if (lock.mutex_.enabled_)
+      event_.signal(lock);
+  }
+
+  // Signal all waiters.
+  void signal_all(conditionally_enabled_mutex::scoped_lock& lock)
+  {
+    if (lock.mutex_.enabled_)
+      event_.signal_all(lock);
+  }
+
+  // Unlock the mutex and signal one waiter.
+  void unlock_and_signal_one(
+      conditionally_enabled_mutex::scoped_lock& lock)
+  {
+    if (lock.mutex_.enabled_)
+      event_.unlock_and_signal_one(lock);
+  }
+
+  // If there's a waiter, unlock the mutex and signal it.
+  bool maybe_unlock_and_signal_one(
+      conditionally_enabled_mutex::scoped_lock& lock)
+  {
+    if (lock.mutex_.enabled_)
+      return event_.maybe_unlock_and_signal_one(lock);
+    else
+      return false;
+  }
+
+  // Reset the event.
+  void clear(conditionally_enabled_mutex::scoped_lock& lock)
+  {
+    if (lock.mutex_.enabled_)
+      event_.clear(lock);
+  }
+
+  // Wait for the event to become signalled.
+  void wait(conditionally_enabled_mutex::scoped_lock& lock)
+  {
+    if (lock.mutex_.enabled_)
+      event_.wait(lock);
+    else
+      null_event().wait(lock);
+  }
+
+  // Timed wait for the event to become signalled.
+  bool wait_for_usec(
+      conditionally_enabled_mutex::scoped_lock& lock, long usec)
+  {
+    if (lock.mutex_.enabled_)
+      return event_.wait_for_usec(lock, usec);
+    else
+      return null_event().wait_for_usec(lock, usec);
+  }
+
+private:
+  asio::detail::event event_;
+};
+
+} // namespace detail
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // ASIO_DETAIL_CONDITIONALLY_ENABLED_EVENT_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/conditionally_enabled_mutex.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/conditionally_enabled_mutex.hpp
new file mode 100644
index 0000000..39c1687
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/conditionally_enabled_mutex.hpp
@@ -0,0 +1,149 @@
+//
+// detail/conditionally_enabled_mutex.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_DETAIL_CONDITIONALLY_ENABLED_MUTEX_HPP
+#define ASIO_DETAIL_CONDITIONALLY_ENABLED_MUTEX_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+#include "asio/detail/mutex.hpp"
+#include "asio/detail/noncopyable.hpp"
+#include "asio/detail/scoped_lock.hpp"
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+namespace detail {
+
+// Mutex adapter used to conditionally enable or disable locking.
+class conditionally_enabled_mutex
+  : private noncopyable
+{
+public:
+  // Helper class to lock and unlock a mutex automatically.
+  class scoped_lock
+    : private noncopyable
+  {
+  public:
+    // Tag type used to distinguish constructors.
+    enum adopt_lock_t { adopt_lock };
+
+    // Constructor adopts a lock that is already held.
+    scoped_lock(conditionally_enabled_mutex& m, adopt_lock_t)
+      : mutex_(m),
+        locked_(m.enabled_)
+    {
+    }
+
+    // Constructor acquires the lock.
+    explicit scoped_lock(conditionally_enabled_mutex& m)
+      : mutex_(m)
+    {
+      if (m.enabled_)
+      {
+        mutex_.mutex_.lock();
+        locked_ = true;
+      }
+      else
+        locked_ = false;
+    }
+
+    // Destructor releases the lock.
+    ~scoped_lock()
+    {
+      if (locked_)
+        mutex_.mutex_.unlock();
+    }
+
+    // Explicitly acquire the lock.
+    void lock()
+    {
+      if (mutex_.enabled_ && !locked_)
+      {
+        mutex_.mutex_.lock();
+        locked_ = true;
+      }
+    }
+
+    // Explicitly release the lock.
+    void unlock()
+    {
+      if (locked_)
+      {
+        mutex_.unlock();
+        locked_ = false;
+      }
+    }
+
+    // Test whether the lock is held.
+    bool locked() const
+    {
+      return locked_;
+    }
+
+    // Get the underlying mutex.
+    asio::detail::mutex& mutex()
+    {
+      return mutex_.mutex_;
+    }
+
+  private:
+    friend class conditionally_enabled_event;
+    conditionally_enabled_mutex& mutex_;
+    bool locked_;
+  };
+
+  // Constructor.
+  explicit conditionally_enabled_mutex(bool enabled)
+    : enabled_(enabled)
+  {
+  }
+
+  // Destructor.
+  ~conditionally_enabled_mutex()
+  {
+  }
+
+  // Determine whether locking is enabled.
+  bool enabled() const
+  {
+    return enabled_;
+  }
+
+  // Lock the mutex.
+  void lock()
+  {
+    if (enabled_)
+      mutex_.lock();
+  }
+
+  // Unlock the mutex.
+  void unlock()
+  {
+    if (enabled_)
+      mutex_.unlock();
+  }
+
+private:
+  friend class scoped_lock;
+  friend class conditionally_enabled_event;
+  asio::detail::mutex mutex_;
+  const bool enabled_;
+};
+
+} // namespace detail
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // ASIO_DETAIL_CONDITIONALLY_ENABLED_MUTEX_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/config.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/config.hpp
index 2a9eaf7..7bd6a94 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/config.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/config.hpp
@@ -2,7 +2,7 @@
 // detail/config.hpp
 // ~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -11,11 +11,6 @@
 #ifndef ASIO_DETAIL_CONFIG_HPP
 #define ASIO_DETAIL_CONFIG_HPP
 
-// MongoDB modification. We want this standalone, and we want separate
-// compilation for what we can to cut down on compile times.
-# define ASIO_STANDALONE // MongoDB
-# define ASIO_SEPARATE_COMPILATION // MongoDB
-
 #if defined(ASIO_STANDALONE)
 # define ASIO_DISABLE_BOOST_ARRAY 1
 # define ASIO_DISABLE_BOOST_ASSERT 1
@@ -70,7 +65,8 @@
 #if !defined(ASIO_MSVC)
 # if defined(ASIO_HAS_BOOST_CONFIG) && defined(BOOST_MSVC)
 #  define ASIO_MSVC BOOST_MSVC
-# elif defined(_MSC_VER) && !defined(__MWERKS__) && !defined(__EDG_VERSION__)
+# elif defined(_MSC_VER) && (defined(__INTELLISENSE__) \
+      || (!defined(__MWERKS__) && !defined(__EDG_VERSION__)))
 #  define ASIO_MSVC _MSC_VER
 # endif // defined(ASIO_HAS_BOOST_CONFIG) && defined(BOOST_MSVC)
 #endif // defined(ASIO_MSVC)
@@ -225,7 +221,12 @@
 #      define ASIO_NOEXCEPT_OR_NOTHROW noexcept(true)
 #    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
 #   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
-#  endif // defined(__GNUC__)
+#  elif defined(ASIO_MSVC)
+#   if (_MSC_VER >= 1900)
+#    define ASIO_NOEXCEPT noexcept(true)
+#    define ASIO_NOEXCEPT_OR_NOTHROW noexcept(true)
+#   endif // (_MSC_VER >= 1900)
+#  endif // defined(ASIO_MSVC)
 # endif // !defined(ASIO_DISABLE_NOEXCEPT)
 # if !defined(ASIO_NOEXCEPT)
 #  define ASIO_NOEXCEPT
@@ -299,8 +300,7 @@
 #     define ASIO_ERROR_CATEGORY_NOEXCEPT noexcept(true)
 #   endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
 #  endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
-# endif // defined(__GNUC__)
-# if defined(ASIO_MSVC)
+# elif defined(ASIO_MSVC)
 #  if (_MSC_VER >= 1900)
 #   define ASIO_ERROR_CATEGORY_NOEXCEPT noexcept(true)
 #  endif // (_MSC_VER >= 1900)
@@ -455,6 +455,15 @@
 # endif // !defined(ASIO_DISABLE_BOOST_CHRONO)
 #endif // !defined(ASIO_HAS_BOOST_CHRONO)
 
+// Some form of chrono library is available.
+#if !defined(ASIO_HAS_CHRONO)
+# if defined(ASIO_HAS_STD_CHRONO) \
+    || defined(ASIO_HAS_BOOST_CHRONO)
+#  define ASIO_HAS_CHRONO 1
+# endif // defined(ASIO_HAS_STD_CHRONO)
+        // || defined(ASIO_HAS_BOOST_CHRONO)
+#endif // !defined(ASIO_HAS_CHRONO)
+
 // Boost support for the DateTime library.
 #if !defined(ASIO_HAS_BOOST_DATE_TIME)
 # if !defined(ASIO_DISABLE_BOOST_DATE_TIME)
@@ -667,23 +676,90 @@
 # endif // !defined(ASIO_DISABLE_STD_CALL_ONCE)
 #endif // !defined(ASIO_HAS_STD_CALL_ONCE)
 
-// WinRT target.
-#if !defined(ASIO_WINDOWS_RUNTIME)
-# if defined(__cplusplus_winrt)
+// Standard library support for futures.
+#if !defined(ASIO_HAS_STD_FUTURE)
+# if !defined(ASIO_DISABLE_STD_FUTURE)
+#  if defined(__clang__)
+#   if defined(ASIO_HAS_CLANG_LIBCXX)
+#    define ASIO_HAS_STD_FUTURE 1
+#   elif (__cplusplus >= 201103)
+#    if __has_include(<future>)
+#     define ASIO_HAS_STD_FUTURE 1
+#    endif // __has_include(<mutex>)
+#   endif // (__cplusplus >= 201103)
+#  endif // defined(__clang__)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define ASIO_HAS_STD_FUTURE 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+#  if defined(ASIO_MSVC)
+#   if (_MSC_VER >= 1700)
+#    define ASIO_HAS_STD_FUTURE 1
+#   endif // (_MSC_VER >= 1700)
+#  endif // defined(ASIO_MSVC)
+# endif // !defined(ASIO_DISABLE_STD_FUTURE)
+#endif // !defined(ASIO_HAS_STD_FUTURE)
+
+// Standard library support for experimental::string_view.
+#if !defined(ASIO_HAS_STD_STRING_VIEW)
+# if !defined(ASIO_DISABLE_STD_STRING_VIEW)
+#  if defined(__clang__)
+#   if (__cplusplus >= 201103)
+#    if __has_include(<experimental/string_view>)
+#     define ASIO_HAS_STD_STRING_VIEW 1
+#     define ASIO_HAS_STD_EXPERIMENTAL_STRING_VIEW 1
+#    endif // __has_include(<experimental/string_view>)
+#   endif // (__cplusplus >= 201103)
+#  endif // defined(__clang__)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 9)) || (__GNUC__ > 4)
+#    if (__cplusplus >= 201300)
+#     define ASIO_HAS_STD_STRING_VIEW 1
+#     define ASIO_HAS_STD_EXPERIMENTAL_STRING_VIEW 1
+#    endif // (__cplusplus >= 201300)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+# endif // !defined(ASIO_DISABLE_STD_STRING_VIEW)
+#endif // !defined(ASIO_HAS_STD_STRING_VIEW)
+
+// Windows App target. Windows but with a limited API.
+#if !defined(ASIO_WINDOWS_APP)
+# if defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0603)
 #  include <winapifamily.h>
-#  if WINAPI_FAMILY_ONE_PARTITION(WINAPI_FAMILY, WINAPI_PARTITION_APP)
-#   define ASIO_WINDOWS_RUNTIME 1
-#  endif // WINAPI_FAMILY_ONE_PARTITION(WINAPI_FAMILY, WINAPI_PARTITION_APP)
-# endif // defined(__cplusplus_winrt)
+#  if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) \
+   && !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
+#   define ASIO_WINDOWS_APP 1
+#  endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
+         // && !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
+# endif // defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0603)
+#endif // !defined(ASIO_WINDOWS_APP)
+
+// Legacy WinRT target. Windows App is preferred.
+#if !defined(ASIO_WINDOWS_RUNTIME)
+# if !defined(ASIO_WINDOWS_APP)
+#  if defined(__cplusplus_winrt)
+#   include <winapifamily.h>
+#   if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) \
+    && !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
+#    define ASIO_WINDOWS_RUNTIME 1
+#   endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
+          // && !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
+#  endif // defined(__cplusplus_winrt)
+# endif // !defined(ASIO_WINDOWS_APP)
 #endif // !defined(ASIO_WINDOWS_RUNTIME)
 
-// Windows target. Excludes WinRT.
+// Windows target. Excludes WinRT but includes Windows App targets.
 #if !defined(ASIO_WINDOWS)
 # if !defined(ASIO_WINDOWS_RUNTIME)
 #  if defined(ASIO_HAS_BOOST_CONFIG) && defined(BOOST_WINDOWS)
 #   define ASIO_WINDOWS 1
 #  elif defined(WIN32) || defined(_WIN32) || defined(__WIN32__)
 #   define ASIO_WINDOWS 1
+#  elif defined(ASIO_WINDOWS_APP)
+#   define ASIO_WINDOWS 1
 #  endif // defined(ASIO_HAS_BOOST_CONFIG) && defined(BOOST_WINDOWS)
 # endif // !defined(ASIO_WINDOWS_RUNTIME)
 #endif // !defined(ASIO_WINDOWS)
@@ -751,11 +827,11 @@
 #if !defined(ASIO_HAS_IOCP)
 # if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
 #  if defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0400)
-#   if !defined(UNDER_CE)
+#   if !defined(UNDER_CE) && !defined(ASIO_WINDOWS_APP)
 #    if !defined(ASIO_DISABLE_IOCP)
 #     define ASIO_HAS_IOCP 1
 #    endif // !defined(ASIO_DISABLE_IOCP)
-#   endif // !defined(UNDER_CE)
+#   endif // !defined(UNDER_CE) && !defined(ASIO_WINDOWS_APP)
 #  endif // defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0400)
 # endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
 #endif // !defined(ASIO_HAS_IOCP)
@@ -871,9 +947,9 @@
 #if !defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE)
 # if !defined(ASIO_DISABLE_WINDOWS_OBJECT_HANDLE)
 #  if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-#   if !defined(UNDER_CE)
+#   if !defined(UNDER_CE) && !defined(ASIO_WINDOWS_APP)
 #    define ASIO_HAS_WINDOWS_OBJECT_HANDLE 1
-#   endif // !defined(UNDER_CE)
+#   endif // !defined(UNDER_CE) && !defined(ASIO_WINDOWS_APP)
 #  endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
 # endif // !defined(ASIO_DISABLE_WINDOWS_OBJECT_HANDLE)
 #endif // !defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE)
@@ -937,15 +1013,25 @@
 
 // Can use getaddrinfo() and getnameinfo().
 #if !defined(ASIO_HAS_GETADDRINFO)
-# if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-#  if defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0501)
-#   define ASIO_HAS_GETADDRINFO 1
-#  elif defined(UNDER_CE)
+# if !defined(ASIO_DISABLE_GETADDRINFO)
+#  if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
+#   if defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0501)
+#    define ASIO_HAS_GETADDRINFO 1
+#   elif defined(UNDER_CE)
+#    define ASIO_HAS_GETADDRINFO 1
+#   endif // defined(UNDER_CE)
+#  elif defined(__MACH__) && defined(__APPLE__)
+#   if defined(__MAC_OS_X_VERSION_MIN_REQUIRED)
+#    if (__MAC_OS_X_VERSION_MIN_REQUIRED >= 1050)
+#     define ASIO_HAS_GETADDRINFO 1
+#    endif // (__MAC_OS_X_VERSION_MIN_REQUIRED >= 1050)
+#   else // defined(__MAC_OS_X_VERSION_MIN_REQUIRED)
+#    define ASIO_HAS_GETADDRINFO 1
+#   endif // defined(__MAC_OS_X_VERSION_MIN_REQUIRED)
+#  else // defined(__MACH__) && defined(__APPLE__)
 #   define ASIO_HAS_GETADDRINFO 1
-#  endif // defined(UNDER_CE)
-# elif !(defined(__MACH__) && defined(__APPLE__))
-#  define ASIO_HAS_GETADDRINFO 1
-# endif // !(defined(__MACH__) && defined(__APPLE__))
+#  endif // defined(__MACH__) && defined(__APPLE__)
+# endif // !defined(ASIO_DISABLE_GETADDRINFO)
 #endif // !defined(ASIO_HAS_GETADDRINFO)
 
 // Whether standard iostreams are disabled.
@@ -974,11 +1060,18 @@
 # if !defined(ASIO_DISABLE_THREADS)
 #  if defined(ASIO_HAS_BOOST_CONFIG) && defined(BOOST_HAS_THREADS)
 #   define ASIO_HAS_THREADS 1
-#  elif defined(_MSC_VER) && defined(_MT)
+#  elif defined(__GNUC__) && !defined(__MINGW32__) \
+     && !defined(linux) && !defined(__linux) && !defined(__linux__)
+#   define ASIO_HAS_THREADS 1
+#  elif defined(_MT) || defined(__MT__)
+#   define ASIO_HAS_THREADS 1
+#  elif defined(_REENTRANT)
 #   define ASIO_HAS_THREADS 1
-#  elif defined(__BORLANDC__) && defined(__MT__)
+#  elif defined(__APPLE__)
 #   define ASIO_HAS_THREADS 1
-#  elif defined(_POSIX_THREADS)
+#  elif defined(_POSIX_THREADS) && (_POSIX_THREADS + 0 >= 0)
+#   define ASIO_HAS_THREADS 1
+#  elif defined(_PTHREADS)
 #   define ASIO_HAS_THREADS 1
 #  endif // defined(ASIO_HAS_BOOST_CONFIG) && defined(BOOST_HAS_THREADS)
 # endif // !defined(ASIO_DISABLE_THREADS)
@@ -989,7 +1082,7 @@
 # if defined(ASIO_HAS_THREADS)
 #  if defined(ASIO_HAS_BOOST_CONFIG) && defined(BOOST_HAS_PTHREADS)
 #   define ASIO_HAS_PTHREADS 1
-#  elif defined(_POSIX_THREADS)
+#  elif defined(_POSIX_THREADS) && (_POSIX_THREADS + 0 >= 0)
 #   define ASIO_HAS_PTHREADS 1
 #  endif // defined(ASIO_HAS_BOOST_CONFIG) && defined(BOOST_HAS_PTHREADS)
 # endif // defined(ASIO_HAS_THREADS)
@@ -1089,12 +1182,14 @@
 # if defined(__linux__)
 #  if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
 #   if ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3)
-#    if !defined(__INTEL_COMPILER) && !defined(__ICL)
+#    if !defined(__INTEL_COMPILER) && !defined(__ICL) \
+       && !(defined(__clang__) && defined(__ANDROID__))
 #     define ASIO_HAS_THREAD_KEYWORD_EXTENSION 1
 #     define ASIO_THREAD_KEYWORD __thread
 #    elif defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 1100)
 #     define ASIO_HAS_THREAD_KEYWORD_EXTENSION 1
 #    endif // defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 1100)
+           // && !(defined(__clang__) && defined(__ANDROID__))
 #   endif // ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3)
 #  endif // defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
 # endif // defined(__linux__)
@@ -1118,4 +1213,40 @@
         //   || (defined(__MACH__) && defined(__APPLE__))
 #endif // !defined(ASIO_DISABLE_SSIZE_T)
 
+// Helper macros to manage the transition away from the old services-based API.
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+# define ASIO_SVC_TPARAM , typename Service
+# define ASIO_SVC_TPARAM_DEF1(d1) , typename Service d1
+# define ASIO_SVC_TPARAM_DEF2(d1, d2) , typename Service d1, d2
+# define ASIO_SVC_TARG , Service
+# define ASIO_SVC_T Service
+# define ASIO_SVC_TPARAM1 , typename Service1
+# define ASIO_SVC_TPARAM1_DEF1(d1) , typename Service1 d1
+# define ASIO_SVC_TPARAM1_DEF2(d1, d2) , typename Service1 d1, d2
+# define ASIO_SVC_TARG1 , Service1
+# define ASIO_SVC_T1 Service1
+# define ASIO_SVC_ACCESS public
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+# define ASIO_SVC_TPARAM
+# define ASIO_SVC_TPARAM_DEF1(d1)
+# define ASIO_SVC_TPARAM_DEF2(d1, d2)
+# define ASIO_SVC_TARG
+// ASIO_SVC_T is defined at each point of use.
+# define ASIO_SVC_TPARAM1
+# define ASIO_SVC_TPARAM1_DEF1(d1)
+# define ASIO_SVC_TPARAM1_DEF2(d1, d2)
+# define ASIO_SVC_TARG1
+// ASIO_SVC_T1 is defined at each point of use.
+# define ASIO_SVC_ACCESS protected
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
+// Helper macros to manage transition away from error_code return values.
+#if defined(ASIO_NO_DEPRECATED)
+# define ASIO_SYNC_OP_VOID void
+# define ASIO_SYNC_OP_VOID_RETURN(e) return
+#else // defined(ASIO_NO_DEPRECATED)
+# define ASIO_SYNC_OP_VOID asio::error_code
+# define ASIO_SYNC_OP_VOID_RETURN(e) return e
+#endif // defined(ASIO_NO_DEPRECATED)
+
 #endif // ASIO_DETAIL_CONFIG_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/consuming_buffers.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/consuming_buffers.hpp
index 37c9ffa..e99ca67 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/consuming_buffers.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/consuming_buffers.hpp
@@ -2,7 +2,7 @@
 // detail/consuming_buffers.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,8 +17,8 @@
 
 #include "asio/detail/config.hpp"
 #include <cstddef>
-#include <iterator>
 #include "asio/buffer.hpp"
+#include "asio/detail/buffer_sequence_adapter.hpp"
 #include "asio/detail/limits.hpp"
 
 #include "asio/detail/push_options.hpp"
@@ -26,262 +26,362 @@
 namespace asio {
 namespace detail {
 
-// A proxy iterator for a sub-range in a list of buffers.
-template <typename Buffer, typename Buffer_Iterator>
-class consuming_buffers_iterator
-{
-public:
-  /// The type used for the distance between two iterators.
-  typedef std::ptrdiff_t difference_type;
 
-  /// The type of the value pointed to by the iterator.
+// A buffer sequence used to represent a subsequence of the buffers.
+template <typename Buffer>
+struct prepared_buffers
+{
   typedef Buffer value_type;
+  typedef const Buffer* const_iterator;
 
-  /// The type of the result of applying operator->() to the iterator.
-  typedef const Buffer* pointer;
+  enum
+  {
+    max_buffers = buffer_sequence_adapter_base::max_buffers < 8
+      ? buffer_sequence_adapter_base::max_buffers : 8
+  };
+
+  prepared_buffers() : count(0) {}
+  const_iterator begin() const { return elems; }
+  const_iterator end() const { return elems + count; }
 
-  /// The type of the result of applying operator*() to the iterator.
-  typedef const Buffer& reference;
+  Buffer elems[max_buffers];
+  std::size_t count;
+};
 
-  /// The iterator category.
-  typedef std::forward_iterator_tag iterator_category;
+// A proxy for a sub-range in a list of buffers.
+template <typename Buffer, typename Buffers, typename Buffer_Iterator>
+class consuming_buffers
+{
+public:
+  // Construct to represent the entire list of buffers.
+  explicit consuming_buffers(const Buffers& buffers)
+    : buffers_(buffers),
+      total_size_(asio::buffer_size(buffers)),
+      total_consumed_(0),
+      next_elem_(0),
+      next_elem_offset_(0)
+  {
+  }
 
-  // Default constructor creates an end iterator.
-  consuming_buffers_iterator()
-    : at_end_(true)
+  // Determine if we are at the end of the buffers.
+  bool empty() const
   {
+    return total_consumed_ >= total_size_;
   }
 
-  // Construct with a buffer for the first entry and an iterator
-  // range for the remaining entries.
-  consuming_buffers_iterator(bool at_end, const Buffer& first,
-      Buffer_Iterator begin_remainder, Buffer_Iterator end_remainder,
-      std::size_t max_size)
-    : at_end_(max_size > 0 ? at_end : true),
-      first_(buffer(first, max_size)),
-      begin_remainder_(begin_remainder),
-      end_remainder_(end_remainder),
-      offset_(0),
-      max_size_(max_size)
+  // Get the buffer for a single transfer, with a size.
+  prepared_buffers<Buffer> prepare(std::size_t max_size)
   {
+    prepared_buffers<Buffer> result;
+
+    Buffer_Iterator next = asio::buffer_sequence_begin(buffers_);
+    Buffer_Iterator end = asio::buffer_sequence_end(buffers_);
+
+    std::advance(next, next_elem_);
+    std::size_t elem_offset = next_elem_offset_;
+    while (next != end && max_size > 0 && result.count < result.max_buffers)
+    {
+      Buffer next_buf = Buffer(*next) + elem_offset;
+      result.elems[result.count] = asio::buffer(next_buf, max_size);
+      max_size -= result.elems[result.count].size();
+      elem_offset = 0;
+      if (result.elems[result.count].size() > 0)
+        ++result.count;
+      ++next;
+    }
+
+    return result;
+  }
+
+  // Consume the specified number of bytes from the buffers.
+  void consume(std::size_t size)
+  {
+    total_consumed_ += size;
+
+    Buffer_Iterator next = asio::buffer_sequence_begin(buffers_);
+    Buffer_Iterator end = asio::buffer_sequence_end(buffers_);
+
+    std::advance(end, next_elem_);
+    while (next != end && size > 0)
+    {
+      Buffer next_buf = Buffer(*next) + next_elem_offset_;
+      if (size < next_buf.size())
+      {
+        next_elem_offset_ += size;
+        size = 0;
+      }
+      else
+      {
+        size -= next_buf.size();
+        next_elem_offset_ = 0;
+        ++next_elem_;
+        ++next;
+      }
+    }
   }
 
-  // Dereference an iterator.
-  const Buffer& operator*() const
+  // Get the total number of bytes consumed from the buffers.
+  std::size_t total_consumed() const
   {
-    return dereference();
+    return total_consumed_;
   }
 
-  // Dereference an iterator.
-  const Buffer* operator->() const
+private:
+  Buffers buffers_;
+  std::size_t total_size_;
+  std::size_t total_consumed_;
+  std::size_t next_elem_;
+  std::size_t next_elem_offset_;
+};
+
+// Base class of all consuming_buffers specialisations for single buffers.
+template <typename Buffer>
+class consuming_single_buffer
+{
+public:
+  // Construct to represent the entire list of buffers.
+  template <typename Buffer1>
+  explicit consuming_single_buffer(const Buffer1& buffer)
+    : buffer_(buffer),
+      total_consumed_(0)
   {
-    return &dereference();
   }
 
-  // Increment operator (prefix).
-  consuming_buffers_iterator& operator++()
+  // Determine if we are at the end of the buffers.
+  bool empty() const
   {
-    increment();
-    return *this;
+    return total_consumed_ >= buffer_.size();
   }
 
-  // Increment operator (postfix).
-  consuming_buffers_iterator operator++(int)
+  // Get the buffer for a single transfer, with a size.
+  Buffer prepare(std::size_t max_size)
   {
-    consuming_buffers_iterator tmp(*this);
-    ++*this;
-    return tmp;
+    return asio::buffer(buffer_ + total_consumed_, max_size);
   }
 
-  // Test two iterators for equality.
-  friend bool operator==(const consuming_buffers_iterator& a,
-      const consuming_buffers_iterator& b)
+  // Consume the specified number of bytes from the buffers.
+  void consume(std::size_t size)
   {
-    return a.equal(b);
+    total_consumed_ += size;
   }
 
-  // Test two iterators for inequality.
-  friend bool operator!=(const consuming_buffers_iterator& a,
-      const consuming_buffers_iterator& b)
+  // Get the total number of bytes consumed from the buffers.
+  std::size_t total_consumed() const
   {
-    return !a.equal(b);
+    return total_consumed_;
   }
 
 private:
-  void increment()
+  Buffer buffer_;
+  std::size_t total_consumed_;
+};
+
+template <>
+class consuming_buffers<mutable_buffer, mutable_buffer, const mutable_buffer*>
+  : public consuming_single_buffer<ASIO_MUTABLE_BUFFER>
+{
+public:
+  explicit consuming_buffers(const mutable_buffer& buffer)
+    : consuming_single_buffer<ASIO_MUTABLE_BUFFER>(buffer)
+  {
+  }
+};
+
+template <>
+class consuming_buffers<const_buffer, mutable_buffer, const mutable_buffer*>
+  : public consuming_single_buffer<ASIO_CONST_BUFFER>
+{
+public:
+  explicit consuming_buffers(const mutable_buffer& buffer)
+    : consuming_single_buffer<ASIO_CONST_BUFFER>(buffer)
   {
-    if (!at_end_)
-    {
-      if (begin_remainder_ == end_remainder_
-          || offset_ + buffer_size(first_) >= max_size_)
-      {
-        at_end_ = true;
-      }
-      else
-      {
-        offset_ += buffer_size(first_);
-        first_ = buffer(*begin_remainder_++, max_size_ - offset_);
-      }
-    }
   }
+};
 
-  bool equal(const consuming_buffers_iterator& other) const
+template <>
+class consuming_buffers<const_buffer, const_buffer, const const_buffer*>
+  : public consuming_single_buffer<ASIO_CONST_BUFFER>
+{
+public:
+  explicit consuming_buffers(const const_buffer& buffer)
+    : consuming_single_buffer<ASIO_CONST_BUFFER>(buffer)
   {
-    if (at_end_ && other.at_end_)
-      return true;
-    return !at_end_ && !other.at_end_
-      && buffer_cast<const void*>(first_)
-        == buffer_cast<const void*>(other.first_)
-      && buffer_size(first_) == buffer_size(other.first_)
-      && begin_remainder_ == other.begin_remainder_
-      && end_remainder_ == other.end_remainder_;
   }
+};
 
-  const Buffer& dereference() const
+#if !defined(ASIO_NO_DEPRECATED)
+
+template <>
+class consuming_buffers<mutable_buffer,
+    mutable_buffers_1, const mutable_buffer*>
+  : public consuming_single_buffer<ASIO_MUTABLE_BUFFER>
+{
+public:
+  explicit consuming_buffers(const mutable_buffers_1& buffer)
+    : consuming_single_buffer<ASIO_MUTABLE_BUFFER>(buffer)
   {
-    return first_;
   }
+};
 
-  bool at_end_;
-  Buffer first_;
-  Buffer_Iterator begin_remainder_;
-  Buffer_Iterator end_remainder_;
-  std::size_t offset_;
-  std::size_t max_size_;
+template <>
+class consuming_buffers<const_buffer, mutable_buffers_1, const mutable_buffer*>
+  : public consuming_single_buffer<ASIO_CONST_BUFFER>
+{
+public:
+  explicit consuming_buffers(const mutable_buffers_1& buffer)
+    : consuming_single_buffer<ASIO_CONST_BUFFER>(buffer)
+  {
+  }
 };
 
-// A proxy for a sub-range in a list of buffers.
-template <typename Buffer, typename Buffers>
-class consuming_buffers
+template <>
+class consuming_buffers<const_buffer, const_buffers_1, const const_buffer*>
+  : public consuming_single_buffer<ASIO_CONST_BUFFER>
 {
 public:
-  // The type for each element in the list of buffers.
-  typedef Buffer value_type;
+  explicit consuming_buffers(const const_buffers_1& buffer)
+    : consuming_single_buffer<ASIO_CONST_BUFFER>(buffer)
+  {
+  }
+};
 
-  // A forward-only iterator type that may be used to read elements.
-  typedef consuming_buffers_iterator<Buffer, typename Buffers::const_iterator>
-    const_iterator;
+#endif // !defined(ASIO_NO_DEPRECATED)
 
+template <typename Buffer, typename Elem>
+class consuming_buffers<Buffer, boost::array<Elem, 2>,
+    typename boost::array<Elem, 2>::const_iterator>
+{
+public:
   // Construct to represent the entire list of buffers.
-  consuming_buffers(const Buffers& buffers)
+  explicit consuming_buffers(const boost::array<Elem, 2>& buffers)
     : buffers_(buffers),
-      at_end_(buffers_.begin() == buffers_.end()),
-      begin_remainder_(buffers_.begin()),
-      max_size_((std::numeric_limits<std::size_t>::max)())
+      total_consumed_(0)
   {
-    if (!at_end_)
-    {
-      first_ = *buffers_.begin();
-      ++begin_remainder_;
-    }
   }
 
-  // Copy constructor.
-  consuming_buffers(const consuming_buffers& other)
-    : buffers_(other.buffers_),
-      at_end_(other.at_end_),
-      first_(other.first_),
-      begin_remainder_(buffers_.begin()),
-      max_size_(other.max_size_)
-  {
-    typename Buffers::const_iterator first = other.buffers_.begin();
-    typename Buffers::const_iterator second = other.begin_remainder_;
-    std::advance(begin_remainder_, std::distance(first, second));
+  // Determine if we are at the end of the buffers.
+  bool empty() const
+  {
+    return total_consumed_ >=
+      Buffer(buffers_[0]).size() + Buffer(buffers_[1]).size();
+  }
+
+  // Get the buffer for a single transfer, with a size.
+  boost::array<Buffer, 2> prepare(std::size_t max_size)
+  {
+    boost::array<Buffer, 2> result = {{
+      Buffer(buffers_[0]), Buffer(buffers_[1]) }};
+    std::size_t buffer0_size = result[0].size();
+    result[0] = asio::buffer(result[0] + total_consumed_, max_size);
+    result[1] = asio::buffer(
+        result[1] + (total_consumed_ < buffer0_size
+          ? 0 : total_consumed_ - buffer0_size),
+        max_size - result[0].size());
+    return result;
+  }
+
+  // Consume the specified number of bytes from the buffers.
+  void consume(std::size_t size)
+  {
+    total_consumed_ += size;
   }
 
-  // Assignment operator.
-  consuming_buffers& operator=(const consuming_buffers& other)
-  {
-    buffers_ = other.buffers_;
-    at_end_ = other.at_end_;
-    first_ = other.first_;
-    begin_remainder_ = buffers_.begin();
-    typename Buffers::const_iterator first = other.buffers_.begin();
-    typename Buffers::const_iterator second = other.begin_remainder_;
-    std::advance(begin_remainder_, std::distance(first, second));
-    max_size_ = other.max_size_;
-    return *this;
+  // Get the total number of bytes consumed from the buffers.
+  std::size_t total_consumed() const
+  {
+    return total_consumed_;
   }
 
-  // Get a forward-only iterator to the first element.
-  const_iterator begin() const
+private:
+  boost::array<Elem, 2> buffers_;
+  std::size_t total_consumed_;
+};
+
+#if defined(ASIO_HAS_STD_ARRAY)
+
+template <typename Buffer, typename Elem>
+class consuming_buffers<Buffer, std::array<Elem, 2>,
+    typename std::array<Elem, 2>::const_iterator>
+{
+public:
+  // Construct to represent the entire list of buffers.
+  explicit consuming_buffers(const std::array<Elem, 2>& buffers)
+    : buffers_(buffers),
+      total_consumed_(0)
   {
-    return const_iterator(at_end_, first_,
-        begin_remainder_, buffers_.end(), max_size_);
   }
 
-  // Get a forward-only iterator for one past the last element.
-  const_iterator end() const
+  // Determine if we are at the end of the buffers.
+  bool empty() const
   {
-    return const_iterator();
+    return total_consumed_ >=
+      Buffer(buffers_[0]).size() + Buffer(buffers_[1]).size();
   }
 
-  // Set the maximum size for a single transfer.
-  void prepare(std::size_t max_size)
+  // Get the buffer for a single transfer, with a size.
+  std::array<Buffer, 2> prepare(std::size_t max_size)
   {
-    max_size_ = max_size;
+    std::array<Buffer, 2> result = {{
+      Buffer(buffers_[0]), Buffer(buffers_[1]) }};
+    std::size_t buffer0_size = result[0].size();
+    result[0] = asio::buffer(result[0] + total_consumed_, max_size);
+    result[1] = asio::buffer(
+        result[1] + (total_consumed_ < buffer0_size
+          ? 0 : total_consumed_ - buffer0_size),
+        max_size - result[0].size());
+    return result;
   }
 
   // Consume the specified number of bytes from the buffers.
   void consume(std::size_t size)
   {
-    // Remove buffers from the start until the specified size is reached.
-    while (size > 0 && !at_end_)
-    {
-      if (buffer_size(first_) <= size)
-      {
-        size -= buffer_size(first_);
-        if (begin_remainder_ == buffers_.end())
-          at_end_ = true;
-        else
-          first_ = *begin_remainder_++;
-      }
-      else
-      {
-        first_ = first_ + size;
-        size = 0;
-      }
-    }
+    total_consumed_ += size;
+  }
 
-    // Remove any more empty buffers at the start.
-    while (!at_end_ && buffer_size(first_) == 0)
-    {
-      if (begin_remainder_ == buffers_.end())
-        at_end_ = true;
-      else
-        first_ = *begin_remainder_++;
-    }
+  // Get the total number of bytes consumed from the buffers.
+  std::size_t total_consumed() const
+  {
+    return total_consumed_;
   }
 
 private:
-  Buffers buffers_;
-  bool at_end_;
-  Buffer first_;
-  typename Buffers::const_iterator begin_remainder_;
-  std::size_t max_size_;
+  std::array<Elem, 2> buffers_;
+  std::size_t total_consumed_;
 };
 
+#endif // defined(ASIO_HAS_STD_ARRAY)
+
 // Specialisation for null_buffers to ensure that the null_buffers type is
 // always passed through to the underlying read or write operation.
 template <typename Buffer>
-class consuming_buffers<Buffer, asio::null_buffers>
+class consuming_buffers<Buffer, null_buffers, const mutable_buffer*>
   : public asio::null_buffers
 {
 public:
-  consuming_buffers(const asio::null_buffers&)
+  consuming_buffers(const null_buffers&)
   {
     // No-op.
   }
 
-  void prepare(std::size_t)
+  bool empty()
   {
-    // No-op.
+    return false;
+  }
+
+  null_buffers prepare(std::size_t)
+  {
+    return null_buffers();
   }
 
   void consume(std::size_t)
   {
     // No-op.
   }
+
+  std::size_t total_consume() const
+  {
+    return 0;
+  }
 };
 
 } // namespace detail
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/cstddef.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/cstddef.hpp
index f784247..a5092ce 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/cstddef.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/cstddef.hpp
@@ -2,7 +2,7 @@
 // detail/cstddef.hpp
 // ~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/cstdint.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/cstdint.hpp
index e3ee84c..2c06414 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/cstdint.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/cstdint.hpp
@@ -2,7 +2,7 @@
 // detail/cstdint.hpp
 // ~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -27,18 +27,32 @@ namespace asio {
 
 #if defined(ASIO_HAS_CSTDINT)
 using std::int16_t;
+using std::int_least16_t;
 using std::uint16_t;
+using std::uint_least16_t;
 using std::int32_t;
+using std::int_least32_t;
 using std::uint32_t;
+using std::uint_least32_t;
 using std::int64_t;
+using std::int_least64_t;
 using std::uint64_t;
+using std::uint_least64_t;
+using std::uintmax_t;
 #else // defined(ASIO_HAS_CSTDINT)
 using boost::int16_t;
+using boost::int_least16_t;
 using boost::uint16_t;
+using boost::uint_least16_t;
 using boost::int32_t;
+using boost::int_least32_t;
 using boost::uint32_t;
+using boost::uint_least32_t;
 using boost::int64_t;
+using boost::int_least64_t;
 using boost::uint64_t;
+using boost::uint_least64_t;
+using boost::uintmax_t;
 #endif // defined(ASIO_HAS_CSTDINT)
 
 } // namespace asio
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/date_time_fwd.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/date_time_fwd.hpp
index 74e33a9..918bb7b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/date_time_fwd.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/date_time_fwd.hpp
@@ -2,7 +2,7 @@
 // detail/date_time_fwd.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/deadline_timer_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/deadline_timer_service.hpp
index 0e4a2ec..816f16f 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/deadline_timer_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/deadline_timer_service.hpp
@@ -2,7 +2,7 @@
 // detail/deadline_timer_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -18,7 +18,7 @@
 #include "asio/detail/config.hpp"
 #include <cstddef>
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/detail/bind_handler.hpp"
 #include "asio/detail/fenced_block.hpp"
 #include "asio/detail/memory.hpp"
@@ -26,6 +26,7 @@
 #include "asio/detail/socket_ops.hpp"
 #include "asio/detail/socket_types.hpp"
 #include "asio/detail/timer_queue.hpp"
+#include "asio/detail/timer_queue_ptime.hpp"
 #include "asio/detail/timer_scheduler.hpp"
 #include "asio/detail/wait_handler.hpp"
 #include "asio/detail/wait_op.hpp"
@@ -42,6 +43,7 @@ namespace detail {
 
 template <typename Time_Traits>
 class deadline_timer_service
+  : public service_base<deadline_timer_service<Time_Traits> >
 {
 public:
   // The time type.
@@ -61,8 +63,9 @@ public:
   };
 
   // Constructor.
-  deadline_timer_service(asio::io_service& io_service)
-    : scheduler_(asio::use_service<timer_scheduler>(io_service))
+  deadline_timer_service(asio::io_context& io_context)
+    : service_base<deadline_timer_service<Time_Traits> >(io_context),
+      scheduler_(asio::use_service<timer_scheduler>(io_context))
   {
     scheduler_.init_task();
     scheduler_.add_timer_queue(timer_queue_);
@@ -75,7 +78,7 @@ public:
   }
 
   // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
+  void shutdown()
   {
   }
 
@@ -134,7 +137,8 @@ public:
       return 0;
     }
 
-    ASIO_HANDLER_OPERATION(("deadline_timer", &impl, "cancel"));
+    ASIO_HANDLER_OPERATION((scheduler_.context(),
+          "deadline_timer", &impl, 0, "cancel"));
 
     std::size_t count = scheduler_.cancel_timer(timer_queue_, impl.timer_data);
     impl.might_have_pending_waits = false;
@@ -152,7 +156,8 @@ public:
       return 0;
     }
 
-    ASIO_HANDLER_OPERATION(("deadline_timer", &impl, "cancel_one"));
+    ASIO_HANDLER_OPERATION((scheduler_.context(),
+          "deadline_timer", &impl, 0, "cancel_one"));
 
     std::size_t count = scheduler_.cancel_timer(
         timer_queue_, impl.timer_data, 1);
@@ -168,6 +173,18 @@ public:
     return impl.expiry;
   }
 
+  // Get the expiry time for the timer as an absolute time.
+  time_type expires_at(const implementation_type& impl) const
+  {
+    return impl.expiry;
+  }
+
+  // Get the expiry time for the timer relative to now.
+  duration_type expires_from_now(const implementation_type& impl) const
+  {
+    return Time_Traits::subtract(this->expiry(impl), Time_Traits::now());
+  }
+
   // Set the expiry time for the timer as an absolute time.
   std::size_t expires_at(implementation_type& impl,
       const time_type& expiry_time, asio::error_code& ec)
@@ -186,6 +203,14 @@ public:
         Time_Traits::add(Time_Traits::now(), expiry_time), ec);
   }
 
+  // Set the expiry time for the timer relative to now.
+  std::size_t expires_from_now(implementation_type& impl,
+      const duration_type& expiry_time, asio::error_code& ec)
+  {
+    return expires_at(impl,
+        Time_Traits::add(Time_Traits::now(), expiry_time), ec);
+  }
+
   // Perform a blocking wait on the timer.
   void wait(implementation_type& impl, asio::error_code& ec)
   {
@@ -211,7 +236,8 @@ public:
 
     impl.might_have_pending_waits = true;
 
-    ASIO_HANDLER_CREATION((p.p, "deadline_timer", &impl, "async_wait"));
+    ASIO_HANDLER_CREATION((scheduler_.context(),
+          *p.p, "deadline_timer", &impl, 0, "async_wait"));
 
     scheduler_.schedule_timer(timer_queue_, impl.expiry, impl.timer_data, p.p);
     p.v = p.p = 0;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/dependent_type.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/dependent_type.hpp
index abb4817..a4737e2 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/dependent_type.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/dependent_type.hpp
@@ -2,7 +2,7 @@
 // detail/dependent_type.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/descriptor_ops.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/descriptor_ops.hpp
index a620ec1..677f010 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/descriptor_ops.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/descriptor_ops.hpp
@@ -2,7 +2,7 @@
 // detail/descriptor_ops.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -22,6 +22,7 @@
   && !defined(__CYGWIN__)
 
 #include <cstddef>
+#include "asio/error.hpp"
 #include "asio/error_code.hpp"
 #include "asio/detail/socket_types.hpp"
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/descriptor_read_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/descriptor_read_op.hpp
index 80178c4..f1027b0 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/descriptor_read_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/descriptor_read_op.hpp
@@ -2,7 +2,7 @@
 // detail/descriptor_read_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -44,15 +44,21 @@ public:
   {
   }
 
-  static bool do_perform(reactor_op* base)
+  static status do_perform(reactor_op* base)
   {
     descriptor_read_op_base* o(static_cast<descriptor_read_op_base*>(base));
 
     buffer_sequence_adapter<asio::mutable_buffer,
         MutableBufferSequence> bufs(o->buffers_);
 
-    return descriptor_ops::non_blocking_read(o->descriptor_,
-        bufs.buffers(), bufs.count(), o->ec_, o->bytes_transferred_);
+    status result = descriptor_ops::non_blocking_read(o->descriptor_,
+        bufs.buffers(), bufs.count(), o->ec_, o->bytes_transferred_)
+      ? done : not_done;
+
+    ASIO_HANDLER_REACTOR_OPERATION((*o, "non_blocking_read",
+          o->ec_, o->bytes_transferred_));
+
+    return result;
   }
 
 private:
@@ -85,7 +91,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
     // Make a copy of the handler so that the memory can be deallocated before
     // the upcall is made. Even if we're not about to make an upcall, a
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/descriptor_write_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/descriptor_write_op.hpp
index c49064a..96d6e5b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/descriptor_write_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/descriptor_write_op.hpp
@@ -2,7 +2,7 @@
 // detail/descriptor_write_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -44,15 +44,21 @@ public:
   {
   }
 
-  static bool do_perform(reactor_op* base)
+  static status do_perform(reactor_op* base)
   {
     descriptor_write_op_base* o(static_cast<descriptor_write_op_base*>(base));
 
     buffer_sequence_adapter<asio::const_buffer,
         ConstBufferSequence> bufs(o->buffers_);
 
-    return descriptor_ops::non_blocking_write(o->descriptor_,
-        bufs.buffers(), bufs.count(), o->ec_, o->bytes_transferred_);
+    status result = descriptor_ops::non_blocking_write(o->descriptor_,
+        bufs.buffers(), bufs.count(), o->ec_, o->bytes_transferred_)
+      ? done : not_done;
+
+    ASIO_HANDLER_REACTOR_OPERATION((*o, "non_blocking_write",
+          o->ec_, o->bytes_transferred_));
+
+    return result;
   }
 
 private:
@@ -85,7 +91,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
     // Make a copy of the handler so that the memory can be deallocated before
     // the upcall is made. Even if we're not about to make an upcall, a
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/dev_poll_reactor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/dev_poll_reactor.hpp
index e523011..1f59cf3 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/dev_poll_reactor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/dev_poll_reactor.hpp
@@ -2,7 +2,7 @@
 // detail/dev_poll_reactor.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -59,10 +59,10 @@ public:
   ASIO_DECL ~dev_poll_reactor();
 
   // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
+  ASIO_DECL void shutdown();
 
   // Recreate internal descriptors following a fork.
-  ASIO_DECL void fork_service(
+  ASIO_DECL void notify_fork(
       asio::execution_context::fork_event fork_ev);
 
   // Initialise the task.
@@ -158,7 +158,7 @@ private:
   // Get the timeout value for the /dev/poll DP_POLL operation. The timeout
   // value is returned as a number of milliseconds. A return value of -1
   // indicates that the poll should block indefinitely.
-  ASIO_DECL int get_timeout();
+  ASIO_DECL int get_timeout(int msec);
 
   // Cancel all operations associated with the given descriptor. The do_cancel
   // function of the handler objects will be invoked. This function does not
@@ -166,10 +166,6 @@ private:
   ASIO_DECL void cancel_ops_unlocked(socket_type descriptor,
       const asio::error_code& ec);
 
-  // Helper class used to reregister descriptors after a fork.
-  class fork_helper;
-  friend class fork_helper;
-
   // Add a pending event entry for the given descriptor.
   ASIO_DECL ::pollfd& add_pending_event_change(int descriptor);
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/epoll_reactor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/epoll_reactor.hpp
index 11a0a4e..ba8b2a1 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/epoll_reactor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/epoll_reactor.hpp
@@ -2,7 +2,7 @@
 // detail/epoll_reactor.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -20,8 +20,8 @@
 #if defined(ASIO_HAS_EPOLL)
 
 #include "asio/detail/atomic_count.hpp"
+#include "asio/detail/conditionally_enabled_mutex.hpp"
 #include "asio/detail/limits.hpp"
-#include "asio/detail/mutex.hpp"
 #include "asio/detail/object_pool.hpp"
 #include "asio/detail/op_queue.hpp"
 #include "asio/detail/reactor_op.hpp"
@@ -40,6 +40,10 @@ namespace detail {
 class epoll_reactor
   : public execution_context_service_base<epoll_reactor>
 {
+private:
+  // The mutex type used by this reactor.
+  typedef conditionally_enabled_mutex mutex;
+
 public:
   enum op_types { read_op = 0, write_op = 1,
     connect_op = 1, except_op = 2, max_ops = 3 };
@@ -58,9 +62,10 @@ public:
     int descriptor_;
     uint32_t registered_events_;
     op_queue<reactor_op> op_queue_[max_ops];
+    bool try_speculative_[max_ops];
     bool shutdown_;
 
-    ASIO_DECL descriptor_state();
+    ASIO_DECL descriptor_state(bool locking);
     void set_ready_events(uint32_t events) { task_result_ = events; }
     ASIO_DECL operation* perform_io(uint32_t events);
     ASIO_DECL static void do_complete(
@@ -78,10 +83,10 @@ public:
   ASIO_DECL ~epoll_reactor();
 
   // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
+  ASIO_DECL void shutdown();
 
   // Recreate internal descriptors following a fork.
-  ASIO_DECL void fork_service(
+  ASIO_DECL void notify_fork(
       asio::execution_context::fork_event fork_ev);
 
   // Initialise the task.
@@ -159,7 +164,7 @@ public:
       typename timer_queue<Time_Traits>::per_timer_data& source);
 
   // Run epoll once until interrupted or events are ready to be dispatched.
-  ASIO_DECL void run(bool block, op_queue<operation>& ops);
+  ASIO_DECL void run(long usec, op_queue<operation>& ops);
 
   // Interrupt the select loop.
   ASIO_DECL void interrupt();
@@ -193,7 +198,7 @@ private:
   // Get the timeout value for the epoll_wait call. The timeout value is
   // returned as a number of milliseconds. A return value of -1 indicates
   // that epoll_wait should block indefinitely.
-  ASIO_DECL int get_timeout();
+  ASIO_DECL int get_timeout(int msec);
 
 #if defined(ASIO_HAS_TIMERFD)
   // Get the timeout value for the timer descriptor. The return value is the
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/event.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/event.hpp
index 2f6934c..bb07fcd 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/event.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/event.hpp
@@ -2,7 +2,7 @@
 // detail/event.hpp
 // ~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/eventfd_select_interrupter.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/eventfd_select_interrupter.hpp
index daa4389..fcc8663 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/eventfd_select_interrupter.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/eventfd_select_interrupter.hpp
@@ -2,7 +2,7 @@
 // detail/eventfd_select_interrupter.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2008 Roelof Naude (roelof.naude at gmail dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/executor_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/executor_op.hpp
index eb7c094..3145130 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/executor_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/executor_op.hpp
@@ -2,7 +2,7 @@
 // detail/executor_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -48,7 +48,7 @@ public:
     executor_op* o(static_cast<executor_op*>(base));
     ptr p = { o->allocator_, o, o };
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
     // Make a copy of the handler so that the memory can be deallocated before
     // the upcall is made. Even if we're not about to make an upcall, a
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/fd_set_adapter.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/fd_set_adapter.hpp
index 661f145..44c4c46 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/fd_set_adapter.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/fd_set_adapter.hpp
@@ -2,7 +2,7 @@
 // detail/fd_set_adapter.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/fenced_block.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/fenced_block.hpp
index 6b5a60e..c07c85f 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/fenced_block.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/fenced_block.hpp
@@ -2,7 +2,7 @@
 // detail/fenced_block.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/functional.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/functional.hpp
index caf0659..a72a5fc 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/functional.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/functional.hpp
@@ -2,7 +2,7 @@
 // detail/functional.hpp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/gcc_arm_fenced_block.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/gcc_arm_fenced_block.hpp
index f60f4e4..debdd3c 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/gcc_arm_fenced_block.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/gcc_arm_fenced_block.hpp
@@ -2,7 +2,7 @@
 // detail/gcc_arm_fenced_block.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/gcc_hppa_fenced_block.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/gcc_hppa_fenced_block.hpp
index 22f018e..cd41eb2 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/gcc_hppa_fenced_block.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/gcc_hppa_fenced_block.hpp
@@ -2,7 +2,7 @@
 // detail/gcc_hppa_fenced_block.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/gcc_sync_fenced_block.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/gcc_sync_fenced_block.hpp
index c2c12fe..1933099 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/gcc_sync_fenced_block.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/gcc_sync_fenced_block.hpp
@@ -2,7 +2,7 @@
 // detail/gcc_sync_fenced_block.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/gcc_x86_fenced_block.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/gcc_x86_fenced_block.hpp
index a8b38fa..0ec66c5 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/gcc_x86_fenced_block.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/gcc_x86_fenced_block.hpp
@@ -2,7 +2,7 @@
 // detail/gcc_x86_fenced_block.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/global.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/global.hpp
index ab1b4f5..87c57a0 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/global.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/global.hpp
@@ -2,7 +2,7 @@
 // detail/global.hpp
 // ~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_alloc_helpers.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_alloc_helpers.hpp
index 704b760..0658b98 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_alloc_helpers.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_alloc_helpers.hpp
@@ -2,7 +2,7 @@
 // detail/handler_alloc_helpers.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_cont_helpers.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_cont_helpers.hpp
index ef95de3..defdf26 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_cont_helpers.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_cont_helpers.hpp
@@ -2,7 +2,7 @@
 // detail/handler_cont_helpers.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_invoke_helpers.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_invoke_helpers.hpp
index d1b743d..91325ee 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_invoke_helpers.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_invoke_helpers.hpp
@@ -2,7 +2,7 @@
 // detail/handler_invoke_helpers.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_tracking.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_tracking.hpp
index 14e8177..6ea19a3 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_tracking.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_tracking.hpp
@@ -2,7 +2,7 @@
 // detail/handler_tracking.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,7 +17,15 @@
 
 #include "asio/detail/config.hpp"
 
-#if defined(ASIO_ENABLE_HANDLER_TRACKING)
+namespace asio {
+
+class execution_context;
+
+} // namespace asio
+
+#if defined(ASIO_CUSTOM_HANDLER_TRACKING)
+# include ASIO_CUSTOM_HANDLER_TRACKING
+#elif defined(ASIO_ENABLE_HANDLER_TRACKING)
 # include "asio/error_code.hpp"
 # include "asio/detail/cstdint.hpp"
 # include "asio/detail/static_mutex.hpp"
@@ -29,7 +37,30 @@
 namespace asio {
 namespace detail {
 
-#if defined(ASIO_ENABLE_HANDLER_TRACKING)
+#if defined(ASIO_CUSTOM_HANDLER_TRACKING)
+
+// The user-specified header must define the following macros:
+// - ASIO_INHERIT_TRACKED_HANDLER
+// - ASIO_ALSO_INHERIT_TRACKED_HANDLER
+// - ASIO_HANDLER_TRACKING_INIT
+// - ASIO_HANDLER_CREATION(args)
+// - ASIO_HANDLER_COMPLETION(args)
+// - ASIO_HANDLER_INVOCATION_BEGIN(args)
+// - ASIO_HANDLER_INVOCATION_END
+// - ASIO_HANDLER_OPERATION(args)
+// - ASIO_HANDLER_REACTOR_REGISTRATION(args)
+// - ASIO_HANDLER_REACTOR_DEREGISTRATION(args)
+// - ASIO_HANDLER_REACTOR_READ_EVENT
+// - ASIO_HANDLER_REACTOR_WRITE_EVENT
+// - ASIO_HANDLER_REACTOR_ERROR_EVENT
+// - ASIO_HANDLER_REACTOR_EVENTS(args)
+// - ASIO_HANDLER_REACTOR_OPERATION(args)
+
+# if !defined(ASIO_ENABLE_HANDLER_TRACKING)
+#  define ASIO_ENABLE_HANDLER_TRACKING 1
+# endif /// !defined(ASIO_ENABLE_HANDLER_TRACKING)
+
+#elif defined(ASIO_ENABLE_HANDLER_TRACKING)
 
 class handler_tracking
 {
@@ -57,14 +88,16 @@ public:
   ASIO_DECL static void init();
 
   // Record the creation of a tracked handler.
-  ASIO_DECL static void creation(tracked_handler* h,
-      const char* object_type, void* object, const char* op_name);
+  ASIO_DECL static void creation(
+      execution_context& context, tracked_handler& h,
+      const char* object_type, void* object,
+      uintmax_t native_handle, const char* op_name);
 
   class completion
   {
   public:
     // Constructor records that handler is to be invoked with no arguments.
-    ASIO_DECL explicit completion(tracked_handler* h);
+    ASIO_DECL explicit completion(const tracked_handler& h);
 
     // Destructor records only when an exception is thrown from the handler, or
     // if the memory is being freed without the handler having been invoked.
@@ -98,9 +131,32 @@ public:
     completion* next_;
   };
 
-  // Record an operation that affects pending handlers.
-  ASIO_DECL static void operation(const char* object_type,
-      void* object, const char* op_name);
+  // Record an operation that is not directly associated with a handler.
+  ASIO_DECL static void operation(execution_context& context,
+      const char* object_type, void* object,
+      uintmax_t native_handle, const char* op_name);
+
+  // Record that a descriptor has been registered with the reactor.
+  ASIO_DECL static void reactor_registration(execution_context& context,
+      uintmax_t native_handle, uintmax_t registration);
+
+  // Record that a descriptor has been deregistered from the reactor.
+  ASIO_DECL static void reactor_deregistration(execution_context& context,
+      uintmax_t native_handle, uintmax_t registration);
+
+  // Record a reactor-based operation that is associated with a handler.
+  ASIO_DECL static void reactor_events(execution_context& context,
+      uintmax_t registration, unsigned events);
+
+  // Record a reactor-based operation that is associated with a handler.
+  ASIO_DECL static void reactor_operation(
+      const tracked_handler& h, const char* op_name,
+      const asio::error_code& ec);
+
+  // Record a reactor-based operation that is associated with a handler.
+  ASIO_DECL static void reactor_operation(
+      const tracked_handler& h, const char* op_name,
+      const asio::error_code& ec, std::size_t bytes_transferred);
 
   // Write a line of output.
   ASIO_DECL static void write_line(const char* format, ...);
@@ -134,6 +190,22 @@ private:
 # define ASIO_HANDLER_OPERATION(args) \
   asio::detail::handler_tracking::operation args
 
+# define ASIO_HANDLER_REACTOR_REGISTRATION(args) \
+  asio::detail::handler_tracking::reactor_registration args
+
+# define ASIO_HANDLER_REACTOR_DEREGISTRATION(args) \
+  asio::detail::handler_tracking::reactor_deregistration args
+
+# define ASIO_HANDLER_REACTOR_READ_EVENT 1
+# define ASIO_HANDLER_REACTOR_WRITE_EVENT 2
+# define ASIO_HANDLER_REACTOR_ERROR_EVENT 4
+
+# define ASIO_HANDLER_REACTOR_EVENTS(args) \
+  asio::detail::handler_tracking::reactor_events args
+
+# define ASIO_HANDLER_REACTOR_OPERATION(args) \
+  asio::detail::handler_tracking::reactor_operation args
+
 #else // defined(ASIO_ENABLE_HANDLER_TRACKING)
 
 # define ASIO_INHERIT_TRACKED_HANDLER
@@ -144,6 +216,13 @@ private:
 # define ASIO_HANDLER_INVOCATION_BEGIN(args) (void)0
 # define ASIO_HANDLER_INVOCATION_END (void)0
 # define ASIO_HANDLER_OPERATION(args) (void)0
+# define ASIO_HANDLER_REACTOR_REGISTRATION(args) (void)0
+# define ASIO_HANDLER_REACTOR_DEREGISTRATION(args) (void)0
+# define ASIO_HANDLER_REACTOR_READ_EVENT 0
+# define ASIO_HANDLER_REACTOR_WRITE_EVENT 0
+# define ASIO_HANDLER_REACTOR_ERROR_EVENT 0
+# define ASIO_HANDLER_REACTOR_EVENTS(args) (void)0
+# define ASIO_HANDLER_REACTOR_OPERATION(args) (void)0
 
 #endif // defined(ASIO_ENABLE_HANDLER_TRACKING)
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_type_requirements.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_type_requirements.hpp
index 8026278..aaa473d 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_type_requirements.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_type_requirements.hpp
@@ -2,7 +2,7 @@
 // detail/handler_type_requirements.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -50,11 +50,13 @@
 #endif // !defined(ASIO_DISABLE_HANDLER_TYPE_REQUIREMENTS)
 
 #if defined(ASIO_ENABLE_HANDLER_TYPE_REQUIREMENTS)
-# include "asio/handler_type.hpp"
+# include "asio/async_result.hpp"
 #endif // defined(ASIO_ENABLE_HANDLER_TYPE_REQUIREMENTS)
 
-// Newer gcc needs special treatment to suppress unused typedef warnings.
-#if defined(__GNUC__)
+// Newer gcc, clang need special treatment to suppress unused typedef warnings.
+#if defined(__clang__) && (__clang_major__ >= 7)
+# define ASIO_UNUSED_TYPEDEF __attribute__((__unused__))
+#elif defined(__GNUC__)
 # if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4)
 #  define ASIO_UNUSED_TYPEDEF __attribute__((__unused__))
 # endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4)
@@ -100,6 +102,16 @@ auto two_arg_handler_test(Handler h, Arg1* a1, Arg2* a2)
 template <typename Handler>
 char (&two_arg_handler_test(Handler, ...))[2];
 
+template <typename Handler, typename Arg1, typename Arg2>
+auto two_arg_move_handler_test(Handler h, Arg1* a1, Arg2* a2)
+  -> decltype(
+    sizeof(Handler(ASIO_MOVE_CAST(Handler)(h))),
+    ((h)(*a1, ASIO_MOVE_CAST(Arg2)(*a2))),
+    char(0));
+
+template <typename Handler>
+char (&two_arg_move_handler_test(Handler, ...))[2];
+
 #  define ASIO_HANDLER_TYPE_REQUIREMENTS_ASSERT(expr, msg) \
      static_assert(expr, msg);
 
@@ -228,6 +240,33 @@ struct handler_type_requirements
             asio::detail::lvref<const asio::error_code>()), \
         char(0))> ASIO_UNUSED_TYPEDEF
 
+#define ASIO_MOVE_ACCEPT_HANDLER_CHECK( \
+    handler_type, handler, socket_type) \
+  \
+  typedef ASIO_HANDLER_TYPE(handler_type, \
+      void(asio::error_code, socket_type)) \
+    asio_true_handler_type; \
+  \
+  ASIO_HANDLER_TYPE_REQUIREMENTS_ASSERT( \
+      sizeof(asio::detail::two_arg_move_handler_test( \
+          asio::detail::rvref< \
+            asio_true_handler_type>(), \
+          static_cast<const asio::error_code*>(0), \
+          static_cast<socket_type*>(0))) == 1, \
+      "MoveAcceptHandler type requirements not met") \
+  \
+  typedef asio::detail::handler_type_requirements< \
+      sizeof( \
+        asio::detail::argbyv( \
+          asio::detail::rvref< \
+            asio_true_handler_type>())) + \
+      sizeof( \
+        asio::detail::lvref< \
+          asio_true_handler_type>()( \
+            asio::detail::lvref<const asio::error_code>(), \
+            asio::detail::rvref<socket_type>()), \
+        char(0))> ASIO_UNUSED_TYPEDEF
+
 #define ASIO_CONNECT_HANDLER_CHECK( \
     handler_type, handler) \
   \
@@ -253,7 +292,34 @@ struct handler_type_requirements
             asio::detail::lvref<const asio::error_code>()), \
         char(0))> ASIO_UNUSED_TYPEDEF
 
-#define ASIO_COMPOSED_CONNECT_HANDLER_CHECK( \
+#define ASIO_RANGE_CONNECT_HANDLER_CHECK( \
+    handler_type, handler, endpoint_type) \
+  \
+  typedef ASIO_HANDLER_TYPE(handler_type, \
+      void(asio::error_code, endpoint_type)) \
+    asio_true_handler_type; \
+  \
+  ASIO_HANDLER_TYPE_REQUIREMENTS_ASSERT( \
+      sizeof(asio::detail::two_arg_handler_test( \
+          asio::detail::rvref< \
+            asio_true_handler_type>(), \
+          static_cast<const asio::error_code*>(0), \
+          static_cast<const endpoint_type*>(0))) == 1, \
+      "RangeConnectHandler type requirements not met") \
+  \
+  typedef asio::detail::handler_type_requirements< \
+      sizeof( \
+        asio::detail::argbyv( \
+          asio::detail::rvref< \
+            asio_true_handler_type>())) + \
+      sizeof( \
+        asio::detail::lvref< \
+          asio_true_handler_type>()( \
+            asio::detail::lvref<const asio::error_code>(), \
+            asio::detail::lvref<const endpoint_type>()), \
+        char(0))> ASIO_UNUSED_TYPEDEF
+
+#define ASIO_ITERATOR_CONNECT_HANDLER_CHECK( \
     handler_type, handler, iter_type) \
   \
   typedef ASIO_HANDLER_TYPE(handler_type, \
@@ -266,7 +332,7 @@ struct handler_type_requirements
             asio_true_handler_type>(), \
           static_cast<const asio::error_code*>(0), \
           static_cast<const iter_type*>(0))) == 1, \
-      "ComposedConnectHandler type requirements not met") \
+      "IteratorConnectHandler type requirements not met") \
   \
   typedef asio::detail::handler_type_requirements< \
       sizeof( \
@@ -281,10 +347,10 @@ struct handler_type_requirements
         char(0))> ASIO_UNUSED_TYPEDEF
 
 #define ASIO_RESOLVE_HANDLER_CHECK( \
-    handler_type, handler, iter_type) \
+    handler_type, handler, range_type) \
   \
   typedef ASIO_HANDLER_TYPE(handler_type, \
-      void(asio::error_code, iter_type)) \
+      void(asio::error_code, range_type)) \
     asio_true_handler_type; \
   \
   ASIO_HANDLER_TYPE_REQUIREMENTS_ASSERT( \
@@ -292,7 +358,7 @@ struct handler_type_requirements
           asio::detail::rvref< \
             asio_true_handler_type>(), \
           static_cast<const asio::error_code*>(0), \
-          static_cast<const iter_type*>(0))) == 1, \
+          static_cast<const range_type*>(0))) == 1, \
       "ResolveHandler type requirements not met") \
   \
   typedef asio::detail::handler_type_requirements< \
@@ -304,7 +370,7 @@ struct handler_type_requirements
         asio::detail::lvref< \
           asio_true_handler_type>()( \
             asio::detail::lvref<const asio::error_code>(), \
-            asio::detail::lvref<const iter_type>()), \
+            asio::detail::lvref<const range_type>()), \
         char(0))> ASIO_UNUSED_TYPEDEF
 
 #define ASIO_WAIT_HANDLER_CHECK( \
@@ -458,7 +524,11 @@ struct handler_type_requirements
     handler_type, handler) \
   typedef int ASIO_UNUSED_TYPEDEF
 
-#define ASIO_COMPOSED_CONNECT_HANDLER_CHECK( \
+#define ASIO_RANGE_CONNECT_HANDLER_CHECK( \
+    handler_type, handler, iter_type) \
+  typedef int ASIO_UNUSED_TYPEDEF
+
+#define ASIO_ITERATOR_CONNECT_HANDLER_CHECK( \
     handler_type, handler, iter_type) \
   typedef int ASIO_UNUSED_TYPEDEF
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_work.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_work.hpp
index 90828dc..327c552 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_work.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/handler_work.hpp
@@ -2,7 +2,7 @@
 // detail/handler_work.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/hash_map.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/hash_map.hpp
index e11b542..8c52edc 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/hash_map.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/hash_map.hpp
@@ -2,7 +2,7 @@
 // detail/hash_map.hpp
 // ~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -243,15 +243,15 @@ private:
   {
     if (num_buckets == num_buckets_)
       return;
-    num_buckets_ = num_buckets;
-    ASIO_ASSERT(num_buckets_ != 0);
+    ASIO_ASSERT(num_buckets != 0);
 
     iterator end_iter = values_.end();
 
     // Update number of buckets and initialise all buckets to empty.
-    bucket_type* tmp = new bucket_type[num_buckets_];
+    bucket_type* tmp = new bucket_type[num_buckets];
     delete[] buckets_;
     buckets_ = tmp;
+    num_buckets_ = num_buckets;
     for (std::size_t i = 0; i < num_buckets_; ++i)
       buckets_[i].first = buckets_[i].last = end_iter;
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/buffer_sequence_adapter.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/buffer_sequence_adapter.ipp
index f32764f..9bf955f 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/buffer_sequence_adapter.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/buffer_sequence_adapter.ipp
@@ -2,7 +2,7 @@
 // detail/impl/buffer_sequence_adapter.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -39,16 +39,16 @@ class winrt_buffer_impl :
 public:
   explicit winrt_buffer_impl(const asio::const_buffer& b)
   {
-    bytes_ = const_cast<byte*>(asio::buffer_cast<const byte*>(b));
-    length_ = asio::buffer_size(b);
-    capacity_ = asio::buffer_size(b);
+    bytes_ = const_cast<byte*>(static_cast<const byte*>(b.data()));
+    length_ = b.size();
+    capacity_ = b.size();
   }
 
   explicit winrt_buffer_impl(const asio::mutable_buffer& b)
   {
-    bytes_ = const_cast<byte*>(asio::buffer_cast<const byte*>(b));
+    bytes_ = static_cast<byte*>(b.data());
     length_ = 0;
-    capacity_ = asio::buffer_size(b);
+    capacity_ = b.size();
   }
 
   ~winrt_buffer_impl()
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/descriptor_ops.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/descriptor_ops.ipp
index 6de1385..07355e8 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/descriptor_ops.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/descriptor_ops.ipp
@@ -2,7 +2,7 @@
 // detail/impl/descriptor_ops.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/dev_poll_reactor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/dev_poll_reactor.hpp
index 9ed9585..f6c00a5 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/dev_poll_reactor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/dev_poll_reactor.hpp
@@ -2,7 +2,7 @@
 // detail/impl/dev_poll_reactor.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/dev_poll_reactor.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/dev_poll_reactor.ipp
index f0f408d..ac0cede 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/dev_poll_reactor.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/dev_poll_reactor.ipp
@@ -2,7 +2,7 @@
 // detail/impl/dev_poll_reactor.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -47,11 +47,11 @@ dev_poll_reactor::dev_poll_reactor(asio::execution_context& ctx)
 
 dev_poll_reactor::~dev_poll_reactor()
 {
-  shutdown_service();
+  shutdown();
   ::close(dev_poll_fd_);
 }
 
-void dev_poll_reactor::shutdown_service()
+void dev_poll_reactor::shutdown()
 {
   asio::detail::mutex::scoped_lock lock(mutex_);
   shutdown_ = true;
@@ -67,7 +67,7 @@ void dev_poll_reactor::shutdown_service()
   scheduler_.abandon_operations(ops);
 } 
 
-void dev_poll_reactor::fork_service(asio::io_service::fork_event fork_ev)
+void dev_poll_reactor::notify_fork(asio::io_context::fork_event fork_ev)
 {
   if (fork_ev == asio::execution_context::fork_child)
   {
@@ -234,7 +234,7 @@ void dev_poll_reactor::deregister_internal_descriptor(
     op_queue_[i].cancel_operations(descriptor, ops, ec);
 }
 
-void dev_poll_reactor::run(bool block, op_queue<operation>& ops)
+void dev_poll_reactor::run(long usec, op_queue<operation>& ops)
 {
   asio::detail::mutex::scoped_lock lock(mutex_);
 
@@ -266,7 +266,15 @@ void dev_poll_reactor::run(bool block, op_queue<operation>& ops)
     pending_event_change_index_.clear();
   }
 
-  int timeout = block ? get_timeout() : 0;
+  // Calculate timeout.
+  int timeout;
+  if (usec == 0)
+    timeout = 0;
+  else
+  {
+    timeout = (usec < 0) ? -1 : ((usec - 1) / 1000 + 1);
+    timeout = get_timeout(timeout);
+  }
   lock.unlock();
 
   // Block on the /dev/poll descriptor.
@@ -380,11 +388,13 @@ void dev_poll_reactor::do_remove_timer_queue(timer_queue_base& queue)
   timer_queues_.erase(&queue);
 }
 
-int dev_poll_reactor::get_timeout()
+int dev_poll_reactor::get_timeout(int msec)
 {
   // By default we will wait no longer than 5 minutes. This will ensure that
   // any changes to the system clock are detected after no longer than this.
-  return timer_queues_.wait_duration_msec(5 * 60 * 1000);
+  const int max_msec = 5 * 60 * 1000;
+  return timer_queues_.wait_duration_msec(
+      (msec < 0 || max_msec < msec) ? max_msec : msec);
 }
 
 void dev_poll_reactor::cancel_ops_unlocked(socket_type descriptor,
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/epoll_reactor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/epoll_reactor.hpp
index 595813e..a906654 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/epoll_reactor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/epoll_reactor.hpp
@@ -2,7 +2,7 @@
 // detail/impl/epoll_reactor.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -71,7 +71,7 @@ void epoll_reactor::move_timer(timer_queue<Time_Traits>& queue,
     typename timer_queue<Time_Traits>::per_timer_data& target,
     typename timer_queue<Time_Traits>::per_timer_data& source)
 {
-  asio::detail::mutex::scoped_lock lock(mutex_);
+  mutex::scoped_lock lock(mutex_);
   op_queue<operation> ops;
   queue.cancel_timer(target, ops);
   queue.move_timer(target, source);
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/epoll_reactor.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/epoll_reactor.ipp
index 4cdef35..382061e 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/epoll_reactor.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/epoll_reactor.ipp
@@ -2,7 +2,7 @@
 // detail/impl/epoll_reactor.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -37,11 +37,13 @@ namespace detail {
 epoll_reactor::epoll_reactor(asio::execution_context& ctx)
   : execution_context_service_base<epoll_reactor>(ctx),
     scheduler_(use_service<scheduler>(ctx)),
-    mutex_(),
+    mutex_(ASIO_CONCURRENCY_HINT_IS_LOCKING(
+          SCHEDULER, scheduler_.concurrency_hint())),
     interrupter_(),
     epoll_fd_(do_epoll_create()),
     timer_fd_(do_timerfd_create()),
-    shutdown_(false)
+    shutdown_(false),
+    registered_descriptors_mutex_(mutex_.enabled())
 {
   // Add the interrupter's descriptor to epoll.
   epoll_event ev = { 0, { 0 } };
@@ -67,7 +69,7 @@ epoll_reactor::~epoll_reactor()
     close(timer_fd_);
 }
 
-void epoll_reactor::shutdown_service()
+void epoll_reactor::shutdown()
 {
   mutex::scoped_lock lock(mutex_);
   shutdown_ = true;
@@ -88,7 +90,7 @@ void epoll_reactor::shutdown_service()
   scheduler_.abandon_operations(ops);
 }
 
-void epoll_reactor::fork_service(
+void epoll_reactor::notify_fork(
     asio::execution_context::fork_event fork_ev)
 {
   if (fork_ev == asio::execution_context::fork_child)
@@ -150,12 +152,18 @@ int epoll_reactor::register_descriptor(socket_type descriptor,
 {
   descriptor_data = allocate_descriptor_state();
 
+  ASIO_HANDLER_REACTOR_REGISTRATION((
+        context(), static_cast<uintmax_t>(descriptor),
+        reinterpret_cast<uintmax_t>(descriptor_data)));
+
   {
     mutex::scoped_lock descriptor_lock(descriptor_data->mutex_);
 
     descriptor_data->reactor_ = this;
     descriptor_data->descriptor_ = descriptor;
     descriptor_data->shutdown_ = false;
+    for (int i = 0; i < max_ops; ++i)
+      descriptor_data->try_speculative_[i] = true;
   }
 
   epoll_event ev = { 0, { 0 } };
@@ -164,7 +172,18 @@ int epoll_reactor::register_descriptor(socket_type descriptor,
   ev.data.ptr = descriptor_data;
   int result = epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, descriptor, &ev);
   if (result != 0)
+  {
+    if (errno == EPERM)
+    {
+      // This file descriptor type is not supported by epoll. However, if it is
+      // a regular file then operations on it will not block. We will allow
+      // this descriptor to be used and fail later if an operation on it would
+      // otherwise require a trip through the reactor.
+      descriptor_data->registered_events_ = 0;
+      return 0;
+    }
     return errno;
+  }
 
   return 0;
 }
@@ -175,6 +194,10 @@ int epoll_reactor::register_internal_descriptor(
 {
   descriptor_data = allocate_descriptor_state();
 
+  ASIO_HANDLER_REACTOR_REGISTRATION((
+        context(), static_cast<uintmax_t>(descriptor),
+        reinterpret_cast<uintmax_t>(descriptor_data)));
+
   {
     mutex::scoped_lock descriptor_lock(descriptor_data->mutex_);
 
@@ -182,6 +205,8 @@ int epoll_reactor::register_internal_descriptor(
     descriptor_data->descriptor_ = descriptor;
     descriptor_data->shutdown_ = false;
     descriptor_data->op_queue_[op_type].push(op);
+    for (int i = 0; i < max_ops; ++i)
+      descriptor_data->try_speculative_[i] = true;
   }
 
   epoll_event ev = { 0, { 0 } };
@@ -228,9 +253,22 @@ void epoll_reactor::start_op(int op_type, socket_type descriptor,
         && (op_type != read_op
           || descriptor_data->op_queue_[except_op].empty()))
     {
-      if (op->perform())
+      if (descriptor_data->try_speculative_[op_type])
+      {
+        if (reactor_op::status status = op->perform())
+        {
+          if (status == reactor_op::done_and_exhausted)
+            if (descriptor_data->registered_events_ != 0)
+              descriptor_data->try_speculative_[op_type] = false;
+          descriptor_lock.unlock();
+          scheduler_.post_immediate_completion(op, is_continuation);
+          return;
+        }
+      }
+
+      if (descriptor_data->registered_events_ == 0)
       {
-        descriptor_lock.unlock();
+        op->ec_ = asio::error::operation_not_supported;
         scheduler_.post_immediate_completion(op, is_continuation);
         return;
       }
@@ -256,6 +294,12 @@ void epoll_reactor::start_op(int op_type, socket_type descriptor,
         }
       }
     }
+    else if (descriptor_data->registered_events_ == 0)
+    {
+      op->ec_ = asio::error::operation_not_supported;
+      scheduler_.post_immediate_completion(op, is_continuation);
+      return;
+    }
     else
     {
       if (op_type == write_op)
@@ -313,7 +357,7 @@ void epoll_reactor::deregister_descriptor(socket_type descriptor,
       // The descriptor will be automatically removed from the epoll set when
       // it is closed.
     }
-    else
+    else if (descriptor_data->registered_events_ != 0)
     {
       epoll_event ev = { 0, { 0 } };
       epoll_ctl(epoll_fd_, EPOLL_CTL_DEL, descriptor, &ev);
@@ -335,6 +379,10 @@ void epoll_reactor::deregister_descriptor(socket_type descriptor,
 
     descriptor_lock.unlock();
 
+    ASIO_HANDLER_REACTOR_DEREGISTRATION((
+          context(), static_cast<uintmax_t>(descriptor),
+          reinterpret_cast<uintmax_t>(descriptor_data)));
+
     free_descriptor_state(descriptor_data);
     descriptor_data = 0;
 
@@ -364,12 +412,16 @@ void epoll_reactor::deregister_internal_descriptor(socket_type descriptor,
 
     descriptor_lock.unlock();
 
+    ASIO_HANDLER_REACTOR_DEREGISTRATION((
+          context(), static_cast<uintmax_t>(descriptor),
+          reinterpret_cast<uintmax_t>(descriptor_data)));
+
     free_descriptor_state(descriptor_data);
     descriptor_data = 0;
   }
 }
 
-void epoll_reactor::run(bool block, op_queue<operation>& ops)
+void epoll_reactor::run(long usec, op_queue<operation>& ops)
 {
   // This code relies on the fact that the scheduler queues the reactor task
   // behind all descriptor operations generated by this function. This means,
@@ -377,20 +429,53 @@ void epoll_reactor::run(bool block, op_queue<operation>& ops)
   // operations have already been dequeued. Therefore it is now safe for us to
   // reuse and return them for the scheduler to queue again.
 
-  // Calculate a timeout only if timerfd is not used.
+  // Calculate timeout. Check the timer queues only if timerfd is not in use.
   int timeout;
-  if (timer_fd_ != -1)
-    timeout = block ? -1 : 0;
+  if (usec == 0)
+    timeout = 0;
   else
   {
-    mutex::scoped_lock lock(mutex_);
-    timeout = block ? get_timeout() : 0;
+    timeout = (usec < 0) ? -1 : ((usec - 1) / 1000 + 1);
+    if (timer_fd_ == -1)
+    {
+      mutex::scoped_lock lock(mutex_);
+      timeout = get_timeout(timeout);
+    }
   }
 
   // Block on the epoll descriptor.
   epoll_event events[128];
   int num_events = epoll_wait(epoll_fd_, events, 128, timeout);
 
+#if defined(ASIO_ENABLE_HANDLER_TRACKING)
+  // Trace the waiting events.
+  for (int i = 0; i < num_events; ++i)
+  {
+    void* ptr = events[i].data.ptr;
+    if (ptr == &interrupter_)
+    {
+      // Ignore.
+    }
+# if defined(ASIO_HAS_TIMERFD)
+    else if (ptr == &timer_fd_)
+    {
+      // Ignore.
+    }
+# endif // defined(ASIO_HAS_TIMERFD)
+    {
+      unsigned event_mask = 0;
+      if ((events[i].events & EPOLLIN) != 0)
+        event_mask |= ASIO_HANDLER_REACTOR_READ_EVENT;
+      if ((events[i].events & EPOLLOUT))
+        event_mask |= ASIO_HANDLER_REACTOR_WRITE_EVENT;
+      if ((events[i].events & (EPOLLERR | EPOLLHUP)) != 0)
+        event_mask |= ASIO_HANDLER_REACTOR_ERROR_EVENT;
+      ASIO_HANDLER_REACTOR_EVENTS((context(),
+            reinterpret_cast<uintmax_t>(ptr), event_mask));
+    }
+  }
+#endif // defined(ASIO_ENABLE_HANDLER_TRACKING)
+
 #if defined(ASIO_HAS_TIMERFD)
   bool check_timers = (timer_fd_ == -1);
 #else // defined(ASIO_HAS_TIMERFD)
@@ -509,7 +594,7 @@ int epoll_reactor::do_timerfd_create()
 epoll_reactor::descriptor_state* epoll_reactor::allocate_descriptor_state()
 {
   mutex::scoped_lock descriptors_lock(registered_descriptors_mutex_);
-  return registered_descriptors_.alloc();
+  return registered_descriptors_.alloc(registered_descriptors_mutex_.enabled());
 }
 
 void epoll_reactor::free_descriptor_state(epoll_reactor::descriptor_state* s)
@@ -545,11 +630,13 @@ void epoll_reactor::update_timeout()
   interrupt();
 }
 
-int epoll_reactor::get_timeout()
+int epoll_reactor::get_timeout(int msec)
 {
   // By default we will wait no longer than 5 minutes. This will ensure that
   // any changes to the system clock are detected after no longer than this.
-  return timer_queues_.wait_duration_msec(5 * 60 * 1000);
+  const int max_msec = 5 * 60 * 1000;
+  return timer_queues_.wait_duration_msec(
+      (msec < 0 || max_msec < msec) ? max_msec : msec);
 }
 
 #if defined(ASIO_HAS_TIMERFD)
@@ -590,7 +677,7 @@ struct epoll_reactor::perform_io_cleanup_on_block_exit
       // No user-initiated operations have completed, so we need to compensate
       // for the work_finished() call that the scheduler will make once this
       // operation returns.
-      reactor_->scheduler_.work_started();
+      reactor_->scheduler_.compensating_work_started();
     }
   }
 
@@ -599,8 +686,9 @@ struct epoll_reactor::perform_io_cleanup_on_block_exit
   operation* first_op_;
 };
 
-epoll_reactor::descriptor_state::descriptor_state()
-  : operation(&epoll_reactor::descriptor_state::do_complete)
+epoll_reactor::descriptor_state::descriptor_state(bool locking)
+  : operation(&epoll_reactor::descriptor_state::do_complete),
+    mutex_(locking)
 {
 }
 
@@ -617,12 +705,18 @@ operation* epoll_reactor::descriptor_state::perform_io(uint32_t events)
   {
     if (events & (flag[j] | EPOLLERR | EPOLLHUP))
     {
+      try_speculative_[j] = true;
       while (reactor_op* op = op_queue_[j].front())
       {
-        if (op->perform())
+        if (reactor_op::status status = op->perform())
         {
           op_queue_[j].pop();
           io_cleanup.ops_.push(op);
+          if (status == reactor_op::done_and_exhausted)
+          {
+            try_speculative_[j] = false;
+            break;
+          }
         }
         else
           break;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/eventfd_select_interrupter.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/eventfd_select_interrupter.ipp
index 744ab0c..152bffd 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/eventfd_select_interrupter.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/eventfd_select_interrupter.ipp
@@ -2,7 +2,7 @@
 // detail/impl/eventfd_select_interrupter.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2008 Roelof Naude (roelof.naude at gmail dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/handler_tracking.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/handler_tracking.ipp
index 29fbe51..7e628d0 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/handler_tracking.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/handler_tracking.ipp
@@ -2,7 +2,7 @@
 // detail/impl/handler_tracking.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,7 +17,11 @@
 
 #include "asio/detail/config.hpp"
 
-#if defined(ASIO_ENABLE_HANDLER_TRACKING)
+#if defined(ASIO_CUSTOM_HANDLER_TRACKING)
+
+// The handler tracking implementation is provided by the user-specified header.
+
+#elif defined(ASIO_ENABLE_HANDLER_TRACKING)
 
 #include <cstdarg>
 #include <cstdio>
@@ -25,17 +29,15 @@
 
 #if defined(ASIO_HAS_BOOST_DATE_TIME)
 # include "asio/time_traits.hpp"
-#else // defined(ASIO_HAS_BOOST_DATE_TIME)
-# if defined(ASIO_HAS_STD_CHRONO)
-#  include <chrono>
-# elif defined(ASIO_HAS_BOOST_CHRONO)
-#  include <boost/chrono/system_clocks.hpp>
-# endif
+#elif defined(ASIO_HAS_CHRONO)
+# include "asio/detail/chrono.hpp"
 # include "asio/detail/chrono_time_traits.hpp"
 # include "asio/wait_traits.hpp"
 #endif // defined(ASIO_HAS_BOOST_DATE_TIME)
 
-#if !defined(ASIO_WINDOWS)
+#if defined(ASIO_WINDOWS_RUNTIME)
+# include "asio/detail/socket_types.hpp"
+#elif !defined(ASIO_WINDOWS)
 # include <unistd.h>
 #endif // !defined(ASIO_WINDOWS)
 
@@ -55,16 +57,11 @@ struct handler_tracking_timestamp
     boost::posix_time::ptime epoch(boost::gregorian::date(1970, 1, 1));
     boost::posix_time::time_duration now =
       boost::posix_time::microsec_clock::universal_time() - epoch;
-#elif defined(ASIO_HAS_STD_CHRONO)
-    typedef chrono_time_traits<std::chrono::system_clock,
-        asio::wait_traits<std::chrono::system_clock> > traits_helper;
-    traits_helper::posix_time_duration now(
-        std::chrono::system_clock::now().time_since_epoch());
-#elif defined(ASIO_HAS_BOOST_CHRONO)
-    typedef chrono_time_traits<boost::chrono::system_clock,
-        asio::wait_traits<boost::chrono::system_clock> > traits_helper;
+#elif defined(ASIO_HAS_CHRONO)
+    typedef chrono_time_traits<chrono::system_clock,
+        asio::wait_traits<chrono::system_clock> > traits_helper;
     traits_helper::posix_time_duration now(
-        boost::chrono::system_clock::now().time_since_epoch());
+        chrono::system_clock::now().time_since_epoch());
 #endif
     seconds = static_cast<uint64_t>(now.total_seconds());
     microseconds = static_cast<uint64_t>(now.total_microseconds() % 1000000);
@@ -95,13 +92,15 @@ void handler_tracking::init()
     state->current_completion_ = new tss_ptr<completion>;
 }
 
-void handler_tracking::creation(handler_tracking::tracked_handler* h,
-    const char* object_type, void* object, const char* op_name)
+void handler_tracking::creation(execution_context&,
+    handler_tracking::tracked_handler& h,
+    const char* object_type, void* object,
+    uintmax_t /*native_handle*/, const char* op_name)
 {
   static tracking_state* state = get_state();
 
   static_mutex::scoped_lock lock(state->mutex_);
-  h->id_ = state->next_id_++;
+  h.id_ = state->next_id_++;
   lock.unlock();
 
   handler_tracking_timestamp timestamp;
@@ -117,11 +116,12 @@ void handler_tracking::creation(handler_tracking::tracked_handler* h,
       "@asio|%llu.%06llu|%llu*%llu|%.20s@%p.%.50s\n",
 #endif // defined(ASIO_WINDOWS)
       timestamp.seconds, timestamp.microseconds,
-      current_id, h->id_, object_type, object, op_name);
+      current_id, h.id_, object_type, object, op_name);
 }
 
-handler_tracking::completion::completion(handler_tracking::tracked_handler* h)
-  : id_(h->id_),
+handler_tracking::completion::completion(
+    const handler_tracking::tracked_handler& h)
+  : id_(h.id_),
     invoked_(false),
     next_(*get_state()->current_completion_)
 {
@@ -249,8 +249,9 @@ void handler_tracking::completion::invocation_end()
   }
 }
 
-void handler_tracking::operation(const char* object_type,
-    void* object, const char* op_name)
+void handler_tracking::operation(execution_context&,
+    const char* object_type, void* object,
+    uintmax_t /*native_handle*/, const char* op_name)
 {
   static tracking_state* state = get_state();
 
@@ -270,6 +271,54 @@ void handler_tracking::operation(const char* object_type,
       current_id, object_type, object, op_name);
 }
 
+void handler_tracking::reactor_registration(execution_context& /*context*/,
+    uintmax_t /*native_handle*/, uintmax_t /*registration*/)
+{
+}
+
+void handler_tracking::reactor_deregistration(execution_context& /*context*/,
+    uintmax_t /*native_handle*/, uintmax_t /*registration*/)
+{
+}
+
+void handler_tracking::reactor_events(execution_context& /*context*/,
+    uintmax_t /*native_handle*/, unsigned /*events*/)
+{
+}
+
+void handler_tracking::reactor_operation(
+    const tracked_handler& h, const char* op_name,
+    const asio::error_code& ec)
+{
+  handler_tracking_timestamp timestamp;
+
+  write_line(
+#if defined(ASIO_WINDOWS)
+      "@asio|%I64u.%06I64u|.%I64u|%s,ec=%.20s:%d\n",
+#else // defined(ASIO_WINDOWS)
+      "@asio|%llu.%06llu|.%llu|%s,ec=%.20s:%d\n",
+#endif // defined(ASIO_WINDOWS)
+      timestamp.seconds, timestamp.microseconds,
+      h.id_, op_name, ec.category().name(), ec.value());
+}
+
+void handler_tracking::reactor_operation(
+    const tracked_handler& h, const char* op_name,
+    const asio::error_code& ec, std::size_t bytes_transferred)
+{
+  handler_tracking_timestamp timestamp;
+
+  write_line(
+#if defined(ASIO_WINDOWS)
+      "@asio|%I64u.%06I64u|.%I64u|%s,ec=%.20s:%d,bytes_transferred=%I64u\n",
+#else // defined(ASIO_WINDOWS)
+      "@asio|%llu.%06llu|.%llu|%s,ec=%.20s:%d,bytes_transferred=%llu\n",
+#endif // defined(ASIO_WINDOWS)
+      timestamp.seconds, timestamp.microseconds,
+      h.id_, op_name, ec.category().name(), ec.value(),
+      static_cast<uint64_t>(bytes_transferred));
+}
+
 void handler_tracking::write_line(const char* format, ...)
 {
   using namespace std; // For sprintf (or equivalent).
@@ -286,7 +335,11 @@ void handler_tracking::write_line(const char* format, ...)
 
   va_end(args);
 
-#if defined(ASIO_WINDOWS)
+#if defined(ASIO_WINDOWS_RUNTIME)
+  wchar_t wline[256] = L"";
+  mbstowcs_s(0, wline, sizeof(wline) / sizeof(wchar_t), line, length);
+  ::OutputDebugStringW(wline);
+#elif defined(ASIO_WINDOWS)
   HANDLE stderr_handle = ::GetStdHandle(STD_ERROR_HANDLE);
   DWORD bytes_written = 0;
   ::WriteFile(stderr_handle, line, length, &bytes_written, 0);
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/kqueue_reactor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/kqueue_reactor.hpp
index 1a86d00..eaa7a55 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/kqueue_reactor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/kqueue_reactor.hpp
@@ -2,7 +2,7 @@
 // detail/impl/kqueue_reactor.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2005 Stefan Arentz (stefan at soze dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -43,7 +43,7 @@ void kqueue_reactor::schedule_timer(timer_queue<Time_Traits>& queue,
     const typename Time_Traits::time_type& time,
     typename timer_queue<Time_Traits>::per_timer_data& timer, wait_op* op)
 {
-  asio::detail::mutex::scoped_lock lock(mutex_);
+  mutex::scoped_lock lock(mutex_);
 
   if (shutdown_)
   {
@@ -62,7 +62,7 @@ std::size_t kqueue_reactor::cancel_timer(timer_queue<Time_Traits>& queue,
     typename timer_queue<Time_Traits>::per_timer_data& timer,
     std::size_t max_cancelled)
 {
-  asio::detail::mutex::scoped_lock lock(mutex_);
+  mutex::scoped_lock lock(mutex_);
   op_queue<operation> ops;
   std::size_t n = queue.cancel_timer(timer, ops, max_cancelled);
   lock.unlock();
@@ -75,7 +75,7 @@ void kqueue_reactor::move_timer(timer_queue<Time_Traits>& queue,
     typename timer_queue<Time_Traits>::per_timer_data& target,
     typename timer_queue<Time_Traits>::per_timer_data& source)
 {
-  asio::detail::mutex::scoped_lock lock(mutex_);
+  mutex::scoped_lock lock(mutex_);
   op_queue<operation> ops;
   queue.cancel_timer(target, ops);
   queue.move_timer(target, source);
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/kqueue_reactor.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/kqueue_reactor.ipp
index b4f2e9d..6ba6458 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/kqueue_reactor.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/kqueue_reactor.ipp
@@ -2,7 +2,7 @@
 // detail/impl/kqueue_reactor.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2005 Stefan Arentz (stefan at soze dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -42,15 +42,17 @@ namespace detail {
 kqueue_reactor::kqueue_reactor(asio::execution_context& ctx)
   : execution_context_service_base<kqueue_reactor>(ctx),
     scheduler_(use_service<scheduler>(ctx)),
-    mutex_(),
+    mutex_(ASIO_CONCURRENCY_HINT_IS_LOCKING(
+          SCHEDULER, scheduler_.concurrency_hint())),
     kqueue_fd_(do_kqueue_create()),
     interrupter_(),
-    shutdown_(false)
+    shutdown_(false),
+    registered_descriptors_mutex_(mutex_.enabled())
 {
-  struct kevent event;
-  ASIO_KQUEUE_EV_SET(&event, interrupter_.read_descriptor(),
+  struct kevent events[1];
+  ASIO_KQUEUE_EV_SET(&events[0], interrupter_.read_descriptor(),
       EVFILT_READ, EV_ADD, 0, 0, &interrupter_);
-  if (::kevent(kqueue_fd_, &event, 1, 0, 0, 0) == -1)
+  if (::kevent(kqueue_fd_, events, 1, 0, 0, 0) == -1)
   {
     asio::error_code error(errno,
         asio::error::get_system_category());
@@ -63,7 +65,7 @@ kqueue_reactor::~kqueue_reactor()
   close(kqueue_fd_);
 }
 
-void kqueue_reactor::shutdown_service()
+void kqueue_reactor::shutdown()
 {
   mutex::scoped_lock lock(mutex_);
   shutdown_ = true;
@@ -84,7 +86,7 @@ void kqueue_reactor::shutdown_service()
   scheduler_.abandon_operations(ops);
 }
 
-void kqueue_reactor::fork_service(
+void kqueue_reactor::notify_fork(
     asio::execution_context::fork_event fork_ev)
 {
   if (fork_ev == asio::execution_context::fork_child)
@@ -95,14 +97,14 @@ void kqueue_reactor::fork_service(
 
     interrupter_.recreate();
 
-    struct kevent event;
-    ASIO_KQUEUE_EV_SET(&event, interrupter_.read_descriptor(),
+    struct kevent events[2];
+    ASIO_KQUEUE_EV_SET(&events[0], interrupter_.read_descriptor(),
         EVFILT_READ, EV_ADD, 0, 0, &interrupter_);
-    if (::kevent(kqueue_fd_, &event, 1, 0, 0, 0) == -1)
+    if (::kevent(kqueue_fd_, events, 1, 0, 0, 0) == -1)
     {
-      asio::error_code error(errno,
+      asio::error_code ec(errno,
           asio::error::get_system_category());
-      asio::detail::throw_error(error);
+      asio::detail::throw_error(ec, "kqueue interrupter registration");
     }
 
     // Re-register all descriptors with kqueue.
@@ -110,16 +112,18 @@ void kqueue_reactor::fork_service(
     for (descriptor_state* state = registered_descriptors_.first();
         state != 0; state = state->next_)
     {
-      struct kevent events[2];
-      ASIO_KQUEUE_EV_SET(&events[0], state->descriptor_,
-          EVFILT_READ, EV_ADD | EV_CLEAR, 0, 0, state);
-      ASIO_KQUEUE_EV_SET(&events[1], state->descriptor_,
-          EVFILT_WRITE, EV_ADD | EV_CLEAR, 0, 0, state);
-      if (::kevent(kqueue_fd_, events, 2, 0, 0, 0) == -1)
+      if (state->num_kevents_ > 0)
       {
-        asio::error_code error(errno,
-            asio::error::get_system_category());
-        asio::detail::throw_error(error);
+        ASIO_KQUEUE_EV_SET(&events[0], state->descriptor_,
+            EVFILT_READ, EV_ADD | EV_CLEAR, 0, 0, state);
+        ASIO_KQUEUE_EV_SET(&events[1], state->descriptor_,
+            EVFILT_WRITE, EV_ADD | EV_CLEAR, 0, 0, state);
+        if (::kevent(kqueue_fd_, events, state->num_kevents_, 0, 0, 0) == -1)
+        {
+          asio::error_code ec(errno,
+              asio::error::get_system_category());
+          asio::detail::throw_error(ec, "kqueue re-registration");
+        }
       }
     }
   }
@@ -135,19 +139,16 @@ int kqueue_reactor::register_descriptor(socket_type descriptor,
 {
   descriptor_data = allocate_descriptor_state();
 
+  ASIO_HANDLER_REACTOR_REGISTRATION((
+        context(), static_cast<uintmax_t>(descriptor),
+        reinterpret_cast<uintmax_t>(descriptor_data)));
+
   mutex::scoped_lock lock(descriptor_data->mutex_);
 
   descriptor_data->descriptor_ = descriptor;
+  descriptor_data->num_kevents_ = 0;
   descriptor_data->shutdown_ = false;
 
-  struct kevent events[2];
-  ASIO_KQUEUE_EV_SET(&events[0], descriptor, EVFILT_READ,
-      EV_ADD | EV_CLEAR, 0, 0, descriptor_data);
-  ASIO_KQUEUE_EV_SET(&events[1], descriptor, EVFILT_WRITE,
-      EV_ADD | EV_CLEAR, 0, 0, descriptor_data);
-  if (::kevent(kqueue_fd_, events, 2, 0, 0, 0) == -1)
-    return errno;
-
   return 0;
 }
 
@@ -157,18 +158,21 @@ int kqueue_reactor::register_internal_descriptor(
 {
   descriptor_data = allocate_descriptor_state();
 
+  ASIO_HANDLER_REACTOR_REGISTRATION((
+        context(), static_cast<uintmax_t>(descriptor),
+        reinterpret_cast<uintmax_t>(descriptor_data)));
+
   mutex::scoped_lock lock(descriptor_data->mutex_);
 
   descriptor_data->descriptor_ = descriptor;
+  descriptor_data->num_kevents_ = 1;
   descriptor_data->shutdown_ = false;
   descriptor_data->op_queue_[op_type].push(op);
 
-  struct kevent events[2];
+  struct kevent events[1];
   ASIO_KQUEUE_EV_SET(&events[0], descriptor, EVFILT_READ,
       EV_ADD | EV_CLEAR, 0, 0, descriptor_data);
-  ASIO_KQUEUE_EV_SET(&events[1], descriptor, EVFILT_WRITE,
-      EV_ADD | EV_CLEAR, 0, 0, descriptor_data);
-  if (::kevent(kqueue_fd_, events, 2, 0, 0, 0) == -1)
+  if (::kevent(kqueue_fd_, events, 1, 0, 0, 0) == -1)
     return errno;
 
   return 0;
@@ -201,9 +205,10 @@ void kqueue_reactor::start_op(int op_type, socket_type descriptor,
     return;
   }
 
-  bool first = descriptor_data->op_queue_[op_type].empty();
-  if (first)
+  if (descriptor_data->op_queue_[op_type].empty())
   {
+    static const int num_kevents[max_ops] = { 1, 2, 1 };
+
     if (allow_speculative
         && (op_type != read_op
           || descriptor_data->op_queue_[except_op].empty()))
@@ -214,15 +219,38 @@ void kqueue_reactor::start_op(int op_type, socket_type descriptor,
         scheduler_.post_immediate_completion(op, is_continuation);
         return;
       }
+
+      if (descriptor_data->num_kevents_ < num_kevents[op_type])
+      {
+        struct kevent events[2];
+        ASIO_KQUEUE_EV_SET(&events[0], descriptor, EVFILT_READ,
+            EV_ADD | EV_CLEAR, 0, 0, descriptor_data);
+        ASIO_KQUEUE_EV_SET(&events[1], descriptor, EVFILT_WRITE,
+            EV_ADD | EV_CLEAR, 0, 0, descriptor_data);
+        if (::kevent(kqueue_fd_, events, num_kevents[op_type], 0, 0, 0) != -1)
+        {
+          descriptor_data->num_kevents_ = num_kevents[op_type];
+        }
+        else
+        {
+          op->ec_ = asio::error_code(errno,
+              asio::error::get_system_category());
+          scheduler_.post_immediate_completion(op, is_continuation);
+          return;
+        }
+      }
     }
     else
     {
+      if (descriptor_data->num_kevents_ < num_kevents[op_type])
+        descriptor_data->num_kevents_ = num_kevents[op_type];
+
       struct kevent events[2];
       ASIO_KQUEUE_EV_SET(&events[0], descriptor, EVFILT_READ,
           EV_ADD | EV_CLEAR, 0, 0, descriptor_data);
       ASIO_KQUEUE_EV_SET(&events[1], descriptor, EVFILT_WRITE,
           EV_ADD | EV_CLEAR, 0, 0, descriptor_data);
-      ::kevent(kqueue_fd_, events, 2, 0, 0, 0);
+      ::kevent(kqueue_fd_, events, descriptor_data->num_kevents_, 0, 0, 0);
     }
   }
 
@@ -276,7 +304,7 @@ void kqueue_reactor::deregister_descriptor(socket_type descriptor,
           EVFILT_READ, EV_DELETE, 0, 0, 0);
       ASIO_KQUEUE_EV_SET(&events[1], descriptor,
           EVFILT_WRITE, EV_DELETE, 0, 0, 0);
-      ::kevent(kqueue_fd_, events, 2, 0, 0, 0);
+      ::kevent(kqueue_fd_, events, descriptor_data->num_kevents_, 0, 0, 0);
     }
 
     op_queue<operation> ops;
@@ -295,6 +323,10 @@ void kqueue_reactor::deregister_descriptor(socket_type descriptor,
 
     descriptor_lock.unlock();
 
+    ASIO_HANDLER_REACTOR_DEREGISTRATION((
+          context(), static_cast<uintmax_t>(descriptor),
+          reinterpret_cast<uintmax_t>(descriptor_data)));
+
     free_descriptor_state(descriptor_data);
     descriptor_data = 0;
 
@@ -317,7 +349,7 @@ void kqueue_reactor::deregister_internal_descriptor(socket_type descriptor,
         EVFILT_READ, EV_DELETE, 0, 0, 0);
     ASIO_KQUEUE_EV_SET(&events[1], descriptor,
         EVFILT_WRITE, EV_DELETE, 0, 0, 0);
-    ::kevent(kqueue_fd_, events, 2, 0, 0, 0);
+    ::kevent(kqueue_fd_, events, descriptor_data->num_kevents_, 0, 0, 0);
 
     op_queue<operation> ops;
     for (int i = 0; i < max_ops; ++i)
@@ -328,18 +360,22 @@ void kqueue_reactor::deregister_internal_descriptor(socket_type descriptor,
 
     descriptor_lock.unlock();
 
+    ASIO_HANDLER_REACTOR_DEREGISTRATION((
+          context(), static_cast<uintmax_t>(descriptor),
+          reinterpret_cast<uintmax_t>(descriptor_data)));
+
     free_descriptor_state(descriptor_data);
     descriptor_data = 0;
   }
 }
 
-void kqueue_reactor::run(bool block, op_queue<operation>& ops)
+void kqueue_reactor::run(long usec, op_queue<operation>& ops)
 {
   mutex::scoped_lock lock(mutex_);
 
   // Determine how long to block while waiting for events.
   timespec timeout_buf = { 0, 0 };
-  timespec* timeout = block ? get_timeout(timeout_buf) : &timeout_buf;
+  timespec* timeout = usec ? get_timeout(usec, timeout_buf) : &timeout_buf;
 
   lock.unlock();
 
@@ -347,6 +383,31 @@ void kqueue_reactor::run(bool block, op_queue<operation>& ops)
   struct kevent events[128];
   int num_events = kevent(kqueue_fd_, 0, 0, events, 128, timeout);
 
+#if defined(ASIO_ENABLE_HANDLER_TRACKING)
+  // Trace the waiting events.
+  for (int i = 0; i < num_events; ++i)
+  {
+    void* ptr = reinterpret_cast<void*>(events[i].udata);
+    if (ptr != &interrupter_)
+    {
+      unsigned event_mask = 0;
+      switch (events[i].filter)
+      {
+      case EVFILT_READ:
+        event_mask |= ASIO_HANDLER_REACTOR_READ_EVENT;
+        break;
+      case EVFILT_WRITE:
+        event_mask |= ASIO_HANDLER_REACTOR_WRITE_EVENT;
+        break;
+      }
+      if ((events[i].flags & (EV_ERROR | EV_OOBAND)) != 0)
+        event_mask |= ASIO_HANDLER_REACTOR_ERROR_EVENT;
+      ASIO_HANDLER_REACTOR_EVENTS((context(),
+            reinterpret_cast<uintmax_t>(ptr), event_mask));
+    }
+  }
+#endif // defined(ASIO_ENABLE_HANDLER_TRACKING)
+
   // Dispatch the waiting events.
   for (int i = 0; i < num_events; ++i)
   {
@@ -360,6 +421,21 @@ void kqueue_reactor::run(bool block, op_queue<operation>& ops)
       descriptor_state* descriptor_data = static_cast<descriptor_state*>(ptr);
       mutex::scoped_lock descriptor_lock(descriptor_data->mutex_);
 
+      if (events[i].filter == EVFILT_WRITE
+          && descriptor_data->num_kevents_ == 2
+          && descriptor_data->op_queue_[write_op].empty())
+      {
+        // Some descriptor types, like serial ports, don't seem to support
+        // EV_CLEAR with EVFILT_WRITE. Since we have no pending write
+        // operations we'll remove the EVFILT_WRITE registration here so that
+        // we don't end up in a tight spin.
+        struct kevent delete_events[1];
+        ASIO_KQUEUE_EV_SET(&delete_events[0],
+            descriptor_data->descriptor_, EVFILT_WRITE, EV_DELETE, 0, 0, 0);
+        ::kevent(kqueue_fd_, delete_events, 1, 0, 0, 0);
+        descriptor_data->num_kevents_ = 1;
+      }
+
       // Exception operations must be processed first to ensure that any
       // out-of-band data is read before normal data.
 #if defined(__NetBSD__)
@@ -422,7 +498,7 @@ int kqueue_reactor::do_kqueue_create()
 kqueue_reactor::descriptor_state* kqueue_reactor::allocate_descriptor_state()
 {
   mutex::scoped_lock descriptors_lock(registered_descriptors_mutex_);
-  return registered_descriptors_.alloc();
+  return registered_descriptors_.alloc(registered_descriptors_mutex_.enabled());
 }
 
 void kqueue_reactor::free_descriptor_state(kqueue_reactor::descriptor_state* s)
@@ -443,11 +519,13 @@ void kqueue_reactor::do_remove_timer_queue(timer_queue_base& queue)
   timer_queues_.erase(&queue);
 }
 
-timespec* kqueue_reactor::get_timeout(timespec& ts)
+timespec* kqueue_reactor::get_timeout(long usec, timespec& ts)
 {
   // By default we will wait no longer than 5 minutes. This will ensure that
   // any changes to the system clock are detected after no longer than this.
-  long usec = timer_queues_.wait_duration_usec(5 * 60 * 1000 * 1000);
+  const long max_usec = 5 * 60 * 1000 * 1000;
+  usec = timer_queues_.wait_duration_usec(
+      (usec < 0 || max_usec < usec) ? max_usec : usec);
   ts.tv_sec = usec / 1000000;
   ts.tv_nsec = (usec % 1000000) * 1000;
   return &ts;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/null_event.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/null_event.ipp
new file mode 100644
index 0000000..71b6080
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/null_event.ipp
@@ -0,0 +1,74 @@
+//
+// detail/impl/null_event.ipp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_DETAIL_IMPL_NULL_EVENT_IPP
+#define ASIO_DETAIL_IMPL_NULL_EVENT_IPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+
+#if defined(ASIO_WINDOWS_RUNTIME)
+# include <thread>
+#elif defined(ASIO_WINDOWS) || defined(__CYGWIN__)
+# include "asio/detail/socket_types.hpp"
+#else
+# include <unistd.h>
+# if defined(__hpux)
+#  include <sys/time.h>
+# endif
+# if !defined(__hpux) || defined(__SELECT)
+#  include <sys/select.h>
+# endif
+#endif
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+namespace detail {
+
+void null_event::do_wait()
+{
+#if defined(ASIO_WINDOWS_RUNTIME)
+  std::this_thread::sleep_until(std::chrono::steady_clock::time_point::max());
+#elif defined(ASIO_WINDOWS) || defined(__CYGWIN__)
+  ::Sleep(INFINITE);
+#else
+  ::pause();
+#endif
+}
+
+void null_event::do_wait_for_usec(long usec)
+{
+#if defined(ASIO_WINDOWS_RUNTIME)
+  std::this_thread::sleep_for(std::chrono::microseconds(usec));
+#elif defined(ASIO_WINDOWS) || defined(__CYGWIN__)
+  ::Sleep(usec / 1000);
+#elif defined(__hpux) && defined(__SELECT)
+  timespec ts;
+  ts.tv_sec = usec / 1000000;
+  ts.tv_nsec = (usec % 1000000) * 1000;
+  ::pselect(0, 0, 0, 0, &ts, 0);
+#else
+  timeval tv;
+  tv.tv_sec = usec / 1000000;
+  tv.tv_usec = usec % 1000000;
+  ::select(0, 0, 0, 0, &tv);
+#endif
+}
+
+} // namespace detail
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // ASIO_DETAIL_IMPL_NULL_EVENT_IPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/pipe_select_interrupter.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/pipe_select_interrupter.ipp
index d05f16f..435da01 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/pipe_select_interrupter.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/pipe_select_interrupter.ipp
@@ -2,7 +2,7 @@
 // detail/impl/pipe_select_interrupter.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/posix_event.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/posix_event.ipp
index ec2c116..a62c434 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/posix_event.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/posix_event.ipp
@@ -2,7 +2,7 @@
 // detail/impl/posix_event.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -31,7 +31,16 @@ namespace detail {
 posix_event::posix_event()
   : state_(0)
 {
+#if (defined(__MACH__) && defined(__APPLE__))
   int error = ::pthread_cond_init(&cond_, 0);
+#else // (defined(__MACH__) && defined(__APPLE__))
+  ::pthread_condattr_t attr;
+  ::pthread_condattr_init(&attr);
+  int error = ::pthread_condattr_setclock(&attr, CLOCK_MONOTONIC);
+  if (error == 0)
+    error = ::pthread_cond_init(&cond_, &attr);
+#endif // (defined(__MACH__) && defined(__APPLE__))
+
   asio::error_code ec(error,
       asio::error::get_system_category());
   asio::detail::throw_error(ec, "event");
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/posix_mutex.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/posix_mutex.ipp
index a768867..c629f6b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/posix_mutex.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/posix_mutex.ipp
@@ -2,7 +2,7 @@
 // detail/impl/posix_mutex.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/posix_thread.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/posix_thread.ipp
index 470751a..a4eb2a8 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/posix_thread.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/posix_thread.ipp
@@ -2,7 +2,7 @@
 // detail/impl/posix_thread.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/posix_tss_ptr.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/posix_tss_ptr.ipp
index 8f39ab2..4d35ebc 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/posix_tss_ptr.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/posix_tss_ptr.ipp
@@ -2,7 +2,7 @@
 // detail/impl/posix_tss_ptr.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/reactive_descriptor_service.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/reactive_descriptor_service.ipp
index 21138b0..7aaf362 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/reactive_descriptor_service.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/reactive_descriptor_service.ipp
@@ -2,7 +2,7 @@
 // detail/impl/reactive_descriptor_service.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -30,13 +30,14 @@ namespace asio {
 namespace detail {
 
 reactive_descriptor_service::reactive_descriptor_service(
-    asio::io_service& io_service)
-  : reactor_(asio::use_service<reactor>(io_service))
+    asio::io_context& io_context)
+  : service_base<reactive_descriptor_service>(io_context),
+    reactor_(asio::use_service<reactor>(io_context))
 {
   reactor_.init_task();
 }
 
-void reactive_descriptor_service::shutdown_service()
+void reactive_descriptor_service::shutdown()
 {
 }
 
@@ -83,7 +84,8 @@ void reactive_descriptor_service::destroy(
 {
   if (is_open(impl))
   {
-    ASIO_HANDLER_OPERATION(("descriptor", &impl, "close"));
+    ASIO_HANDLER_OPERATION((reactor_.context(),
+          "descriptor", &impl, impl.descriptor_, "close"));
 
     reactor_.deregister_descriptor(impl.descriptor_, impl.reactor_data_,
         (impl.state_ & descriptor_ops::possible_dup) == 0);
@@ -123,7 +125,8 @@ asio::error_code reactive_descriptor_service::close(
 {
   if (is_open(impl))
   {
-    ASIO_HANDLER_OPERATION(("descriptor", &impl, "close"));
+    ASIO_HANDLER_OPERATION((reactor_.context(),
+          "descriptor", &impl, impl.descriptor_, "close"));
 
     reactor_.deregister_descriptor(impl.descriptor_, impl.reactor_data_,
         (impl.state_ & descriptor_ops::possible_dup) == 0);
@@ -150,7 +153,8 @@ reactive_descriptor_service::release(
 
   if (is_open(impl))
   {
-    ASIO_HANDLER_OPERATION(("descriptor", &impl, "release"));
+    ASIO_HANDLER_OPERATION((reactor_.context(),
+          "descriptor", &impl, impl.descriptor_, "release"));
 
     reactor_.deregister_descriptor(impl.descriptor_, impl.reactor_data_, false);
     construct(impl);
@@ -169,7 +173,8 @@ asio::error_code reactive_descriptor_service::cancel(
     return ec;
   }
 
-  ASIO_HANDLER_OPERATION(("descriptor", &impl, "cancel"));
+  ASIO_HANDLER_OPERATION((reactor_.context(),
+        "descriptor", &impl, impl.descriptor_, "cancel"));
 
   reactor_.cancel_ops(impl.descriptor_, impl.reactor_data_);
   ec = asio::error_code();
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/reactive_serial_port_service.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/reactive_serial_port_service.ipp
index b3ce7b9..7ea37a4 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/reactive_serial_port_service.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/reactive_serial_port_service.ipp
@@ -2,7 +2,7 @@
 // detail/impl/reactive_serial_port_service.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -30,14 +30,15 @@ namespace asio {
 namespace detail {
 
 reactive_serial_port_service::reactive_serial_port_service(
-    asio::io_service& io_service)
-  : descriptor_service_(io_service)
+    asio::io_context& io_context)
+  : service_base<reactive_serial_port_service>(io_context),
+    descriptor_service_(io_context)
 {
 }
 
-void reactive_serial_port_service::shutdown_service()
+void reactive_serial_port_service::shutdown()
 {
-  descriptor_service_.shutdown_service();
+  descriptor_service_.shutdown();
 }
 
 asio::error_code reactive_serial_port_service::open(
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/reactive_socket_service_base.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/reactive_socket_service_base.ipp
index f6cf62a..f1ed1fa 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/reactive_socket_service_base.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/reactive_socket_service_base.ipp
@@ -2,7 +2,7 @@
 // detail/reactive_socket_service_base.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -28,13 +28,14 @@ namespace asio {
 namespace detail {
 
 reactive_socket_service_base::reactive_socket_service_base(
-    asio::io_service& io_service)
-  : reactor_(use_service<reactor>(io_service))
+    asio::io_context& io_context)
+  : io_context_(io_context),
+    reactor_(use_service<reactor>(io_context))
 {
   reactor_.init_task();
 }
 
-void reactive_socket_service_base::shutdown_service()
+void reactive_socket_service_base::base_shutdown()
 {
 }
 
@@ -81,7 +82,8 @@ void reactive_socket_service_base::destroy(
 {
   if (impl.socket_ != invalid_socket)
   {
-    ASIO_HANDLER_OPERATION(("socket", &impl, "close"));
+    ASIO_HANDLER_OPERATION((reactor_.context(),
+          "socket", &impl, impl.socket_, "close"));
 
     reactor_.deregister_descriptor(impl.socket_, impl.reactor_data_,
         (impl.state_ & socket_ops::possible_dup) == 0);
@@ -97,7 +99,8 @@ asio::error_code reactive_socket_service_base::close(
 {
   if (is_open(impl))
   {
-    ASIO_HANDLER_OPERATION(("socket", &impl, "close"));
+    ASIO_HANDLER_OPERATION((reactor_.context(),
+          "socket", &impl, impl.socket_, "close"));
 
     reactor_.deregister_descriptor(impl.socket_, impl.reactor_data_,
         (impl.state_ & socket_ops::possible_dup) == 0);
@@ -128,7 +131,8 @@ asio::error_code reactive_socket_service_base::cancel(
     return ec;
   }
 
-  ASIO_HANDLER_OPERATION(("socket", &impl, "cancel"));
+  ASIO_HANDLER_OPERATION((reactor_.context(),
+        "socket", &impl, impl.socket_, "cancel"));
 
   reactor_.cancel_ops(impl.socket_, impl.reactor_data_);
   ec = asio::error_code();
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/resolver_service_base.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/resolver_service_base.ipp
index 0e8e847..5899db5 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/resolver_service_base.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/resolver_service_base.ipp
@@ -2,7 +2,7 @@
 // detail/impl/resolver_service_base.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -23,62 +23,62 @@
 namespace asio {
 namespace detail {
 
-class resolver_service_base::work_io_service_runner
+class resolver_service_base::work_io_context_runner
 {
 public:
-  work_io_service_runner(asio::io_service& io_service)
-    : io_service_(io_service) {}
-  void operator()() { io_service_.run(); }
+  work_io_context_runner(asio::io_context& io_context)
+    : io_context_(io_context) {}
+  void operator()() { io_context_.run(); }
 private:
-  asio::io_service& io_service_;
+  asio::io_context& io_context_;
 };
 
 resolver_service_base::resolver_service_base(
-    asio::io_service& io_service)
-  : io_service_impl_(asio::use_service<io_service_impl>(io_service)),
-    work_io_service_(new asio::io_service),
-    work_io_service_impl_(asio::use_service<
-        io_service_impl>(*work_io_service_)),
-    work_(new asio::io_service::work(*work_io_service_)),
+    asio::io_context& io_context)
+  : io_context_impl_(asio::use_service<io_context_impl>(io_context)),
+    work_io_context_(new asio::io_context(-1)),
+    work_io_context_impl_(asio::use_service<
+        io_context_impl>(*work_io_context_)),
+    work_(asio::make_work_guard(*work_io_context_)),
     work_thread_(0)
 {
 }
 
 resolver_service_base::~resolver_service_base()
 {
-  shutdown_service();
+  base_shutdown();
 }
 
-void resolver_service_base::shutdown_service()
+void resolver_service_base::base_shutdown()
 {
   work_.reset();
-  if (work_io_service_.get())
+  if (work_io_context_.get())
   {
-    work_io_service_->stop();
+    work_io_context_->stop();
     if (work_thread_.get())
     {
       work_thread_->join();
       work_thread_.reset();
     }
-    work_io_service_.reset();
+    work_io_context_.reset();
   }
 }
 
-void resolver_service_base::fork_service(
-    asio::io_service::fork_event fork_ev)
+void resolver_service_base::base_notify_fork(
+    asio::io_context::fork_event fork_ev)
 {
   if (work_thread_.get())
   {
-    if (fork_ev == asio::io_service::fork_prepare)
+    if (fork_ev == asio::io_context::fork_prepare)
     {
-      work_io_service_->stop();
+      work_io_context_->stop();
       work_thread_->join();
     }
     else
     {
-      work_io_service_->restart();
+      work_io_context_->restart();
       work_thread_.reset(new asio::detail::thread(
-            work_io_service_runner(*work_io_service_)));
+            work_io_context_runner(*work_io_context_)));
     }
   }
 }
@@ -92,24 +92,48 @@ void resolver_service_base::construct(
 void resolver_service_base::destroy(
     resolver_service_base::implementation_type& impl)
 {
-  ASIO_HANDLER_OPERATION(("resolver", &impl, "cancel"));
+  ASIO_HANDLER_OPERATION((io_context_impl_.context(),
+        "resolver", &impl, 0, "cancel"));
 
   impl.reset();
 }
 
+void resolver_service_base::move_construct(implementation_type& impl,
+    implementation_type& other_impl)
+{
+  impl = ASIO_MOVE_CAST(implementation_type)(other_impl);
+}
+
+void resolver_service_base::move_assign(implementation_type& impl,
+    resolver_service_base&, implementation_type& other_impl)
+{
+  destroy(impl);
+  impl = ASIO_MOVE_CAST(implementation_type)(other_impl);
+}
+
 void resolver_service_base::cancel(
     resolver_service_base::implementation_type& impl)
 {
-  ASIO_HANDLER_OPERATION(("resolver", &impl, "cancel"));
+  ASIO_HANDLER_OPERATION((io_context_impl_.context(),
+        "resolver", &impl, 0, "cancel"));
 
   impl.reset(static_cast<void*>(0), socket_ops::noop_deleter());
 }
 
-void resolver_service_base::start_resolve_op(operation* op)
+void resolver_service_base::start_resolve_op(resolve_op* op)
 {
-  start_work_thread();
-  io_service_impl_.work_started();
-  work_io_service_impl_.post_immediate_completion(op, false);
+  if (ASIO_CONCURRENCY_HINT_IS_LOCKING(SCHEDULER,
+        io_context_impl_.concurrency_hint()))
+  {
+    start_work_thread();
+    io_context_impl_.work_started();
+    work_io_context_impl_.post_immediate_completion(op, false);
+  }
+  else
+  {
+    op->ec_ = asio::error::operation_not_supported;
+    io_context_impl_.post_immediate_completion(op, false);
+  }
 }
 
 void resolver_service_base::start_work_thread()
@@ -118,7 +142,7 @@ void resolver_service_base::start_work_thread()
   if (!work_thread_.get())
   {
     work_thread_.reset(new asio::detail::thread(
-          work_io_service_runner(*work_io_service_)));
+          work_io_context_runner(*work_io_context_)));
   }
 }
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/scheduler.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/scheduler.ipp
index 8145651..1b20465 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/scheduler.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/scheduler.ipp
@@ -2,7 +2,7 @@
 // detail/impl/scheduler.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,6 +17,7 @@
 
 #include "asio/detail/config.hpp"
 
+#include "asio/detail/concurrency_hint.hpp"
 #include "asio/detail/event.hpp"
 #include "asio/detail/limits.hpp"
 #include "asio/detail/reactor.hpp"
@@ -84,20 +85,24 @@ struct scheduler::work_cleanup
 };
 
 scheduler::scheduler(
-    asio::execution_context& ctx, std::size_t concurrency_hint)
+    asio::execution_context& ctx, int concurrency_hint)
   : asio::detail::execution_context_service_base<scheduler>(ctx),
-    one_thread_(concurrency_hint == 1),
-    mutex_(),
+    one_thread_(concurrency_hint == 1
+        || !ASIO_CONCURRENCY_HINT_IS_LOCKING(
+          SCHEDULER, concurrency_hint)),
+    mutex_(ASIO_CONCURRENCY_HINT_IS_LOCKING(
+          SCHEDULER, concurrency_hint)),
     task_(0),
     task_interrupted_(true),
     outstanding_work_(0),
     stopped_(false),
-    shutdown_(false)
+    shutdown_(false),
+    concurrency_hint_(concurrency_hint)
 {
   ASIO_HANDLER_TRACKING_INIT;
 }
 
-void scheduler::shutdown_service()
+void scheduler::shutdown()
 {
   mutex::scoped_lock lock(mutex_);
   shutdown_ = true;
@@ -167,6 +172,24 @@ std::size_t scheduler::run_one(asio::error_code& ec)
   return do_run_one(lock, this_thread, ec);
 }
 
+std::size_t scheduler::wait_one(long usec, asio::error_code& ec)
+{
+  ec = asio::error_code();
+  if (outstanding_work_ == 0)
+  {
+    stop();
+    return 0;
+  }
+
+  thread_info this_thread;
+  this_thread.private_outstanding_work = 0;
+  thread_call_stack::context ctx(this, this_thread);
+
+  mutex::scoped_lock lock(mutex_);
+
+  return do_wait_one(lock, this_thread, usec, ec);
+}
+
 std::size_t scheduler::poll(asio::error_code& ec)
 {
   ec = asio::error_code();
@@ -243,6 +266,12 @@ void scheduler::restart()
   stopped_ = false;
 }
 
+void scheduler::compensating_work_started()
+{
+  thread_info_base* this_thread = thread_call_stack::contains(this);
+  ++static_cast<thread_info*>(this_thread)->private_outstanding_work;
+}
+
 void scheduler::post_immediate_completion(
     scheduler::operation* op, bool is_continuation)
 {
@@ -350,7 +379,7 @@ std::size_t scheduler::do_run_one(mutex::scoped_lock& lock,
         // Run the task. May throw an exception. Only block if the operation
         // queue is empty and we're not polling, otherwise we want to return
         // as soon as possible.
-        task_->run(!more_handlers, this_thread.private_op_queue);
+        task_->run(more_handlers ? 0 : -1, this_thread.private_op_queue);
       }
       else
       {
@@ -381,6 +410,76 @@ std::size_t scheduler::do_run_one(mutex::scoped_lock& lock,
   return 0;
 }
 
+std::size_t scheduler::do_wait_one(mutex::scoped_lock& lock,
+    scheduler::thread_info& this_thread, long usec,
+    const asio::error_code& ec)
+{
+  if (stopped_)
+    return 0;
+
+  operation* o = op_queue_.front();
+  if (o == 0)
+  {
+    wakeup_event_.clear(lock);
+    wakeup_event_.wait_for_usec(lock, usec);
+    usec = 0; // Wait at most once.
+    o = op_queue_.front();
+  }
+
+  if (o == &task_operation_)
+  {
+    op_queue_.pop();
+    bool more_handlers = (!op_queue_.empty());
+
+    task_interrupted_ = more_handlers;
+
+    if (more_handlers && !one_thread_)
+      wakeup_event_.unlock_and_signal_one(lock);
+    else
+      lock.unlock();
+
+    {
+      task_cleanup on_exit = { this, &lock, &this_thread };
+      (void)on_exit;
+
+      // Run the task. May throw an exception. Only block if the operation
+      // queue is empty and we're not polling, otherwise we want to return
+      // as soon as possible.
+      task_->run(more_handlers ? 0 : usec, this_thread.private_op_queue);
+    }
+
+    o = op_queue_.front();
+    if (o == &task_operation_)
+    {
+      if (!one_thread_)
+        wakeup_event_.maybe_unlock_and_signal_one(lock);
+      return 0;
+    }
+  }
+
+  if (o == 0)
+    return 0;
+
+  op_queue_.pop();
+  bool more_handlers = (!op_queue_.empty());
+
+  std::size_t task_result = o->task_result_;
+
+  if (more_handlers && !one_thread_)
+    wake_one_thread_and_unlock(lock);
+  else
+    lock.unlock();
+
+  // Ensure the count of outstanding work is decremented on block exit.
+  work_cleanup on_exit = { this, &lock, &this_thread };
+  (void)on_exit;
+
+  // Complete the operation. May throw an exception. Deletes the object.
+  o->complete(this, ec, task_result);
+
+  return 1;
+}
+
 std::size_t scheduler::do_poll_one(mutex::scoped_lock& lock,
     scheduler::thread_info& this_thread,
     const asio::error_code& ec)
@@ -401,7 +500,7 @@ std::size_t scheduler::do_poll_one(mutex::scoped_lock& lock,
       // Run the task. May throw an exception. Only block if the operation
       // queue is empty and we're not polling, otherwise we want to return
       // as soon as possible.
-      task_->run(false, this_thread.private_op_queue);
+      task_->run(0, this_thread.private_op_queue);
     }
 
     o = op_queue_.front();
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/select_reactor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/select_reactor.hpp
index 4fb58f4..04e17f8 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/select_reactor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/select_reactor.hpp
@@ -2,7 +2,7 @@
 // detail/impl/select_reactor.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/select_reactor.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/select_reactor.ipp
index cb0eef3..dc0737b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/select_reactor.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/select_reactor.ipp
@@ -2,7 +2,7 @@
 // detail/impl/select_reactor.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -71,10 +71,10 @@ select_reactor::select_reactor(asio::execution_context& ctx)
 
 select_reactor::~select_reactor()
 {
-  shutdown_service();
+  shutdown();
 }
 
-void select_reactor::shutdown_service()
+void select_reactor::shutdown()
 {
   asio::detail::mutex::scoped_lock lock(mutex_);
   shutdown_ = true;
@@ -103,7 +103,7 @@ void select_reactor::shutdown_service()
   scheduler_.abandon_operations(ops);
 }
 
-void select_reactor::fork_service(
+void select_reactor::notify_fork(
     asio::execution_context::fork_event fork_ev)
 {
   if (fork_ev == asio::execution_context::fork_child)
@@ -180,7 +180,7 @@ void select_reactor::deregister_internal_descriptor(
     op_queue_[i].cancel_operations(descriptor, ops);
 }
 
-void select_reactor::run(bool block, op_queue<operation>& ops)
+void select_reactor::run(long usec, op_queue<operation>& ops)
 {
   asio::detail::mutex::scoped_lock lock(mutex_);
 
@@ -217,12 +217,12 @@ void select_reactor::run(bool block, op_queue<operation>& ops)
 
   // We can return immediately if there's no work to do and the reactor is
   // not supposed to block.
-  if (!block && !have_work_to_do)
+  if (!usec && !have_work_to_do)
     return;
 
   // Determine how long to block while waiting for events.
   timeval tv_buf = { 0, 0 };
-  timeval* tv = block ? get_timeout(tv_buf) : &tv_buf;
+  timeval* tv = usec ? get_timeout(usec, tv_buf) : &tv_buf;
 
   lock.unlock();
 
@@ -289,11 +289,13 @@ void select_reactor::do_remove_timer_queue(timer_queue_base& queue)
   timer_queues_.erase(&queue);
 }
 
-timeval* select_reactor::get_timeout(timeval& tv)
+timeval* select_reactor::get_timeout(long usec, timeval& tv)
 {
   // By default we will wait no longer than 5 minutes. This will ensure that
   // any changes to the system clock are detected after no longer than this.
-  long usec = timer_queues_.wait_duration_usec(5 * 60 * 1000 * 1000);
+  const long max_usec = 5 * 60 * 1000 * 1000;
+  usec = timer_queues_.wait_duration_usec(
+      (usec < 0 || max_usec < usec) ? max_usec : usec);
   tv.tv_sec = usec / 1000000;
   tv.tv_usec = usec % 1000000;
   return &tv;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/service_registry.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/service_registry.hpp
index a6c1d9c..1b735e1 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/service_registry.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/service_registry.hpp
@@ -2,7 +2,7 @@
 // detail/impl/service_registry.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -24,17 +24,17 @@ template <typename Service>
 Service& service_registry::use_service()
 {
   execution_context::service::key key;
-  init_key(key, Service::id);
+  init_key<Service>(key, 0);
   factory_type factory = &service_registry::create<Service, execution_context>;
   return *static_cast<Service*>(do_use_service(key, factory, &owner_));
 }
 
 template <typename Service>
-Service& service_registry::use_service(io_service& owner)
+Service& service_registry::use_service(io_context& owner)
 {
   execution_context::service::key key;
-  init_key(key, Service::id);
-  factory_type factory = &service_registry::create<Service, io_service>;
+  init_key<Service>(key, 0);
+  factory_type factory = &service_registry::create<Service, io_context>;
   return *static_cast<Service*>(do_use_service(key, factory, &owner));
 }
 
@@ -42,7 +42,7 @@ template <typename Service>
 void service_registry::add_service(Service* new_service)
 {
   execution_context::service::key key;
-  init_key(key, Service::id);
+  init_key<Service>(key, 0);
   return do_add_service(key, new_service);
 }
 
@@ -50,13 +50,29 @@ template <typename Service>
 bool service_registry::has_service() const
 {
   execution_context::service::key key;
-  init_key(key, Service::id);
+  init_key<Service>(key, 0);
   return do_has_service(key);
 }
 
+template <typename Service>
+inline void service_registry::init_key(
+    execution_context::service::key& key, ...)
+{
+  init_key_from_id(key, Service::id);
+}
+
 #if !defined(ASIO_NO_TYPEID)
 template <typename Service>
 void service_registry::init_key(execution_context::service::key& key,
+    typename enable_if<
+      is_base_of<typename Service::key_type, Service>::value>::type*)
+{
+  key.type_info_ = &typeid(typeid_wrapper<Service>);
+  key.id_ = 0;
+}
+
+template <typename Service>
+void service_registry::init_key_from_id(execution_context::service::key& key,
     const service_id<Service>& /*id*/)
 {
   key.type_info_ = &typeid(typeid_wrapper<Service>);
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/service_registry.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/service_registry.ipp
index a54e96d..ef1955f 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/service_registry.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/service_registry.ipp
@@ -2,7 +2,7 @@
 // detail/impl/service_registry.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -40,7 +40,7 @@ void service_registry::shutdown_services()
   execution_context::service* service = first_service_;
   while (service)
   {
-    service->shutdown_service();
+    service->shutdown();
     service = service->next_;
   }
 }
@@ -78,13 +78,13 @@ void service_registry::notify_fork(execution_context::fork_event fork_ev)
   std::size_t num_services = services.size();
   if (fork_ev == execution_context::fork_prepare)
     for (std::size_t i = 0; i < num_services; ++i)
-      services[i]->fork_service(fork_ev);
+      services[i]->notify_fork(fork_ev);
   else
     for (std::size_t i = num_services; i > 0; --i)
-      services[i - 1]->fork_service(fork_ev);
+      services[i - 1]->notify_fork(fork_ev);
 }
 
-void service_registry::init_key(execution_context::service::key& key,
+void service_registry::init_key_from_id(execution_context::service::key& key,
     const execution_context::id& id)
 {
   key.type_info_ = 0;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/signal_set_service.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/signal_set_service.ipp
index 72516b3..114a0b1 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/signal_set_service.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/signal_set_service.ipp
@@ -2,7 +2,7 @@
 // detail/impl/signal_set_service.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -18,10 +18,12 @@
 #include "asio/detail/config.hpp"
 
 #include <cstring>
+#include <stdexcept>
 #include "asio/detail/reactor.hpp"
 #include "asio/detail/signal_blocker.hpp"
 #include "asio/detail/signal_set_service.hpp"
 #include "asio/detail/static_mutex.hpp"
+#include "asio/detail/throw_exception.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -91,7 +93,7 @@ public:
   {
   }
 
-  static bool do_perform(reactor_op*)
+  static status do_perform(reactor_op*)
   {
     signal_state* state = get_signal_state();
 
@@ -101,7 +103,7 @@ public:
       if (signal_number >= 0 && signal_number < max_signal_number)
         signal_set_service::deliver_signal(signal_number);
 
-    return false;
+    return not_done;
   }
 
   static void do_complete(void* /*owner*/, operation* base,
@@ -117,12 +119,13 @@ public:
        //   && !defined(__CYGWIN__)
 
 signal_set_service::signal_set_service(
-    asio::io_service& io_service)
-  : io_service_(asio::use_service<io_service_impl>(io_service)),
+    asio::io_context& io_context)
+  : service_base<signal_set_service>(io_context),
+    io_context_(asio::use_service<io_context_impl>(io_context)),
 #if !defined(ASIO_WINDOWS) \
   && !defined(ASIO_WINDOWS_RUNTIME) \
   && !defined(__CYGWIN__)
-    reactor_(asio::use_service<reactor>(io_service)),
+    reactor_(asio::use_service<reactor>(io_context)),
 #endif // !defined(ASIO_WINDOWS)
        //   && !defined(ASIO_WINDOWS_RUNTIME)
        //   && !defined(__CYGWIN__)
@@ -150,7 +153,7 @@ signal_set_service::~signal_set_service()
   remove_service(this);
 }
 
-void signal_set_service::shutdown_service()
+void signal_set_service::shutdown()
 {
   remove_service(this);
 
@@ -166,11 +169,11 @@ void signal_set_service::shutdown_service()
     }
   }
 
-  io_service_.abandon_operations(ops);
+  io_context_.abandon_operations(ops);
 }
 
-void signal_set_service::fork_service(
-    asio::io_service::fork_event fork_ev)
+void signal_set_service::notify_fork(
+    asio::io_context::fork_event fork_ev)
 {
 #if !defined(ASIO_WINDOWS) \
   && !defined(ASIO_WINDOWS_RUNTIME) \
@@ -180,7 +183,7 @@ void signal_set_service::fork_service(
 
   switch (fork_ev)
   {
-  case asio::io_service::fork_prepare:
+  case asio::io_context::fork_prepare:
     {
       int read_descriptor = state->read_descriptor_;
       state->fork_prepared_ = true;
@@ -188,7 +191,7 @@ void signal_set_service::fork_service(
       reactor_.deregister_internal_descriptor(read_descriptor, reactor_data_);
     }
     break;
-  case asio::io_service::fork_parent:
+  case asio::io_context::fork_parent:
     if (state->fork_prepared_)
     {
       int read_descriptor = state->read_descriptor_;
@@ -198,7 +201,7 @@ void signal_set_service::fork_service(
           read_descriptor, reactor_data_, new pipe_read_op);
     }
     break;
-  case asio::io_service::fork_child:
+  case asio::io_context::fork_child:
     if (state->fork_prepared_)
     {
       asio::detail::signal_blocker blocker;
@@ -437,7 +440,8 @@ asio::error_code signal_set_service::cancel(
     signal_set_service::implementation_type& impl,
     asio::error_code& ec)
 {
-  ASIO_HANDLER_OPERATION(("signal_set", &impl, "cancel"));
+  ASIO_HANDLER_OPERATION((io_context_.context(),
+        "signal_set", &impl, 0, "cancel"));
 
   op_queue<operation> ops;
   {
@@ -452,7 +456,7 @@ asio::error_code signal_set_service::cancel(
     }
   }
 
-  io_service_.post_deferred_completions(ops);
+  io_context_.post_deferred_completions(ops);
 
   ec = asio::error_code();
   return ec;
@@ -488,7 +492,7 @@ void signal_set_service::deliver_signal(int signal_number)
       reg = reg->next_in_table_;
     }
 
-    service->io_service_.post_deferred_completions(ops);
+    service->io_context_.post_deferred_completions(ops);
 
     service = service->next_;
   }
@@ -505,6 +509,22 @@ void signal_set_service::add_service(signal_set_service* service)
     open_descriptors();
 #endif // !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
 
+  // If an io_context object is thread-unsafe then it must be the only
+  // io_context used to create signal_set objects.
+  if (state->service_list_ != 0)
+  {
+    if (!ASIO_CONCURRENCY_HINT_IS_LOCKING(SCHEDULER,
+          service->io_context_.concurrency_hint())
+        || !ASIO_CONCURRENCY_HINT_IS_LOCKING(SCHEDULER,
+          state->service_list_->io_context_.concurrency_hint()))
+    {
+      std::logic_error ex(
+          "Thread-unsafe io_context objects require "
+          "exclusive access to signal handling.");
+      asio::detail::throw_exception(ex);
+    }
+  }
+
   // Insert service into linked list of all services.
   service->next_ = state->service_list_;
   service->prev_ = 0;
@@ -617,7 +637,7 @@ void signal_set_service::close_descriptors()
 void signal_set_service::start_wait_op(
     signal_set_service::implementation_type& impl, signal_op* op)
 {
-  io_service_.work_started();
+  io_context_.work_started();
 
   signal_state* state = get_signal_state();
   static_mutex::scoped_lock lock(state->mutex_);
@@ -629,7 +649,7 @@ void signal_set_service::start_wait_op(
     {
       --reg->undelivered_;
       op->signal_number_ = reg->signal_number_;
-      io_service_.post_deferred_completion(op);
+      io_context_.post_deferred_completion(op);
       return;
     }
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/socket_ops.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/socket_ops.ipp
index d4f0e0b..d9cc1c9 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/socket_ops.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/socket_ops.ipp
@@ -2,7 +2,7 @@
 // detail/impl/socket_ops.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -168,7 +168,7 @@ socket_type sync_accept(socket_type s, state_type state,
       return invalid_socket;
 
     // Wait for socket to become ready.
-    if (socket_ops::poll_read(s, 0, ec) < 0)
+    if (socket_ops::poll_read(s, 0, -1, ec) < 0)
       return invalid_socket;
   }
 }
@@ -505,7 +505,7 @@ void sync_connect(socket_type s, const socket_addr_type* addr,
   }
 
   // Wait for socket to become ready.
-  if (socket_ops::poll_connect(s, ec) < 0)
+  if (socket_ops::poll_connect(s, -1, ec) < 0)
     return;
 
   // Get the error code from the connect operation.
@@ -827,7 +827,7 @@ size_t sync_recv(socket_type s, state_type state, buf* bufs,
       return 0;
 
     // Wait for socket to become ready.
-    if (socket_ops::poll_read(s, 0, ec) < 0)
+    if (socket_ops::poll_read(s, 0, -1, ec) < 0)
       return 0;
   }
 }
@@ -966,7 +966,7 @@ size_t sync_recvfrom(socket_type s, state_type state, buf* bufs,
       return 0;
 
     // Wait for socket to become ready.
-    if (socket_ops::poll_read(s, 0, ec) < 0)
+    if (socket_ops::poll_read(s, 0, -1, ec) < 0)
       return 0;
   }
 }
@@ -1079,7 +1079,7 @@ size_t sync_recvmsg(socket_type s, state_type state,
       return 0;
 
     // Wait for socket to become ready.
-    if (socket_ops::poll_read(s, 0, ec) < 0)
+    if (socket_ops::poll_read(s, 0, -1, ec) < 0)
       return 0;
   }
 }
@@ -1206,7 +1206,7 @@ size_t sync_send(socket_type s, state_type state, const buf* bufs,
       return 0;
 
     // Wait for socket to become ready.
-    if (socket_ops::poll_write(s, 0, ec) < 0)
+    if (socket_ops::poll_write(s, 0, -1, ec) < 0)
       return 0;
   }
 }
@@ -1330,7 +1330,7 @@ size_t sync_sendto(socket_type s, state_type state, const buf* bufs,
       return 0;
 
     // Wait for socket to become ready.
-    if (socket_ops::poll_write(s, 0, ec) < 0)
+    if (socket_ops::poll_write(s, 0, -1, ec) < 0)
       return 0;
   }
 }
@@ -1633,7 +1633,8 @@ int getpeername(socket_type s, socket_addr_type* addr,
     return socket_error_retval;
   }
 
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
+#if defined(ASIO_WINDOWS) && !defined(ASIO_WINDOWS_APP) \
+  || defined(__CYGWIN__)
   if (cached)
   {
     // Check if socket is still connected.
@@ -1654,9 +1655,11 @@ int getpeername(socket_type s, socket_addr_type* addr,
     ec = asio::error_code();
     return 0;
   }
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
+#else // defined(ASIO_WINDOWS) && !defined(ASIO_WINDOWS_APP)
+      // || defined(__CYGWIN__)
   (void)cached;
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
+#endif // defined(ASIO_WINDOWS) && !defined(ASIO_WINDOWS_APP)
+       // || defined(__CYGWIN__)
 
   clear_last_error();
   int result = error_wrapper(call_getpeername(
@@ -1781,7 +1784,8 @@ int select(int nfds, fd_set* readfds, fd_set* writefds,
 #endif
 }
 
-int poll_read(socket_type s, state_type state, asio::error_code& ec)
+int poll_read(socket_type s, state_type state,
+    int msec, asio::error_code& ec)
 {
   if (s == invalid_socket)
   {
@@ -1795,10 +1799,22 @@ int poll_read(socket_type s, state_type state, asio::error_code& ec)
   fd_set fds;
   FD_ZERO(&fds);
   FD_SET(s, &fds);
-  timeval zero_timeout;
-  zero_timeout.tv_sec = 0;
-  zero_timeout.tv_usec = 0;
-  timeval* timeout = (state & user_set_non_blocking) ? &zero_timeout : 0;
+  timeval timeout_obj;
+  timeval* timeout;
+  if (state & user_set_non_blocking)
+  {
+    timeout_obj.tv_sec = 0;
+    timeout_obj.tv_usec = 0;
+    timeout = &timeout_obj;
+  }
+  else if (msec >= 0)
+  {
+    timeout_obj.tv_sec = msec / 1000;
+    timeout_obj.tv_usec = (msec % 1000) * 1000;
+    timeout = &timeout_obj;
+  }
+  else
+    timeout = 0;
   clear_last_error();
   int result = error_wrapper(::select(s + 1, &fds, 0, 0, timeout), ec);
 #else // defined(ASIO_WINDOWS)
@@ -1808,7 +1824,7 @@ int poll_read(socket_type s, state_type state, asio::error_code& ec)
   fds.fd = s;
   fds.events = POLLIN;
   fds.revents = 0;
-  int timeout = (state & user_set_non_blocking) ? 0 : -1;
+  int timeout = (state & user_set_non_blocking) ? 0 : msec;
   clear_last_error();
   int result = error_wrapper(::poll(&fds, 1, timeout), ec);
 #endif // defined(ASIO_WINDOWS)
@@ -1822,7 +1838,8 @@ int poll_read(socket_type s, state_type state, asio::error_code& ec)
   return result;
 }
 
-int poll_write(socket_type s, state_type state, asio::error_code& ec)
+int poll_write(socket_type s, state_type state,
+    int msec, asio::error_code& ec)
 {
   if (s == invalid_socket)
   {
@@ -1836,10 +1853,22 @@ int poll_write(socket_type s, state_type state, asio::error_code& ec)
   fd_set fds;
   FD_ZERO(&fds);
   FD_SET(s, &fds);
-  timeval zero_timeout;
-  zero_timeout.tv_sec = 0;
-  zero_timeout.tv_usec = 0;
-  timeval* timeout = (state & user_set_non_blocking) ? &zero_timeout : 0;
+  timeval timeout_obj;
+  timeval* timeout;
+  if (state & user_set_non_blocking)
+  {
+    timeout_obj.tv_sec = 0;
+    timeout_obj.tv_usec = 0;
+    timeout = &timeout_obj;
+  }
+  else if (msec >= 0)
+  {
+    timeout_obj.tv_sec = msec / 1000;
+    timeout_obj.tv_usec = (msec % 1000) * 1000;
+    timeout = &timeout_obj;
+  }
+  else
+    timeout = 0;
   clear_last_error();
   int result = error_wrapper(::select(s + 1, 0, &fds, 0, timeout), ec);
 #else // defined(ASIO_WINDOWS)
@@ -1849,7 +1878,7 @@ int poll_write(socket_type s, state_type state, asio::error_code& ec)
   fds.fd = s;
   fds.events = POLLOUT;
   fds.revents = 0;
-  int timeout = (state & user_set_non_blocking) ? 0 : -1;
+  int timeout = (state & user_set_non_blocking) ? 0 : msec;
   clear_last_error();
   int result = error_wrapper(::poll(&fds, 1, timeout), ec);
 #endif // defined(ASIO_WINDOWS)
@@ -1863,7 +1892,8 @@ int poll_write(socket_type s, state_type state, asio::error_code& ec)
   return result;
 }
 
-int poll_error(socket_type s, state_type state, asio::error_code& ec)
+int poll_error(socket_type s, state_type state,
+    int msec, asio::error_code& ec)
 {
   if (s == invalid_socket)
   {
@@ -1877,10 +1907,22 @@ int poll_error(socket_type s, state_type state, asio::error_code& ec)
   fd_set fds;
   FD_ZERO(&fds);
   FD_SET(s, &fds);
-  timeval zero_timeout;
-  zero_timeout.tv_sec = 0;
-  zero_timeout.tv_usec = 0;
-  timeval* timeout = (state & user_set_non_blocking) ? &zero_timeout : 0;
+  timeval timeout_obj;
+  timeval* timeout;
+  if (state & user_set_non_blocking)
+  {
+    timeout_obj.tv_sec = 0;
+    timeout_obj.tv_usec = 0;
+    timeout = &timeout_obj;
+  }
+  else if (msec >= 0)
+  {
+    timeout_obj.tv_sec = msec / 1000;
+    timeout_obj.tv_usec = (msec % 1000) * 1000;
+    timeout = &timeout_obj;
+  }
+  else
+    timeout = 0;
   clear_last_error();
   int result = error_wrapper(::select(s + 1, 0, 0, &fds, timeout), ec);
 #else // defined(ASIO_WINDOWS)
@@ -1890,7 +1932,7 @@ int poll_error(socket_type s, state_type state, asio::error_code& ec)
   fds.fd = s;
   fds.events = POLLPRI | POLLERR | POLLHUP;
   fds.revents = 0;
-  int timeout = (state & user_set_non_blocking) ? 0 : -1;
+  int timeout = (state & user_set_non_blocking) ? 0 : msec;
   clear_last_error();
   int result = error_wrapper(::poll(&fds, 1, timeout), ec);
 #endif // defined(ASIO_WINDOWS)
@@ -1904,7 +1946,7 @@ int poll_error(socket_type s, state_type state, asio::error_code& ec)
   return result;
 }
 
-int poll_connect(socket_type s, asio::error_code& ec)
+int poll_connect(socket_type s, int msec, asio::error_code& ec)
 {
   if (s == invalid_socket)
   {
@@ -1921,9 +1963,19 @@ int poll_connect(socket_type s, asio::error_code& ec)
   fd_set except_fds;
   FD_ZERO(&except_fds);
   FD_SET(s, &except_fds);
+  timeval timeout_obj;
+  timeval* timeout;
+  if (msec >= 0)
+  {
+    timeout_obj.tv_sec = msec / 1000;
+    timeout_obj.tv_usec = (msec % 1000) * 1000;
+    timeout = &timeout_obj;
+  }
+  else
+    timeout = 0;
   clear_last_error();
   int result = error_wrapper(::select(
-        s + 1, 0, &write_fds, &except_fds, 0), ec);
+        s + 1, 0, &write_fds, &except_fds, timeout), ec);
   if (result >= 0)
     ec = asio::error_code();
   return result;
@@ -1935,7 +1987,7 @@ int poll_connect(socket_type s, asio::error_code& ec)
   fds.events = POLLOUT;
   fds.revents = 0;
   clear_last_error();
-  int result = error_wrapper(::poll(&fds, 1, -1), ec);
+  int result = error_wrapper(::poll(&fds, 1, msec), ec);
   if (result >= 0)
     ec = asio::error_code();
   return result;
@@ -2272,14 +2324,34 @@ int inet_pton(int af, const char* src, void* dest,
 
   return result == socket_error_retval ? -1 : 1;
 #else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  int result = error_wrapper(::inet_pton(af, src, dest), ec);
+  using namespace std; // For strchr, memcpy and atoi.
+
+  // On some platforms, inet_pton fails if an address string contains a scope
+  // id. Detect and remove the scope id before passing the string to inet_pton.
+  const bool is_v6 = (af == ASIO_OS_DEF(AF_INET6));
+  const char* if_name = is_v6 ? strchr(src, '%') : 0;
+  char src_buf[max_addr_v6_str_len + 1];
+  const char* src_ptr = src;
+  if (if_name != 0)
+  {
+    if (if_name - src > max_addr_v6_str_len)
+    {
+      ec = asio::error::invalid_argument;
+      return 0;
+    }
+    memcpy(src_buf, src, if_name - src);
+    src_buf[if_name - src] = 0;
+    src_ptr = src_buf;
+  }
+
+  int result = error_wrapper(::inet_pton(af, src_ptr, dest), ec);
   if (result <= 0 && !ec)
     ec = asio::error::invalid_argument;
-  if (result > 0 && af == ASIO_OS_DEF(AF_INET6) && scope_id)
+  if (result > 0 && is_v6 && scope_id)
   {
     using namespace std; // For strchr and atoi.
     *scope_id = 0;
-    if (const char* if_name = strchr(src, '%'))
+    if (if_name != 0)
     {
       in6_addr_type* ipv6_address = static_cast<in6_addr_type*>(dest);
       bool is_link_local = ((ipv6_address->s6_addr[0] == 0xfe)
@@ -2601,7 +2673,8 @@ inline void gai_strcpy(char* target, const char* source, std::size_t max_size)
   strcpy_s(target, max_size, source);
 #else // defined(ASIO_HAS_SECURE_RTL)
   *target = 0;
-  strncat(target, source, max_size);
+  if (max_size > 0)
+    strncat(target, source, max_size - 1);
 #endif // defined(ASIO_HAS_SECURE_RTL)
 }
 
@@ -3424,8 +3497,8 @@ u_short_type network_to_host_short(u_short_type value)
 {
 #if defined(ASIO_WINDOWS_RUNTIME)
   unsigned char* value_p = reinterpret_cast<unsigned char*>(&value);
-  u_short_type result = (static_cast<u_long_type>(value_p[0]) << 8)
-    | static_cast<u_long_type>(value_p[1]);
+  u_short_type result = (static_cast<u_short_type>(value_p[0]) << 8)
+    | static_cast<u_short_type>(value_p[1]);
   return result;
 #else // defined(ASIO_WINDOWS_RUNTIME)
   return ntohs(value);
@@ -3435,7 +3508,7 @@ u_short_type network_to_host_short(u_short_type value)
 u_short_type host_to_network_short(u_short_type value)
 {
 #if defined(ASIO_WINDOWS_RUNTIME)
-  u_long_type result;
+  u_short_type result;
   unsigned char* result_p = reinterpret_cast<unsigned char*>(&result);
   result_p[0] = static_cast<unsigned char>((value >> 8) & 0xFF);
   result_p[1] = static_cast<unsigned char>(value & 0xFF);
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/socket_select_interrupter.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/socket_select_interrupter.ipp
index 21c0fbc..2f4d377 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/socket_select_interrupter.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/socket_select_interrupter.ipp
@@ -2,7 +2,7 @@
 // detail/impl/socket_select_interrupter.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -71,7 +71,8 @@ void socket_select_interrupter::open_descriptors()
   // Some broken firewalls on Windows will intermittently cause getsockname to
   // return 0.0.0.0 when the socket is actually bound to 127.0.0.1. We
   // explicitly specify the target address here to work around this problem.
-  addr.sin_addr.s_addr = socket_ops::host_to_network_long(INADDR_LOOPBACK);
+  if (addr.sin_addr.s_addr == socket_ops::host_to_network_long(INADDR_ANY))
+    addr.sin_addr.s_addr = socket_ops::host_to_network_long(INADDR_LOOPBACK);
 
   if (socket_ops::listen(acceptor.get(),
         SOMAXCONN, ec) == socket_error_retval)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/strand_executor_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/strand_executor_service.hpp
index 20cc24c..fedea1c 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/strand_executor_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/strand_executor_service.hpp
@@ -2,7 +2,7 @@
 // detail/impl/strand_executor_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -19,7 +19,7 @@
 #include "asio/detail/fenced_block.hpp"
 #include "asio/detail/handler_invoke_helpers.hpp"
 #include "asio/detail/recycling_allocator.hpp"
-#include "asio/executor_work.hpp"
+#include "asio/executor_work_guard.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -45,7 +45,7 @@ public:
 #if defined(ASIO_HAS_MOVE)
   invoker(invoker&& other)
     : impl_(ASIO_MOVE_CAST(implementation_type)(other.impl_)),
-      work_(ASIO_MOVE_CAST(executor_work<Executor>)(other.work_))
+      work_(ASIO_MOVE_CAST(executor_work_guard<Executor>)(other.work_))
   {
   }
 #endif // defined(ASIO_HAS_MOVE)
@@ -92,7 +92,7 @@ public:
 
 private:
   implementation_type impl_;
-  executor_work<Executor> work_;
+  executor_work_guard<Executor> work_;
 };
 
 template <typename Executor, typename Function, typename Allocator>
@@ -121,7 +121,8 @@ void strand_executor_service::dispatch(const implementation_type& impl,
   p.v = p.a.allocate(1);
   p.p = new (p.v) op(tmp, allocator);
 
-  ASIO_HANDLER_CREATION((p.p, "strand_executor", this, "dispatch"));
+  ASIO_HANDLER_CREATION((impl->service_->context(), *p.p,
+        "strand_executor", impl.get(), 0, "dispatch"));
 
   // Add the function to the strand and schedule the strand if required.
   bool first = enqueue(impl, p.p);
@@ -149,7 +150,8 @@ void strand_executor_service::post(const implementation_type& impl,
   p.v = p.a.allocate(1);
   p.p = new (p.v) op(tmp, allocator);
 
-  ASIO_HANDLER_CREATION((p.p, "strand_executor", this, "post"));
+  ASIO_HANDLER_CREATION((impl->service_->context(), *p.p,
+        "strand_executor", impl.get(), 0, "post"));
 
   // Add the function to the strand and schedule the strand if required.
   bool first = enqueue(impl, p.p);
@@ -177,7 +179,8 @@ void strand_executor_service::defer(const implementation_type& impl,
   p.v = p.a.allocate(1);
   p.p = new (p.v) op(tmp, allocator);
 
-  ASIO_HANDLER_CREATION((p.p, "strand_executor", this, "defer"));
+  ASIO_HANDLER_CREATION((impl->service_->context(), *p.p,
+        "strand_executor", impl.get(), 0, "defer"));
 
   // Add the function to the strand and schedule the strand if required.
   bool first = enqueue(impl, p.p);
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/strand_executor_service.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/strand_executor_service.ipp
index 2e62a79..3baadcb 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/strand_executor_service.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/strand_executor_service.ipp
@@ -2,7 +2,7 @@
 // detail/impl/strand_executor_service.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -31,7 +31,7 @@ strand_executor_service::strand_executor_service(execution_context& ctx)
 {
 }
 
-void strand_executor_service::shutdown_service()
+void strand_executor_service::shutdown()
 {
   op_queue<scheduler_operation> ops;
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/strand_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/strand_service.hpp
index 5accfda..00b88a4 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/strand_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/strand_service.hpp
@@ -2,7 +2,7 @@
 // detail/impl/strand_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -35,7 +35,7 @@ inline strand_service::strand_impl::strand_impl()
 
 struct strand_service::on_dispatch_exit
 {
-  io_service_impl* io_service_;
+  io_context_impl* io_context_;
   strand_impl* impl_;
 
   ~on_dispatch_exit()
@@ -46,7 +46,7 @@ struct strand_service::on_dispatch_exit
     impl_->mutex_.unlock();
 
     if (more_handlers)
-      io_service_->post_immediate_completion(impl_, false);
+      io_context_->post_immediate_completion(impl_, false);
   }
 };
 
@@ -68,7 +68,8 @@ void strand_service::dispatch(strand_service::implementation_type& impl,
     op::ptr::allocate(handler), 0 };
   p.p = new (p.v) op(handler);
 
-  ASIO_HANDLER_CREATION((p.p, "strand", impl, "dispatch"));
+  ASIO_HANDLER_CREATION((this->context(),
+        *p.p, "strand", impl, 0, "dispatch"));
 
   bool dispatch_immediately = do_dispatch(impl, p.p);
   operation* o = p.p;
@@ -80,15 +81,15 @@ void strand_service::dispatch(strand_service::implementation_type& impl,
     call_stack<strand_impl>::context ctx(impl);
 
     // Ensure the next handler, if any, is scheduled on block exit.
-    on_dispatch_exit on_exit = { &io_service_, impl };
+    on_dispatch_exit on_exit = { &io_context_, impl };
     (void)on_exit;
 
     completion_handler<Handler>::do_complete(
-        &io_service_, o, asio::error_code(), 0);
+        &io_context_, o, asio::error_code(), 0);
   }
 }
 
-// Request the io_service to invoke the given handler and return immediately.
+// Request the io_context to invoke the given handler and return immediately.
 template <typename Handler>
 void strand_service::post(strand_service::implementation_type& impl,
     Handler& handler)
@@ -102,7 +103,8 @@ void strand_service::post(strand_service::implementation_type& impl,
     op::ptr::allocate(handler), 0 };
   p.p = new (p.v) op(handler);
 
-  ASIO_HANDLER_CREATION((p.p, "strand", impl, "post"));
+  ASIO_HANDLER_CREATION((this->context(),
+        *p.p, "strand", impl, 0, "post"));
 
   do_post(impl, p.p, is_continuation);
   p.v = p.p = 0;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/strand_service.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/strand_service.ipp
index 0aedaa9..16946dc 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/strand_service.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/strand_service.ipp
@@ -2,7 +2,7 @@
 // detail/impl/strand_service.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -26,7 +26,7 @@ namespace detail {
 
 struct strand_service::on_do_complete_exit
 {
-  io_service_impl* owner_;
+  io_context_impl* owner_;
   strand_impl* impl_;
 
   ~on_do_complete_exit()
@@ -41,15 +41,15 @@ struct strand_service::on_do_complete_exit
   }
 };
 
-strand_service::strand_service(asio::io_service& io_service)
-  : asio::detail::service_base<strand_service>(io_service),
-    io_service_(asio::use_service<io_service_impl>(io_service)),
+strand_service::strand_service(asio::io_context& io_context)
+  : asio::detail::service_base<strand_service>(io_context),
+    io_context_(asio::use_service<io_context_impl>(io_context)),
     mutex_(),
     salt_(0)
 {
 }
 
-void strand_service::shutdown_service()
+void strand_service::shutdown()
 {
   op_queue<operation> ops;
 
@@ -92,9 +92,9 @@ bool strand_service::running_in_this_thread(
 
 bool strand_service::do_dispatch(implementation_type& impl, operation* op)
 {
-  // If we are running inside the io_service, and no other handler already
+  // If we are running inside the io_context, and no other handler already
   // holds the strand lock, then the handler can run immediately.
-  bool can_dispatch = io_service_.can_dispatch();
+  bool can_dispatch = io_context_.can_dispatch();
   impl->mutex_.lock();
   if (can_dispatch && !impl->locked_)
   {
@@ -117,7 +117,7 @@ bool strand_service::do_dispatch(implementation_type& impl, operation* op)
     impl->locked_ = true;
     impl->mutex_.unlock();
     impl->ready_queue_.push(op);
-    io_service_.post_immediate_completion(impl, false);
+    io_context_.post_immediate_completion(impl, false);
   }
 
   return false;
@@ -140,7 +140,7 @@ void strand_service::do_post(implementation_type& impl,
     impl->locked_ = true;
     impl->mutex_.unlock();
     impl->ready_queue_.push(op);
-    io_service_.post_immediate_completion(impl, is_continuation);
+    io_context_.post_immediate_completion(impl, is_continuation);
   }
 }
 
@@ -156,7 +156,7 @@ void strand_service::do_complete(void* owner, operation* base,
 
     // Ensure the next handler, if any, is scheduled on block exit.
     on_do_complete_exit on_exit;
-    on_exit.owner_ = static_cast<io_service_impl*>(owner);
+    on_exit.owner_ = static_cast<io_context_impl*>(owner);
     on_exit.impl_ = impl;
 
     // Run all ready handlers. No lock is required since the ready queue is
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/throw_error.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/throw_error.ipp
index 0e327d0..d59eca2 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/throw_error.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/throw_error.ipp
@@ -2,7 +2,7 @@
 // detail/impl/throw_error.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/timer_queue_ptime.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/timer_queue_ptime.ipp
index 3a396ee..10c4295 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/timer_queue_ptime.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/timer_queue_ptime.ipp
@@ -2,7 +2,7 @@
 // detail/impl/timer_queue_ptime.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,12 +16,13 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
+
+#if defined(ASIO_HAS_BOOST_DATE_TIME)
+
 #include "asio/detail/timer_queue_ptime.hpp"
 
 #include "asio/detail/push_options.hpp"
 
-#if defined(ASIO_HAS_BOOST_DATE_TIME)
-
 namespace asio {
 namespace detail {
 
@@ -74,11 +75,17 @@ std::size_t timer_queue<time_traits<boost::posix_time::ptime> >::cancel_timer(
   return impl_.cancel_timer(timer, ops, max_cancelled);
 }
 
+void timer_queue<time_traits<boost::posix_time::ptime> >::move_timer(
+    per_timer_data& target, per_timer_data& source)
+{
+  impl_.move_timer(target, source);
+}
+
 } // namespace detail
 } // namespace asio
 
-#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
-
 #include "asio/detail/pop_options.hpp"
 
+#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
+
 #endif // ASIO_DETAIL_IMPL_TIMER_QUEUE_PTIME_IPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/timer_queue_set.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/timer_queue_set.ipp
index b76e238..a683182 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/timer_queue_set.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/timer_queue_set.ipp
@@ -2,7 +2,7 @@
 // detail/impl/timer_queue_set.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_event.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_event.ipp
index 38bfe52..e3d77e6 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_event.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_event.ipp
@@ -2,7 +2,7 @@
 // detail/win_event.ipp
 // ~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -31,7 +31,11 @@ namespace detail {
 win_event::win_event()
   : state_(0)
 {
-  events_[0] = ::CreateEvent(0, true, false, 0);
+#if defined(ASIO_WINDOWS_APP)
+  events_[0] = ::CreateEventExW(0, 0, CREATE_EVENT_MANUAL_RESET, 0);
+#else // defined(ASIO_WINDOWS_APP)
+  events_[0] = ::CreateEventW(0, true, false, 0);
+#endif // defined(ASIO_WINDOWS_APP)
   if (!events_[0])
   {
     DWORD last_error = ::GetLastError();
@@ -40,7 +44,11 @@ win_event::win_event()
     asio::detail::throw_error(ec, "event");
   }
 
-  events_[1] = ::CreateEvent(0, false, false, 0);
+#if defined(ASIO_WINDOWS_APP)
+  events_[1] = ::CreateEventExW(0, 0, 0, 0);
+#else // defined(ASIO_WINDOWS_APP)
+  events_[1] = ::CreateEventW(0, false, false, 0);
+#endif // defined(ASIO_WINDOWS_APP)
   if (!events_[1])
   {
     DWORD last_error = ::GetLastError();
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_handle_service.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_handle_service.ipp
index b484f7b..7e6fcb9 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_handle_service.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_handle_service.ipp
@@ -2,7 +2,7 @@
 // detail/impl/win_iocp_handle_service.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -39,7 +39,7 @@ public:
     OffsetHigh = 0;
 
     // Create a non-signalled manual-reset event, for GetOverlappedResult.
-    hEvent = ::CreateEvent(0, TRUE, FALSE, 0);
+    hEvent = ::CreateEventW(0, TRUE, FALSE, 0);
     if (hEvent)
     {
       // As documented in GetQueuedCompletionStatus, setting the low order
@@ -66,14 +66,15 @@ public:
 };
 
 win_iocp_handle_service::win_iocp_handle_service(
-    asio::io_service& io_service)
-  : iocp_service_(asio::use_service<win_iocp_io_service>(io_service)),
+    asio::io_context& io_context)
+  : service_base<win_iocp_handle_service>(io_context),
+    iocp_service_(asio::use_service<win_iocp_io_context>(io_context)),
     mutex_(),
     impl_list_(0)
 {
 }
 
-void win_iocp_handle_service::shutdown_service()
+void win_iocp_handle_service::shutdown()
 {
   // Close all implementations, causing all operations to complete.
   asio::detail::mutex::scoped_lock lock(mutex_);
@@ -199,7 +200,8 @@ asio::error_code win_iocp_handle_service::close(
 {
   if (is_open(impl))
   {
-    ASIO_HANDLER_OPERATION(("handle", &impl, "close"));
+    ASIO_HANDLER_OPERATION((iocp_service_.context(), "handle",
+          &impl, reinterpret_cast<uintmax_t>(impl.handle_), "close"));
 
     if (!::CloseHandle(impl.handle_))
     {
@@ -233,7 +235,8 @@ asio::error_code win_iocp_handle_service::cancel(
     return ec;
   }
 
-  ASIO_HANDLER_OPERATION(("handle", &impl, "cancel"));
+  ASIO_HANDLER_OPERATION((iocp_service_.context(), "handle",
+        &impl, reinterpret_cast<uintmax_t>(impl.handle_), "cancel"));
 
   if (FARPROC cancel_io_ex_ptr = ::GetProcAddress(
         ::GetModuleHandleA("KERNEL32"), "CancelIoEx"))
@@ -303,7 +306,7 @@ size_t win_iocp_handle_service::do_write(
   }
 
   // A request to write 0 bytes on a handle is a no-op.
-  if (asio::buffer_size(buffer) == 0)
+  if (buffer.size() == 0)
   {
     ec = asio::error_code();
     return 0;
@@ -318,9 +321,8 @@ size_t win_iocp_handle_service::do_write(
   // Write the data. 
   overlapped.Offset = offset & 0xFFFFFFFF;
   overlapped.OffsetHigh = (offset >> 32) & 0xFFFFFFFF;
-  BOOL ok = ::WriteFile(impl.handle_,
-      asio::buffer_cast<LPCVOID>(buffer),
-      static_cast<DWORD>(asio::buffer_size(buffer)), 0, &overlapped);
+  BOOL ok = ::WriteFile(impl.handle_, buffer.data(),
+      static_cast<DWORD>(buffer.size()), 0, &overlapped);
   if (!ok) 
   {
     DWORD last_error = ::GetLastError();
@@ -359,7 +361,7 @@ void win_iocp_handle_service::start_write_op(
   {
     iocp_service_.on_completion(op, asio::error::bad_descriptor);
   }
-  else if (asio::buffer_size(buffer) == 0)
+  else if (buffer.size() == 0)
   {
     // A request to write 0 bytes on a handle is a no-op.
     iocp_service_.on_completion(op);
@@ -369,9 +371,8 @@ void win_iocp_handle_service::start_write_op(
     DWORD bytes_transferred = 0;
     op->Offset = offset & 0xFFFFFFFF;
     op->OffsetHigh = (offset >> 32) & 0xFFFFFFFF;
-    BOOL ok = ::WriteFile(impl.handle_,
-        asio::buffer_cast<LPCVOID>(buffer),
-        static_cast<DWORD>(asio::buffer_size(buffer)),
+    BOOL ok = ::WriteFile(impl.handle_, buffer.data(),
+        static_cast<DWORD>(buffer.size()),
         &bytes_transferred, op);
     DWORD last_error = ::GetLastError();
     if (!ok && last_error != ERROR_IO_PENDING
@@ -397,7 +398,7 @@ size_t win_iocp_handle_service::do_read(
   }
   
   // A request to read 0 bytes on a stream handle is a no-op.
-  if (asio::buffer_size(buffer) == 0)
+  if (buffer.size() == 0)
   {
     ec = asio::error_code();
     return 0;
@@ -412,9 +413,8 @@ size_t win_iocp_handle_service::do_read(
   // Read some data.
   overlapped.Offset = offset & 0xFFFFFFFF;
   overlapped.OffsetHigh = (offset >> 32) & 0xFFFFFFFF;
-  BOOL ok = ::ReadFile(impl.handle_,
-      asio::buffer_cast<LPVOID>(buffer),
-      static_cast<DWORD>(asio::buffer_size(buffer)), 0, &overlapped);
+  BOOL ok = ::ReadFile(impl.handle_, buffer.data(),
+      static_cast<DWORD>(buffer.size()), 0, &overlapped);
   if (!ok) 
   {
     DWORD last_error = ::GetLastError();
@@ -467,7 +467,7 @@ void win_iocp_handle_service::start_read_op(
   {
     iocp_service_.on_completion(op, asio::error::bad_descriptor);
   }
-  else if (asio::buffer_size(buffer) == 0)
+  else if (buffer.size() == 0)
   {
     // A request to read 0 bytes on a handle is a no-op.
     iocp_service_.on_completion(op);
@@ -477,9 +477,8 @@ void win_iocp_handle_service::start_read_op(
     DWORD bytes_transferred = 0;
     op->Offset = offset & 0xFFFFFFFF;
     op->OffsetHigh = (offset >> 32) & 0xFFFFFFFF;
-    BOOL ok = ::ReadFile(impl.handle_,
-        asio::buffer_cast<LPVOID>(buffer),
-        static_cast<DWORD>(asio::buffer_size(buffer)),
+    BOOL ok = ::ReadFile(impl.handle_, buffer.data(),
+        static_cast<DWORD>(buffer.size()),
         &bytes_transferred, op);
     DWORD last_error = ::GetLastError();
     if (!ok && last_error != ERROR_IO_PENDING
@@ -507,7 +506,8 @@ void win_iocp_handle_service::close_for_destruction(implementation_type& impl)
 {
   if (is_open(impl))
   {
-    ASIO_HANDLER_OPERATION(("handle", &impl, "close"));
+    ASIO_HANDLER_OPERATION((iocp_service_.context(), "handle",
+          &impl, reinterpret_cast<uintmax_t>(impl.handle_), "close"));
 
     ::CloseHandle(impl.handle_);
     impl.handle_ = INVALID_HANDLE_VALUE;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_io_context.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_io_context.hpp
new file mode 100644
index 0000000..4d1d75a
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_io_context.hpp
@@ -0,0 +1,103 @@
+//
+// detail/impl/win_iocp_io_context.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_DETAIL_IMPL_WIN_IOCP_IO_CONTEXT_HPP
+#define ASIO_DETAIL_IMPL_WIN_IOCP_IO_CONTEXT_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+
+#if defined(ASIO_HAS_IOCP)
+
+#include "asio/detail/completion_handler.hpp"
+#include "asio/detail/fenced_block.hpp"
+#include "asio/detail/handler_alloc_helpers.hpp"
+#include "asio/detail/handler_invoke_helpers.hpp"
+#include "asio/detail/memory.hpp"
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+namespace detail {
+
+template <typename Time_Traits>
+void win_iocp_io_context::add_timer_queue(
+    timer_queue<Time_Traits>& queue)
+{
+  do_add_timer_queue(queue);
+}
+
+template <typename Time_Traits>
+void win_iocp_io_context::remove_timer_queue(
+    timer_queue<Time_Traits>& queue)
+{
+  do_remove_timer_queue(queue);
+}
+
+template <typename Time_Traits>
+void win_iocp_io_context::schedule_timer(timer_queue<Time_Traits>& queue,
+    const typename Time_Traits::time_type& time,
+    typename timer_queue<Time_Traits>::per_timer_data& timer, wait_op* op)
+{
+  // If the service has been shut down we silently discard the timer.
+  if (::InterlockedExchangeAdd(&shutdown_, 0) != 0)
+  {
+    post_immediate_completion(op, false);
+    return;
+  }
+
+  mutex::scoped_lock lock(dispatch_mutex_);
+
+  bool earliest = queue.enqueue_timer(time, timer, op);
+  work_started();
+  if (earliest)
+    update_timeout();
+}
+
+template <typename Time_Traits>
+std::size_t win_iocp_io_context::cancel_timer(timer_queue<Time_Traits>& queue,
+    typename timer_queue<Time_Traits>::per_timer_data& timer,
+    std::size_t max_cancelled)
+{
+  // If the service has been shut down we silently ignore the cancellation.
+  if (::InterlockedExchangeAdd(&shutdown_, 0) != 0)
+    return 0;
+
+  mutex::scoped_lock lock(dispatch_mutex_);
+  op_queue<win_iocp_operation> ops;
+  std::size_t n = queue.cancel_timer(timer, ops, max_cancelled);
+  post_deferred_completions(ops);
+  return n;
+}
+
+template <typename Time_Traits>
+void win_iocp_io_context::move_timer(timer_queue<Time_Traits>& queue,
+    typename timer_queue<Time_Traits>::per_timer_data& to,
+    typename timer_queue<Time_Traits>::per_timer_data& from)
+{
+  asio::detail::mutex::scoped_lock lock(dispatch_mutex_);
+  op_queue<operation> ops;
+  queue.cancel_timer(to, ops);
+  queue.move_timer(to, from);
+  lock.unlock();
+  post_deferred_completions(ops);
+}
+
+} // namespace detail
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // defined(ASIO_HAS_IOCP)
+
+#endif // ASIO_DETAIL_IMPL_WIN_IOCP_IO_CONTEXT_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_io_context.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_io_context.ipp
new file mode 100644
index 0000000..d4a1638
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_io_context.ipp
@@ -0,0 +1,554 @@
+//
+// detail/impl/win_iocp_io_context.ipp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_DETAIL_IMPL_WIN_IOCP_IO_CONTEXT_IPP
+#define ASIO_DETAIL_IMPL_WIN_IOCP_IO_CONTEXT_IPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+
+#if defined(ASIO_HAS_IOCP)
+
+#include "asio/error.hpp"
+#include "asio/detail/cstdint.hpp"
+#include "asio/detail/handler_alloc_helpers.hpp"
+#include "asio/detail/handler_invoke_helpers.hpp"
+#include "asio/detail/limits.hpp"
+#include "asio/detail/throw_error.hpp"
+#include "asio/detail/win_iocp_io_context.hpp"
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+namespace detail {
+
+struct win_iocp_io_context::work_finished_on_block_exit
+{
+  ~work_finished_on_block_exit()
+  {
+    io_context_->work_finished();
+  }
+
+  win_iocp_io_context* io_context_;
+};
+
+struct win_iocp_io_context::timer_thread_function
+{
+  void operator()()
+  {
+    while (::InterlockedExchangeAdd(&io_context_->shutdown_, 0) == 0)
+    {
+      if (::WaitForSingleObject(io_context_->waitable_timer_.handle,
+            INFINITE) == WAIT_OBJECT_0)
+      {
+        ::InterlockedExchange(&io_context_->dispatch_required_, 1);
+        ::PostQueuedCompletionStatus(io_context_->iocp_.handle,
+            0, wake_for_dispatch, 0);
+      }
+    }
+  }
+
+  win_iocp_io_context* io_context_;
+};
+
+win_iocp_io_context::win_iocp_io_context(
+    asio::execution_context& ctx, int concurrency_hint)
+  : execution_context_service_base<win_iocp_io_context>(ctx),
+    iocp_(),
+    outstanding_work_(0),
+    stopped_(0),
+    stop_event_posted_(0),
+    shutdown_(0),
+    gqcs_timeout_(get_gqcs_timeout()),
+    dispatch_required_(0),
+    concurrency_hint_(concurrency_hint)
+{
+  ASIO_HANDLER_TRACKING_INIT;
+
+  iocp_.handle = ::CreateIoCompletionPort(INVALID_HANDLE_VALUE, 0, 0,
+      static_cast<DWORD>(concurrency_hint >= 0 ? concurrency_hint : DWORD(~0)));
+  if (!iocp_.handle)
+  {
+    DWORD last_error = ::GetLastError();
+    asio::error_code ec(last_error,
+        asio::error::get_system_category());
+    asio::detail::throw_error(ec, "iocp");
+  }
+}
+
+void win_iocp_io_context::shutdown()
+{
+  ::InterlockedExchange(&shutdown_, 1);
+
+  if (timer_thread_.get())
+  {
+    LARGE_INTEGER timeout;
+    timeout.QuadPart = 1;
+    ::SetWaitableTimer(waitable_timer_.handle, &timeout, 1, 0, 0, FALSE);
+  }
+
+  while (::InterlockedExchangeAdd(&outstanding_work_, 0) > 0)
+  {
+    op_queue<win_iocp_operation> ops;
+    timer_queues_.get_all_timers(ops);
+    ops.push(completed_ops_);
+    if (!ops.empty())
+    {
+      while (win_iocp_operation* op = ops.front())
+      {
+        ops.pop();
+        ::InterlockedDecrement(&outstanding_work_);
+        op->destroy();
+      }
+    }
+    else
+    {
+      DWORD bytes_transferred = 0;
+      dword_ptr_t completion_key = 0;
+      LPOVERLAPPED overlapped = 0;
+      ::GetQueuedCompletionStatus(iocp_.handle, &bytes_transferred,
+          &completion_key, &overlapped, gqcs_timeout_);
+      if (overlapped)
+      {
+        ::InterlockedDecrement(&outstanding_work_);
+        static_cast<win_iocp_operation*>(overlapped)->destroy();
+      }
+    }
+  }
+
+  if (timer_thread_.get())
+    timer_thread_->join();
+}
+
+asio::error_code win_iocp_io_context::register_handle(
+    HANDLE handle, asio::error_code& ec)
+{
+  if (::CreateIoCompletionPort(handle, iocp_.handle, 0, 0) == 0)
+  {
+    DWORD last_error = ::GetLastError();
+    ec = asio::error_code(last_error,
+        asio::error::get_system_category());
+  }
+  else
+  {
+    ec = asio::error_code();
+  }
+  return ec;
+}
+
+size_t win_iocp_io_context::run(asio::error_code& ec)
+{
+  if (::InterlockedExchangeAdd(&outstanding_work_, 0) == 0)
+  {
+    stop();
+    ec = asio::error_code();
+    return 0;
+  }
+
+  win_iocp_thread_info this_thread;
+  thread_call_stack::context ctx(this, this_thread);
+
+  size_t n = 0;
+  while (do_one(INFINITE, ec))
+    if (n != (std::numeric_limits<size_t>::max)())
+      ++n;
+  return n;
+}
+
+size_t win_iocp_io_context::run_one(asio::error_code& ec)
+{
+  if (::InterlockedExchangeAdd(&outstanding_work_, 0) == 0)
+  {
+    stop();
+    ec = asio::error_code();
+    return 0;
+  }
+
+  win_iocp_thread_info this_thread;
+  thread_call_stack::context ctx(this, this_thread);
+
+  return do_one(INFINITE, ec);
+}
+
+size_t win_iocp_io_context::wait_one(long usec, asio::error_code& ec)
+{
+  if (::InterlockedExchangeAdd(&outstanding_work_, 0) == 0)
+  {
+    stop();
+    ec = asio::error_code();
+    return 0;
+  }
+
+  win_iocp_thread_info this_thread;
+  thread_call_stack::context ctx(this, this_thread);
+
+  return do_one(usec < 0 ? INFINITE : ((usec - 1) / 1000 + 1), ec);
+}
+
+size_t win_iocp_io_context::poll(asio::error_code& ec)
+{
+  if (::InterlockedExchangeAdd(&outstanding_work_, 0) == 0)
+  {
+    stop();
+    ec = asio::error_code();
+    return 0;
+  }
+
+  win_iocp_thread_info this_thread;
+  thread_call_stack::context ctx(this, this_thread);
+
+  size_t n = 0;
+  while (do_one(0, ec))
+    if (n != (std::numeric_limits<size_t>::max)())
+      ++n;
+  return n;
+}
+
+size_t win_iocp_io_context::poll_one(asio::error_code& ec)
+{
+  if (::InterlockedExchangeAdd(&outstanding_work_, 0) == 0)
+  {
+    stop();
+    ec = asio::error_code();
+    return 0;
+  }
+
+  win_iocp_thread_info this_thread;
+  thread_call_stack::context ctx(this, this_thread);
+
+  return do_one(0, ec);
+}
+
+void win_iocp_io_context::stop()
+{
+  if (::InterlockedExchange(&stopped_, 1) == 0)
+  {
+    if (::InterlockedExchange(&stop_event_posted_, 1) == 0)
+    {
+      if (!::PostQueuedCompletionStatus(iocp_.handle, 0, 0, 0))
+      {
+        DWORD last_error = ::GetLastError();
+        asio::error_code ec(last_error,
+            asio::error::get_system_category());
+        asio::detail::throw_error(ec, "pqcs");
+      }
+    }
+  }
+}
+
+void win_iocp_io_context::post_deferred_completion(win_iocp_operation* op)
+{
+  // Flag the operation as ready.
+  op->ready_ = 1;
+
+  // Enqueue the operation on the I/O completion port.
+  if (!::PostQueuedCompletionStatus(iocp_.handle, 0, 0, op))
+  {
+    // Out of resources. Put on completed queue instead.
+    mutex::scoped_lock lock(dispatch_mutex_);
+    completed_ops_.push(op);
+    ::InterlockedExchange(&dispatch_required_, 1);
+  }
+}
+
+void win_iocp_io_context::post_deferred_completions(
+    op_queue<win_iocp_operation>& ops)
+{
+  while (win_iocp_operation* op = ops.front())
+  {
+    ops.pop();
+
+    // Flag the operation as ready.
+    op->ready_ = 1;
+
+    // Enqueue the operation on the I/O completion port.
+    if (!::PostQueuedCompletionStatus(iocp_.handle, 0, 0, op))
+    {
+      // Out of resources. Put on completed queue instead.
+      mutex::scoped_lock lock(dispatch_mutex_);
+      completed_ops_.push(op);
+      completed_ops_.push(ops);
+      ::InterlockedExchange(&dispatch_required_, 1);
+    }
+  }
+}
+
+void win_iocp_io_context::abandon_operations(
+    op_queue<win_iocp_operation>& ops)
+{
+  while (win_iocp_operation* op = ops.front())
+  {
+    ops.pop();
+    ::InterlockedDecrement(&outstanding_work_);
+    op->destroy();
+  }
+}
+
+void win_iocp_io_context::on_pending(win_iocp_operation* op)
+{
+  if (::InterlockedCompareExchange(&op->ready_, 1, 0) == 1)
+  {
+    // Enqueue the operation on the I/O completion port.
+    if (!::PostQueuedCompletionStatus(iocp_.handle,
+          0, overlapped_contains_result, op))
+    {
+      // Out of resources. Put on completed queue instead.
+      mutex::scoped_lock lock(dispatch_mutex_);
+      completed_ops_.push(op);
+      ::InterlockedExchange(&dispatch_required_, 1);
+    }
+  }
+}
+
+void win_iocp_io_context::on_completion(win_iocp_operation* op,
+    DWORD last_error, DWORD bytes_transferred)
+{
+  // Flag that the operation is ready for invocation.
+  op->ready_ = 1;
+
+  // Store results in the OVERLAPPED structure.
+  op->Internal = reinterpret_cast<ulong_ptr_t>(
+      &asio::error::get_system_category());
+  op->Offset = last_error;
+  op->OffsetHigh = bytes_transferred;
+
+  // Enqueue the operation on the I/O completion port.
+  if (!::PostQueuedCompletionStatus(iocp_.handle,
+        0, overlapped_contains_result, op))
+  {
+    // Out of resources. Put on completed queue instead.
+    mutex::scoped_lock lock(dispatch_mutex_);
+    completed_ops_.push(op);
+    ::InterlockedExchange(&dispatch_required_, 1);
+  }
+}
+
+void win_iocp_io_context::on_completion(win_iocp_operation* op,
+    const asio::error_code& ec, DWORD bytes_transferred)
+{
+  // Flag that the operation is ready for invocation.
+  op->ready_ = 1;
+
+  // Store results in the OVERLAPPED structure.
+  op->Internal = reinterpret_cast<ulong_ptr_t>(&ec.category());
+  op->Offset = ec.value();
+  op->OffsetHigh = bytes_transferred;
+
+  // Enqueue the operation on the I/O completion port.
+  if (!::PostQueuedCompletionStatus(iocp_.handle,
+        0, overlapped_contains_result, op))
+  {
+    // Out of resources. Put on completed queue instead.
+    mutex::scoped_lock lock(dispatch_mutex_);
+    completed_ops_.push(op);
+    ::InterlockedExchange(&dispatch_required_, 1);
+  }
+}
+
+size_t win_iocp_io_context::do_one(DWORD msec, asio::error_code& ec)
+{
+  for (;;)
+  {
+    // Try to acquire responsibility for dispatching timers and completed ops.
+    if (::InterlockedCompareExchange(&dispatch_required_, 0, 1) == 1)
+    {
+      mutex::scoped_lock lock(dispatch_mutex_);
+
+      // Dispatch pending timers and operations.
+      op_queue<win_iocp_operation> ops;
+      ops.push(completed_ops_);
+      timer_queues_.get_ready_timers(ops);
+      post_deferred_completions(ops);
+      update_timeout();
+    }
+
+    // Get the next operation from the queue.
+    DWORD bytes_transferred = 0;
+    dword_ptr_t completion_key = 0;
+    LPOVERLAPPED overlapped = 0;
+    ::SetLastError(0);
+    BOOL ok = ::GetQueuedCompletionStatus(iocp_.handle,
+        &bytes_transferred, &completion_key, &overlapped,
+        msec < gqcs_timeout_ ? msec : gqcs_timeout_);
+    DWORD last_error = ::GetLastError();
+
+    if (overlapped)
+    {
+      win_iocp_operation* op = static_cast<win_iocp_operation*>(overlapped);
+      asio::error_code result_ec(last_error,
+          asio::error::get_system_category());
+
+      // We may have been passed the last_error and bytes_transferred in the
+      // OVERLAPPED structure itself.
+      if (completion_key == overlapped_contains_result)
+      {
+        result_ec = asio::error_code(static_cast<int>(op->Offset),
+            *reinterpret_cast<asio::error_category*>(op->Internal));
+        bytes_transferred = op->OffsetHigh;
+      }
+
+      // Otherwise ensure any result has been saved into the OVERLAPPED
+      // structure.
+      else
+      {
+        op->Internal = reinterpret_cast<ulong_ptr_t>(&result_ec.category());
+        op->Offset = result_ec.value();
+        op->OffsetHigh = bytes_transferred;
+      }
+
+      // Dispatch the operation only if ready. The operation may not be ready
+      // if the initiating function (e.g. a call to WSARecv) has not yet
+      // returned. This is because the initiating function still wants access
+      // to the operation's OVERLAPPED structure.
+      if (::InterlockedCompareExchange(&op->ready_, 1, 0) == 1)
+      {
+        // Ensure the count of outstanding work is decremented on block exit.
+        work_finished_on_block_exit on_exit = { this };
+        (void)on_exit;
+
+        op->complete(this, result_ec, bytes_transferred);
+        ec = asio::error_code();
+        return 1;
+      }
+    }
+    else if (!ok)
+    {
+      if (last_error != WAIT_TIMEOUT)
+      {
+        ec = asio::error_code(last_error,
+            asio::error::get_system_category());
+        return 0;
+      }
+
+      // If we're waiting indefinitely we need to keep going until we get a
+      // real handler.
+      if (msec == INFINITE)
+        continue;
+
+      ec = asio::error_code();
+      return 0;
+    }
+    else if (completion_key == wake_for_dispatch)
+    {
+      // We have been woken up to try to acquire responsibility for dispatching
+      // timers and completed operations.
+    }
+    else
+    {
+      // Indicate that there is no longer an in-flight stop event.
+      ::InterlockedExchange(&stop_event_posted_, 0);
+
+      // The stopped_ flag is always checked to ensure that any leftover
+      // stop events from a previous run invocation are ignored.
+      if (::InterlockedExchangeAdd(&stopped_, 0) != 0)
+      {
+        // Wake up next thread that is blocked on GetQueuedCompletionStatus.
+        if (::InterlockedExchange(&stop_event_posted_, 1) == 0)
+        {
+          if (!::PostQueuedCompletionStatus(iocp_.handle, 0, 0, 0))
+          {
+            last_error = ::GetLastError();
+            ec = asio::error_code(last_error,
+                asio::error::get_system_category());
+            return 0;
+          }
+        }
+
+        ec = asio::error_code();
+        return 0;
+      }
+    }
+  }
+}
+
+DWORD win_iocp_io_context::get_gqcs_timeout()
+{
+  OSVERSIONINFOEX osvi;
+  ZeroMemory(&osvi, sizeof(osvi));
+  osvi.dwOSVersionInfoSize = sizeof(osvi);
+  osvi.dwMajorVersion = 6ul;
+
+  const uint64_t condition_mask = ::VerSetConditionMask(
+      0, VER_MAJORVERSION, VER_GREATER_EQUAL);
+
+  if (!!::VerifyVersionInfo(&osvi, VER_MAJORVERSION, condition_mask))
+    return INFINITE;
+
+  return default_gqcs_timeout;
+}
+
+void win_iocp_io_context::do_add_timer_queue(timer_queue_base& queue)
+{
+  mutex::scoped_lock lock(dispatch_mutex_);
+
+  timer_queues_.insert(&queue);
+
+  if (!waitable_timer_.handle)
+  {
+    waitable_timer_.handle = ::CreateWaitableTimer(0, FALSE, 0);
+    if (waitable_timer_.handle == 0)
+    {
+      DWORD last_error = ::GetLastError();
+      asio::error_code ec(last_error,
+          asio::error::get_system_category());
+      asio::detail::throw_error(ec, "timer");
+    }
+
+    LARGE_INTEGER timeout;
+    timeout.QuadPart = -max_timeout_usec;
+    timeout.QuadPart *= 10;
+    ::SetWaitableTimer(waitable_timer_.handle,
+        &timeout, max_timeout_msec, 0, 0, FALSE);
+  }
+
+  if (!timer_thread_.get())
+  {
+    timer_thread_function thread_function = { this };
+    timer_thread_.reset(new thread(thread_function, 65536));
+  }
+}
+
+void win_iocp_io_context::do_remove_timer_queue(timer_queue_base& queue)
+{
+  mutex::scoped_lock lock(dispatch_mutex_);
+
+  timer_queues_.erase(&queue);
+}
+
+void win_iocp_io_context::update_timeout()
+{
+  if (timer_thread_.get())
+  {
+    // There's no point updating the waitable timer if the new timeout period
+    // exceeds the maximum timeout. In that case, we might as well wait for the
+    // existing period of the timer to expire.
+    long timeout_usec = timer_queues_.wait_duration_usec(max_timeout_usec);
+    if (timeout_usec < max_timeout_usec)
+    {
+      LARGE_INTEGER timeout;
+      timeout.QuadPart = -timeout_usec;
+      timeout.QuadPart *= 10;
+      ::SetWaitableTimer(waitable_timer_.handle,
+          &timeout, max_timeout_msec, 0, 0, FALSE);
+    }
+  }
+}
+
+} // namespace detail
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // defined(ASIO_HAS_IOCP)
+
+#endif // ASIO_DETAIL_IMPL_WIN_IOCP_IO_CONTEXT_IPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_io_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_io_service.hpp
deleted file mode 100644
index 9f4a7a6..0000000
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_io_service.hpp
+++ /dev/null
@@ -1,103 +0,0 @@
-//
-// detail/impl/win_iocp_io_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_WIN_IOCP_IO_SERVICE_HPP
-#define ASIO_DETAIL_IMPL_WIN_IOCP_IO_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/detail/completion_handler.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/memory.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Time_Traits>
-void win_iocp_io_service::add_timer_queue(
-    timer_queue<Time_Traits>& queue)
-{
-  do_add_timer_queue(queue);
-}
-
-template <typename Time_Traits>
-void win_iocp_io_service::remove_timer_queue(
-    timer_queue<Time_Traits>& queue)
-{
-  do_remove_timer_queue(queue);
-}
-
-template <typename Time_Traits>
-void win_iocp_io_service::schedule_timer(timer_queue<Time_Traits>& queue,
-    const typename Time_Traits::time_type& time,
-    typename timer_queue<Time_Traits>::per_timer_data& timer, wait_op* op)
-{
-  // If the service has been shut down we silently discard the timer.
-  if (::InterlockedExchangeAdd(&shutdown_, 0) != 0)
-  {
-    post_immediate_completion(op, false);
-    return;
-  }
-
-  mutex::scoped_lock lock(dispatch_mutex_);
-
-  bool earliest = queue.enqueue_timer(time, timer, op);
-  work_started();
-  if (earliest)
-    update_timeout();
-}
-
-template <typename Time_Traits>
-std::size_t win_iocp_io_service::cancel_timer(timer_queue<Time_Traits>& queue,
-    typename timer_queue<Time_Traits>::per_timer_data& timer,
-    std::size_t max_cancelled)
-{
-  // If the service has been shut down we silently ignore the cancellation.
-  if (::InterlockedExchangeAdd(&shutdown_, 0) != 0)
-    return 0;
-
-  mutex::scoped_lock lock(dispatch_mutex_);
-  op_queue<win_iocp_operation> ops;
-  std::size_t n = queue.cancel_timer(timer, ops, max_cancelled);
-  post_deferred_completions(ops);
-  return n;
-}
-
-template <typename Time_Traits>
-void win_iocp_io_service::move_timer(timer_queue<Time_Traits>& queue,
-    typename timer_queue<Time_Traits>::per_timer_data& to,
-    typename timer_queue<Time_Traits>::per_timer_data& from)
-{
-  asio::detail::mutex::scoped_lock lock(dispatch_mutex_);
-  op_queue<operation> ops;
-  queue.cancel_timer(to, ops);
-  queue.move_timer(to, from);
-  lock.unlock();
-  post_deferred_completions(ops);
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_IMPL_WIN_IOCP_IO_SERVICE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_io_service.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_io_service.ipp
deleted file mode 100644
index 92c6722..0000000
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_io_service.ipp
+++ /dev/null
@@ -1,537 +0,0 @@
-//
-// detail/impl/win_iocp_io_service.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_WIN_IOCP_IO_SERVICE_IPP
-#define ASIO_DETAIL_IMPL_WIN_IOCP_IO_SERVICE_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/error.hpp"
-#include "asio/detail/cstdint.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/limits.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/detail/win_iocp_io_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-struct win_iocp_io_service::work_finished_on_block_exit
-{
-  ~work_finished_on_block_exit()
-  {
-    io_service_->work_finished();
-  }
-
-  win_iocp_io_service* io_service_;
-};
-
-struct win_iocp_io_service::timer_thread_function
-{
-  void operator()()
-  {
-    while (::InterlockedExchangeAdd(&io_service_->shutdown_, 0) == 0)
-    {
-      if (::WaitForSingleObject(io_service_->waitable_timer_.handle,
-            INFINITE) == WAIT_OBJECT_0)
-      {
-        ::InterlockedExchange(&io_service_->dispatch_required_, 1);
-        ::PostQueuedCompletionStatus(io_service_->iocp_.handle,
-            0, wake_for_dispatch, 0);
-      }
-    }
-  }
-
-  win_iocp_io_service* io_service_;
-};
-
-win_iocp_io_service::win_iocp_io_service(
-    asio::execution_context& ctx, size_t concurrency_hint)
-  : execution_context_service_base<win_iocp_io_service>(ctx),
-    iocp_(),
-    outstanding_work_(0),
-    stopped_(0),
-    stop_event_posted_(0),
-    shutdown_(0),
-    gqcs_timeout_(get_gqcs_timeout()),
-    dispatch_required_(0)
-{
-  ASIO_HANDLER_TRACKING_INIT;
-
-  iocp_.handle = ::CreateIoCompletionPort(INVALID_HANDLE_VALUE, 0, 0,
-      static_cast<DWORD>(concurrency_hint < DWORD(~0)
-        ? concurrency_hint : DWORD(~0)));
-  if (!iocp_.handle)
-  {
-    DWORD last_error = ::GetLastError();
-    asio::error_code ec(last_error,
-        asio::error::get_system_category());
-    asio::detail::throw_error(ec, "iocp");
-  }
-}
-
-void win_iocp_io_service::shutdown_service()
-{
-  ::InterlockedExchange(&shutdown_, 1);
-
-  if (timer_thread_.get())
-  {
-    LARGE_INTEGER timeout;
-    timeout.QuadPart = 1;
-    ::SetWaitableTimer(waitable_timer_.handle, &timeout, 1, 0, 0, FALSE);
-  }
-
-  while (::InterlockedExchangeAdd(&outstanding_work_, 0) > 0)
-  {
-    op_queue<win_iocp_operation> ops;
-    timer_queues_.get_all_timers(ops);
-    ops.push(completed_ops_);
-    if (!ops.empty())
-    {
-      while (win_iocp_operation* op = ops.front())
-      {
-        ops.pop();
-        ::InterlockedDecrement(&outstanding_work_);
-        op->destroy();
-      }
-    }
-    else
-    {
-      DWORD bytes_transferred = 0;
-      dword_ptr_t completion_key = 0;
-      LPOVERLAPPED overlapped = 0;
-      ::GetQueuedCompletionStatus(iocp_.handle, &bytes_transferred,
-          &completion_key, &overlapped, gqcs_timeout_);
-      if (overlapped)
-      {
-        ::InterlockedDecrement(&outstanding_work_);
-        static_cast<win_iocp_operation*>(overlapped)->destroy();
-      }
-    }
-  }
-
-  if (timer_thread_.get())
-    timer_thread_->join();
-}
-
-asio::error_code win_iocp_io_service::register_handle(
-    HANDLE handle, asio::error_code& ec)
-{
-  if (::CreateIoCompletionPort(handle, iocp_.handle, 0, 0) == 0)
-  {
-    DWORD last_error = ::GetLastError();
-    ec = asio::error_code(last_error,
-        asio::error::get_system_category());
-  }
-  else
-  {
-    ec = asio::error_code();
-  }
-  return ec;
-}
-
-size_t win_iocp_io_service::run(asio::error_code& ec)
-{
-  if (::InterlockedExchangeAdd(&outstanding_work_, 0) == 0)
-  {
-    stop();
-    ec = asio::error_code();
-    return 0;
-  }
-
-  win_iocp_thread_info this_thread;
-  thread_call_stack::context ctx(this, this_thread);
-
-  size_t n = 0;
-  while (do_one(true, ec))
-    if (n != (std::numeric_limits<size_t>::max)())
-      ++n;
-  return n;
-}
-
-size_t win_iocp_io_service::run_one(asio::error_code& ec)
-{
-  if (::InterlockedExchangeAdd(&outstanding_work_, 0) == 0)
-  {
-    stop();
-    ec = asio::error_code();
-    return 0;
-  }
-
-  win_iocp_thread_info this_thread;
-  thread_call_stack::context ctx(this, this_thread);
-
-  return do_one(true, ec);
-}
-
-size_t win_iocp_io_service::poll(asio::error_code& ec)
-{
-  if (::InterlockedExchangeAdd(&outstanding_work_, 0) == 0)
-  {
-    stop();
-    ec = asio::error_code();
-    return 0;
-  }
-
-  win_iocp_thread_info this_thread;
-  thread_call_stack::context ctx(this, this_thread);
-
-  size_t n = 0;
-  while (do_one(false, ec))
-    if (n != (std::numeric_limits<size_t>::max)())
-      ++n;
-  return n;
-}
-
-size_t win_iocp_io_service::poll_one(asio::error_code& ec)
-{
-  if (::InterlockedExchangeAdd(&outstanding_work_, 0) == 0)
-  {
-    stop();
-    ec = asio::error_code();
-    return 0;
-  }
-
-  win_iocp_thread_info this_thread;
-  thread_call_stack::context ctx(this, this_thread);
-
-  return do_one(false, ec);
-}
-
-void win_iocp_io_service::stop()
-{
-  if (::InterlockedExchange(&stopped_, 1) == 0)
-  {
-    if (::InterlockedExchange(&stop_event_posted_, 1) == 0)
-    {
-      if (!::PostQueuedCompletionStatus(iocp_.handle, 0, 0, 0))
-      {
-        DWORD last_error = ::GetLastError();
-        asio::error_code ec(last_error,
-            asio::error::get_system_category());
-        asio::detail::throw_error(ec, "pqcs");
-      }
-    }
-  }
-}
-
-void win_iocp_io_service::post_deferred_completion(win_iocp_operation* op)
-{
-  // Flag the operation as ready.
-  op->ready_ = 1;
-
-  // Enqueue the operation on the I/O completion port.
-  if (!::PostQueuedCompletionStatus(iocp_.handle, 0, 0, op))
-  {
-    // Out of resources. Put on completed queue instead.
-    mutex::scoped_lock lock(dispatch_mutex_);
-    completed_ops_.push(op);
-    ::InterlockedExchange(&dispatch_required_, 1);
-  }
-}
-
-void win_iocp_io_service::post_deferred_completions(
-    op_queue<win_iocp_operation>& ops)
-{
-  while (win_iocp_operation* op = ops.front())
-  {
-    ops.pop();
-
-    // Flag the operation as ready.
-    op->ready_ = 1;
-
-    // Enqueue the operation on the I/O completion port.
-    if (!::PostQueuedCompletionStatus(iocp_.handle, 0, 0, op))
-    {
-      // Out of resources. Put on completed queue instead.
-      mutex::scoped_lock lock(dispatch_mutex_);
-      completed_ops_.push(op);
-      completed_ops_.push(ops);
-      ::InterlockedExchange(&dispatch_required_, 1);
-    }
-  }
-}
-
-void win_iocp_io_service::abandon_operations(
-    op_queue<win_iocp_operation>& ops)
-{
-  while (win_iocp_operation* op = ops.front())
-  {
-    ops.pop();
-    ::InterlockedDecrement(&outstanding_work_);
-    op->destroy();
-  }
-}
-
-void win_iocp_io_service::on_pending(win_iocp_operation* op)
-{
-  if (::InterlockedCompareExchange(&op->ready_, 1, 0) == 1)
-  {
-    // Enqueue the operation on the I/O completion port.
-    if (!::PostQueuedCompletionStatus(iocp_.handle,
-          0, overlapped_contains_result, op))
-    {
-      // Out of resources. Put on completed queue instead.
-      mutex::scoped_lock lock(dispatch_mutex_);
-      completed_ops_.push(op);
-      ::InterlockedExchange(&dispatch_required_, 1);
-    }
-  }
-}
-
-void win_iocp_io_service::on_completion(win_iocp_operation* op,
-    DWORD last_error, DWORD bytes_transferred)
-{
-  // Flag that the operation is ready for invocation.
-  op->ready_ = 1;
-
-  // Store results in the OVERLAPPED structure.
-  op->Internal = reinterpret_cast<ulong_ptr_t>(
-      &asio::error::get_system_category());
-  op->Offset = last_error;
-  op->OffsetHigh = bytes_transferred;
-
-  // Enqueue the operation on the I/O completion port.
-  if (!::PostQueuedCompletionStatus(iocp_.handle,
-        0, overlapped_contains_result, op))
-  {
-    // Out of resources. Put on completed queue instead.
-    mutex::scoped_lock lock(dispatch_mutex_);
-    completed_ops_.push(op);
-    ::InterlockedExchange(&dispatch_required_, 1);
-  }
-}
-
-void win_iocp_io_service::on_completion(win_iocp_operation* op,
-    const asio::error_code& ec, DWORD bytes_transferred)
-{
-  // Flag that the operation is ready for invocation.
-  op->ready_ = 1;
-
-  // Store results in the OVERLAPPED structure.
-  op->Internal = reinterpret_cast<ulong_ptr_t>(&ec.category());
-  op->Offset = ec.value();
-  op->OffsetHigh = bytes_transferred;
-
-  // Enqueue the operation on the I/O completion port.
-  if (!::PostQueuedCompletionStatus(iocp_.handle,
-        0, overlapped_contains_result, op))
-  {
-    // Out of resources. Put on completed queue instead.
-    mutex::scoped_lock lock(dispatch_mutex_);
-    completed_ops_.push(op);
-    ::InterlockedExchange(&dispatch_required_, 1);
-  }
-}
-
-size_t win_iocp_io_service::do_one(bool block, asio::error_code& ec)
-{
-  for (;;)
-  {
-    // Try to acquire responsibility for dispatching timers and completed ops.
-    if (::InterlockedCompareExchange(&dispatch_required_, 0, 1) == 1)
-    {
-      mutex::scoped_lock lock(dispatch_mutex_);
-
-      // Dispatch pending timers and operations.
-      op_queue<win_iocp_operation> ops;
-      ops.push(completed_ops_);
-      timer_queues_.get_ready_timers(ops);
-      post_deferred_completions(ops);
-      update_timeout();
-    }
-
-    // Get the next operation from the queue.
-    DWORD bytes_transferred = 0;
-    dword_ptr_t completion_key = 0;
-    LPOVERLAPPED overlapped = 0;
-    ::SetLastError(0);
-    BOOL ok = ::GetQueuedCompletionStatus(iocp_.handle, &bytes_transferred,
-        &completion_key, &overlapped, block ? gqcs_timeout_ : 0);
-    DWORD last_error = ::GetLastError();
-
-    if (overlapped)
-    {
-      win_iocp_operation* op = static_cast<win_iocp_operation*>(overlapped);
-      asio::error_code result_ec(last_error,
-          asio::error::get_system_category());
-
-      // We may have been passed the last_error and bytes_transferred in the
-      // OVERLAPPED structure itself.
-      if (completion_key == overlapped_contains_result)
-      {
-        result_ec = asio::error_code(static_cast<int>(op->Offset),
-            *reinterpret_cast<asio::error_category*>(op->Internal));
-        bytes_transferred = op->OffsetHigh;
-      }
-
-      // Otherwise ensure any result has been saved into the OVERLAPPED
-      // structure.
-      else
-      {
-        op->Internal = reinterpret_cast<ulong_ptr_t>(&result_ec.category());
-        op->Offset = result_ec.value();
-        op->OffsetHigh = bytes_transferred;
-      }
-
-      // Dispatch the operation only if ready. The operation may not be ready
-      // if the initiating function (e.g. a call to WSARecv) has not yet
-      // returned. This is because the initiating function still wants access
-      // to the operation's OVERLAPPED structure.
-      if (::InterlockedCompareExchange(&op->ready_, 1, 0) == 1)
-      {
-        // Ensure the count of outstanding work is decremented on block exit.
-        work_finished_on_block_exit on_exit = { this };
-        (void)on_exit;
-
-        op->complete(this, result_ec, bytes_transferred);
-        ec = asio::error_code();
-        return 1;
-      }
-    }
-    else if (!ok)
-    {
-      if (last_error != WAIT_TIMEOUT)
-      {
-        ec = asio::error_code(last_error,
-            asio::error::get_system_category());
-        return 0;
-      }
-
-      // If we're not polling we need to keep going until we get a real handler.
-      if (block)
-        continue;
-
-      ec = asio::error_code();
-      return 0;
-    }
-    else if (completion_key == wake_for_dispatch)
-    {
-      // We have been woken up to try to acquire responsibility for dispatching
-      // timers and completed operations.
-    }
-    else
-    {
-      // Indicate that there is no longer an in-flight stop event.
-      ::InterlockedExchange(&stop_event_posted_, 0);
-
-      // The stopped_ flag is always checked to ensure that any leftover
-      // stop events from a previous run invocation are ignored.
-      if (::InterlockedExchangeAdd(&stopped_, 0) != 0)
-      {
-        // Wake up next thread that is blocked on GetQueuedCompletionStatus.
-        if (::InterlockedExchange(&stop_event_posted_, 1) == 0)
-        {
-          if (!::PostQueuedCompletionStatus(iocp_.handle, 0, 0, 0))
-          {
-            last_error = ::GetLastError();
-            ec = asio::error_code(last_error,
-                asio::error::get_system_category());
-            return 0;
-          }
-        }
-
-        ec = asio::error_code();
-        return 0;
-      }
-    }
-  }
-}
-
-DWORD win_iocp_io_service::get_gqcs_timeout()
-{
-  OSVERSIONINFOEX osvi;
-  ZeroMemory(&osvi, sizeof(osvi));
-  osvi.dwOSVersionInfoSize = sizeof(osvi);
-  osvi.dwMajorVersion = 6ul;
-
-  const uint64_t condition_mask = ::VerSetConditionMask(
-      0, VER_MAJORVERSION, VER_GREATER_EQUAL);
-
-  if (!!::VerifyVersionInfo(&osvi, VER_MAJORVERSION, condition_mask))
-    return INFINITE;
-
-  return default_gqcs_timeout;
-}
-
-void win_iocp_io_service::do_add_timer_queue(timer_queue_base& queue)
-{
-  mutex::scoped_lock lock(dispatch_mutex_);
-
-  timer_queues_.insert(&queue);
-
-  if (!waitable_timer_.handle)
-  {
-    waitable_timer_.handle = ::CreateWaitableTimer(0, FALSE, 0);
-    if (waitable_timer_.handle == 0)
-    {
-      DWORD last_error = ::GetLastError();
-      asio::error_code ec(last_error,
-          asio::error::get_system_category());
-      asio::detail::throw_error(ec, "timer");
-    }
-
-    LARGE_INTEGER timeout;
-    timeout.QuadPart = -max_timeout_usec;
-    timeout.QuadPart *= 10;
-    ::SetWaitableTimer(waitable_timer_.handle,
-        &timeout, max_timeout_msec, 0, 0, FALSE);
-  }
-
-  if (!timer_thread_.get())
-  {
-    timer_thread_function thread_function = { this };
-    timer_thread_.reset(new thread(thread_function, 65536));
-  }
-}
-
-void win_iocp_io_service::do_remove_timer_queue(timer_queue_base& queue)
-{
-  mutex::scoped_lock lock(dispatch_mutex_);
-
-  timer_queues_.erase(&queue);
-}
-
-void win_iocp_io_service::update_timeout()
-{
-  if (timer_thread_.get())
-  {
-    // There's no point updating the waitable timer if the new timeout period
-    // exceeds the maximum timeout. In that case, we might as well wait for the
-    // existing period of the timer to expire.
-    long timeout_usec = timer_queues_.wait_duration_usec(max_timeout_usec);
-    if (timeout_usec < max_timeout_usec)
-    {
-      LARGE_INTEGER timeout;
-      timeout.QuadPart = -timeout_usec;
-      timeout.QuadPart *= 10;
-      ::SetWaitableTimer(waitable_timer_.handle,
-          &timeout, max_timeout_msec, 0, 0, FALSE);
-    }
-  }
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_IMPL_WIN_IOCP_IO_SERVICE_IPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_serial_port_service.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_serial_port_service.ipp
index 43e46f7..d84f4b2 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_serial_port_service.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_serial_port_service.ipp
@@ -2,7 +2,7 @@
 // detail/impl/win_iocp_serial_port_service.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -29,12 +29,13 @@ namespace asio {
 namespace detail {
 
 win_iocp_serial_port_service::win_iocp_serial_port_service(
-    asio::io_service& io_service)
-  : handle_service_(io_service)
+    asio::io_context& io_context)
+  : service_base<win_iocp_serial_port_service>(io_context),
+    handle_service_(io_context)
 {
 }
 
-void win_iocp_serial_port_service::shutdown_service()
+void win_iocp_serial_port_service::shutdown()
 {
 }
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_socket_service_base.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_socket_service_base.ipp
index 3e374f7..4230f5c 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_socket_service_base.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_iocp_socket_service_base.ipp
@@ -2,7 +2,7 @@
 // detail/impl/win_iocp_socket_service_base.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -27,9 +27,9 @@ namespace asio {
 namespace detail {
 
 win_iocp_socket_service_base::win_iocp_socket_service_base(
-    asio::io_service& io_service)
-  : io_service_(io_service),
-    iocp_service_(use_service<win_iocp_io_service>(io_service)),
+    asio::io_context& io_context)
+  : io_context_(io_context),
+    iocp_service_(use_service<win_iocp_io_context>(io_context)),
     reactor_(0),
     connect_ex_(0),
     mutex_(),
@@ -37,7 +37,7 @@ win_iocp_socket_service_base::win_iocp_socket_service_base(
 {
 }
 
-void win_iocp_socket_service_base::shutdown_service()
+void win_iocp_socket_service_base::base_shutdown()
 {
   // Close all implementations, causing all operations to complete.
   asio::detail::mutex::scoped_lock lock(mutex_);
@@ -166,7 +166,8 @@ asio::error_code win_iocp_socket_service_base::close(
 {
   if (is_open(impl))
   {
-    ASIO_HANDLER_OPERATION(("socket", &impl, "close"));
+    ASIO_HANDLER_OPERATION((iocp_service_.context(),
+          "socket", &impl, impl.socket_, "close"));
 
     // Check if the reactor was created, in which case we need to close the
     // socket on the reactor as well to cancel any operations that might be
@@ -200,7 +201,8 @@ asio::error_code win_iocp_socket_service_base::cancel(
     return ec;
   }
 
-  ASIO_HANDLER_OPERATION(("socket", &impl, "cancel"));
+  ASIO_HANDLER_OPERATION((iocp_service_.context(),
+        "socket", &impl, impl.socket_, "cancel"));
 
   if (FARPROC cancel_io_ex_ptr = ::GetProcAddress(
         ::GetModuleHandleA("KERNEL32"), "CancelIoEx"))
@@ -618,7 +620,8 @@ void win_iocp_socket_service_base::close_for_destruction(
 {
   if (is_open(impl))
   {
-    ASIO_HANDLER_OPERATION(("socket", &impl, "close"));
+    ASIO_HANDLER_OPERATION((iocp_service_.context(),
+          "socket", &impl, impl.socket_, "close"));
 
     // Check if the reactor was created, in which case we need to close the
     // socket on the reactor as well to cancel any operations that might be
@@ -660,7 +663,7 @@ select_reactor& win_iocp_socket_service_base::get_reactor()
           reinterpret_cast<void**>(&reactor_), 0, 0));
   if (!r)
   {
-    r = &(use_service<select_reactor>(io_service_));
+    r = &(use_service<select_reactor>(io_context_));
     interlocked_exchange_pointer(reinterpret_cast<void**>(&reactor_), r);
   }
   return *r;
@@ -670,6 +673,11 @@ win_iocp_socket_service_base::connect_ex_fn
 win_iocp_socket_service_base::get_connect_ex(
     win_iocp_socket_service_base::base_implementation_type& impl, int type)
 {
+#if defined(ASIO_DISABLE_CONNECTEX)
+  (void)impl;
+  (void)type;
+  return 0;
+#else // defined(ASIO_DISABLE_CONNECTEX)
   if (type != ASIO_OS_DEF(SOCK_STREAM)
       && type != ASIO_OS_DEF(SOCK_SEQPACKET))
     return 0;
@@ -693,6 +701,7 @@ win_iocp_socket_service_base::get_connect_ex(
   }
 
   return reinterpret_cast<connect_ex_fn>(ptr == this ? 0 : ptr);
+#endif // defined(ASIO_DISABLE_CONNECTEX)
 }
 
 void* win_iocp_socket_service_base::interlocked_compare_exchange_pointer(
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_mutex.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_mutex.ipp
index 608f4f5..1d5d5a8 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_mutex.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_mutex.ipp
@@ -2,7 +2,7 @@
 // detail/impl/win_mutex.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -43,6 +43,8 @@ int win_mutex::do_init()
   // we'll just call the Windows API and hope.
 # if defined(UNDER_CE)
   ::InitializeCriticalSection(&crit_section_);
+# elif defined(ASIO_WINDOWS_APP)
+  ::InitializeCriticalSectionEx(&crit_section_, 0x80000000, 0);
 # else
   if (!::InitializeCriticalSectionAndSpinCount(&crit_section_, 0x80000000))
     return ::GetLastError();
@@ -53,6 +55,8 @@ int win_mutex::do_init()
   {
 # if defined(UNDER_CE)
     ::InitializeCriticalSection(&crit_section_);
+# elif defined(ASIO_WINDOWS_APP)
+    ::InitializeCriticalSectionEx(&crit_section_, 0x80000000, 0);
 # else
     if (!::InitializeCriticalSectionAndSpinCount(&crit_section_, 0x80000000))
       return ::GetLastError();
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_object_handle_service.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_object_handle_service.ipp
index f10bc4d..9b3da7f 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_object_handle_service.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_object_handle_service.ipp
@@ -2,7 +2,7 @@
 // detail/impl/win_object_handle_service.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2011 Boris Schaeling (boris@highscore.de)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -28,15 +28,16 @@ namespace asio {
 namespace detail {
 
 win_object_handle_service::win_object_handle_service(
-    asio::io_service& io_service)
-  : io_service_(asio::use_service<io_service_impl>(io_service)),
+    asio::io_context& io_context)
+  : service_base<win_object_handle_service>(io_context),
+    io_context_(asio::use_service<io_context_impl>(io_context)),
     mutex_(),
     impl_list_(0),
     shutdown_(false)
 {
 }
 
-void win_object_handle_service::shutdown_service()
+void win_object_handle_service::shutdown()
 {
   mutex::scoped_lock lock(mutex_);
 
@@ -51,7 +52,7 @@ void win_object_handle_service::shutdown_service()
 
   lock.unlock();
 
-  io_service_.abandon_operations(ops);
+  io_context_.abandon_operations(ops);
 }
 
 void win_object_handle_service::construct(
@@ -177,7 +178,8 @@ void win_object_handle_service::destroy(
 
   if (is_open(impl))
   {
-    ASIO_HANDLER_OPERATION(("object_handle", &impl, "close"));
+    ASIO_HANDLER_OPERATION((io_context_.context(), "object_handle",
+          &impl, reinterpret_cast<uintmax_t>(impl.wait_handle_), "close"));
 
     HANDLE wait_handle = impl.wait_handle_;
     impl.wait_handle_ = INVALID_HANDLE_VALUE;
@@ -201,7 +203,7 @@ void win_object_handle_service::destroy(
     ::CloseHandle(impl.handle_);
     impl.handle_ = INVALID_HANDLE_VALUE;
 
-    io_service_.post_deferred_completions(ops);
+    io_context_.post_deferred_completions(ops);
   }
 }
 
@@ -226,7 +228,8 @@ asio::error_code win_object_handle_service::close(
 {
   if (is_open(impl))
   {
-    ASIO_HANDLER_OPERATION(("object_handle", &impl, "close"));
+    ASIO_HANDLER_OPERATION((io_context_.context(), "object_handle",
+          &impl, reinterpret_cast<uintmax_t>(impl.wait_handle_), "close"));
 
     mutex::scoped_lock lock(mutex_);
 
@@ -261,7 +264,7 @@ asio::error_code win_object_handle_service::close(
           asio::error::get_system_category());
     }
 
-    io_service_.post_deferred_completions(completed_ops);
+    io_context_.post_deferred_completions(completed_ops);
   }
   else
   {
@@ -277,7 +280,8 @@ asio::error_code win_object_handle_service::cancel(
 {
   if (is_open(impl))
   {
-    ASIO_HANDLER_OPERATION(("object_handle", &impl, "cancel"));
+    ASIO_HANDLER_OPERATION((io_context_.context(), "object_handle",
+          &impl, reinterpret_cast<uintmax_t>(impl.wait_handle_), "cancel"));
 
     mutex::scoped_lock lock(mutex_);
 
@@ -302,7 +306,7 @@ asio::error_code win_object_handle_service::cancel(
 
     ec = asio::error_code();
 
-    io_service_.post_deferred_completions(completed_ops);
+    io_context_.post_deferred_completions(completed_ops);
   }
   else
   {
@@ -336,7 +340,7 @@ void win_object_handle_service::wait(
 void win_object_handle_service::start_wait_op(
     win_object_handle_service::implementation_type& impl, wait_op* op)
 {
-  io_service_.work_started();
+  io_context_.work_started();
 
   if (is_open(impl))
   {
@@ -354,13 +358,13 @@ void win_object_handle_service::start_wait_op(
     else
     {
       lock.unlock();
-      io_service_.post_deferred_completion(op);
+      io_context_.post_deferred_completion(op);
     }
   }
   else
   {
     op->ec_ = asio::error::bad_descriptor;
-    io_service_.post_deferred_completion(op);
+    io_context_.post_deferred_completion(op);
   }
 }
 
@@ -387,7 +391,7 @@ void win_object_handle_service::register_wait_callback(
     }
 
     lock.unlock();
-    io_service_.post_deferred_completions(completed_ops);
+    io_context_.post_deferred_completions(completed_ops);
   }
 }
 
@@ -429,8 +433,9 @@ void win_object_handle_service::wait_callback(PVOID param, BOOLEAN)
       }
     }
 
+    io_context_impl& ioc = impl->owner_->io_context_;
     lock.unlock();
-    impl->owner_->io_service_.post_deferred_completions(completed_ops);
+    ioc.post_deferred_completions(completed_ops);
   }
 }
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_static_mutex.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_static_mutex.ipp
index 2654aa6..359752d 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_static_mutex.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_static_mutex.ipp
@@ -2,7 +2,7 @@
 // detail/impl/win_static_mutex.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -49,13 +49,23 @@ int win_static_mutex::do_init()
       mutex_name, 128, L"asio-58CCDC44-6264-4842-90C2-F3C545CB8AA7-%u-%p",
       static_cast<unsigned int>(::GetCurrentProcessId()), this);
 
+#if defined(ASIO_WINDOWS_APP)
+  HANDLE mutex = ::CreateMutexExW(0, mutex_name, CREATE_MUTEX_INITIAL_OWNER, 0);
+#else // defined(ASIO_WINDOWS_APP)
   HANDLE mutex = ::CreateMutexW(0, TRUE, mutex_name);
+#endif // defined(ASIO_WINDOWS_APP)
   DWORD last_error = ::GetLastError();
   if (mutex == 0)
     return ::GetLastError();
 
   if (last_error == ERROR_ALREADY_EXISTS)
+  {
+#if defined(ASIO_WINDOWS_APP)
+    ::WaitForSingleObjectEx(mutex, INFINITE, false);
+#else // defined(ASIO_WINDOWS_APP)
     ::WaitForSingleObject(mutex, INFINITE);
+#endif // defined(ASIO_WINDOWS_APP)
+  }
 
   if (initialised_)
   {
@@ -83,6 +93,8 @@ int win_static_mutex::do_init()
   {
 # if defined(UNDER_CE)
     ::InitializeCriticalSection(&crit_section_);
+# elif defined(ASIO_WINDOWS_APP)
+    ::InitializeCriticalSectionEx(&crit_section_, 0x80000000, 0);
 # else
     if (!::InitializeCriticalSectionAndSpinCount(&crit_section_, 0x80000000))
     {
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_thread.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_thread.ipp
index 4274ebe..4269e6b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_thread.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_thread.ipp
@@ -2,7 +2,7 @@
 // detail/impl/win_thread.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,7 +17,9 @@
 
 #include "asio/detail/config.hpp"
 
-#if defined(ASIO_WINDOWS) && !defined(UNDER_CE)
+#if defined(ASIO_WINDOWS) \
+  && !defined(ASIO_WINDOWS_APP) \
+  && !defined(UNDER_CE)
 
 #include <process.h>
 #include "asio/detail/throw_error.hpp"
@@ -63,7 +65,7 @@ std::size_t win_thread::hardware_concurrency()
 void win_thread::start_thread(func_base* arg, unsigned int stack_size)
 {
   ::HANDLE entry_event = 0;
-  arg->entry_event_ = entry_event = ::CreateEvent(0, true, false, 0);
+  arg->entry_event_ = entry_event = ::CreateEventW(0, true, false, 0);
   if (!entry_event)
   {
     DWORD last_error = ::GetLastError();
@@ -73,7 +75,7 @@ void win_thread::start_thread(func_base* arg, unsigned int stack_size)
     asio::detail::throw_error(ec, "thread.entry_event");
   }
 
-  arg->exit_event_ = exit_event_ = ::CreateEvent(0, true, false, 0);
+  arg->exit_event_ = exit_event_ = ::CreateEventW(0, true, false, 0);
   if (!exit_event_)
   {
     DWORD last_error = ::GetLastError();
@@ -141,6 +143,8 @@ void __stdcall apc_function(ULONG_PTR) {}
 
 #include "asio/detail/pop_options.hpp"
 
-#endif // defined(ASIO_WINDOWS) && !defined(UNDER_CE)
+#endif // defined(ASIO_WINDOWS)
+       // && !defined(ASIO_WINDOWS_APP)
+       // && !defined(UNDER_CE)
 
 #endif // ASIO_DETAIL_IMPL_WIN_THREAD_IPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_tss_ptr.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_tss_ptr.ipp
index 74414a3..75a436c 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_tss_ptr.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/win_tss_ptr.ipp
@@ -2,7 +2,7 @@
 // detail/impl/win_tss_ptr.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/winrt_ssocket_service_base.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/winrt_ssocket_service_base.ipp
index 0650700..f3d74cf 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/winrt_ssocket_service_base.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/winrt_ssocket_service_base.ipp
@@ -2,7 +2,7 @@
 // detail/impl/winrt_ssocket_service_base.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -30,15 +30,15 @@ namespace asio {
 namespace detail {
 
 winrt_ssocket_service_base::winrt_ssocket_service_base(
-    asio::io_service& io_service)
-  : io_service_(use_service<io_service_impl>(io_service)),
-    async_manager_(use_service<winrt_async_manager>(io_service)),
+    asio::io_context& io_context)
+  : io_context_(use_service<io_context_impl>(io_context)),
+    async_manager_(use_service<winrt_async_manager>(io_context)),
     mutex_(),
     impl_list_(0)
 {
 }
 
-void winrt_ssocket_service_base::shutdown_service()
+void winrt_ssocket_service_base::base_shutdown()
 {
   // Close all implementations, causing all operations to complete.
   asio::detail::mutex::scoped_lock lock(mutex_);
@@ -381,7 +381,7 @@ void winrt_ssocket_service_base::start_connect_op(
   if (!is_open(impl))
   {
     op->ec_ = asio::error::bad_descriptor;
-    io_service_.post_immediate_completion(op, is_continuation);
+    io_context_.post_immediate_completion(op, is_continuation);
     return;
   }
 
@@ -410,7 +410,7 @@ void winrt_ssocket_service_base::start_connect_op(
 
   if (op->ec_)
   {
-    io_service_.post_immediate_completion(op, is_continuation);
+    io_context_.post_immediate_completion(op, is_continuation);
     return;
   }
 
@@ -425,7 +425,7 @@ void winrt_ssocket_service_base::start_connect_op(
   {
     op->ec_ = asio::error_code(
         e->HResult, asio::system_category());
-    io_service_.post_immediate_completion(op, is_continuation);
+    io_context_.post_immediate_completion(op, is_continuation);
   }
 }
 
@@ -449,7 +449,7 @@ std::size_t winrt_ssocket_service_base::do_send(
   try
   {
     buffer_sequence_adapter<asio::const_buffer,
-      asio::const_buffers_1> bufs(asio::buffer(data));
+      asio::const_buffer> bufs(asio::buffer(data));
 
     if (bufs.all_empty())
     {
@@ -476,25 +476,25 @@ void winrt_ssocket_service_base::start_send_op(
   if (flags)
   {
     op->ec_ = asio::error::operation_not_supported;
-    io_service_.post_immediate_completion(op, is_continuation);
+    io_context_.post_immediate_completion(op, is_continuation);
     return;
   }
 
   if (!is_open(impl))
   {
     op->ec_ = asio::error::bad_descriptor;
-    io_service_.post_immediate_completion(op, is_continuation);
+    io_context_.post_immediate_completion(op, is_continuation);
     return;
   }
 
   try
   {
     buffer_sequence_adapter<asio::const_buffer,
-        asio::const_buffers_1> bufs(asio::buffer(data));
+        asio::const_buffer> bufs(asio::buffer(data));
 
     if (bufs.all_empty())
     {
-      io_service_.post_immediate_completion(op, is_continuation);
+      io_context_.post_immediate_completion(op, is_continuation);
       return;
     }
 
@@ -505,7 +505,7 @@ void winrt_ssocket_service_base::start_send_op(
   {
     op->ec_ = asio::error_code(e->HResult,
         asio::system_category());
-    io_service_.post_immediate_completion(op, is_continuation);
+    io_context_.post_immediate_completion(op, is_continuation);
   }
 }
 
@@ -529,7 +529,7 @@ std::size_t winrt_ssocket_service_base::do_receive(
   try
   {
     buffer_sequence_adapter<asio::mutable_buffer,
-        asio::mutable_buffers_1> bufs(asio::buffer(data));
+        asio::mutable_buffer> bufs(asio::buffer(data));
 
     if (bufs.all_empty())
     {
@@ -567,25 +567,25 @@ void winrt_ssocket_service_base::start_receive_op(
   if (flags)
   {
     op->ec_ = asio::error::operation_not_supported;
-    io_service_.post_immediate_completion(op, is_continuation);
+    io_context_.post_immediate_completion(op, is_continuation);
     return;
   }
 
   if (!is_open(impl))
   {
     op->ec_ = asio::error::bad_descriptor;
-    io_service_.post_immediate_completion(op, is_continuation);
+    io_context_.post_immediate_completion(op, is_continuation);
     return;
   }
 
   try
   {
     buffer_sequence_adapter<asio::mutable_buffer,
-        asio::mutable_buffers_1> bufs(asio::buffer(data));
+        asio::mutable_buffer> bufs(asio::buffer(data));
 
     if (bufs.all_empty())
     {
-      io_service_.post_immediate_completion(op, is_continuation);
+      io_context_.post_immediate_completion(op, is_continuation);
       return;
     }
 
@@ -598,7 +598,7 @@ void winrt_ssocket_service_base::start_receive_op(
   {
     op->ec_ = asio::error_code(e->HResult,
         asio::system_category());
-    io_service_.post_immediate_completion(op, is_continuation);
+    io_context_.post_immediate_completion(op, is_continuation);
   }
 }
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/winrt_timer_scheduler.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/winrt_timer_scheduler.hpp
index 1ed26d6..e844731 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/winrt_timer_scheduler.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/winrt_timer_scheduler.hpp
@@ -2,7 +2,7 @@
 // detail/impl/winrt_timer_scheduler.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -46,12 +46,12 @@ void winrt_timer_scheduler::schedule_timer(timer_queue<Time_Traits>& queue,
 
   if (shutdown_)
   {
-    io_service_.post_immediate_completion(op, false);
+    io_context_.post_immediate_completion(op, false);
     return;
   }
 
   bool earliest = queue.enqueue_timer(time, timer, op);
-  io_service_.work_started();
+  io_context_.work_started();
   if (earliest)
     event_.signal(lock);
 }
@@ -65,7 +65,7 @@ std::size_t winrt_timer_scheduler::cancel_timer(timer_queue<Time_Traits>& queue,
   op_queue<operation> ops;
   std::size_t n = queue.cancel_timer(timer, ops, max_cancelled);
   lock.unlock();
-  io_service_.post_deferred_completions(ops);
+  io_context_.post_deferred_completions(ops);
   return n;
 }
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/winrt_timer_scheduler.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/winrt_timer_scheduler.ipp
index 7738917..2bc92b7 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/winrt_timer_scheduler.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/winrt_timer_scheduler.ipp
@@ -2,7 +2,7 @@
 // detail/impl/winrt_timer_scheduler.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -28,9 +28,9 @@ namespace asio {
 namespace detail {
 
 winrt_timer_scheduler::winrt_timer_scheduler(
-    asio::io_service& io_service)
-  : asio::detail::service_base<winrt_timer_scheduler>(io_service),
-    io_service_(use_service<io_service_impl>(io_service)),
+    asio::io_context& io_context)
+  : asio::detail::service_base<winrt_timer_scheduler>(io_context),
+    io_context_(use_service<io_context_impl>(io_context)),
     mutex_(),
     event_(),
     timer_queues_(),
@@ -44,10 +44,10 @@ winrt_timer_scheduler::winrt_timer_scheduler(
 
 winrt_timer_scheduler::~winrt_timer_scheduler()
 {
-  shutdown_service();
+  shutdown();
 }
 
-void winrt_timer_scheduler::shutdown_service()
+void winrt_timer_scheduler::shutdown()
 {
   asio::detail::mutex::scoped_lock lock(mutex_);
   shutdown_ = true;
@@ -64,10 +64,10 @@ void winrt_timer_scheduler::shutdown_service()
 
   op_queue<operation> ops;
   timer_queues_.get_all_timers(ops);
-  io_service_.abandon_operations(ops);
+  io_context_.abandon_operations(ops);
 }
 
-void winrt_timer_scheduler::fork_service(asio::io_service::fork_event)
+void winrt_timer_scheduler::notify_fork(asio::io_context::fork_event)
 {
 }
 
@@ -89,7 +89,7 @@ void winrt_timer_scheduler::run_thread()
     if (!ops.empty())
     {
       lock.unlock();
-      io_service_.post_deferred_completions(ops);
+      io_context_.post_deferred_completions(ops);
       lock.lock();
     }
   }
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/winsock_init.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/winsock_init.ipp
index 45cc9e0..094b58b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/winsock_init.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/impl/winsock_init.ipp
@@ -2,7 +2,7 @@
 // detail/impl/winsock_init.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/io_control.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/io_control.hpp
index f5dd900..81b3d49 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/io_control.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/io_control.hpp
@@ -2,7 +2,7 @@
 // detail/io_control.hpp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/is_buffer_sequence.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/is_buffer_sequence.hpp
index e7a0cae..95f29c5 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/is_buffer_sequence.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/is_buffer_sequence.hpp
@@ -2,7 +2,7 @@
 // detail/is_buffer_sequence.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -21,6 +21,10 @@
 #include "asio/detail/push_options.hpp"
 
 namespace asio {
+
+class mutable_buffer;
+class const_buffer;
+
 namespace detail {
 
 struct buffer_sequence_memfns_base
@@ -129,14 +133,26 @@ char consume_memfn_helper(
       &buffer_sequence_memfns_derived<T>::consume>*);
 
 template <typename, typename>
-char (&value_type_const_iterator_typedefs_helper(...))[2];
+char (&buffer_element_type_helper(...))[2];
+
+#if defined(ASIO_HAS_DECL_TYPE)
+
+template <typename T, typename Buffer>
+char buffer_element_type_helper(T* t,
+    typename enable_if<is_convertible<
+      decltype(*buffer_sequence_begin(*t)),
+        Buffer>::value>::type*);
+
+#else // defined(ASIO_HAS_DECL_TYPE)
 
 template <typename T, typename Buffer>
-char value_type_const_iterator_typedefs_helper(
+char buffer_element_type_helper(
     typename T::const_iterator*,
     typename enable_if<is_convertible<
       typename T::value_type, Buffer>::value>::type*);
 
+#endif // defined(ASIO_HAS_DECL_TYPE)
+
 template <typename>
 char (&const_buffers_type_typedef_helper(...))[2];
 
@@ -156,7 +172,7 @@ struct is_buffer_sequence_class
   : integral_constant<bool,
       sizeof(begin_memfn_helper<T>(0)) != 1 &&
       sizeof(end_memfn_helper<T>(0)) != 1 &&
-      sizeof(value_type_const_iterator_typedefs_helper<T, Buffer>(0, 0)) == 1>
+      sizeof(buffer_element_type_helper<T, Buffer>(0, 0)) == 1>
 {
 };
 
@@ -168,8 +184,32 @@ struct is_buffer_sequence
 {
 };
 
+template <>
+struct is_buffer_sequence<mutable_buffer, mutable_buffer>
+  : true_type
+{
+};
+
+template <>
+struct is_buffer_sequence<mutable_buffer, const_buffer>
+  : true_type
+{
+};
+
+template <>
+struct is_buffer_sequence<const_buffer, const_buffer>
+  : true_type
+{
+};
+
+template <>
+struct is_buffer_sequence<const_buffer, mutable_buffer>
+  : false_type
+{
+};
+
 template <typename T>
-struct is_dynamic_buffer_sequence_class
+struct is_dynamic_buffer_class
   : integral_constant<bool,
       sizeof(size_memfn_helper<T>(0)) != 1 &&
       sizeof(max_size_memfn_helper<T>(0)) != 1 &&
@@ -184,9 +224,9 @@ struct is_dynamic_buffer_sequence_class
 };
 
 template <typename T>
-struct is_dynamic_buffer_sequence
+struct is_dynamic_buffer
   : conditional<is_class<T>::value,
-      is_dynamic_buffer_sequence_class<T>,
+      is_dynamic_buffer_class<T>,
       false_type>::type
 {
 };
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/is_executor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/is_executor.hpp
new file mode 100644
index 0000000..ec0ee00
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/is_executor.hpp
@@ -0,0 +1,126 @@
+//
+// detail/is_executor.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_DETAIL_IS_EXECUTOR_HPP
+#define ASIO_DETAIL_IS_EXECUTOR_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+#include "asio/detail/type_traits.hpp"
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+namespace detail {
+
+struct executor_memfns_base
+{
+  void context();
+  void on_work_started();
+  void on_work_finished();
+  void dispatch();
+  void post();
+  void defer();
+};
+
+template <typename T>
+struct executor_memfns_derived
+  : T, executor_memfns_base
+{
+};
+
+template <typename T, T>
+struct executor_memfns_check
+{
+};
+
+template <typename>
+char (&context_memfn_helper(...))[2];
+
+template <typename T>
+char context_memfn_helper(
+    executor_memfns_check<
+      void (executor_memfns_base::*)(),
+      &executor_memfns_derived<T>::context>*);
+
+template <typename>
+char (&on_work_started_memfn_helper(...))[2];
+
+template <typename T>
+char on_work_started_memfn_helper(
+    executor_memfns_check<
+      void (executor_memfns_base::*)(),
+      &executor_memfns_derived<T>::on_work_started>*);
+
+template <typename>
+char (&on_work_finished_memfn_helper(...))[2];
+
+template <typename T>
+char on_work_finished_memfn_helper(
+    executor_memfns_check<
+      void (executor_memfns_base::*)(),
+      &executor_memfns_derived<T>::on_work_finished>*);
+
+template <typename>
+char (&dispatch_memfn_helper(...))[2];
+
+template <typename T>
+char dispatch_memfn_helper(
+    executor_memfns_check<
+      void (executor_memfns_base::*)(),
+      &executor_memfns_derived<T>::dispatch>*);
+
+template <typename>
+char (&post_memfn_helper(...))[2];
+
+template <typename T>
+char post_memfn_helper(
+    executor_memfns_check<
+      void (executor_memfns_base::*)(),
+      &executor_memfns_derived<T>::post>*);
+
+template <typename>
+char (&defer_memfn_helper(...))[2];
+
+template <typename T>
+char defer_memfn_helper(
+    executor_memfns_check<
+      void (executor_memfns_base::*)(),
+      &executor_memfns_derived<T>::defer>*);
+
+template <typename T>
+struct is_executor_class
+  : integral_constant<bool,
+      sizeof(context_memfn_helper<T>(0)) != 1 &&
+      sizeof(on_work_started_memfn_helper<T>(0)) != 1 &&
+      sizeof(on_work_finished_memfn_helper<T>(0)) != 1 &&
+      sizeof(dispatch_memfn_helper<T>(0)) != 1 &&
+      sizeof(post_memfn_helper<T>(0)) != 1 &&
+      sizeof(defer_memfn_helper<T>(0)) != 1>
+{
+};
+
+template <typename T>
+struct is_executor
+  : conditional<is_class<T>::value,
+      is_executor_class<T>,
+      false_type>::type
+{
+};
+
+} // namespace detail
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // ASIO_DETAIL_IS_EXECUTOR_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/keyword_tss_ptr.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/keyword_tss_ptr.hpp
index c4840bf..c1f9b93 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/keyword_tss_ptr.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/keyword_tss_ptr.hpp
@@ -2,7 +2,7 @@
 // detail/keyword_tss_ptr.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/kqueue_reactor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/kqueue_reactor.hpp
index e841616..8d1c667 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/kqueue_reactor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/kqueue_reactor.hpp
@@ -2,7 +2,7 @@
 // detail/kqueue_reactor.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2005 Stefan Arentz (stefan at soze dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -52,6 +52,10 @@ class scheduler;
 class kqueue_reactor
   : public execution_context_service_base<kqueue_reactor>
 {
+private:
+  // The mutex type used by this reactor.
+  typedef conditionally_enabled_mutex mutex;
+
 public:
   enum op_types { read_op = 0, write_op = 1,
     connect_op = 1, except_op = 2, max_ops = 3 };
@@ -59,6 +63,8 @@ public:
   // Per-descriptor queues.
   struct descriptor_state
   {
+    descriptor_state(bool locking) : mutex_(locking) {}
+
     friend class kqueue_reactor;
     friend class object_pool_access;
 
@@ -67,6 +73,7 @@ public:
 
     mutex mutex_;
     int descriptor_;
+    int num_kevents_; // 1 == read only, 2 == read and write
     op_queue<reactor_op> op_queue_[max_ops];
     bool shutdown_;
   };
@@ -81,10 +88,10 @@ public:
   ASIO_DECL ~kqueue_reactor();
 
   // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
+  ASIO_DECL void shutdown();
 
   // Recreate internal descriptors following a fork.
-  ASIO_DECL void fork_service(
+  ASIO_DECL void notify_fork(
       asio::execution_context::fork_event fork_ev);
 
   // Initialise the task.
@@ -162,7 +169,7 @@ public:
       typename timer_queue<Time_Traits>::per_timer_data& source);
 
   // Run the kqueue loop.
-  ASIO_DECL void run(bool block, op_queue<operation>& ops);
+  ASIO_DECL void run(long usec, op_queue<operation>& ops);
 
   // Interrupt the kqueue loop.
   ASIO_DECL void interrupt();
@@ -185,7 +192,7 @@ private:
   ASIO_DECL void do_remove_timer_queue(timer_queue_base& queue);
 
   // Get the timeout value for the kevent call.
-  ASIO_DECL timespec* get_timeout(timespec& ts);
+  ASIO_DECL timespec* get_timeout(long usec, timespec& ts);
 
   // The scheduler used to post completions.
   scheduler& scheduler_;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/local_free_on_block_exit.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/local_free_on_block_exit.hpp
index 2960dea..a0ea47c 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/local_free_on_block_exit.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/local_free_on_block_exit.hpp
@@ -2,7 +2,7 @@
 // detail/local_free_on_block_exit.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -18,6 +18,7 @@
 #include "asio/detail/config.hpp"
 
 #if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
+#if !defined(ASIO_WINDOWS_APP)
 
 #include "asio/detail/noncopyable.hpp"
 #include "asio/detail/socket_types.hpp"
@@ -52,6 +53,7 @@ private:
 
 #include "asio/detail/pop_options.hpp"
 
+#endif // !defined(ASIO_WINDOWS_APP)
 #endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
 
 #endif // ASIO_DETAIL_LOCAL_FREE_ON_BLOCK_EXIT_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/macos_fenced_block.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/macos_fenced_block.hpp
index 4b64772..e44b900 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/macos_fenced_block.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/macos_fenced_block.hpp
@@ -2,7 +2,7 @@
 // detail/macos_fenced_block.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/memory.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/memory.hpp
index cd0b4ed..51f4532 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/memory.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/memory.hpp
@@ -2,7 +2,7 @@
 // detail/memory.hpp
 // ~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/mutex.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/mutex.hpp
index 35885ad..9821e81 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/mutex.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/mutex.hpp
@@ -2,7 +2,7 @@
 // detail/mutex.hpp
 // ~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/noncopyable.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/noncopyable.hpp
index db5ac4c..31f646a 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/noncopyable.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/noncopyable.hpp
@@ -2,7 +2,7 @@
 // detail/noncopyable.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_event.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_event.hpp
index 394bb16..465a701 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_event.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_event.hpp
@@ -2,7 +2,7 @@
 // detail/null_event.hpp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,9 +16,6 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_THREADS)
-
 #include "asio/detail/noncopyable.hpp"
 
 #include "asio/detail/push_options.hpp"
@@ -75,7 +72,20 @@ public:
   template <typename Lock>
   void wait(Lock&)
   {
+    do_wait();
   }
+
+  // Timed wait for the event to become signalled.
+  template <typename Lock>
+  bool wait_for_usec(Lock&, long usec)
+  {
+    do_wait_for_usec(usec);
+    return true;
+  }
+
+private:
+  ASIO_DECL static void do_wait();
+  ASIO_DECL static void do_wait_for_usec(long usec);
 };
 
 } // namespace detail
@@ -83,6 +93,8 @@ public:
 
 #include "asio/detail/pop_options.hpp"
 
-#endif // !defined(ASIO_HAS_THREADS)
+#if defined(ASIO_HEADER_ONLY)
+# include "asio/detail/impl/null_event.ipp"
+#endif // defined(ASIO_HEADER_ONLY)
 
 #endif // ASIO_DETAIL_NULL_EVENT_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_fenced_block.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_fenced_block.hpp
index 241ceb2..2ec3554 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_fenced_block.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_fenced_block.hpp
@@ -2,7 +2,7 @@
 // detail/null_fenced_block.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_global.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_global.hpp
index b8f73ac..7d3c0df 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_global.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_global.hpp
@@ -2,7 +2,7 @@
 // detail/null_global.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_mutex.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_mutex.hpp
index 4ee92e4..582ab1d 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_mutex.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_mutex.hpp
@@ -2,7 +2,7 @@
 // detail/null_mutex.hpp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_reactor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_reactor.hpp
index 8d2cc84..3b6f1d4 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_reactor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_reactor.hpp
@@ -2,7 +2,7 @@
 // detail/null_reactor.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -43,12 +43,12 @@ public:
   }
 
   // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
+  void shutdown()
   {
   }
 
   // No-op because should never be called.
-  void run(bool /*block*/, op_queue<scheduler_operation>& /*ops*/)
+  void run(long /*usec*/, op_queue<scheduler_operation>& /*ops*/)
   {
   }
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_signal_blocker.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_signal_blocker.hpp
index 43ed011..9992bd6 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_signal_blocker.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_signal_blocker.hpp
@@ -2,7 +2,7 @@
 // detail/null_signal_blocker.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_socket_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_socket_service.hpp
index c991720..59df013 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_socket_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_socket_service.hpp
@@ -2,7 +2,7 @@
 // detail/null_socket_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -21,7 +21,7 @@
 
 #include "asio/buffer.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/socket_base.hpp"
 #include "asio/detail/bind_handler.hpp"
 
@@ -31,7 +31,8 @@ namespace asio {
 namespace detail {
 
 template <typename Protocol>
-class null_socket_service
+class null_socket_service :
+  public service_base<null_socket_service<Protocol> >
 {
 public:
   // The protocol type.
@@ -49,13 +50,14 @@ public:
   };
 
   // Constructor.
-  null_socket_service(asio::io_service& io_service)
-    : io_service_(io_service)
+  null_socket_service(asio::io_context& io_context)
+    : service_base<null_socket_service<Protocol> >(io_context),
+      io_context_(io_context)
   {
   }
 
   // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
+  void shutdown()
   {
   }
 
@@ -267,7 +269,7 @@ public:
   {
     asio::error_code ec = asio::error::operation_not_supported;
     const std::size_t bytes_transferred = 0;
-    io_service_.post(detail::bind_handler(handler, ec, bytes_transferred));
+    io_context_.post(detail::bind_handler(handler, ec, bytes_transferred));
   }
 
   // Start an asynchronous wait until data can be sent without blocking.
@@ -277,7 +279,7 @@ public:
   {
     asio::error_code ec = asio::error::operation_not_supported;
     const std::size_t bytes_transferred = 0;
-    io_service_.post(detail::bind_handler(handler, ec, bytes_transferred));
+    io_context_.post(detail::bind_handler(handler, ec, bytes_transferred));
   }
 
   // Receive some data from the peer. Returns the number of bytes received.
@@ -305,7 +307,7 @@ public:
   {
     asio::error_code ec = asio::error::operation_not_supported;
     const std::size_t bytes_transferred = 0;
-    io_service_.post(detail::bind_handler(handler, ec, bytes_transferred));
+    io_context_.post(detail::bind_handler(handler, ec, bytes_transferred));
   }
 
   // Wait until data can be received without blocking.
@@ -315,7 +317,7 @@ public:
   {
     asio::error_code ec = asio::error::operation_not_supported;
     const std::size_t bytes_transferred = 0;
-    io_service_.post(detail::bind_handler(handler, ec, bytes_transferred));
+    io_context_.post(detail::bind_handler(handler, ec, bytes_transferred));
   }
 
   // Receive some data with associated flags. Returns the number of bytes
@@ -347,7 +349,7 @@ public:
   {
     asio::error_code ec = asio::error::operation_not_supported;
     const std::size_t bytes_transferred = 0;
-    io_service_.post(detail::bind_handler(handler, ec, bytes_transferred));
+    io_context_.post(detail::bind_handler(handler, ec, bytes_transferred));
   }
 
   // Wait until data can be received without blocking.
@@ -358,7 +360,7 @@ public:
   {
     asio::error_code ec = asio::error::operation_not_supported;
     const std::size_t bytes_transferred = 0;
-    io_service_.post(detail::bind_handler(handler, ec, bytes_transferred));
+    io_context_.post(detail::bind_handler(handler, ec, bytes_transferred));
   }
 
   // Send a datagram to the specified endpoint. Returns the number of bytes
@@ -390,7 +392,7 @@ public:
   {
     asio::error_code ec = asio::error::operation_not_supported;
     const std::size_t bytes_transferred = 0;
-    io_service_.post(detail::bind_handler(handler, ec, bytes_transferred));
+    io_context_.post(detail::bind_handler(handler, ec, bytes_transferred));
   }
 
   // Start an asynchronous wait until data can be sent without blocking.
@@ -400,7 +402,7 @@ public:
   {
     asio::error_code ec = asio::error::operation_not_supported;
     const std::size_t bytes_transferred = 0;
-    io_service_.post(detail::bind_handler(handler, ec, bytes_transferred));
+    io_context_.post(detail::bind_handler(handler, ec, bytes_transferred));
   }
 
   // Receive a datagram with the endpoint of the sender. Returns the number of
@@ -433,7 +435,7 @@ public:
   {
     asio::error_code ec = asio::error::operation_not_supported;
     const std::size_t bytes_transferred = 0;
-    io_service_.post(detail::bind_handler(handler, ec, bytes_transferred));
+    io_context_.post(detail::bind_handler(handler, ec, bytes_transferred));
   }
 
   // Wait until data can be received without blocking.
@@ -444,7 +446,7 @@ public:
   {
     asio::error_code ec = asio::error::operation_not_supported;
     const std::size_t bytes_transferred = 0;
-    io_service_.post(detail::bind_handler(handler, ec, bytes_transferred));
+    io_context_.post(detail::bind_handler(handler, ec, bytes_transferred));
   }
 
   // Accept a new connection.
@@ -463,7 +465,7 @@ public:
       endpoint_type*, Handler& handler)
   {
     asio::error_code ec = asio::error::operation_not_supported;
-    io_service_.post(detail::bind_handler(handler, ec));
+    io_context_.post(detail::bind_handler(handler, ec));
   }
 
   // Connect the socket to the specified endpoint.
@@ -480,11 +482,11 @@ public:
       const endpoint_type&, Handler& handler)
   {
     asio::error_code ec = asio::error::operation_not_supported;
-    io_service_.post(detail::bind_handler(handler, ec));
+    io_context_.post(detail::bind_handler(handler, ec));
   }
 
 private:
-  asio::io_service& io_service_;
+  asio::io_context& io_context_;
 };
 
 } // namespace detail
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_static_mutex.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_static_mutex.hpp
index af4dfec..ee30120 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_static_mutex.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_static_mutex.hpp
@@ -2,7 +2,7 @@
 // detail/null_static_mutex.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_thread.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_thread.hpp
index afcb403..eb1753f 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_thread.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_thread.hpp
@@ -2,7 +2,7 @@
 // detail/null_thread.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_tss_ptr.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_tss_ptr.hpp
index 2ba1c9f..5277ee5 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_tss_ptr.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/null_tss_ptr.hpp
@@ -2,7 +2,7 @@
 // detail/null_tss_ptr.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/object_pool.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/object_pool.hpp
index 53e22f6..82a6dd7 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/object_pool.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/object_pool.hpp
@@ -2,7 +2,7 @@
 // detail/object_pool.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -34,6 +34,12 @@ public:
     return new Object;
   }
 
+  template <typename Object, typename Arg>
+  static Object* create(Arg arg)
+  {
+    return new Object(arg);
+  }
+
   template <typename Object>
   static void destroy(Object* o)
   {
@@ -96,6 +102,25 @@ public:
     return o;
   }
 
+  // Allocate a new object with an argument.
+  template <typename Arg>
+  Object* alloc(Arg arg)
+  {
+    Object* o = free_list_;
+    if (o)
+      free_list_ = object_pool_access::next(free_list_);
+    else
+      o = object_pool_access::create<Object>(arg);
+
+    object_pool_access::next(o) = live_list_;
+    object_pool_access::prev(o) = 0;
+    if (live_list_)
+      object_pool_access::prev(live_list_) = o;
+    live_list_ = o;
+
+    return o;
+  }
+
   // Free an object. Moves it to the free list. No destructors are run.
   void free(Object* o)
   {
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/old_win_sdk_compat.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/old_win_sdk_compat.hpp
index f168182..9b34816 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/old_win_sdk_compat.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/old_win_sdk_compat.hpp
@@ -2,7 +2,7 @@
 // detail/old_win_sdk_compat.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/op_queue.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/op_queue.hpp
index 38076be..1ab4046 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/op_queue.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/op_queue.hpp
@@ -2,7 +2,7 @@
 // detail/op_queue.hpp
 // ~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/operation.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/operation.hpp
index 23960d6..72144d6 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/operation.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/operation.hpp
@@ -2,7 +2,7 @@
 // detail/operation.hpp
 // ~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/pipe_select_interrupter.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/pipe_select_interrupter.hpp
index 57e211e..b339def 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/pipe_select_interrupter.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/pipe_select_interrupter.hpp
@@ -2,7 +2,7 @@
 // detail/pipe_select_interrupter.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/pop_options.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/pop_options.hpp
index 770302e..880121f 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/pop_options.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/pop_options.hpp
@@ -2,7 +2,7 @@
 // detail/pop_options.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -23,6 +23,28 @@
 
 // Intel C++
 
+# if (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)
+#  pragma GCC visibility pop
+# endif // (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)
+
+#elif defined(__clang__)
+
+// Clang
+
+# if defined(__OBJC__)
+#  if !defined(__APPLE_CC__) || (__APPLE_CC__ <= 1)
+#   if defined(ASIO_OBJC_WORKAROUND)
+#    undef Protocol
+#    undef id
+#    undef ASIO_OBJC_WORKAROUND
+#   endif
+#  endif
+# endif
+
+# if !defined(_WIN32) && !defined(__WIN32__) && !defined(WIN32)
+#  pragma GCC visibility pop
+# endif // !defined(_WIN32) && !defined(__WIN32__) && !defined(WIN32)
+
 #elif defined(__GNUC__)
 
 // GNU C++
@@ -41,6 +63,10 @@
 #  endif
 # endif
 
+# if (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)
+#  pragma GCC visibility pop
+# endif // (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)
+
 #elif defined(__KCC)
 
 // Kai C++
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_event.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_event.hpp
index 984b70f..57ddc11 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_event.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_event.hpp
@@ -2,7 +2,7 @@
 // detail/posix_event.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -107,6 +107,36 @@ public:
     }
   }
 
+  // Timed wait for the event to become signalled.
+  template <typename Lock>
+  bool wait_for_usec(Lock& lock, long usec)
+  {
+    ASIO_ASSERT(lock.locked());
+    if ((state_ & 1) == 0)
+    {
+      state_ += 2;
+      timespec ts;
+#if (defined(__MACH__) && defined(__APPLE__))
+      ts.tv_sec = usec / 1000000;
+      ts.tv_nsec = (usec % 1000000) * 1000;
+      ::pthread_cond_timedwait_relative_np(
+          &cond_, &lock.mutex().mutex_, &ts); // Ignore EINVAL.
+#else // (defined(__MACH__) && defined(__APPLE__))
+      if (::clock_gettime(CLOCK_MONOTONIC, &ts) == 0)
+      {
+        ts.tv_sec += usec / 1000000;
+        ts.tv_nsec = (usec % 1000000) * 1000;
+        ts.tv_sec += ts.tv_nsec / 1000000000;
+        ts.tv_nsec = ts.tv_nsec % 1000000000;
+        ::pthread_cond_timedwait(&cond_,
+            &lock.mutex().mutex_, &ts); // Ignore EINVAL.
+      }
+#endif // (defined(__MACH__) && defined(__APPLE__))
+      state_ -= 2;
+    }
+    return (state_ & 1) != 0;
+  }
+
 private:
   ::pthread_cond_t cond_;
   std::size_t state_;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_fd_set_adapter.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_fd_set_adapter.hpp
index 2ea97b6..5ab9c8e 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_fd_set_adapter.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_fd_set_adapter.hpp
@@ -2,7 +2,7 @@
 // detail/posix_fd_set_adapter.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_global.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_global.hpp
index 12f2d64..bb9373b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_global.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_global.hpp
@@ -2,7 +2,7 @@
 // detail/posix_global.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_mutex.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_mutex.hpp
index 783bc56..08b220b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_mutex.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_mutex.hpp
@@ -2,7 +2,7 @@
 // detail/posix_mutex.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_signal_blocker.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_signal_blocker.hpp
index d344c32..dc476fd 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_signal_blocker.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_signal_blocker.hpp
@@ -2,7 +2,7 @@
 // detail/posix_signal_blocker.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_static_mutex.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_static_mutex.hpp
index 72bd2f4..e65d09a 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_static_mutex.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_static_mutex.hpp
@@ -2,7 +2,7 @@
 // detail/posix_static_mutex.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_thread.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_thread.hpp
index 741cb63..a07d5b3 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_thread.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_thread.hpp
@@ -2,7 +2,7 @@
 // detail/posix_thread.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_tss_ptr.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_tss_ptr.hpp
index fd7e9de..a677d15 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_tss_ptr.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/posix_tss_ptr.hpp
@@ -2,7 +2,7 @@
 // detail/posix_tss_ptr.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/push_options.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/push_options.hpp
index 62608ab..384bab1 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/push_options.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/push_options.hpp
@@ -2,7 +2,7 @@
 // detail/push_options.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -23,6 +23,30 @@
 
 // Intel C++
 
+# if (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)
+#  pragma GCC visibility push (default)
+# endif // (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)
+
+#elif defined(__clang__)
+
+// Clang
+
+# if defined(__OBJC__)
+#  if !defined(__APPLE_CC__) || (__APPLE_CC__ <= 1)
+#   if !defined(ASIO_DISABLE_OBJC_WORKAROUND)
+#    if !defined(Protocol) && !defined(id)
+#     define Protocol cpp_Protocol
+#     define id cpp_id
+#     define ASIO_OBJC_WORKAROUND
+#    endif
+#   endif
+#  endif
+# endif
+
+# if !defined(_WIN32) && !defined(__WIN32__) && !defined(WIN32)
+#  pragma GCC visibility push (default)
+# endif // !defined(_WIN32) && !defined(__WIN32__) && !defined(WIN32)
+
 #elif defined(__GNUC__)
 
 // GNU C++
@@ -43,6 +67,10 @@
 #  endif
 # endif
 
+# if (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)
+#  pragma GCC visibility push (default)
+# endif // (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)
+
 #elif defined(__KCC)
 
 // Kai C++
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_descriptor_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_descriptor_service.hpp
index 1903f95..42bc3df 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_descriptor_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_descriptor_service.hpp
@@ -2,7 +2,7 @@
 // detail/reactive_descriptor_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -22,7 +22,7 @@
   && !defined(__CYGWIN__)
 
 #include "asio/buffer.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/detail/bind_handler.hpp"
 #include "asio/detail/buffer_sequence_adapter.hpp"
 #include "asio/detail/descriptor_ops.hpp"
@@ -41,7 +41,8 @@
 namespace asio {
 namespace detail {
 
-class reactive_descriptor_service
+class reactive_descriptor_service :
+  public service_base<reactive_descriptor_service>
 {
 public:
   // The native type of a descriptor.
@@ -75,10 +76,10 @@ public:
 
   // Constructor.
   ASIO_DECL reactive_descriptor_service(
-      asio::io_service& io_service);
+      asio::io_context& io_context);
 
   // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
+  ASIO_DECL void shutdown();
 
   // Construct a new descriptor implementation.
   ASIO_DECL void construct(implementation_type& impl);
@@ -202,7 +203,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(handler);
 
-    ASIO_HANDLER_CREATION((p.p, "descriptor", &impl, "async_wait"));
+    ASIO_HANDLER_CREATION((reactor_.context(), *p.p, "descriptor",
+          &impl, impl.descriptor_, "async_wait"));
 
     int op_type;
     switch (w)
@@ -264,7 +266,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(impl.descriptor_, buffers, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "descriptor", &impl, "async_write_some"));
+    ASIO_HANDLER_CREATION((reactor_.context(), *p.p, "descriptor",
+          &impl, impl.descriptor_, "async_write_some"));
 
     start_op(impl, reactor::write_op, p.p, is_continuation, true,
         buffer_sequence_adapter<asio::const_buffer,
@@ -286,8 +289,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(handler);
 
-    ASIO_HANDLER_CREATION((p.p, "descriptor",
-          &impl, "async_write_some(null_buffers)"));
+    ASIO_HANDLER_CREATION((reactor_.context(), *p.p, "descriptor",
+          &impl, impl.descriptor_, "async_write_some(null_buffers)"));
 
     start_op(impl, reactor::write_op, p.p, is_continuation, false, false);
     p.v = p.p = 0;
@@ -330,7 +333,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(impl.descriptor_, buffers, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "descriptor", &impl, "async_read_some"));
+    ASIO_HANDLER_CREATION((reactor_.context(), *p.p, "descriptor",
+          &impl, impl.descriptor_, "async_read_some"));
 
     start_op(impl, reactor::read_op, p.p, is_continuation, true,
         buffer_sequence_adapter<asio::mutable_buffer,
@@ -352,8 +356,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(handler);
 
-    ASIO_HANDLER_CREATION((p.p, "descriptor",
-          &impl, "async_read_some(null_buffers)"));
+    ASIO_HANDLER_CREATION((reactor_.context(), *p.p, "descriptor",
+          &impl, impl.descriptor_, "async_read_some(null_buffers)"));
 
     start_op(impl, reactor::read_op, p.p, is_continuation, false, false);
     p.v = p.p = 0;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_null_buffers_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_null_buffers_op.hpp
index ec44d1e..504e4f6 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_null_buffers_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_null_buffers_op.hpp
@@ -2,7 +2,7 @@
 // detail/reactive_null_buffers_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -41,9 +41,9 @@ public:
     handler_work<Handler>::start(handler_);
   }
 
-  static bool do_perform(reactor_op*)
+  static status do_perform(reactor_op*)
   {
-    return true;
+    return done;
   }
 
   static void do_complete(void* owner, operation* base,
@@ -55,7 +55,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
     // Make a copy of the handler so that the memory can be deallocated before
     // the upcall is made. Even if we're not about to make an upcall, a
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_serial_port_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_serial_port_service.hpp
index efac78e..986e87b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_serial_port_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_serial_port_service.hpp
@@ -2,7 +2,7 @@
 // detail/reactive_serial_port_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -23,7 +23,7 @@
 
 #include <string>
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/serial_port_base.hpp"
 #include "asio/detail/descriptor_ops.hpp"
 #include "asio/detail/reactive_descriptor_service.hpp"
@@ -34,7 +34,8 @@ namespace asio {
 namespace detail {
 
 // Extend reactive_descriptor_service to provide serial port support.
-class reactive_serial_port_service
+class reactive_serial_port_service :
+  public service_base<reactive_serial_port_service>
 {
 public:
   // The native type of a serial port.
@@ -44,10 +45,10 @@ public:
   typedef reactive_descriptor_service::implementation_type implementation_type;
 
   ASIO_DECL reactive_serial_port_service(
-      asio::io_service& io_service);
+      asio::io_context& io_context);
 
   // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
+  ASIO_DECL void shutdown();
 
   // Construct a new serial port implementation.
   void construct(implementation_type& impl)
@@ -189,8 +190,8 @@ private:
   static asio::error_code store_option(const void* option,
       termios& storage, asio::error_code& ec)
   {
-    return static_cast<const SettableSerialPortOption*>(option)->store(
-        storage, ec);
+    static_cast<const SettableSerialPortOption*>(option)->store(storage, ec);
+    return ec;
   }
 
   // Helper function to set a serial port option.
@@ -207,7 +208,8 @@ private:
   static asio::error_code load_option(void* option,
       const termios& storage, asio::error_code& ec)
   {
-    return static_cast<GettableSerialPortOption*>(option)->load(storage, ec);
+    static_cast<GettableSerialPortOption*>(option)->load(storage, ec);
+    return ec;
   }
 
   // Helper function to get a serial port option.
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_accept_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_accept_op.hpp
index ae6ca42..11b81d5 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_accept_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_accept_op.hpp
@@ -2,7 +2,7 @@
 // detail/reactive_socket_accept_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -41,40 +41,48 @@ public:
       state_(state),
       peer_(peer),
       protocol_(protocol),
-      peer_endpoint_(peer_endpoint)
+      peer_endpoint_(peer_endpoint),
+      addrlen_(peer_endpoint ? peer_endpoint->capacity() : 0)
   {
   }
 
-  static bool do_perform(reactor_op* base)
+  static status do_perform(reactor_op* base)
   {
     reactive_socket_accept_op_base* o(
         static_cast<reactive_socket_accept_op_base*>(base));
 
-    std::size_t addrlen = o->peer_endpoint_ ? o->peer_endpoint_->capacity() : 0;
     socket_type new_socket = invalid_socket;
-    bool result = socket_ops::non_blocking_accept(o->socket_,
-          o->state_, o->peer_endpoint_ ? o->peer_endpoint_->data() : 0,
-          o->peer_endpoint_ ? &addrlen : 0, o->ec_, new_socket);
+    status result = socket_ops::non_blocking_accept(o->socket_,
+        o->state_, o->peer_endpoint_ ? o->peer_endpoint_->data() : 0,
+        o->peer_endpoint_ ? &o->addrlen_ : 0, o->ec_, new_socket)
+    ? done : not_done;
+    o->new_socket_.reset(new_socket);
 
-    // On success, assign new connection to peer socket object.
-    if (new_socket != invalid_socket)
-    {
-      socket_holder new_socket_holder(new_socket);
-      if (o->peer_endpoint_)
-        o->peer_endpoint_->resize(addrlen);
-      if (!o->peer_.assign(o->protocol_, new_socket, o->ec_))
-        new_socket_holder.release();
-    }
+    ASIO_HANDLER_REACTOR_OPERATION((*o, "non_blocking_accept", o->ec_));
 
     return result;
   }
 
+  void do_assign()
+  {
+    if (new_socket_.get() != invalid_socket)
+    {
+      if (peer_endpoint_)
+        peer_endpoint_->resize(addrlen_);
+      peer_.assign(protocol_, new_socket_.get(), ec_);
+      if (!ec_)
+        new_socket_.release();
+    }
+  }
+
 private:
   socket_type socket_;
   socket_ops::state_type state_;
+  socket_holder new_socket_;
   Socket& peer_;
   Protocol protocol_;
   typename Protocol::endpoint* peer_endpoint_;
+  std::size_t addrlen_;
 };
 
 template <typename Socket, typename Protocol, typename Handler>
@@ -103,7 +111,11 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    // On success, assign new connection to peer socket object.
+    if (owner)
+      o->do_assign();
+
+    ASIO_HANDLER_COMPLETION((*o));
 
     // Make a copy of the handler so that the memory can be deallocated before
     // the upcall is made. Even if we're not about to make an upcall, a
@@ -130,6 +142,73 @@ private:
   Handler handler_;
 };
 
+#if defined(ASIO_HAS_MOVE)
+
+template <typename Protocol, typename Handler>
+class reactive_socket_move_accept_op :
+  private Protocol::socket,
+  public reactive_socket_accept_op_base<typename Protocol::socket, Protocol>
+{
+public:
+  ASIO_DEFINE_HANDLER_PTR(reactive_socket_move_accept_op);
+
+  reactive_socket_move_accept_op(io_context& ioc, socket_type socket,
+      socket_ops::state_type state, const Protocol& protocol,
+      typename Protocol::endpoint* peer_endpoint, Handler& handler)
+    : Protocol::socket(ioc),
+      reactive_socket_accept_op_base<typename Protocol::socket, Protocol>(
+        socket, state, *this, protocol, peer_endpoint,
+        &reactive_socket_move_accept_op::do_complete),
+      handler_(ASIO_MOVE_CAST(Handler)(handler))
+  {
+    handler_work<Handler>::start(handler_);
+  }
+
+  static void do_complete(void* owner, operation* base,
+      const asio::error_code& /*ec*/,
+      std::size_t /*bytes_transferred*/)
+  {
+    // Take ownership of the handler object.
+    reactive_socket_move_accept_op* o(
+        static_cast<reactive_socket_move_accept_op*>(base));
+    ptr p = { asio::detail::addressof(o->handler_), o, o };
+    handler_work<Handler> w(o->handler_);
+
+    // On success, assign new connection to peer socket object.
+    if (owner)
+      o->do_assign();
+
+    ASIO_HANDLER_COMPLETION((*o));
+
+    // Make a copy of the handler so that the memory can be deallocated before
+    // the upcall is made. Even if we're not about to make an upcall, a
+    // sub-object of the handler may be the true owner of the memory associated
+    // with the handler. Consequently, a local copy of the handler is required
+    // to ensure that any owning sub-object remains valid until after we have
+    // deallocated the memory here.
+    detail::move_binder2<Handler,
+      asio::error_code, typename Protocol::socket>
+        handler(0, ASIO_MOVE_CAST(Handler)(o->handler_), o->ec_,
+          ASIO_MOVE_CAST(typename Protocol::socket)(*o));
+    p.h = asio::detail::addressof(handler.handler_);
+    p.reset();
+
+    // Make the upcall if required.
+    if (owner)
+    {
+      fenced_block b(fenced_block::half);
+      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, "..."));
+      w.complete(handler, handler.handler_);
+      ASIO_HANDLER_INVOCATION_END;
+    }
+  }
+
+private:
+  Handler handler_;
+};
+
+#endif // defined(ASIO_HAS_MOVE)
+
 } // namespace detail
 } // namespace asio
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_connect_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_connect_op.hpp
index 0600444..428db3f 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_connect_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_connect_op.hpp
@@ -2,7 +2,7 @@
 // detail/reactive_socket_connect_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -37,12 +37,17 @@ public:
   {
   }
 
-  static bool do_perform(reactor_op* base)
+  static status do_perform(reactor_op* base)
   {
     reactive_socket_connect_op_base* o(
         static_cast<reactive_socket_connect_op_base*>(base));
 
-    return socket_ops::non_blocking_connect(o->socket_, o->ec_);
+    status result = socket_ops::non_blocking_connect(
+        o->socket_, o->ec_) ? done : not_done;
+
+    ASIO_HANDLER_REACTOR_OPERATION((*o, "non_blocking_connect", o->ec_));
+
+    return result;
   }
 
 private:
@@ -73,7 +78,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
     // Make a copy of the handler so that the memory can be deallocated before
     // the upcall is made. Even if we're not about to make an upcall, a
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_recv_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_recv_op.hpp
index 5067602..71f0aec 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_recv_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_recv_op.hpp
@@ -2,7 +2,7 @@
 // detail/reactive_socket_recv_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -43,7 +43,7 @@ public:
   {
   }
 
-  static bool do_perform(reactor_op* base)
+  static status do_perform(reactor_op* base)
   {
     reactive_socket_recv_op_base* o(
         static_cast<reactive_socket_recv_op_base*>(base));
@@ -51,10 +51,20 @@ public:
     buffer_sequence_adapter<asio::mutable_buffer,
         MutableBufferSequence> bufs(o->buffers_);
 
-    return socket_ops::non_blocking_recv(o->socket_,
+    status result = socket_ops::non_blocking_recv(o->socket_,
         bufs.buffers(), bufs.count(), o->flags_,
         (o->state_ & socket_ops::stream_oriented) != 0,
-        o->ec_, o->bytes_transferred_);
+        o->ec_, o->bytes_transferred_) ? done : not_done;
+
+    if (result == done)
+      if ((o->state_ & socket_ops::stream_oriented) != 0)
+        if (o->bytes_transferred_ < bufs.total_size())
+          result = done_and_exhausted;
+
+    ASIO_HANDLER_REACTOR_OPERATION((*o, "non_blocking_recv",
+          o->ec_, o->bytes_transferred_));
+
+    return result;
   }
 
 private:
@@ -90,7 +100,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
     // Make a copy of the handler so that the memory can be deallocated before
     // the upcall is made. Even if we're not about to make an upcall, a
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_recvfrom_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_recvfrom_op.hpp
index 6735d18..309a032 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_recvfrom_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_recvfrom_op.hpp
@@ -2,7 +2,7 @@
 // detail/reactive_socket_recvfrom_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -44,7 +44,7 @@ public:
   {
   }
 
-  static bool do_perform(reactor_op* base)
+  static status do_perform(reactor_op* base)
   {
     reactive_socket_recvfrom_op_base* o(
         static_cast<reactive_socket_recvfrom_op_base*>(base));
@@ -53,14 +53,17 @@ public:
         MutableBufferSequence> bufs(o->buffers_);
 
     std::size_t addr_len = o->sender_endpoint_.capacity();
-    bool result = socket_ops::non_blocking_recvfrom(o->socket_,
+    status result = socket_ops::non_blocking_recvfrom(o->socket_,
         bufs.buffers(), bufs.count(), o->flags_,
         o->sender_endpoint_.data(), &addr_len,
-        o->ec_, o->bytes_transferred_);
+        o->ec_, o->bytes_transferred_) ? done : not_done;
 
     if (result && !o->ec_)
       o->sender_endpoint_.resize(addr_len);
 
+    ASIO_HANDLER_REACTOR_OPERATION((*o, "non_blocking_recvfrom",
+          o->ec_, o->bytes_transferred_));
+
     return result;
   }
 
@@ -100,7 +103,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
     // Make a copy of the handler so that the memory can be deallocated before
     // the upcall is made. Even if we're not about to make an upcall, a
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_recvmsg_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_recvmsg_op.hpp
index 489d13a..e0c801f 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_recvmsg_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_recvmsg_op.hpp
@@ -2,7 +2,7 @@
 // detail/reactive_socket_recvmsg_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -44,7 +44,7 @@ public:
   {
   }
 
-  static bool do_perform(reactor_op* base)
+  static status do_perform(reactor_op* base)
   {
     reactive_socket_recvmsg_op_base* o(
         static_cast<reactive_socket_recvmsg_op_base*>(base));
@@ -52,10 +52,15 @@ public:
     buffer_sequence_adapter<asio::mutable_buffer,
         MutableBufferSequence> bufs(o->buffers_);
 
-    return socket_ops::non_blocking_recvmsg(o->socket_,
+    status result = socket_ops::non_blocking_recvmsg(o->socket_,
         bufs.buffers(), bufs.count(),
         o->in_flags_, o->out_flags_,
-        o->ec_, o->bytes_transferred_);
+        o->ec_, o->bytes_transferred_) ? done : not_done;
+
+    ASIO_HANDLER_REACTOR_OPERATION((*o, "non_blocking_recvmsg",
+          o->ec_, o->bytes_transferred_));
+
+    return result;
   }
 
 private:
@@ -92,7 +97,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
     // Make a copy of the handler so that the memory can be deallocated before
     // the upcall is made. Even if we're not about to make an upcall, a
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_send_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_send_op.hpp
index f4d9bea..708e8ea 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_send_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_send_op.hpp
@@ -2,7 +2,7 @@
 // detail/reactive_socket_send_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -33,16 +33,17 @@ class reactive_socket_send_op_base : public reactor_op
 {
 public:
   reactive_socket_send_op_base(socket_type socket,
-      const ConstBufferSequence& buffers,
+      socket_ops::state_type state, const ConstBufferSequence& buffers,
       socket_base::message_flags flags, func_type complete_func)
     : reactor_op(&reactive_socket_send_op_base::do_perform, complete_func),
       socket_(socket),
+      state_(state),
       buffers_(buffers),
       flags_(flags)
   {
   }
 
-  static bool do_perform(reactor_op* base)
+  static status do_perform(reactor_op* base)
   {
     reactive_socket_send_op_base* o(
         static_cast<reactive_socket_send_op_base*>(base));
@@ -50,13 +51,24 @@ public:
     buffer_sequence_adapter<asio::const_buffer,
         ConstBufferSequence> bufs(o->buffers_);
 
-    return socket_ops::non_blocking_send(o->socket_,
+    status result = socket_ops::non_blocking_send(o->socket_,
           bufs.buffers(), bufs.count(), o->flags_,
-          o->ec_, o->bytes_transferred_);
+          o->ec_, o->bytes_transferred_) ? done : not_done;
+
+    if (result == done)
+      if ((o->state_ & socket_ops::stream_oriented) != 0)
+        if (o->bytes_transferred_ < bufs.total_size())
+          result = done_and_exhausted;
+
+    ASIO_HANDLER_REACTOR_OPERATION((*o, "non_blocking_send",
+          o->ec_, o->bytes_transferred_));
+
+    return result;
   }
 
 private:
   socket_type socket_;
+  socket_ops::state_type state_;
   ConstBufferSequence buffers_;
   socket_base::message_flags flags_;
 };
@@ -69,10 +81,10 @@ public:
   ASIO_DEFINE_HANDLER_PTR(reactive_socket_send_op);
 
   reactive_socket_send_op(socket_type socket,
-      const ConstBufferSequence& buffers,
+      socket_ops::state_type state, const ConstBufferSequence& buffers,
       socket_base::message_flags flags, Handler& handler)
     : reactive_socket_send_op_base<ConstBufferSequence>(socket,
-        buffers, flags, &reactive_socket_send_op::do_complete),
+        state, buffers, flags, &reactive_socket_send_op::do_complete),
       handler_(ASIO_MOVE_CAST(Handler)(handler))
   {
     handler_work<Handler>::start(handler_);
@@ -87,7 +99,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
     // Make a copy of the handler so that the memory can be deallocated before
     // the upcall is made. Even if we're not about to make an upcall, a
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_sendto_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_sendto_op.hpp
index 3688840..cab8f88 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_sendto_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_sendto_op.hpp
@@ -2,7 +2,7 @@
 // detail/reactive_socket_sendto_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -43,7 +43,7 @@ public:
   {
   }
 
-  static bool do_perform(reactor_op* base)
+  static status do_perform(reactor_op* base)
   {
     reactive_socket_sendto_op_base* o(
         static_cast<reactive_socket_sendto_op_base*>(base));
@@ -51,10 +51,15 @@ public:
     buffer_sequence_adapter<asio::const_buffer,
         ConstBufferSequence> bufs(o->buffers_);
 
-    return socket_ops::non_blocking_sendto(o->socket_,
+    status result = socket_ops::non_blocking_sendto(o->socket_,
           bufs.buffers(), bufs.count(), o->flags_,
           o->destination_.data(), o->destination_.size(),
-          o->ec_, o->bytes_transferred_);
+          o->ec_, o->bytes_transferred_) ? done : not_done;
+
+    ASIO_HANDLER_REACTOR_OPERATION((*o, "non_blocking_sendto",
+          o->ec_, o->bytes_transferred_));
+
+    return result;
   }
 
 private:
@@ -90,7 +95,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
     // Make a copy of the handler so that the memory can be deallocated before
     // the upcall is made. Even if we're not about to make an upcall, a
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_service.hpp
index 9566777..4ba2556 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_service.hpp
@@ -2,7 +2,7 @@
 // detail/reactive_socket_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -21,7 +21,7 @@
 
 #include "asio/buffer.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/socket_base.hpp"
 #include "asio/detail/buffer_sequence_adapter.hpp"
 #include "asio/detail/memory.hpp"
@@ -45,6 +45,7 @@ namespace detail {
 
 template <typename Protocol>
 class reactive_socket_service :
+  public service_base<reactive_socket_service<Protocol> >,
   public reactive_socket_service_base
 {
 public:
@@ -72,11 +73,18 @@ public:
   };
 
   // Constructor.
-  reactive_socket_service(asio::io_service& io_service)
-    : reactive_socket_service_base(io_service)
+  reactive_socket_service(asio::io_context& io_context)
+    : service_base<reactive_socket_service<Protocol> >(io_context),
+      reactive_socket_service_base(io_context)
   {
   }
 
+  // Destroy all user-defined handler objects owned by the service.
+  void shutdown()
+  {
+    this->base_shutdown();
+  }
+
   // Move-construct a new socket implementation.
   void move_construct(implementation_type& impl,
       implementation_type& other_impl)
@@ -194,6 +202,14 @@ public:
     return endpoint;
   }
 
+  // Disable sends or receives on the socket.
+  asio::error_code shutdown(base_implementation_type& impl,
+      socket_base::shutdown_type what, asio::error_code& ec)
+  {
+    socket_ops::shutdown(impl.socket_, what, ec);
+    return ec;
+  }
+
   // Send a datagram to the specified endpoint. Returns the number of bytes
   // sent.
   template <typename ConstBufferSequence>
@@ -215,7 +231,7 @@ public:
       asio::error_code& ec)
   {
     // Wait for socket to become ready.
-    socket_ops::poll_write(impl.socket_, impl.state_, ec);
+    socket_ops::poll_write(impl.socket_, impl.state_, -1, ec);
 
     return 0;
   }
@@ -238,7 +254,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(impl.socket_, buffers, destination, flags, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_send_to"));
+    ASIO_HANDLER_CREATION((reactor_.context(), *p.p, "socket",
+          &impl, impl.socket_, "async_send_to"));
 
     start_op(impl, reactor::write_op, p.p, is_continuation, true, false);
     p.v = p.p = 0;
@@ -258,8 +275,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket",
-          &impl, "async_send_to(null_buffers)"));
+    ASIO_HANDLER_CREATION((reactor_.context(), *p.p, "socket",
+          &impl, impl.socket_, "async_send_to(null_buffers)"));
 
     start_op(impl, reactor::write_op, p.p, is_continuation, false, false);
     p.v = p.p = 0;
@@ -293,7 +310,7 @@ public:
       asio::error_code& ec)
   {
     // Wait for socket to become ready.
-    socket_ops::poll_read(impl.socket_, impl.state_, ec);
+    socket_ops::poll_read(impl.socket_, impl.state_, -1, ec);
 
     // Reset endpoint since it can be given no sensible value at this time.
     sender_endpoint = endpoint_type();
@@ -321,8 +338,8 @@ public:
     p.p = new (p.v) op(impl.socket_, protocol,
         buffers, sender_endpoint, flags, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket",
-          &impl, "async_receive_from"));
+    ASIO_HANDLER_CREATION((reactor_.context(), *p.p, "socket",
+          &impl, impl.socket_, "async_receive_from"));
 
     start_op(impl,
         (flags & socket_base::message_out_of_band)
@@ -346,8 +363,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket",
-          &impl, "async_receive_from(null_buffers)"));
+    ASIO_HANDLER_CREATION((reactor_.context(), *p.p, "socket",
+          &impl, impl.socket_, "async_receive_from(null_buffers)"));
 
     // Reset endpoint since it can be given no sensible value at this time.
     sender_endpoint = endpoint_type();
@@ -381,15 +398,44 @@ public:
     {
       if (peer_endpoint)
         peer_endpoint->resize(addr_len);
-      if (!peer.assign(impl.protocol_, new_socket.get(), ec))
+      peer.assign(impl.protocol_, new_socket.get(), ec);
+      if (!ec)
         new_socket.release();
     }
 
     return ec;
   }
 
-  // Start an asynchronous accept. The peer and peer_endpoint objects
-  // must be valid until the accept's handler is invoked.
+#if defined(ASIO_HAS_MOVE)
+  // Accept a new connection.
+  typename Protocol::socket accept(implementation_type& impl,
+      io_context* peer_io_context, endpoint_type* peer_endpoint,
+      asio::error_code& ec)
+  {
+    typename Protocol::socket peer(
+        peer_io_context ? *peer_io_context : io_context_);
+
+    std::size_t addr_len = peer_endpoint ? peer_endpoint->capacity() : 0;
+    socket_holder new_socket(socket_ops::sync_accept(impl.socket_,
+          impl.state_, peer_endpoint ? peer_endpoint->data() : 0,
+          peer_endpoint ? &addr_len : 0, ec));
+
+    // On success, assign new connection to peer socket object.
+    if (new_socket.get() != invalid_socket)
+    {
+      if (peer_endpoint)
+        peer_endpoint->resize(addr_len);
+      peer.assign(impl.protocol_, new_socket.get(), ec);
+      if (!ec)
+        new_socket.release();
+    }
+
+    return peer;
+  }
+#endif // defined(ASIO_HAS_MOVE)
+
+  // Start an asynchronous accept. The peer and peer_endpoint objects must be
+  // valid until the accept's handler is invoked.
   template <typename Socket, typename Handler>
   void async_accept(implementation_type& impl, Socket& peer,
       endpoint_type* peer_endpoint, Handler& handler)
@@ -404,12 +450,39 @@ public:
     p.p = new (p.v) op(impl.socket_, impl.state_, peer,
         impl.protocol_, peer_endpoint, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_accept"));
+    ASIO_HANDLER_CREATION((reactor_.context(), *p.p, "socket",
+          &impl, impl.socket_, "async_accept"));
 
     start_accept_op(impl, p.p, is_continuation, peer.is_open());
     p.v = p.p = 0;
   }
 
+#if defined(ASIO_HAS_MOVE)
+  // Start an asynchronous accept. The peer_endpoint object must be valid until
+  // the accept's handler is invoked.
+  template <typename Handler>
+  void async_accept(implementation_type& impl,
+      asio::io_context* peer_io_context,
+      endpoint_type* peer_endpoint, Handler& handler)
+  {
+    bool is_continuation =
+      asio_handler_cont_helpers::is_continuation(handler);
+
+    // Allocate and construct an operation to wrap the handler.
+    typedef reactive_socket_move_accept_op<Protocol, Handler> op;
+    typename op::ptr p = { asio::detail::addressof(handler),
+      op::ptr::allocate(handler), 0 };
+    p.p = new (p.v) op(peer_io_context ? *peer_io_context : io_context_,
+        impl.socket_, impl.state_, impl.protocol_, peer_endpoint, handler);
+
+    ASIO_HANDLER_CREATION((reactor_.context(), *p.p, "socket",
+          &impl, impl.socket_, "async_accept"));
+
+    start_accept_op(impl, p.p, is_continuation, false);
+    p.v = p.p = 0;
+  }
+#endif // defined(ASIO_HAS_MOVE)
+
   // Connect the socket to the specified endpoint.
   asio::error_code connect(implementation_type& impl,
       const endpoint_type& peer_endpoint, asio::error_code& ec)
@@ -433,7 +506,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(impl.socket_, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_connect"));
+    ASIO_HANDLER_CREATION((reactor_.context(), *p.p, "socket",
+          &impl, impl.socket_, "async_connect"));
 
     start_connect_op(impl, p.p, is_continuation,
         peer_endpoint.data(), peer_endpoint.size());
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_service_base.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_service_base.hpp
index d30fcae..f2de9db 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_service_base.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_socket_service_base.hpp
@@ -2,7 +2,7 @@
 // detail/reactive_socket_service_base.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -22,7 +22,7 @@
 
 #include "asio/buffer.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/socket_base.hpp"
 #include "asio/detail/buffer_sequence_adapter.hpp"
 #include "asio/detail/memory.hpp"
@@ -63,10 +63,10 @@ public:
 
   // Constructor.
   ASIO_DECL reactive_socket_service_base(
-      asio::io_service& io_service);
+      asio::io_context& io_context);
 
   // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
+  ASIO_DECL void base_shutdown();
 
   // Construct a new socket implementation.
   ASIO_DECL void construct(base_implementation_type& impl);
@@ -163,14 +163,6 @@ public:
     return ec;
   }
 
-  // Disable sends or receives on the socket.
-  asio::error_code shutdown(base_implementation_type& impl,
-      socket_base::shutdown_type what, asio::error_code& ec)
-  {
-    socket_ops::shutdown(impl.socket_, what, ec);
-    return ec;
-  }
-
   // Wait for the socket to become ready to read, ready to write, or to have
   // pending error conditions.
   asio::error_code wait(base_implementation_type& impl,
@@ -179,13 +171,13 @@ public:
     switch (w)
     {
     case socket_base::wait_read:
-      socket_ops::poll_read(impl.socket_, impl.state_, ec);
+      socket_ops::poll_read(impl.socket_, impl.state_, -1, ec);
       break;
     case socket_base::wait_write:
-      socket_ops::poll_write(impl.socket_, impl.state_, ec);
+      socket_ops::poll_write(impl.socket_, impl.state_, -1, ec);
       break;
     case socket_base::wait_error:
-      socket_ops::poll_error(impl.socket_, impl.state_, ec);
+      socket_ops::poll_error(impl.socket_, impl.state_, -1, ec);
       break;
     default:
       ec = asio::error::invalid_argument;
@@ -210,7 +202,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_wait"));
+    ASIO_HANDLER_CREATION((reactor_.context(), *p.p, "socket",
+          &impl, impl.socket_, "async_wait"));
 
     int op_type;
     switch (w)
@@ -253,7 +246,7 @@ public:
       socket_base::message_flags, asio::error_code& ec)
   {
     // Wait for socket to become ready.
-    socket_ops::poll_write(impl.socket_, impl.state_, ec);
+    socket_ops::poll_write(impl.socket_, impl.state_, -1, ec);
 
     return 0;
   }
@@ -272,9 +265,10 @@ public:
     typedef reactive_socket_send_op<ConstBufferSequence, Handler> op;
     typename op::ptr p = { asio::detail::addressof(handler),
       op::ptr::allocate(handler), 0 };
-    p.p = new (p.v) op(impl.socket_, buffers, flags, handler);
+    p.p = new (p.v) op(impl.socket_, impl.state_, buffers, flags, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_send"));
+    ASIO_HANDLER_CREATION((reactor_.context(), *p.p, "socket",
+          &impl, impl.socket_, "async_send"));
 
     start_op(impl, reactor::write_op, p.p, is_continuation, true,
         ((impl.state_ & socket_ops::stream_oriented)
@@ -297,8 +291,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket",
-          &impl, "async_send(null_buffers)"));
+    ASIO_HANDLER_CREATION((reactor_.context(), *p.p, "socket",
+          &impl, impl.socket_, "async_send(null_buffers)"));
 
     start_op(impl, reactor::write_op, p.p, is_continuation, false, false);
     p.v = p.p = 0;
@@ -322,7 +316,7 @@ public:
       socket_base::message_flags, asio::error_code& ec)
   {
     // Wait for socket to become ready.
-    socket_ops::poll_read(impl.socket_, impl.state_, ec);
+    socket_ops::poll_read(impl.socket_, impl.state_, -1, ec);
 
     return 0;
   }
@@ -343,7 +337,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(impl.socket_, impl.state_, buffers, flags, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_receive"));
+    ASIO_HANDLER_CREATION((reactor_.context(), *p.p, "socket",
+          &impl, impl.socket_, "async_receive"));
 
     start_op(impl,
         (flags & socket_base::message_out_of_band)
@@ -370,8 +365,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket",
-          &impl, "async_receive(null_buffers)"));
+    ASIO_HANDLER_CREATION((reactor_.context(), *p.p, "socket",
+          &impl, impl.socket_, "async_receive(null_buffers)"));
 
     start_op(impl,
         (flags & socket_base::message_out_of_band)
@@ -401,7 +396,7 @@ public:
       socket_base::message_flags& out_flags, asio::error_code& ec)
   {
     // Wait for socket to become ready.
-    socket_ops::poll_read(impl.socket_, impl.state_, ec);
+    socket_ops::poll_read(impl.socket_, impl.state_, -1, ec);
 
     // Clear out_flags, since we cannot give it any other sensible value when
     // performing a null_buffers operation.
@@ -426,8 +421,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(impl.socket_, buffers, in_flags, out_flags, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket",
-          &impl, "async_receive_with_flags"));
+    ASIO_HANDLER_CREATION((reactor_.context(), *p.p, "socket",
+          &impl, impl.socket_, "async_receive_with_flags"));
 
     start_op(impl,
         (in_flags & socket_base::message_out_of_band)
@@ -452,8 +447,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl,
-          "async_receive_with_flags(null_buffers)"));
+    ASIO_HANDLER_CREATION((reactor_.context(), *p.p, "socket",
+          &impl, impl.socket_, "async_receive_with_flags(null_buffers)"));
 
     // Clear out_flags, since we cannot give it any other sensible value when
     // performing a null_buffers operation.
@@ -490,6 +485,9 @@ protected:
       reactor_op* op, bool is_continuation,
       const socket_addr_type* addr, size_t addrlen);
 
+  // The io_context that owns this socket service.
+  io_context& io_context_;
+
   // The selector that performs event demultiplexing for the service.
   reactor& reactor_;
 };
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_wait_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_wait_op.hpp
index 43adb54..99f8811 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_wait_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactive_wait_op.hpp
@@ -2,7 +2,7 @@
 // detail/reactive_wait_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -41,9 +41,9 @@ public:
     handler_work<Handler>::start(handler_);
   }
 
-  static bool do_perform(reactor_op*)
+  static status do_perform(reactor_op*)
   {
-    return true;
+    return done;
   }
 
   static void do_complete(void* owner, operation* base,
@@ -55,7 +55,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
     // Make a copy of the handler so that the memory can be deallocated before
     // the upcall is made. Even if we're not about to make an upcall, a
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactor.hpp
index e701c36..1f684a2 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactor.hpp
@@ -2,7 +2,7 @@
 // detail/reactor.hpp
 // ~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactor_fwd.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactor_fwd.hpp
index 7f5e36a..1b25e69 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactor_fwd.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactor_fwd.hpp
@@ -2,7 +2,7 @@
 // detail/reactor_fwd.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactor_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactor_op.hpp
index b339ffd..491787b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactor_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactor_op.hpp
@@ -2,7 +2,7 @@
 // detail/reactor_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -33,14 +33,18 @@ public:
   // The number of bytes transferred, to be passed to the completion handler.
   std::size_t bytes_transferred_;
 
+  // Status returned by perform function. May be used to decide whether it is
+  // worth performing more operations on the descriptor immediately.
+  enum status { not_done, done, done_and_exhausted };
+
   // Perform the operation. Returns true if it is finished.
-  bool perform()
+  status perform()
   {
     return perform_func_(this);
   }
 
 protected:
-  typedef bool (*perform_func_type)(reactor_op*);
+  typedef status (*perform_func_type)(reactor_op*);
 
   reactor_op(perform_func_type perform_func, func_type complete_func)
     : operation(complete_func),
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactor_op_queue.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactor_op_queue.hpp
index efeacf7..426adfb 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactor_op_queue.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/reactor_op_queue.hpp
@@ -2,7 +2,7 @@
 // detail/reactor_op_queue.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/recycling_allocator.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/recycling_allocator.hpp
index 1da9516..2abc0a2 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/recycling_allocator.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/recycling_allocator.hpp
@@ -2,7 +2,7 @@
 // detail/recycling_allocator.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/regex_fwd.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/regex_fwd.hpp
index af825c6..447c6b1 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/regex_fwd.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/regex_fwd.hpp
@@ -2,7 +2,7 @@
 // detail/regex_fwd.hpp
 // ~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/resolve_endpoint_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/resolve_endpoint_op.hpp
index 7584aee..234ac24 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/resolve_endpoint_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/resolve_endpoint_op.hpp
@@ -2,7 +2,7 @@
 // detail/resolve_endpoint_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,14 +17,14 @@
 
 #include "asio/detail/config.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/ip/basic_resolver_iterator.hpp"
+#include "asio/io_context.hpp"
+#include "asio/ip/basic_resolver_results.hpp"
 #include "asio/detail/bind_handler.hpp"
 #include "asio/detail/fenced_block.hpp"
 #include "asio/detail/handler_alloc_helpers.hpp"
 #include "asio/detail/handler_invoke_helpers.hpp"
 #include "asio/detail/memory.hpp"
-#include "asio/detail/operation.hpp"
+#include "asio/detail/resolve_op.hpp"
 #include "asio/detail/socket_ops.hpp"
 
 #include "asio/detail/push_options.hpp"
@@ -33,20 +33,20 @@ namespace asio {
 namespace detail {
 
 template <typename Protocol, typename Handler>
-class resolve_endpoint_op : public operation
+class resolve_endpoint_op : public resolve_op
 {
 public:
   ASIO_DEFINE_HANDLER_PTR(resolve_endpoint_op);
 
   typedef typename Protocol::endpoint endpoint_type;
-  typedef asio::ip::basic_resolver_iterator<Protocol> iterator_type;
+  typedef asio::ip::basic_resolver_results<Protocol> results_type;
 
   resolve_endpoint_op(socket_ops::weak_cancel_token_type cancel_token,
-      const endpoint_type& endpoint, io_service_impl& ios, Handler& handler)
-    : operation(&resolve_endpoint_op::do_complete),
+      const endpoint_type& endpoint, io_context_impl& ioc, Handler& handler)
+    : resolve_op(&resolve_endpoint_op::do_complete),
       cancel_token_(cancel_token),
       endpoint_(endpoint),
-      io_service_impl_(ios),
+      io_context_impl_(ioc),
       handler_(ASIO_MOVE_CAST(Handler)(handler))
   {
     handler_work<Handler>::start(handler_);
@@ -61,9 +61,9 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    if (owner && owner != &o->io_service_impl_)
+    if (owner && owner != &o->io_context_impl_)
     {
-      // The operation is being run on the worker io_service. Time to perform
+      // The operation is being run on the worker io_context. Time to perform
       // the resolver operation.
     
       // Perform the blocking endpoint resolution operation.
@@ -72,18 +72,18 @@ public:
       socket_ops::background_getnameinfo(o->cancel_token_, o->endpoint_.data(),
           o->endpoint_.size(), host_name, NI_MAXHOST, service_name, NI_MAXSERV,
           o->endpoint_.protocol().type(), o->ec_);
-      o->iter_ = iterator_type::create(o->endpoint_, host_name, service_name);
+      o->results_ = results_type::create(o->endpoint_, host_name, service_name);
 
-      // Pass operation back to main io_service for completion.
-      o->io_service_impl_.post_deferred_completion(o);
+      // Pass operation back to main io_context for completion.
+      o->io_context_impl_.post_deferred_completion(o);
       p.v = p.p = 0;
     }
     else
     {
-      // The operation has been returned to the main io_service. The completion
+      // The operation has been returned to the main io_context. The completion
       // handler is ready to be delivered.
 
-      ASIO_HANDLER_COMPLETION((o));
+      ASIO_HANDLER_COMPLETION((*o));
 
       // Make a copy of the handler so that the memory can be deallocated
       // before the upcall is made. Even if we're not about to make an upcall,
@@ -91,8 +91,8 @@ public:
       // associated with the handler. Consequently, a local copy of the handler
       // is required to ensure that any owning sub-object remains valid until
       // after we have deallocated the memory here.
-      detail::binder2<Handler, asio::error_code, iterator_type>
-        handler(o->handler_, o->ec_, o->iter_);
+      detail::binder2<Handler, asio::error_code, results_type>
+        handler(o->handler_, o->ec_, o->results_);
       p.h = asio::detail::addressof(handler.handler_);
       p.reset();
 
@@ -109,10 +109,9 @@ public:
 private:
   socket_ops::weak_cancel_token_type cancel_token_;
   endpoint_type endpoint_;
-  io_service_impl& io_service_impl_;
+  io_context_impl& io_context_impl_;
   Handler handler_;
-  asio::error_code ec_;
-  iterator_type iter_;
+  results_type results_;
 };
 
 } // namespace detail
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/resolve_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/resolve_op.hpp
index 0f250b4..724edc5 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/resolve_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/resolve_op.hpp
@@ -2,7 +2,7 @@
 // detail/resolve_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,112 +17,24 @@
 
 #include "asio/detail/config.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/ip/basic_resolver_iterator.hpp"
-#include "asio/ip/basic_resolver_query.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/memory.hpp"
 #include "asio/detail/operation.hpp"
-#include "asio/detail/socket_ops.hpp"
 
 #include "asio/detail/push_options.hpp"
 
 namespace asio {
 namespace detail {
 
-template <typename Protocol, typename Handler>
 class resolve_op : public operation
 {
 public:
-  ASIO_DEFINE_HANDLER_PTR(resolve_op);
-
-  typedef asio::ip::basic_resolver_query<Protocol> query_type;
-  typedef asio::ip::basic_resolver_iterator<Protocol> iterator_type;
-
-  resolve_op(socket_ops::weak_cancel_token_type cancel_token,
-      const query_type& query, io_service_impl& ios, Handler& handler)
-    : operation(&resolve_op::do_complete),
-      cancel_token_(cancel_token),
-      query_(query),
-      io_service_impl_(ios),
-      handler_(ASIO_MOVE_CAST(Handler)(handler)),
-      addrinfo_(0)
-  {
-    handler_work<Handler>::start(handler_);
-  }
+  // The error code to be passed to the completion handler.
+  asio::error_code ec_;
 
-  ~resolve_op()
+protected:
+  resolve_op(func_type complete_func)
+    : operation(complete_func)
   {
-    if (addrinfo_)
-      socket_ops::freeaddrinfo(addrinfo_);
   }
-
-  static void do_complete(void* owner, operation* base,
-      const asio::error_code& /*ec*/,
-      std::size_t /*bytes_transferred*/)
-  {
-    // Take ownership of the operation object.
-    resolve_op* o(static_cast<resolve_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-    handler_work<Handler> w(o->handler_);
-
-    if (owner && owner != &o->io_service_impl_)
-    {
-      // The operation is being run on the worker io_service. Time to perform
-      // the resolver operation.
-    
-      // Perform the blocking host resolution operation.
-      socket_ops::background_getaddrinfo(o->cancel_token_,
-          o->query_.host_name().c_str(), o->query_.service_name().c_str(),
-          o->query_.hints(), &o->addrinfo_, o->ec_);
-
-      // Pass operation back to main io_service for completion.
-      o->io_service_impl_.post_deferred_completion(o);
-      p.v = p.p = 0;
-    }
-    else
-    {
-      // The operation has been returned to the main io_service. The completion
-      // handler is ready to be delivered.
-
-      ASIO_HANDLER_COMPLETION((o));
-
-      // Make a copy of the handler so that the memory can be deallocated
-      // before the upcall is made. Even if we're not about to make an upcall,
-      // a sub-object of the handler may be the true owner of the memory
-      // associated with the handler. Consequently, a local copy of the handler
-      // is required to ensure that any owning sub-object remains valid until
-      // after we have deallocated the memory here.
-      detail::binder2<Handler, asio::error_code, iterator_type>
-        handler(o->handler_, o->ec_, iterator_type());
-      p.h = asio::detail::addressof(handler.handler_);
-      if (o->addrinfo_)
-      {
-        handler.arg2_ = iterator_type::create(o->addrinfo_,
-            o->query_.host_name(), o->query_.service_name());
-      }
-      p.reset();
-
-      if (owner)
-      {
-        fenced_block b(fenced_block::half);
-        ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, "..."));
-        w.complete(handler, handler.handler_);
-        ASIO_HANDLER_INVOCATION_END;
-      }
-    }
-  }
-
-private:
-  socket_ops::weak_cancel_token_type cancel_token_;
-  query_type query_;
-  io_service_impl& io_service_impl_;
-  Handler handler_;
-  asio::error_code ec_;
-  asio::detail::addrinfo_type* addrinfo_;
 };
 
 } // namespace detail
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/resolve_query_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/resolve_query_op.hpp
new file mode 100644
index 0000000..0ce450b
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/resolve_query_op.hpp
@@ -0,0 +1,132 @@
+//
+// detail/resolve_query_op.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_DETAIL_RESOLVE_QUERY_OP_HPP
+#define ASIO_DETAIL_RESOLVE_QUERY_OP_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+#include "asio/error.hpp"
+#include "asio/io_context.hpp"
+#include "asio/ip/basic_resolver_query.hpp"
+#include "asio/ip/basic_resolver_results.hpp"
+#include "asio/detail/bind_handler.hpp"
+#include "asio/detail/fenced_block.hpp"
+#include "asio/detail/handler_alloc_helpers.hpp"
+#include "asio/detail/handler_invoke_helpers.hpp"
+#include "asio/detail/memory.hpp"
+#include "asio/detail/resolve_op.hpp"
+#include "asio/detail/socket_ops.hpp"
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+namespace detail {
+
+template <typename Protocol, typename Handler>
+class resolve_query_op : public resolve_op
+{
+public:
+  ASIO_DEFINE_HANDLER_PTR(resolve_query_op);
+
+  typedef asio::ip::basic_resolver_query<Protocol> query_type;
+  typedef asio::ip::basic_resolver_results<Protocol> results_type;
+
+  resolve_query_op(socket_ops::weak_cancel_token_type cancel_token,
+      const query_type& query, io_context_impl& ioc, Handler& handler)
+    : resolve_op(&resolve_query_op::do_complete),
+      cancel_token_(cancel_token),
+      query_(query),
+      io_context_impl_(ioc),
+      handler_(ASIO_MOVE_CAST(Handler)(handler)),
+      addrinfo_(0)
+  {
+    handler_work<Handler>::start(handler_);
+  }
+
+  ~resolve_query_op()
+  {
+    if (addrinfo_)
+      socket_ops::freeaddrinfo(addrinfo_);
+  }
+
+  static void do_complete(void* owner, operation* base,
+      const asio::error_code& /*ec*/,
+      std::size_t /*bytes_transferred*/)
+  {
+    // Take ownership of the operation object.
+    resolve_query_op* o(static_cast<resolve_query_op*>(base));
+    ptr p = { asio::detail::addressof(o->handler_), o, o };
+    handler_work<Handler> w(o->handler_);
+
+    if (owner && owner != &o->io_context_impl_)
+    {
+      // The operation is being run on the worker io_context. Time to perform
+      // the resolver operation.
+    
+      // Perform the blocking host resolution operation.
+      socket_ops::background_getaddrinfo(o->cancel_token_,
+          o->query_.host_name().c_str(), o->query_.service_name().c_str(),
+          o->query_.hints(), &o->addrinfo_, o->ec_);
+
+      // Pass operation back to main io_context for completion.
+      o->io_context_impl_.post_deferred_completion(o);
+      p.v = p.p = 0;
+    }
+    else
+    {
+      // The operation has been returned to the main io_context. The completion
+      // handler is ready to be delivered.
+
+      ASIO_HANDLER_COMPLETION((*o));
+
+      // Make a copy of the handler so that the memory can be deallocated
+      // before the upcall is made. Even if we're not about to make an upcall,
+      // a sub-object of the handler may be the true owner of the memory
+      // associated with the handler. Consequently, a local copy of the handler
+      // is required to ensure that any owning sub-object remains valid until
+      // after we have deallocated the memory here.
+      detail::binder2<Handler, asio::error_code, results_type>
+        handler(o->handler_, o->ec_, results_type());
+      p.h = asio::detail::addressof(handler.handler_);
+      if (o->addrinfo_)
+      {
+        handler.arg2_ = results_type::create(o->addrinfo_,
+            o->query_.host_name(), o->query_.service_name());
+      }
+      p.reset();
+
+      if (owner)
+      {
+        fenced_block b(fenced_block::half);
+        ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, "..."));
+        w.complete(handler, handler.handler_);
+        ASIO_HANDLER_INVOCATION_END;
+      }
+    }
+  }
+
+private:
+  socket_ops::weak_cancel_token_type cancel_token_;
+  query_type query_;
+  io_context_impl& io_context_impl_;
+  Handler handler_;
+  asio::detail::addrinfo_type* addrinfo_;
+};
+
+} // namespace detail
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // ASIO_DETAIL_RESOLVE_QUERY_OP_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/resolver_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/resolver_service.hpp
index 1b0953a..155e4f3 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/resolver_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/resolver_service.hpp
@@ -2,7 +2,7 @@
 // detail/resolver_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -19,11 +19,12 @@
 
 #if !defined(ASIO_WINDOWS_RUNTIME)
 
-#include "asio/ip/basic_resolver_iterator.hpp"
 #include "asio/ip/basic_resolver_query.hpp"
+#include "asio/ip/basic_resolver_results.hpp"
+#include "asio/detail/concurrency_hint.hpp"
 #include "asio/detail/memory.hpp"
 #include "asio/detail/resolve_endpoint_op.hpp"
-#include "asio/detail/resolve_op.hpp"
+#include "asio/detail/resolve_query_op.hpp"
 #include "asio/detail/resolver_service_base.hpp"
 
 #include "asio/detail/push_options.hpp"
@@ -32,7 +33,9 @@ namespace asio {
 namespace detail {
 
 template <typename Protocol>
-class resolver_service : public resolver_service_base
+class resolver_service :
+  public service_base<resolver_service<Protocol> >,
+  public resolver_service_base
 {
 public:
   // The implementation type of the resolver. A cancellation token is used to
@@ -45,17 +48,30 @@ public:
   // The query type.
   typedef asio::ip::basic_resolver_query<Protocol> query_type;
 
-  // The iterator type.
-  typedef asio::ip::basic_resolver_iterator<Protocol> iterator_type;
+  // The results type.
+  typedef asio::ip::basic_resolver_results<Protocol> results_type;
 
   // Constructor.
-  resolver_service(asio::io_service& io_service)
-    : resolver_service_base(io_service)
+  resolver_service(asio::io_context& io_context)
+    : service_base<resolver_service<Protocol> >(io_context),
+      resolver_service_base(io_context)
   {
   }
 
+  // Destroy all user-defined handler objects owned by the service.
+  void shutdown()
+  {
+    this->base_shutdown();
+  }
+
+  // Perform any fork-related housekeeping.
+  void notify_fork(asio::io_context::fork_event fork_ev)
+  {
+    this->base_notify_fork(fork_ev);
+  }
+
   // Resolve a query to a list of entries.
-  iterator_type resolve(implementation_type&, const query_type& query,
+  results_type resolve(implementation_type&, const query_type& query,
       asio::error_code& ec)
   {
     asio::detail::addrinfo_type* address_info = 0;
@@ -64,7 +80,7 @@ public:
         query.service_name().c_str(), query.hints(), &address_info, ec);
     auto_addrinfo auto_address_info(address_info);
 
-    return ec ? iterator_type() : iterator_type::create(
+    return ec ? results_type() : results_type::create(
         address_info, query.host_name(), query.service_name());
   }
 
@@ -74,19 +90,20 @@ public:
       const query_type& query, Handler& handler)
   {
     // Allocate and construct an operation to wrap the handler.
-    typedef resolve_op<Protocol, Handler> op;
+    typedef resolve_query_op<Protocol, Handler> op;
     typename op::ptr p = { asio::detail::addressof(handler),
       op::ptr::allocate(handler), 0 };
-    p.p = new (p.v) op(impl, query, io_service_impl_, handler);
+    p.p = new (p.v) op(impl, query, io_context_impl_, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "resolver", &impl, "async_resolve"));
+    ASIO_HANDLER_CREATION((io_context_impl_.context(),
+          *p.p, "resolver", &impl, 0, "async_resolve"));
 
     start_resolve_op(p.p);
     p.v = p.p = 0;
   }
 
   // Resolve an endpoint to a list of entries.
-  iterator_type resolve(implementation_type&,
+  results_type resolve(implementation_type&,
       const endpoint_type& endpoint, asio::error_code& ec)
   {
     char host_name[NI_MAXHOST];
@@ -95,7 +112,7 @@ public:
         host_name, NI_MAXHOST, service_name, NI_MAXSERV,
         endpoint.protocol().type(), ec);
 
-    return ec ? iterator_type() : iterator_type::create(
+    return ec ? results_type() : results_type::create(
         endpoint, host_name, service_name);
   }
 
@@ -108,9 +125,10 @@ public:
     typedef resolve_endpoint_op<Protocol, Handler> op;
     typename op::ptr p = { asio::detail::addressof(handler),
       op::ptr::allocate(handler), 0 };
-    p.p = new (p.v) op(impl, endpoint, io_service_impl_, handler);
+    p.p = new (p.v) op(impl, endpoint, io_context_impl_, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "resolver", &impl, "async_resolve"));
+    ASIO_HANDLER_CREATION((io_context_impl_.context(),
+          *p.p, "resolver", &impl, 0, "async_resolve"));
 
     start_resolve_op(p.p);
     p.v = p.p = 0;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/resolver_service_base.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/resolver_service_base.hpp
index 221ae91..e3dd4f7 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/resolver_service_base.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/resolver_service_base.hpp
@@ -2,7 +2,7 @@
 // detail/resolver_service_base.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,10 +17,11 @@
 
 #include "asio/detail/config.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/executor_work_guard.hpp"
+#include "asio/io_context.hpp"
 #include "asio/detail/mutex.hpp"
 #include "asio/detail/noncopyable.hpp"
-#include "asio/detail/operation.hpp"
+#include "asio/detail/resolve_op.hpp"
 #include "asio/detail/socket_ops.hpp"
 #include "asio/detail/socket_types.hpp"
 #include "asio/detail/scoped_ptr.hpp"
@@ -39,17 +40,17 @@ public:
   typedef socket_ops::shared_cancel_token_type implementation_type;
 
   // Constructor.
-  ASIO_DECL resolver_service_base(asio::io_service& io_service);
+  ASIO_DECL resolver_service_base(asio::io_context& io_context);
 
   // Destructor.
   ASIO_DECL ~resolver_service_base();
 
   // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
+  ASIO_DECL void base_shutdown();
 
   // Perform any fork-related housekeeping.
-  ASIO_DECL void fork_service(
-      asio::io_service::fork_event fork_ev);
+  ASIO_DECL void base_notify_fork(
+      asio::io_context::fork_event fork_ev);
 
   // Construct a new resolver implementation.
   ASIO_DECL void construct(implementation_type& impl);
@@ -57,12 +58,21 @@ public:
   // Destroy a resolver implementation.
   ASIO_DECL void destroy(implementation_type&);
 
+  // Move-construct a new resolver implementation.
+  ASIO_DECL void move_construct(implementation_type& impl,
+      implementation_type& other_impl);
+
+  // Move-assign from another resolver implementation.
+  ASIO_DECL void move_assign(implementation_type& impl,
+      resolver_service_base& other_service,
+      implementation_type& other_impl);
+
   // Cancel pending asynchronous operations.
   ASIO_DECL void cancel(implementation_type& impl);
 
 protected:
   // Helper function to start an asynchronous resolve operation.
-  ASIO_DECL void start_resolve_op(operation* op);
+  ASIO_DECL void start_resolve_op(resolve_op* op);
 
 #if !defined(ASIO_WINDOWS_RUNTIME)
   // Helper class to perform exception-safe cleanup of addrinfo objects.
@@ -91,29 +101,30 @@ protected:
   };
 #endif // !defined(ASIO_WINDOWS_RUNTIME)
 
-  // Helper class to run the work io_service in a thread.
-  class work_io_service_runner;
+  // Helper class to run the work io_context in a thread.
+  class work_io_context_runner;
 
   // Start the work thread if it's not already running.
   ASIO_DECL void start_work_thread();
 
-  // The io_service implementation used to post completions.
-  io_service_impl& io_service_impl_;
+  // The io_context implementation used to post completions.
+  io_context_impl& io_context_impl_;
 
 private:
   // Mutex to protect access to internal data.
   asio::detail::mutex mutex_;
 
-  // Private io_service used for performing asynchronous host resolution.
-  asio::detail::scoped_ptr<asio::io_service> work_io_service_;
+  // Private io_context used for performing asynchronous host resolution.
+  asio::detail::scoped_ptr<asio::io_context> work_io_context_;
 
-  // The work io_service implementation used to post completions.
-  io_service_impl& work_io_service_impl_;
+  // The work io_context implementation used to post completions.
+  io_context_impl& work_io_context_impl_;
 
-  // Work for the private io_service to perform.
-  asio::detail::scoped_ptr<asio::io_service::work> work_;
+  // Work for the private io_context to perform.
+  asio::executor_work_guard<
+      asio::io_context::executor_type> work_;
 
-  // Thread used for running the work io_service's run loop.
+  // Thread used for running the work io_context's run loop.
   asio::detail::scoped_ptr<asio::detail::thread> work_thread_;
 };
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/scheduler.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/scheduler.hpp
index 0589a99..3781472 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/scheduler.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/scheduler.hpp
@@ -2,7 +2,7 @@
 // detail/scheduler.hpp
 // ~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -20,8 +20,8 @@
 #include "asio/error_code.hpp"
 #include "asio/execution_context.hpp"
 #include "asio/detail/atomic_count.hpp"
-#include "asio/detail/event.hpp"
-#include "asio/detail/mutex.hpp"
+#include "asio/detail/conditionally_enabled_event.hpp"
+#include "asio/detail/conditionally_enabled_mutex.hpp"
 #include "asio/detail/op_queue.hpp"
 #include "asio/detail/reactor_fwd.hpp"
 #include "asio/detail/scheduler_operation.hpp"
@@ -44,10 +44,10 @@ public:
   // Constructor. Specifies the number of concurrent threads that are likely to
   // run the scheduler. If set to 1 certain optimisation are performed.
   ASIO_DECL scheduler(asio::execution_context& ctx,
-      std::size_t concurrency_hint = 0);
+      int concurrency_hint = 0);
 
   // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
+  ASIO_DECL void shutdown();
 
   // Initialise the task, if required.
   ASIO_DECL void init_task();
@@ -58,6 +58,10 @@ public:
   // Run until interrupted or one operation is performed.
   ASIO_DECL std::size_t run_one(asio::error_code& ec);
 
+  // Run until timeout, interrupted, or one operation is performed.
+  ASIO_DECL std::size_t wait_one(
+      long usec, asio::error_code& ec);
+
   // Poll for operations without blocking.
   ASIO_DECL std::size_t poll(asio::error_code& ec);
 
@@ -79,6 +83,10 @@ public:
     ++outstanding_work_;
   }
 
+  // Used to compensate for a forthcoming work_finished call. Must be called
+  // from within a scheduler-owned thread.
+  ASIO_DECL void compensating_work_started();
+
   // Notify that some work has finished.
   void work_finished()
   {
@@ -109,11 +117,23 @@ public:
   // operation for immediate invocation.
   ASIO_DECL void do_dispatch(operation* op);
 
-  // Process unfinished operations as part of a shutdown_service operation.
-  // Assumes that work_started() was previously called for the operations.
+  // Process unfinished operations as part of a shutdownoperation. Assumes that
+  // work_started() was previously called for the operations.
   ASIO_DECL void abandon_operations(op_queue<operation>& ops);
 
+  // Get the concurrency hint that was used to initialise the scheduler.
+  int concurrency_hint() const
+  {
+    return concurrency_hint_;
+  }
+
 private:
+  // The mutex type used by this scheduler.
+  typedef conditionally_enabled_mutex mutex;
+
+  // The event type used by this scheduler.
+  typedef conditionally_enabled_event event;
+
   // Structure containing thread-specific data.
   typedef scheduler_thread_info thread_info;
 
@@ -121,6 +141,10 @@ private:
   ASIO_DECL std::size_t do_run_one(mutex::scoped_lock& lock,
       thread_info& this_thread, const asio::error_code& ec);
 
+  // Run at most one operation with a timeout. May block.
+  ASIO_DECL std::size_t do_wait_one(mutex::scoped_lock& lock,
+      thread_info& this_thread, long usec, const asio::error_code& ec);
+
   // Poll for at most one operation.
   ASIO_DECL std::size_t do_poll_one(mutex::scoped_lock& lock,
       thread_info& this_thread, const asio::error_code& ec);
@@ -172,6 +196,9 @@ private:
 
   // Flag to indicate that the dispatcher has been shut down.
   bool shutdown_;
+
+  // The concurrency hint used to initialise the scheduler.
+  const int concurrency_hint_;
 };
 
 } // namespace detail
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/scheduler_operation.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/scheduler_operation.hpp
index 8d3c478..112b3df 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/scheduler_operation.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/scheduler_operation.hpp
@@ -2,7 +2,7 @@
 // detail/scheduler_operation.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/scheduler_thread_info.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/scheduler_thread_info.hpp
index c46e1f1..aa8260c 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/scheduler_thread_info.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/scheduler_thread_info.hpp
@@ -2,7 +2,7 @@
 // detail/scheduler_thread_info.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/scoped_lock.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/scoped_lock.hpp
index 27d6c8f..cf52614 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/scoped_lock.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/scoped_lock.hpp
@@ -2,7 +2,7 @@
 // detail/scoped_lock.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/scoped_ptr.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/scoped_ptr.hpp
index adc215f..3bc26f1 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/scoped_ptr.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/scoped_ptr.hpp
@@ -2,7 +2,7 @@
 // detail/scoped_ptr.hpp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/select_interrupter.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/select_interrupter.hpp
index 4db8350..ecac7db 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/select_interrupter.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/select_interrupter.hpp
@@ -2,7 +2,7 @@
 // detail/select_interrupter.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/select_reactor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/select_reactor.hpp
index 183db2b..7f9b55b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/select_reactor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/select_reactor.hpp
@@ -2,7 +2,7 @@
 // detail/select_reactor.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -70,10 +70,10 @@ public:
   ASIO_DECL ~select_reactor();
 
   // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
+  ASIO_DECL void shutdown();
 
   // Recreate internal descriptors following a fork.
-  ASIO_DECL void fork_service(
+  ASIO_DECL void notify_fork(
       asio::execution_context::fork_event fork_ev);
 
   // Initialise the task, but only if the reactor is not in its own thread.
@@ -148,7 +148,7 @@ public:
       typename timer_queue<Time_Traits>::per_timer_data& source);
 
   // Run select once until interrupted or events are ready to be dispatched.
-  ASIO_DECL void run(bool block, op_queue<operation>& ops);
+  ASIO_DECL void run(long usec, op_queue<operation>& ops);
 
   // Interrupt the select loop.
   ASIO_DECL void interrupt();
@@ -166,7 +166,7 @@ private:
   ASIO_DECL void do_remove_timer_queue(timer_queue_base& queue);
 
   // Get the timeout value for the select call.
-  ASIO_DECL timeval* get_timeout(timeval& tv);
+  ASIO_DECL timeval* get_timeout(long usec, timeval& tv);
 
   // Cancel all operations associated with the given descriptor. This function
   // does not acquire the select_reactor's mutex.
@@ -175,7 +175,7 @@ private:
 
   // The scheduler implementation used to post completions.
 # if defined(ASIO_HAS_IOCP)
-  typedef class win_iocp_io_service scheduler_type;
+  typedef class win_iocp_io_context scheduler_type;
 # else // defined(ASIO_HAS_IOCP)
   typedef class scheduler scheduler_type;
 # endif // defined(ASIO_HAS_IOCP)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/service_registry.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/service_registry.hpp
index 7438765..06f49de 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/service_registry.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/service_registry.hpp
@@ -2,7 +2,7 @@
 // detail/service_registry.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -19,31 +19,20 @@
 #include <typeinfo>
 #include "asio/detail/mutex.hpp"
 #include "asio/detail/noncopyable.hpp"
+#include "asio/detail/type_traits.hpp"
 #include "asio/execution_context.hpp"
 
 #include "asio/detail/push_options.hpp"
 
 namespace asio {
 
-class io_service;
+class io_context;
 
 namespace detail {
 
-#if defined(__GNUC__)
-# if (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)
-#  pragma GCC visibility push (default)
-# endif // (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)
-#endif // defined(__GNUC__)
-
 template <typename T>
 class typeid_wrapper {};
 
-#if defined(__GNUC__)
-# if (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)
-#  pragma GCC visibility pop
-# endif // (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)
-#endif // defined(__GNUC__)
-
 class service_registry
   : private noncopyable
 {
@@ -73,9 +62,9 @@ public:
   // create a new service object automatically if no such object already
   // exists. Ownership of the service object is not transferred to the caller.
   // This overload is used for backwards compatibility with services that
-  // inherit from io_service::service.
+  // inherit from io_context::service.
   template <typename Service>
-  Service& use_service(io_service& owner);
+  Service& use_service(io_context& owner);
 
   // Add a service object. Throws on error, in which case ownership of the
   // object is retained by the caller.
@@ -87,15 +76,27 @@ public:
   bool has_service() const;
 
 private:
+  // Initalise a service's key when the key_type typedef is not available.
+  template <typename Service>
+  static void init_key(execution_context::service::key& key, ...);
+
+#if !defined(ASIO_NO_TYPEID)
+  // Initalise a service's key when the key_type typedef is available.
+  template <typename Service>
+  static void init_key(execution_context::service::key& key,
+      typename enable_if<
+        is_base_of<typename Service::key_type, Service>::value>::type*);
+#endif // !defined(ASIO_NO_TYPEID)
+
   // Initialise a service's key based on its id.
-  ASIO_DECL static void init_key(
+  ASIO_DECL static void init_key_from_id(
       execution_context::service::key& key,
       const execution_context::id& id);
 
 #if !defined(ASIO_NO_TYPEID)
   // Initialise a service's key based on its id.
   template <typename Service>
-  static void init_key(execution_context::service::key& key,
+  static void init_key_from_id(execution_context::service::key& key,
       const service_id<Service>& /*id*/);
 #endif // !defined(ASIO_NO_TYPEID)
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/signal_blocker.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/signal_blocker.hpp
index ad668ad..f0fac08 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/signal_blocker.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/signal_blocker.hpp
@@ -2,7 +2,7 @@
 // detail/signal_blocker.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/signal_handler.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/signal_handler.hpp
index 4554f98..19fee65 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/signal_handler.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/signal_handler.hpp
@@ -2,7 +2,7 @@
 // detail/signal_handler.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -51,7 +51,7 @@ public:
     ptr p = { asio::detail::addressof(h->handler_), h, h };
     handler_work<Handler> w(h->handler_);
 
-    ASIO_HANDLER_COMPLETION((h));
+    ASIO_HANDLER_COMPLETION((*h));
 
     // Make a copy of the handler so that the memory can be deallocated before
     // the upcall is made. Even if we're not about to make an upcall, a
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/signal_init.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/signal_init.hpp
index e9a8cac..266a3e0 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/signal_init.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/signal_init.hpp
@@ -2,7 +2,7 @@
 // detail/signal_init.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/signal_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/signal_op.hpp
index 2f7fd62..9921de0 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/signal_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/signal_op.hpp
@@ -2,7 +2,7 @@
 // detail/signal_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/signal_set_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/signal_set_service.hpp
index 0bb3cd7..58ee99b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/signal_set_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/signal_set_service.hpp
@@ -2,7 +2,7 @@
 // detail/signal_set_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -20,7 +20,7 @@
 #include <cstddef>
 #include <signal.h>
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/detail/handler_alloc_helpers.hpp"
 #include "asio/detail/memory.hpp"
 #include "asio/detail/op_queue.hpp"
@@ -47,7 +47,8 @@ extern ASIO_DECL struct signal_state* get_signal_state();
 
 extern "C" ASIO_DECL void asio_signal_handler(int signal_number);
 
-class signal_set_service
+class signal_set_service :
+  public service_base<signal_set_service>
 {
 public:
   // Type used for tracking an individual signal registration.
@@ -108,17 +109,17 @@ public:
   };
 
   // Constructor.
-  ASIO_DECL signal_set_service(asio::io_service& io_service);
+  ASIO_DECL signal_set_service(asio::io_context& io_context);
 
   // Destructor.
   ASIO_DECL ~signal_set_service();
 
   // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
+  ASIO_DECL void shutdown();
 
   // Perform fork-related housekeeping.
-  ASIO_DECL void fork_service(
-      asio::io_service::fork_event fork_ev);
+  ASIO_DECL void notify_fork(
+      asio::io_context::fork_event fork_ev);
 
   // Construct a new signal_set implementation.
   ASIO_DECL void construct(implementation_type& impl);
@@ -152,7 +153,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(handler);
 
-    ASIO_HANDLER_CREATION((p.p, "signal_set", &impl, "async_wait"));
+    ASIO_HANDLER_CREATION((io_context_.context(),
+          *p.p, "signal_set", &impl, 0, "async_wait"));
 
     start_wait_op(impl, p.p);
     p.v = p.p = 0;
@@ -177,8 +179,8 @@ private:
   // Helper function to start a wait operation.
   ASIO_DECL void start_wait_op(implementation_type& impl, signal_op* op);
 
-  // The io_service instance used for dispatching handlers.
-  io_service_impl& io_service_;
+  // The io_context instance used for dispatching handlers.
+  io_context_impl& io_context_;
 
 #if !defined(ASIO_WINDOWS) \
   && !defined(ASIO_WINDOWS_RUNTIME) \
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/socket_holder.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/socket_holder.hpp
index 4fa3143..1c9e721 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/socket_holder.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/socket_holder.hpp
@@ -2,7 +2,7 @@
 // detail/socket_holder.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/socket_ops.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/socket_ops.hpp
index 2ebadac..5529a27 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/socket_ops.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/socket_ops.hpp
@@ -2,7 +2,7 @@
 // detail/socket_ops.hpp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -263,15 +263,16 @@ ASIO_DECL int select(int nfds, fd_set* readfds, fd_set* writefds,
     fd_set* exceptfds, timeval* timeout, asio::error_code& ec);
 
 ASIO_DECL int poll_read(socket_type s,
-    state_type state, asio::error_code& ec);
+    state_type state, int msec, asio::error_code& ec);
 
 ASIO_DECL int poll_write(socket_type s,
-    state_type state, asio::error_code& ec);
+    state_type state, int msec, asio::error_code& ec);
 
 ASIO_DECL int poll_error(socket_type s,
-    state_type state, asio::error_code& ec);
+    state_type state, int msec, asio::error_code& ec);
 
-ASIO_DECL int poll_connect(socket_type s, asio::error_code& ec);
+ASIO_DECL int poll_connect(socket_type s,
+    int msec, asio::error_code& ec);
 
 #endif // !defined(ASIO_WINDOWS_RUNTIME)
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/socket_option.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/socket_option.hpp
index 7241ab7..02860b9 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/socket_option.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/socket_option.hpp
@@ -2,7 +2,7 @@
 // detail/socket_option.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/socket_select_interrupter.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/socket_select_interrupter.hpp
index 470ce78..7089640 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/socket_select_interrupter.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/socket_select_interrupter.hpp
@@ -2,7 +2,7 @@
 // detail/socket_select_interrupter.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/socket_types.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/socket_types.hpp
index f2600c2..3114c08 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/socket_types.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/socket_types.hpp
@@ -2,7 +2,7 @@
 // detail/socket_types.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -37,7 +37,9 @@
 # endif // defined(WINAPI_FAMILY)
 # include <winsock2.h>
 # include <ws2tcpip.h>
-# include <mswsock.h>
+# if !defined(ASIO_WINDOWS_APP)
+#  include <mswsock.h>
+# endif // !defined(ASIO_WINDOWS_APP)
 # if defined(ASIO_WSPIAPI_H_DEFINED)
 #  undef _WSPIAPI_H_
 #  undef ASIO_WSPIAPI_H_DEFINED
@@ -47,7 +49,9 @@
 #   pragma comment(lib, "ws2.lib")
 #  elif defined(_MSC_VER) || defined(__BORLANDC__)
 #   pragma comment(lib, "ws2_32.lib")
-#   pragma comment(lib, "mswsock.lib")
+#   if !defined(ASIO_WINDOWS_APP)
+#    pragma comment(lib, "mswsock.lib")
+#   endif // !defined(ASIO_WINDOWS_APP)
 #  endif // defined(_MSC_VER) || defined(__BORLANDC__)
 # endif // !defined(ASIO_NO_DEFAULT_LINKED_LIBS)
 # include "asio/detail/old_win_sdk_compat.hpp"
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/solaris_fenced_block.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/solaris_fenced_block.hpp
index 7ecc042..c1b599e 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/solaris_fenced_block.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/solaris_fenced_block.hpp
@@ -2,7 +2,7 @@
 // detail/solaris_fenced_block.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/static_mutex.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/static_mutex.hpp
index bc84118..1be0a85 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/static_mutex.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/static_mutex.hpp
@@ -2,7 +2,7 @@
 // detail/static_mutex.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/std_event.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/std_event.hpp
index b7c5e20..e05fcca 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/std_event.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/std_event.hpp
@@ -2,7 +2,7 @@
 // detail/std_event.hpp
 // ~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/std_global.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/std_global.hpp
index f7f856f..416f0d3 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/std_global.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/std_global.hpp
@@ -2,7 +2,7 @@
 // detail/std_global.hpp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/std_mutex.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/std_mutex.hpp
index 478aa1a..31af56a 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/std_mutex.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/std_mutex.hpp
@@ -2,7 +2,7 @@
 // detail/std_mutex.hpp
 // ~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/std_static_mutex.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/std_static_mutex.hpp
index b2abadf..166ede9 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/std_static_mutex.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/std_static_mutex.hpp
@@ -2,7 +2,7 @@
 // detail/std_static_mutex.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/std_thread.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/std_thread.hpp
index 858218c..f6fcec1 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/std_thread.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/std_thread.hpp
@@ -2,7 +2,7 @@
 // detail/std_thread.hpp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/strand_executor_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/strand_executor_service.hpp
index d149e4f..5ca77a3 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/strand_executor_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/strand_executor_service.hpp
@@ -2,7 +2,7 @@
 // detail/strand_executor_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -76,7 +76,7 @@ public:
   ASIO_DECL explicit strand_executor_service(execution_context& context);
 
   // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
+  ASIO_DECL void shutdown();
 
   // Create a new strand_executor implementation.
   ASIO_DECL implementation_type create_implementation();
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/strand_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/strand_service.hpp
index 7b4bc8a..c5d95e7 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/strand_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/strand_service.hpp
@@ -2,7 +2,7 @@
 // detail/strand_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,7 +16,7 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/detail/mutex.hpp"
 #include "asio/detail/op_queue.hpp"
 #include "asio/detail/operation.hpp"
@@ -74,20 +74,20 @@ public:
 
   typedef strand_impl* implementation_type;
 
-  // Construct a new strand service for the specified io_service.
-  ASIO_DECL explicit strand_service(asio::io_service& io_service);
+  // Construct a new strand service for the specified io_context.
+  ASIO_DECL explicit strand_service(asio::io_context& io_context);
 
   // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
+  ASIO_DECL void shutdown();
 
   // Construct a new strand implementation.
   ASIO_DECL void construct(implementation_type& impl);
 
-  // Request the io_service to invoke the given handler.
+  // Request the io_context to invoke the given handler.
   template <typename Handler>
   void dispatch(implementation_type& impl, Handler& handler);
 
-  // Request the io_service to invoke the given handler and return immediately.
+  // Request the io_context to invoke the given handler and return immediately.
   template <typename Handler>
   void post(implementation_type& impl, Handler& handler);
 
@@ -108,8 +108,8 @@ private:
       operation* base, const asio::error_code& ec,
       std::size_t bytes_transferred);
 
-  // The io_service implementation used to post completions.
-  io_service_impl& io_service_;
+  // The io_context implementation used to post completions.
+  io_context_impl& io_context_;
 
   // Mutex to protect access to the array of implementations.
   asio::detail::mutex mutex_;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/string_view.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/string_view.hpp
new file mode 100644
index 0000000..6f4072d
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/string_view.hpp
@@ -0,0 +1,45 @@
+//
+// detail/string_view.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_DETAIL_STRING_VIEW_HPP
+#define ASIO_DETAIL_STRING_VIEW_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#if defined(ASIO_HAS_STD_STRING_VIEW)
+
+#include "asio/detail/config.hpp"
+
+#if defined(ASIO_HAS_STD_EXPERIMENTAL_STRING_VIEW)
+# include <experimental/string_view>
+#else // defined(ASIO_HAS_EXPERIMENTAL_STRING_VIEW)
+# include <string_view>
+#endif // defined(ASIO_HAS_EXPERIMENTAL_STRING_VIEW)
+
+namespace asio {
+
+#if defined(ASIO_HAS_STD_EXPERIMENTAL_STRING_VIEW)
+using std::experimental::basic_string_view;
+using std::experimental::string_view;
+#else // defined(ASIO_HAS_STD_EXPERIMENTAL_STRING_VIEW)
+using std::basic_string_view;
+using std::string_view;
+#endif // defined(ASIO_HAS_STD_EXPERIMENTAL_STRING_VIEW)
+
+} // namespace asio
+
+# define ASIO_STRING_VIEW_PARAM asio::string_view
+#else // defined(ASIO_HAS_STD_STRING_VIEW)
+# define ASIO_STRING_VIEW_PARAM const std::string&
+#endif // defined(ASIO_HAS_STD_STRING_VIEW)
+
+#endif // ASIO_DETAIL_STRING_VIEW_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/thread.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/thread.hpp
index 3592a70..cfb5bad 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/thread.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/thread.hpp
@@ -2,7 +2,7 @@
 // detail/thread.hpp
 // ~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -22,6 +22,8 @@
 #elif defined(ASIO_WINDOWS)
 # if defined(UNDER_CE)
 #  include "asio/detail/wince_thread.hpp"
+# elif defined(ASIO_WINDOWS_APP)
+#  include "asio/detail/winapp_thread.hpp"
 # else
 #  include "asio/detail/win_thread.hpp"
 # endif
@@ -41,6 +43,8 @@ typedef null_thread thread;
 #elif defined(ASIO_WINDOWS)
 # if defined(UNDER_CE)
 typedef wince_thread thread;
+# elif defined(ASIO_WINDOWS_APP)
+typedef winapp_thread thread;
 # else
 typedef win_thread thread;
 # endif
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/thread_context.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/thread_context.hpp
index 0cbf343..66d20d6 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/thread_context.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/thread_context.hpp
@@ -2,7 +2,7 @@
 // detail/thread_context.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -26,7 +26,7 @@ namespace detail {
 
 class thread_info_base;
 
-// Base class for things that manage threads (scheduler, win_iocp_io_service).
+// Base class for things that manage threads (scheduler, win_iocp_io_context).
 class thread_context
 {
 public:
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/thread_group.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/thread_group.hpp
index 6ae7ebf..312af44 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/thread_group.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/thread_group.hpp
@@ -2,7 +2,7 @@
 // detail/thread_group.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -75,7 +75,7 @@ private:
     {
     }
 
-    thread thread_;
+    asio::detail::thread thread_;
     item* next_;
   };
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/thread_info_base.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/thread_info_base.hpp
index dd52468..5fc26c3 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/thread_info_base.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/thread_info_base.hpp
@@ -2,7 +2,7 @@
 // detail/thread_info_base.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/throw_error.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/throw_error.hpp
index 5eff60c..3c1d59c 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/throw_error.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/throw_error.hpp
@@ -2,7 +2,7 @@
 // detail/throw_error.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/throw_exception.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/throw_exception.hpp
index 3cec317..a0c3cf8 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/throw_exception.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/throw_exception.hpp
@@ -2,7 +2,7 @@
 // detail/throw_exception.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_queue.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_queue.hpp
index 79a72ad..1575e03 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_queue.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_queue.hpp
@@ -2,7 +2,7 @@
 // detail/timer_queue.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_queue_base.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_queue_base.hpp
index 56101fd..326d055 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_queue_base.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_queue_base.hpp
@@ -2,7 +2,7 @@
 // detail/timer_queue_base.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_queue_ptime.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_queue_ptime.hpp
index 0062fea..9d3cb7d 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_queue_ptime.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_queue_ptime.hpp
@@ -2,7 +2,7 @@
 // detail/timer_queue_ptime.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -15,13 +15,15 @@
 # pragma once
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
+#include "asio/detail/config.hpp"
+
+#if defined(ASIO_HAS_BOOST_DATE_TIME)
+
 #include "asio/time_traits.hpp"
 #include "asio/detail/timer_queue.hpp"
 
 #include "asio/detail/push_options.hpp"
 
-#if defined(ASIO_HAS_BOOST_DATE_TIME)
-
 namespace asio {
 namespace detail {
 
@@ -75,6 +77,10 @@ public:
       per_timer_data& timer, op_queue<operation>& ops,
       std::size_t max_cancelled = (std::numeric_limits<std::size_t>::max)());
 
+  // Move operations from one timer to another, empty timer.
+  ASIO_DECL void move_timer(per_timer_data& target,
+      per_timer_data& source);
+
 private:
   timer_queue<forwarding_posix_time_traits> impl_;
 };
@@ -82,12 +88,12 @@ private:
 } // namespace detail
 } // namespace asio
 
-#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
-
 #include "asio/detail/pop_options.hpp"
 
 #if defined(ASIO_HEADER_ONLY)
 # include "asio/detail/impl/timer_queue_ptime.ipp"
 #endif // defined(ASIO_HEADER_ONLY)
 
+#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
+
 #endif // ASIO_DETAIL_TIMER_QUEUE_PTIME_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_queue_set.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_queue_set.hpp
index e8bf649..38f46d1 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_queue_set.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_queue_set.hpp
@@ -2,7 +2,7 @@
 // detail/timer_queue_set.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_scheduler.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_scheduler.hpp
index 34f8259..1907316 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_scheduler.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_scheduler.hpp
@@ -2,7 +2,7 @@
 // detail/timer_scheduler.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -21,7 +21,7 @@
 #if defined(ASIO_WINDOWS_RUNTIME)
 # include "asio/detail/winrt_timer_scheduler.hpp"
 #elif defined(ASIO_HAS_IOCP)
-# include "asio/detail/win_iocp_io_service.hpp"
+# include "asio/detail/win_iocp_io_context.hpp"
 #elif defined(ASIO_HAS_EPOLL)
 # include "asio/detail/epoll_reactor.hpp"
 #elif defined(ASIO_HAS_KQUEUE)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_scheduler_fwd.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_scheduler_fwd.hpp
index 69b0586..cf27b8c 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_scheduler_fwd.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/timer_scheduler_fwd.hpp
@@ -2,7 +2,7 @@
 // detail/timer_scheduler_fwd.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -23,7 +23,7 @@ namespace detail {
 #if defined(ASIO_WINDOWS_RUNTIME)
 typedef class winrt_timer_scheduler timer_scheduler;
 #elif defined(ASIO_HAS_IOCP)
-typedef class win_iocp_io_service timer_scheduler;
+typedef class win_iocp_io_context timer_scheduler;
 #elif defined(ASIO_HAS_EPOLL)
 typedef class epoll_reactor timer_scheduler;
 #elif defined(ASIO_HAS_KQUEUE)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/tss_ptr.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/tss_ptr.hpp
index af80f28..2d03061 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/tss_ptr.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/tss_ptr.hpp
@@ -2,7 +2,7 @@
 // detail/tss_ptr.hpp
 // ~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/type_traits.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/type_traits.hpp
index e7e65a8..0866589 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/type_traits.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/type_traits.hpp
@@ -2,7 +2,7 @@
 // detail/type_traits.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -24,6 +24,7 @@
 # include <boost/type_traits/conditional.hpp>
 # include <boost/type_traits/decay.hpp>
 # include <boost/type_traits/integral_constant.hpp>
+# include <boost/type_traits/is_base_of.hpp>
 # include <boost/type_traits/is_class.hpp>
 # include <boost/type_traits/is_const.hpp>
 # include <boost/type_traits/is_convertible.hpp>
@@ -44,6 +45,7 @@ using std::decay;
 using std::enable_if;
 using std::false_type;
 using std::integral_constant;
+using std::is_base_of;
 using std::is_class;
 using std::is_const;
 using std::is_convertible;
@@ -61,6 +63,7 @@ using boost::conditional;
 using boost::decay;
 using boost::false_type;
 using boost::integral_constant;
+using boost::is_base_of;
 using boost::is_class;
 using boost::is_const;
 using boost::is_convertible;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/variadic_templates.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/variadic_templates.hpp
index 696c884..272ae28 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/variadic_templates.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/variadic_templates.hpp
@@ -2,7 +2,7 @@
 // detail/variadic_templates.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -94,6 +94,24 @@
   ASIO_MOVE_CAST(T3)(x3), ASIO_MOVE_CAST(T4)(x4), \
   ASIO_MOVE_CAST(T5)(x5)
 
+# define ASIO_VARIADIC_DECAY(n) \
+  ASIO_VARIADIC_DECAY_##n
+
+# define ASIO_VARIADIC_DECAY_1 \
+  typename decay<T1>::type
+# define ASIO_VARIADIC_DECAY_2 \
+  typename decay<T1>::type, typename decay<T2>::type
+# define ASIO_VARIADIC_DECAY_3 \
+  typename decay<T1>::type, typename decay<T2>::type, \
+  typename decay<T3>::type
+# define ASIO_VARIADIC_DECAY_4 \
+  typename decay<T1>::type, typename decay<T2>::type, \
+  typename decay<T3>::type, typename decay<T4>::type
+# define ASIO_VARIADIC_DECAY_5 \
+  typename decay<T1>::type, typename decay<T2>::type, \
+  typename decay<T3>::type, typename decay<T4>::type, \
+  typename decay<T5>::type
+
 # define ASIO_VARIADIC_GENERATE(m) m(1) m(2) m(3) m(4) m(5)
 
 #endif // !defined(ASIO_HAS_VARIADIC_TEMPLATES)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/wait_handler.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/wait_handler.hpp
index 542060d..29bcfd7 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/wait_handler.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/wait_handler.hpp
@@ -2,7 +2,7 @@
 // detail/wait_handler.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -21,7 +21,7 @@
 #include "asio/detail/handler_invoke_helpers.hpp"
 #include "asio/detail/memory.hpp"
 #include "asio/detail/wait_op.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -50,7 +50,7 @@ public:
     ptr p = { asio::detail::addressof(h->handler_), h, h };
     handler_work<Handler> w(h->handler_);
 
-    ASIO_HANDLER_COMPLETION((h));
+    ASIO_HANDLER_COMPLETION((*h));
 
     // Make a copy of the handler so that the memory can be deallocated before
     // the upcall is made. Even if we're not about to make an upcall, a
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/wait_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/wait_op.hpp
index a03d108..68bb86f 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/wait_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/wait_op.hpp
@@ -2,7 +2,7 @@
 // detail/wait_op.hpp
 // ~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_event.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_event.hpp
index f4170b9..aa04fd5 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_event.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_event.hpp
@@ -2,7 +2,7 @@
 // detail/win_event.hpp
 // ~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -101,12 +101,37 @@ public:
     {
       state_ += 2;
       lock.unlock();
+#if defined(ASIO_WINDOWS_APP)
+      ::WaitForMultipleObjectsEx(2, events_, false, INFINITE, false);
+#else // defined(ASIO_WINDOWS_APP)
       ::WaitForMultipleObjects(2, events_, false, INFINITE);
+#endif // defined(ASIO_WINDOWS_APP)
       lock.lock();
       state_ -= 2;
     }
   }
 
+  // Timed wait for the event to become signalled.
+  template <typename Lock>
+  bool wait_for_usec(Lock& lock, long usec)
+  {
+    ASIO_ASSERT(lock.locked());
+    if ((state_ & 1) == 0)
+    {
+      state_ += 2;
+      lock.unlock();
+      DWORD msec = usec > 0 ? (usec < 1000 ? 1 : usec / 1000) : 0;
+#if defined(ASIO_WINDOWS_APP)
+      ::WaitForMultipleObjectsEx(2, events_, false, msec, false);
+#else // defined(ASIO_WINDOWS_APP)
+      ::WaitForMultipleObjects(2, events_, false, msec);
+#endif // defined(ASIO_WINDOWS_APP)
+      lock.lock();
+      state_ -= 2;
+    }
+    return (state_ & 1) != 0;
+  }
+
 private:
   HANDLE events_[2];
   std::size_t state_;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_fd_set_adapter.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_fd_set_adapter.hpp
index 4a05ce0..7d288f6 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_fd_set_adapter.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_fd_set_adapter.hpp
@@ -2,7 +2,7 @@
 // detail/win_fd_set_adapter.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_fenced_block.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_fenced_block.hpp
index c0b3133..42846ca 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_fenced_block.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_fenced_block.hpp
@@ -2,7 +2,7 @@
 // detail/win_fenced_block.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_global.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_global.hpp
index 8dd1939..92ebdad 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_global.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_global.hpp
@@ -2,7 +2,7 @@
 // detail/win_global.hpp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_handle_read_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_handle_read_op.hpp
index 7753964..c3ff79b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_handle_read_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_handle_read_op.hpp
@@ -2,7 +2,7 @@
 // detail/win_iocp_handle_read_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -60,7 +60,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
     if (owner)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_handle_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_handle_service.hpp
index 65d7f1a..a1d07bd 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_handle_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_handle_service.hpp
@@ -2,7 +2,7 @@
 // detail/win_iocp_handle_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -21,7 +21,7 @@
 #if defined(ASIO_HAS_IOCP)
 
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/detail/buffer_sequence_adapter.hpp"
 #include "asio/detail/cstdint.hpp"
 #include "asio/detail/handler_alloc_helpers.hpp"
@@ -30,14 +30,15 @@
 #include "asio/detail/operation.hpp"
 #include "asio/detail/win_iocp_handle_read_op.hpp"
 #include "asio/detail/win_iocp_handle_write_op.hpp"
-#include "asio/detail/win_iocp_io_service.hpp"
+#include "asio/detail/win_iocp_io_context.hpp"
 
 #include "asio/detail/push_options.hpp"
 
 namespace asio {
 namespace detail {
 
-class win_iocp_handle_service
+class win_iocp_handle_service :
+  public service_base<win_iocp_handle_service>
 {
 public:
   // The native type of a stream handle.
@@ -74,10 +75,10 @@ public:
     implementation_type* prev_;
   };
 
-  ASIO_DECL win_iocp_handle_service(asio::io_service& io_service);
+  ASIO_DECL win_iocp_handle_service(asio::io_context& io_context);
 
   // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
+  ASIO_DECL void shutdown();
 
   // Construct a new handle implementation.
   ASIO_DECL void construct(implementation_type& impl);
@@ -151,7 +152,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(buffers, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "handle", &impl, "async_write_some"));
+    ASIO_HANDLER_CREATION((iocp_service_.context(), *p.p, "handle", &impl,
+          reinterpret_cast<uintmax_t>(impl.handle_), "async_write_some"));
 
     start_write_op(impl, 0,
         buffer_sequence_adapter<asio::const_buffer,
@@ -171,7 +173,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(buffers, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "handle", &impl, "async_write_some_at"));
+    ASIO_HANDLER_CREATION((iocp_service_.context(), *p.p, "handle", &impl,
+          reinterpret_cast<uintmax_t>(impl.handle_), "async_write_some_at"));
 
     start_write_op(impl, offset,
         buffer_sequence_adapter<asio::const_buffer,
@@ -211,7 +214,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(buffers, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "handle", &impl, "async_read_some"));
+    ASIO_HANDLER_CREATION((iocp_service_.context(), *p.p, "handle", &impl,
+          reinterpret_cast<uintmax_t>(impl.handle_), "async_read_some"));
 
     start_read_op(impl, 0,
         buffer_sequence_adapter<asio::mutable_buffer,
@@ -232,7 +236,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(buffers, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "handle", &impl, "async_read_some_at"));
+    ASIO_HANDLER_CREATION((iocp_service_.context(), *p.p, "handle", &impl,
+          reinterpret_cast<uintmax_t>(impl.handle_), "async_read_some_at"));
 
     start_read_op(impl, offset,
         buffer_sequence_adapter<asio::mutable_buffer,
@@ -295,7 +300,7 @@ private:
 
   // The IOCP service used for running asynchronous operations and dispatching
   // handlers.
-  win_iocp_io_service& iocp_service_;
+  win_iocp_io_context& iocp_service_;
 
   // Mutex to protect access to the linked list of implementations.
   mutex mutex_;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_handle_write_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_handle_write_op.hpp
index eb9f41c..36019c8 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_handle_write_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_handle_write_op.hpp
@@ -2,7 +2,7 @@
 // detail/win_iocp_handle_write_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -56,7 +56,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
     if (owner)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_io_context.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_io_context.hpp
new file mode 100644
index 0000000..8b6803d
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_io_context.hpp
@@ -0,0 +1,328 @@
+//
+// detail/win_iocp_io_context.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_DETAIL_WIN_IOCP_IO_CONTEXT_HPP
+#define ASIO_DETAIL_WIN_IOCP_IO_CONTEXT_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+
+#if defined(ASIO_HAS_IOCP)
+
+#include "asio/detail/limits.hpp"
+#include "asio/detail/mutex.hpp"
+#include "asio/detail/op_queue.hpp"
+#include "asio/detail/scoped_ptr.hpp"
+#include "asio/detail/socket_types.hpp"
+#include "asio/detail/thread.hpp"
+#include "asio/detail/thread_context.hpp"
+#include "asio/detail/timer_queue_base.hpp"
+#include "asio/detail/timer_queue_set.hpp"
+#include "asio/detail/wait_op.hpp"
+#include "asio/detail/win_iocp_operation.hpp"
+#include "asio/detail/win_iocp_thread_info.hpp"
+#include "asio/execution_context.hpp"
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+namespace detail {
+
+class wait_op;
+
+class win_iocp_io_context
+  : public execution_context_service_base<win_iocp_io_context>,
+    public thread_context
+{
+public:
+  // Constructor. Specifies a concurrency hint that is passed through to the
+  // underlying I/O completion port.
+  ASIO_DECL win_iocp_io_context(asio::execution_context& ctx,
+      int concurrency_hint = -1);
+
+  // Destroy all user-defined handler objects owned by the service.
+  ASIO_DECL void shutdown();
+
+  // Initialise the task. Nothing to do here.
+  void init_task()
+  {
+  }
+
+  // Register a handle with the IO completion port.
+  ASIO_DECL asio::error_code register_handle(
+      HANDLE handle, asio::error_code& ec);
+
+  // Run the event loop until stopped or no more work.
+  ASIO_DECL size_t run(asio::error_code& ec);
+
+  // Run until stopped or one operation is performed.
+  ASIO_DECL size_t run_one(asio::error_code& ec);
+
+  // Run until timeout, interrupted, or one operation is performed.
+  ASIO_DECL size_t wait_one(long usec, asio::error_code& ec);
+
+  // Poll for operations without blocking.
+  ASIO_DECL size_t poll(asio::error_code& ec);
+
+  // Poll for one operation without blocking.
+  ASIO_DECL size_t poll_one(asio::error_code& ec);
+
+  // Stop the event processing loop.
+  ASIO_DECL void stop();
+
+  // Determine whether the io_context is stopped.
+  bool stopped() const
+  {
+    return ::InterlockedExchangeAdd(&stopped_, 0) != 0;
+  }
+
+  // Restart in preparation for a subsequent run invocation.
+  void restart()
+  {
+    ::InterlockedExchange(&stopped_, 0);
+  }
+
+  // Notify that some work has started.
+  void work_started()
+  {
+    ::InterlockedIncrement(&outstanding_work_);
+  }
+
+  // Notify that some work has finished.
+  void work_finished()
+  {
+    if (::InterlockedDecrement(&outstanding_work_) == 0)
+      stop();
+  }
+
+  // Return whether a handler can be dispatched immediately.
+  bool can_dispatch()
+  {
+    return thread_call_stack::contains(this) != 0;
+  }
+
+  // Request invocation of the given operation and return immediately. Assumes
+  // that work_started() has not yet been called for the operation.
+  void post_immediate_completion(win_iocp_operation* op, bool)
+  {
+    work_started();
+    post_deferred_completion(op);
+  }
+
+  // Request invocation of the given operation and return immediately. Assumes
+  // that work_started() was previously called for the operation.
+  ASIO_DECL void post_deferred_completion(win_iocp_operation* op);
+
+  // Request invocation of the given operation and return immediately. Assumes
+  // that work_started() was previously called for the operations.
+  ASIO_DECL void post_deferred_completions(
+      op_queue<win_iocp_operation>& ops);
+
+  // Request invocation of the given operation using the thread-private queue
+  // and return immediately. Assumes that work_started() has not yet been
+  // called for the operation.
+  void post_private_immediate_completion(win_iocp_operation* op)
+  {
+    post_immediate_completion(op, false);
+  }
+
+  // Request invocation of the given operation using the thread-private queue
+  // and return immediately. Assumes that work_started() was previously called
+  // for the operation.
+  void post_private_deferred_completion(win_iocp_operation* op)
+  {
+    post_deferred_completion(op);
+  }
+
+  // Enqueue the given operation following a failed attempt to dispatch the
+  // operation for immediate invocation.
+  void do_dispatch(operation* op)
+  {
+    post_immediate_completion(op, false);
+  }
+
+  // Process unfinished operations as part of a shutdown operation. Assumes
+  // that work_started() was previously called for the operations.
+  ASIO_DECL void abandon_operations(op_queue<operation>& ops);
+
+  // Called after starting an overlapped I/O operation that did not complete
+  // immediately. The caller must have already called work_started() prior to
+  // starting the operation.
+  ASIO_DECL void on_pending(win_iocp_operation* op);
+
+  // Called after starting an overlapped I/O operation that completed
+  // immediately. The caller must have already called work_started() prior to
+  // starting the operation.
+  ASIO_DECL void on_completion(win_iocp_operation* op,
+      DWORD last_error = 0, DWORD bytes_transferred = 0);
+
+  // Called after starting an overlapped I/O operation that completed
+  // immediately. The caller must have already called work_started() prior to
+  // starting the operation.
+  ASIO_DECL void on_completion(win_iocp_operation* op,
+      const asio::error_code& ec, DWORD bytes_transferred = 0);
+
+  // Add a new timer queue to the service.
+  template <typename Time_Traits>
+  void add_timer_queue(timer_queue<Time_Traits>& timer_queue);
+
+  // Remove a timer queue from the service.
+  template <typename Time_Traits>
+  void remove_timer_queue(timer_queue<Time_Traits>& timer_queue);
+
+  // Schedule a new operation in the given timer queue to expire at the
+  // specified absolute time.
+  template <typename Time_Traits>
+  void schedule_timer(timer_queue<Time_Traits>& queue,
+      const typename Time_Traits::time_type& time,
+      typename timer_queue<Time_Traits>::per_timer_data& timer, wait_op* op);
+
+  // Cancel the timer associated with the given token. Returns the number of
+  // handlers that have been posted or dispatched.
+  template <typename Time_Traits>
+  std::size_t cancel_timer(timer_queue<Time_Traits>& queue,
+      typename timer_queue<Time_Traits>::per_timer_data& timer,
+      std::size_t max_cancelled = (std::numeric_limits<std::size_t>::max)());
+
+  // Move the timer operations associated with the given timer.
+  template <typename Time_Traits>
+  void move_timer(timer_queue<Time_Traits>& queue,
+      typename timer_queue<Time_Traits>::per_timer_data& to,
+      typename timer_queue<Time_Traits>::per_timer_data& from);
+
+  // Get the concurrency hint that was used to initialise the io_context.
+  int concurrency_hint() const
+  {
+    return concurrency_hint_;
+  }
+
+private:
+#if defined(WINVER) && (WINVER < 0x0500)
+  typedef DWORD dword_ptr_t;
+  typedef ULONG ulong_ptr_t;
+#else // defined(WINVER) && (WINVER < 0x0500)
+  typedef DWORD_PTR dword_ptr_t;
+  typedef ULONG_PTR ulong_ptr_t;
+#endif // defined(WINVER) && (WINVER < 0x0500)
+
+  // Dequeues at most one operation from the I/O completion port, and then
+  // executes it. Returns the number of operations that were dequeued (i.e.
+  // either 0 or 1).
+  ASIO_DECL size_t do_one(DWORD msec, asio::error_code& ec);
+
+  // Helper to calculate the GetQueuedCompletionStatus timeout.
+  ASIO_DECL static DWORD get_gqcs_timeout();
+
+  // Helper function to add a new timer queue.
+  ASIO_DECL void do_add_timer_queue(timer_queue_base& queue);
+
+  // Helper function to remove a timer queue.
+  ASIO_DECL void do_remove_timer_queue(timer_queue_base& queue);
+
+  // Called to recalculate and update the timeout.
+  ASIO_DECL void update_timeout();
+
+  // Helper class to call work_finished() on block exit.
+  struct work_finished_on_block_exit;
+
+  // Helper class for managing a HANDLE.
+  struct auto_handle
+  {
+    HANDLE handle;
+    auto_handle() : handle(0) {}
+    ~auto_handle() { if (handle) ::CloseHandle(handle); }
+  };
+
+  // The IO completion port used for queueing operations.
+  auto_handle iocp_;
+
+  // The count of unfinished work.
+  long outstanding_work_;
+
+  // Flag to indicate whether the event loop has been stopped.
+  mutable long stopped_;
+
+  // Flag to indicate whether there is an in-flight stop event. Every event
+  // posted using PostQueuedCompletionStatus consumes non-paged pool, so to
+  // avoid exhausting this resouce we limit the number of outstanding events.
+  long stop_event_posted_;
+
+  // Flag to indicate whether the service has been shut down.
+  long shutdown_;
+
+  enum
+  {
+    // Timeout to use with GetQueuedCompletionStatus on older versions of
+    // Windows. Some versions of windows have a "bug" where a call to
+    // GetQueuedCompletionStatus can appear stuck even though there are events
+    // waiting on the queue. Using a timeout helps to work around the issue.
+    default_gqcs_timeout = 500,
+
+    // Maximum waitable timer timeout, in milliseconds.
+    max_timeout_msec = 5 * 60 * 1000,
+
+    // Maximum waitable timer timeout, in microseconds.
+    max_timeout_usec = max_timeout_msec * 1000,
+
+    // Completion key value used to wake up a thread to dispatch timers or
+    // completed operations.
+    wake_for_dispatch = 1,
+
+    // Completion key value to indicate that an operation has posted with the
+    // original last_error and bytes_transferred values stored in the fields of
+    // the OVERLAPPED structure.
+    overlapped_contains_result = 2
+  };
+
+  // Timeout to use with GetQueuedCompletionStatus.
+  const DWORD gqcs_timeout_;
+
+  // Function object for processing timeouts in a background thread.
+  struct timer_thread_function;
+  friend struct timer_thread_function;
+
+  // Background thread used for processing timeouts.
+  scoped_ptr<thread> timer_thread_;
+
+  // A waitable timer object used for waiting for timeouts.
+  auto_handle waitable_timer_;
+
+  // Non-zero if timers or completed operations need to be dispatched.
+  long dispatch_required_;
+
+  // Mutex for protecting access to the timer queues and completed operations.
+  mutex dispatch_mutex_;
+
+  // The timer queues.
+  timer_queue_set timer_queues_;
+
+  // The operations that are ready to dispatch.
+  op_queue<win_iocp_operation> completed_ops_;
+
+  // The concurrency hint used to initialise the io_context.
+  const int concurrency_hint_;
+};
+
+} // namespace detail
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#include "asio/detail/impl/win_iocp_io_context.hpp"
+#if defined(ASIO_HEADER_ONLY)
+# include "asio/detail/impl/win_iocp_io_context.ipp"
+#endif // defined(ASIO_HEADER_ONLY)
+
+#endif // defined(ASIO_HAS_IOCP)
+
+#endif // ASIO_DETAIL_WIN_IOCP_IO_CONTEXT_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_io_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_io_service.hpp
deleted file mode 100644
index cb69623..0000000
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_io_service.hpp
+++ /dev/null
@@ -1,316 +0,0 @@
-//
-// detail/win_iocp_io_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_IOCP_IO_SERVICE_HPP
-#define ASIO_DETAIL_WIN_IOCP_IO_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/detail/limits.hpp"
-#include "asio/detail/mutex.hpp"
-#include "asio/detail/op_queue.hpp"
-#include "asio/detail/scoped_ptr.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/thread.hpp"
-#include "asio/detail/thread_context.hpp"
-#include "asio/detail/timer_queue_base.hpp"
-#include "asio/detail/timer_queue_set.hpp"
-#include "asio/detail/wait_op.hpp"
-#include "asio/detail/win_iocp_operation.hpp"
-#include "asio/detail/win_iocp_thread_info.hpp"
-#include "asio/execution_context.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class wait_op;
-
-class win_iocp_io_service
-  : public execution_context_service_base<win_iocp_io_service>,
-    public thread_context
-{
-public:
-  // Constructor. Specifies a concurrency hint that is passed through to the
-  // underlying I/O completion port.
-  ASIO_DECL win_iocp_io_service(asio::execution_context& ctx,
-      size_t concurrency_hint = 0);
-
-  // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
-
-  // Initialise the task. Nothing to do here.
-  void init_task()
-  {
-  }
-
-  // Register a handle with the IO completion port.
-  ASIO_DECL asio::error_code register_handle(
-      HANDLE handle, asio::error_code& ec);
-
-  // Run the event loop until stopped or no more work.
-  ASIO_DECL size_t run(asio::error_code& ec);
-
-  // Run until stopped or one operation is performed.
-  ASIO_DECL size_t run_one(asio::error_code& ec);
-
-  // Poll for operations without blocking.
-  ASIO_DECL size_t poll(asio::error_code& ec);
-
-  // Poll for one operation without blocking.
-  ASIO_DECL size_t poll_one(asio::error_code& ec);
-
-  // Stop the event processing loop.
-  ASIO_DECL void stop();
-
-  // Determine whether the io_service is stopped.
-  bool stopped() const
-  {
-    return ::InterlockedExchangeAdd(&stopped_, 0) != 0;
-  }
-
-  // Restart in preparation for a subsequent run invocation.
-  void restart()
-  {
-    ::InterlockedExchange(&stopped_, 0);
-  }
-
-  // Notify that some work has started.
-  void work_started()
-  {
-    ::InterlockedIncrement(&outstanding_work_);
-  }
-
-  // Notify that some work has finished.
-  void work_finished()
-  {
-    if (::InterlockedDecrement(&outstanding_work_) == 0)
-      stop();
-  }
-
-  // Return whether a handler can be dispatched immediately.
-  bool can_dispatch()
-  {
-    return thread_call_stack::contains(this) != 0;
-  }
-
-  // Request invocation of the given operation and return immediately. Assumes
-  // that work_started() has not yet been called for the operation.
-  void post_immediate_completion(win_iocp_operation* op, bool)
-  {
-    work_started();
-    post_deferred_completion(op);
-  }
-
-  // Request invocation of the given operation and return immediately. Assumes
-  // that work_started() was previously called for the operation.
-  ASIO_DECL void post_deferred_completion(win_iocp_operation* op);
-
-  // Request invocation of the given operation and return immediately. Assumes
-  // that work_started() was previously called for the operations.
-  ASIO_DECL void post_deferred_completions(
-      op_queue<win_iocp_operation>& ops);
-
-  // Request invocation of the given operation using the thread-private queue
-  // and return immediately. Assumes that work_started() has not yet been
-  // called for the operation.
-  void post_private_immediate_completion(win_iocp_operation* op)
-  {
-    post_immediate_completion(op, false);
-  }
-
-  // Request invocation of the given operation using the thread-private queue
-  // and return immediately. Assumes that work_started() was previously called
-  // for the operation.
-  void post_private_deferred_completion(win_iocp_operation* op)
-  {
-    post_deferred_completion(op);
-  }
-
-  // Enqueue the given operation following a failed attempt to dispatch the
-  // operation for immediate invocation.
-  void do_dispatch(operation* op)
-  {
-    post_immediate_completion(op, false);
-  }
-
-  // Process unfinished operations as part of a shutdown_service operation.
-  // Assumes that work_started() was previously called for the operations.
-  ASIO_DECL void abandon_operations(op_queue<operation>& ops);
-
-  // Called after starting an overlapped I/O operation that did not complete
-  // immediately. The caller must have already called work_started() prior to
-  // starting the operation.
-  ASIO_DECL void on_pending(win_iocp_operation* op);
-
-  // Called after starting an overlapped I/O operation that completed
-  // immediately. The caller must have already called work_started() prior to
-  // starting the operation.
-  ASIO_DECL void on_completion(win_iocp_operation* op,
-      DWORD last_error = 0, DWORD bytes_transferred = 0);
-
-  // Called after starting an overlapped I/O operation that completed
-  // immediately. The caller must have already called work_started() prior to
-  // starting the operation.
-  ASIO_DECL void on_completion(win_iocp_operation* op,
-      const asio::error_code& ec, DWORD bytes_transferred = 0);
-
-  // Add a new timer queue to the service.
-  template <typename Time_Traits>
-  void add_timer_queue(timer_queue<Time_Traits>& timer_queue);
-
-  // Remove a timer queue from the service.
-  template <typename Time_Traits>
-  void remove_timer_queue(timer_queue<Time_Traits>& timer_queue);
-
-  // Schedule a new operation in the given timer queue to expire at the
-  // specified absolute time.
-  template <typename Time_Traits>
-  void schedule_timer(timer_queue<Time_Traits>& queue,
-      const typename Time_Traits::time_type& time,
-      typename timer_queue<Time_Traits>::per_timer_data& timer, wait_op* op);
-
-  // Cancel the timer associated with the given token. Returns the number of
-  // handlers that have been posted or dispatched.
-  template <typename Time_Traits>
-  std::size_t cancel_timer(timer_queue<Time_Traits>& queue,
-      typename timer_queue<Time_Traits>::per_timer_data& timer,
-      std::size_t max_cancelled = (std::numeric_limits<std::size_t>::max)());
-
-  // Move the timer operations associated with the given timer.
-  template <typename Time_Traits>
-  void move_timer(timer_queue<Time_Traits>& queue,
-      typename timer_queue<Time_Traits>::per_timer_data& to,
-      typename timer_queue<Time_Traits>::per_timer_data& from);
-
-private:
-#if defined(WINVER) && (WINVER < 0x0500)
-  typedef DWORD dword_ptr_t;
-  typedef ULONG ulong_ptr_t;
-#else // defined(WINVER) && (WINVER < 0x0500)
-  typedef DWORD_PTR dword_ptr_t;
-  typedef ULONG_PTR ulong_ptr_t;
-#endif // defined(WINVER) && (WINVER < 0x0500)
-
-  // Dequeues at most one operation from the I/O completion port, and then
-  // executes it. Returns the number of operations that were dequeued (i.e.
-  // either 0 or 1).
-  ASIO_DECL size_t do_one(bool block, asio::error_code& ec);
-
-  // Helper to calculate the GetQueuedCompletionStatus timeout.
-  ASIO_DECL static DWORD get_gqcs_timeout();
-
-  // Helper function to add a new timer queue.
-  ASIO_DECL void do_add_timer_queue(timer_queue_base& queue);
-
-  // Helper function to remove a timer queue.
-  ASIO_DECL void do_remove_timer_queue(timer_queue_base& queue);
-
-  // Called to recalculate and update the timeout.
-  ASIO_DECL void update_timeout();
-
-  // Helper class to call work_finished() on block exit.
-  struct work_finished_on_block_exit;
-
-  // Helper class for managing a HANDLE.
-  struct auto_handle
-  {
-    HANDLE handle;
-    auto_handle() : handle(0) {}
-    ~auto_handle() { if (handle) ::CloseHandle(handle); }
-  };
-
-  // The IO completion port used for queueing operations.
-  auto_handle iocp_;
-
-  // The count of unfinished work.
-  long outstanding_work_;
-
-  // Flag to indicate whether the event loop has been stopped.
-  mutable long stopped_;
-
-  // Flag to indicate whether there is an in-flight stop event. Every event
-  // posted using PostQueuedCompletionStatus consumes non-paged pool, so to
-  // avoid exhausting this resouce we limit the number of outstanding events.
-  long stop_event_posted_;
-
-  // Flag to indicate whether the service has been shut down.
-  long shutdown_;
-
-  enum
-  {
-    // Timeout to use with GetQueuedCompletionStatus on older versions of
-    // Windows. Some versions of windows have a "bug" where a call to
-    // GetQueuedCompletionStatus can appear stuck even though there are events
-    // waiting on the queue. Using a timeout helps to work around the issue.
-    default_gqcs_timeout = 500,
-
-    // Maximum waitable timer timeout, in milliseconds.
-    max_timeout_msec = 5 * 60 * 1000,
-
-    // Maximum waitable timer timeout, in microseconds.
-    max_timeout_usec = max_timeout_msec * 1000,
-
-    // Completion key value used to wake up a thread to dispatch timers or
-    // completed operations.
-    wake_for_dispatch = 1,
-
-    // Completion key value to indicate that an operation has posted with the
-    // original last_error and bytes_transferred values stored in the fields of
-    // the OVERLAPPED structure.
-    overlapped_contains_result = 2
-  };
-
-  // Timeout to use with GetQueuedCompletionStatus.
-  const DWORD gqcs_timeout_;
-
-  // Function object for processing timeouts in a background thread.
-  struct timer_thread_function;
-  friend struct timer_thread_function;
-
-  // Background thread used for processing timeouts.
-  scoped_ptr<thread> timer_thread_;
-
-  // A waitable timer object used for waiting for timeouts.
-  auto_handle waitable_timer_;
-
-  // Non-zero if timers or completed operations need to be dispatched.
-  long dispatch_required_;
-
-  // Mutex for protecting access to the timer queues and completed operations.
-  mutex dispatch_mutex_;
-
-  // The timer queues.
-  timer_queue_set timer_queues_;
-
-  // The operations that are ready to dispatch.
-  op_queue<win_iocp_operation> completed_ops_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/detail/impl/win_iocp_io_service.hpp"
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/win_iocp_io_service.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_WIN_IOCP_IO_SERVICE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_null_buffers_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_null_buffers_op.hpp
index 5e489d4..f9e296d 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_null_buffers_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_null_buffers_op.hpp
@@ -2,7 +2,7 @@
 // detail/win_iocp_null_buffers_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -50,9 +50,9 @@ public:
     handler_work<Handler>::start(handler_);
   }
 
-  static bool do_perform(reactor_op*)
+  static status do_perform(reactor_op*)
   {
-    return true;
+    return done;
   }
 
   static void do_complete(void* owner, operation* base,
@@ -66,7 +66,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
     // The reactor may have stored a result in the operation object.
     if (o->ec_)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_operation.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_operation.hpp
index 95a6877..9f888b1 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_operation.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_operation.hpp
@@ -2,7 +2,7 @@
 // detail/win_iocp_operation.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -29,7 +29,7 @@
 namespace asio {
 namespace detail {
 
-class win_iocp_io_service;
+class win_iocp_io_context;
 
 // Base class for all operations. A function pointer is used instead of virtual
 // functions to avoid the associated overhead.
@@ -80,7 +80,7 @@ protected:
 
 private:
   friend class op_queue_access;
-  friend class win_iocp_io_service;
+  friend class win_iocp_io_context;
   win_iocp_operation* next_;
   func_type func_;
   long ready_;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_overlapped_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_overlapped_op.hpp
index a487d46..fde9a92 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_overlapped_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_overlapped_op.hpp
@@ -2,7 +2,7 @@
 // detail/win_iocp_overlapped_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -53,7 +53,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
     // Make a copy of the handler so that the memory can be deallocated before
     // the upcall is made. Even if we're not about to make an upcall, a
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_overlapped_ptr.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_overlapped_ptr.hpp
index 7816880..22025fd 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_overlapped_ptr.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_overlapped_ptr.hpp
@@ -2,7 +2,7 @@
 // detail/win_iocp_overlapped_ptr.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -19,12 +19,12 @@
 
 #if defined(ASIO_HAS_IOCP)
 
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/detail/handler_alloc_helpers.hpp"
 #include "asio/detail/memory.hpp"
 #include "asio/detail/noncopyable.hpp"
 #include "asio/detail/win_iocp_overlapped_op.hpp"
-#include "asio/detail/win_iocp_io_service.hpp"
+#include "asio/detail/win_iocp_io_context.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -46,11 +46,11 @@ public:
   // Construct an win_iocp_overlapped_ptr to contain the specified handler.
   template <typename Handler>
   explicit win_iocp_overlapped_ptr(
-      asio::io_service& io_service, ASIO_MOVE_ARG(Handler) handler)
+      asio::io_context& io_context, ASIO_MOVE_ARG(Handler) handler)
     : ptr_(0),
       iocp_service_(0)
   {
-    this->reset(io_service, ASIO_MOVE_CAST(Handler)(handler));
+    this->reset(io_context, ASIO_MOVE_CAST(Handler)(handler));
   }
 
   // Destructor automatically frees the OVERLAPPED object unless released.
@@ -74,21 +74,21 @@ public:
   // Reset to contain the specified handler, freeing any current OVERLAPPED
   // object.
   template <typename Handler>
-  void reset(asio::io_service& io_service, Handler handler)
+  void reset(asio::io_context& io_context, Handler handler)
   {
     typedef win_iocp_overlapped_op<Handler> op;
     typename op::ptr p = { asio::detail::addressof(handler),
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(handler);
 
-    ASIO_HANDLER_CREATION((p.p, "io_service",
-          &io_service.impl_, "overlapped"));
+    ASIO_HANDLER_CREATION((io_context, *p.p,
+          "io_context", &io_context.impl_, 0, "overlapped"));
 
-    io_service.impl_.work_started();
+    io_context.impl_.work_started();
     reset();
     ptr_ = p.p;
     p.v = p.p = 0;
-    iocp_service_ = &io_service.impl_;
+    iocp_service_ = &io_context.impl_;
   }
 
   // Get the contained OVERLAPPED object.
@@ -130,7 +130,7 @@ public:
 
 private:
   win_iocp_operation* ptr_;
-  win_iocp_io_service* iocp_service_;
+  win_iocp_io_context* iocp_service_;
 };
 
 } // namespace detail
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_serial_port_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_serial_port_service.hpp
index 2bfdcc5..5385646 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_serial_port_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_serial_port_service.hpp
@@ -2,7 +2,7 @@
 // detail/win_iocp_serial_port_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -22,7 +22,7 @@
 
 #include <string>
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/detail/win_iocp_handle_service.hpp"
 
 #include "asio/detail/push_options.hpp"
@@ -31,7 +31,8 @@ namespace asio {
 namespace detail {
 
 // Extend win_iocp_handle_service to provide serial port support.
-class win_iocp_serial_port_service
+class win_iocp_serial_port_service :
+  public service_base<win_iocp_serial_port_service>
 {
 public:
   // The native type of a serial port.
@@ -42,10 +43,10 @@ public:
 
   // Constructor.
   ASIO_DECL win_iocp_serial_port_service(
-      asio::io_service& io_service);
+      asio::io_context& io_context);
 
   // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
+  ASIO_DECL void shutdown();
 
   // Construct a new serial port implementation.
   void construct(implementation_type& impl)
@@ -184,8 +185,8 @@ private:
   static asio::error_code store_option(const void* option,
       ::DCB& storage, asio::error_code& ec)
   {
-    return static_cast<const SettableSerialPortOption*>(option)->store(
-        storage, ec);
+    static_cast<const SettableSerialPortOption*>(option)->store(storage, ec);
+    return ec;
   }
 
   // Helper function to set a serial port option.
@@ -202,7 +203,8 @@ private:
   static asio::error_code load_option(void* option,
       const ::DCB& storage, asio::error_code& ec)
   {
-    return static_cast<GettableSerialPortOption*>(option)->load(storage, ec);
+    static_cast<GettableSerialPortOption*>(option)->load(storage, ec);
+    return ec;
   }
 
   // Helper function to get a serial port option.
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_accept_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_accept_op.hpp
index d14c617..937f4c0 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_accept_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_accept_op.hpp
@@ -2,7 +2,7 @@
 // detail/win_iocp_socket_accept_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -122,7 +122,7 @@ public:
         *o->peer_endpoint_ = peer_endpoint;
     }
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
     // Make a copy of the handler so that the memory can be deallocated before
     // the upcall is made. Even if we're not about to make an upcall, a
@@ -157,6 +157,136 @@ private:
   Handler handler_;
 };
 
+#if defined(ASIO_HAS_MOVE)
+
+template <typename Protocol, typename Handler>
+class win_iocp_socket_move_accept_op : public operation
+{
+public:
+  ASIO_DEFINE_HANDLER_PTR(win_iocp_socket_move_accept_op);
+
+  win_iocp_socket_move_accept_op(
+      win_iocp_socket_service_base& socket_service, socket_type socket,
+      const Protocol& protocol, asio::io_context& peer_io_context,
+      typename Protocol::endpoint* peer_endpoint,
+      bool enable_connection_aborted, Handler& handler)
+    : operation(&win_iocp_socket_move_accept_op::do_complete),
+      socket_service_(socket_service),
+      socket_(socket),
+      peer_(peer_io_context),
+      protocol_(protocol),
+      peer_endpoint_(peer_endpoint),
+      enable_connection_aborted_(enable_connection_aborted),
+      handler_(ASIO_MOVE_CAST(Handler)(handler))
+  {
+    handler_work<Handler>::start(handler_);
+  }
+
+  socket_holder& new_socket()
+  {
+    return new_socket_;
+  }
+
+  void* output_buffer()
+  {
+    return output_buffer_;
+  }
+
+  DWORD address_length()
+  {
+    return sizeof(sockaddr_storage_type) + 16;
+  }
+
+  static void do_complete(void* owner, operation* base,
+      const asio::error_code& result_ec,
+      std::size_t /*bytes_transferred*/)
+  {
+    asio::error_code ec(result_ec);
+
+    // Take ownership of the operation object.
+    win_iocp_socket_move_accept_op* o(
+        static_cast<win_iocp_socket_move_accept_op*>(base));
+    ptr p = { asio::detail::addressof(o->handler_), o, o };
+    handler_work<Handler> w(o->handler_);
+
+    if (owner)
+    {
+      typename Protocol::endpoint peer_endpoint;
+      std::size_t addr_len = peer_endpoint.capacity();
+      socket_ops::complete_iocp_accept(o->socket_,
+          o->output_buffer(), o->address_length(),
+          peer_endpoint.data(), &addr_len,
+          o->new_socket_.get(), ec);
+
+      // Restart the accept operation if we got the connection_aborted error
+      // and the enable_connection_aborted socket option is not set.
+      if (ec == asio::error::connection_aborted
+          && !o->enable_connection_aborted_)
+      {
+        o->reset();
+        o->socket_service_.restart_accept_op(o->socket_,
+            o->new_socket_, o->protocol_.family(),
+            o->protocol_.type(), o->protocol_.protocol(),
+            o->output_buffer(), o->address_length(), o);
+        p.v = p.p = 0;
+        return;
+      }
+
+      // If the socket was successfully accepted, transfer ownership of the
+      // socket to the peer object.
+      if (!ec)
+      {
+        o->peer_.assign(o->protocol_,
+            typename Protocol::socket::native_handle_type(
+              o->new_socket_.get(), peer_endpoint), ec);
+        if (!ec)
+          o->new_socket_.release();
+      }
+
+      // Pass endpoint back to caller.
+      if (o->peer_endpoint_)
+        *o->peer_endpoint_ = peer_endpoint;
+    }
+
+    ASIO_HANDLER_COMPLETION((*o));
+
+    // Make a copy of the handler so that the memory can be deallocated before
+    // the upcall is made. Even if we're not about to make an upcall, a
+    // sub-object of the handler may be the true owner of the memory associated
+    // with the handler. Consequently, a local copy of the handler is required
+    // to ensure that any owning sub-object remains valid until after we have
+    // deallocated the memory here.
+    detail::move_binder2<Handler,
+      asio::error_code, typename Protocol::socket>
+        handler(0, ASIO_MOVE_CAST(Handler)(o->handler_), ec,
+          ASIO_MOVE_CAST(typename Protocol::socket)(o->peer_));
+    p.h = asio::detail::addressof(handler.handler_);
+    p.reset();
+
+    // Make the upcall if required.
+    if (owner)
+    {
+      fenced_block b(fenced_block::half);
+      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, "..."));
+      w.complete(handler, handler.handler_);
+      ASIO_HANDLER_INVOCATION_END;
+    }
+  }
+
+private:
+  win_iocp_socket_service_base& socket_service_;
+  socket_type socket_;
+  socket_holder new_socket_;
+  typename Protocol::socket peer_;
+  Protocol protocol_;
+  typename Protocol::endpoint* peer_endpoint_;
+  unsigned char output_buffer_[(sizeof(sockaddr_storage_type) + 16) * 2];
+  bool enable_connection_aborted_;
+  Handler handler_;
+};
+
+#endif // defined(ASIO_HAS_MOVE)
+
 } // namespace detail
 } // namespace asio
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_connect_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_connect_op.hpp
index 2f8a516..4edd869 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_connect_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_connect_op.hpp
@@ -2,7 +2,7 @@
 // detail/win_iocp_socket_connect_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -43,12 +43,13 @@ public:
   {
   }
 
-  static bool do_perform(reactor_op* base)
+  static status do_perform(reactor_op* base)
   {
     win_iocp_socket_connect_op_base* o(
         static_cast<win_iocp_socket_connect_op_base*>(base));
 
-    return socket_ops::non_blocking_connect(o->socket_, o->ec_);
+    return socket_ops::non_blocking_connect(
+        o->socket_, o->ec_) ? done : not_done;
   }
 
   socket_type socket_;
@@ -89,7 +90,7 @@ public:
         ec = o->ec_;
     }
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
     // Make a copy of the handler so that the memory can be deallocated before
     // the upcall is made. Even if we're not about to make an upcall, a
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_recv_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_recv_op.hpp
index c25a322..98b0005 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_recv_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_recv_op.hpp
@@ -2,7 +2,7 @@
 // detail/win_iocp_socket_recv_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -63,7 +63,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
     // Check whether buffers are still valid.
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_recvfrom_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_recvfrom_op.hpp
index 0132155..a7af878 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_recvfrom_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_recvfrom_op.hpp
@@ -2,7 +2,7 @@
 // detail/win_iocp_socket_recvfrom_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -70,7 +70,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
     // Check whether buffers are still valid.
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_recvmsg_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_recvmsg_op.hpp
index 718a335..9e5952f 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_recvmsg_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_recvmsg_op.hpp
@@ -2,7 +2,7 @@
 // detail/win_iocp_socket_recvmsg_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -66,7 +66,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
     // Check whether buffers are still valid.
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_send_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_send_op.hpp
index 6ddd63d..15c88a5 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_send_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_send_op.hpp
@@ -2,7 +2,7 @@
 // detail/win_iocp_socket_send_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -61,7 +61,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
     // Check whether buffers are still valid.
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_service.hpp
index 0bb6178..9040f7c 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_service.hpp
@@ -2,7 +2,7 @@
 // detail/win_iocp_socket_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -21,7 +21,7 @@
 
 #include <cstring>
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/socket_base.hpp"
 #include "asio/detail/bind_handler.hpp"
 #include "asio/detail/buffer_sequence_adapter.hpp"
@@ -36,7 +36,7 @@
 #include "asio/detail/socket_holder.hpp"
 #include "asio/detail/socket_ops.hpp"
 #include "asio/detail/socket_types.hpp"
-#include "asio/detail/win_iocp_io_service.hpp"
+#include "asio/detail/win_iocp_io_context.hpp"
 #include "asio/detail/win_iocp_null_buffers_op.hpp"
 #include "asio/detail/win_iocp_socket_accept_op.hpp"
 #include "asio/detail/win_iocp_socket_connect_op.hpp"
@@ -50,7 +50,9 @@ namespace asio {
 namespace detail {
 
 template <typename Protocol>
-class win_iocp_socket_service : public win_iocp_socket_service_base
+class win_iocp_socket_service :
+  public service_base<win_iocp_socket_service<Protocol> >,
+  public win_iocp_socket_service_base
 {
 public:
   // The protocol type.
@@ -127,11 +129,18 @@ public:
   };
 
   // Constructor.
-  win_iocp_socket_service(asio::io_service& io_service)
-    : win_iocp_socket_service_base(io_service)
+  win_iocp_socket_service(asio::io_context& io_context)
+    : service_base<win_iocp_socket_service<Protocol> >(io_context),
+      win_iocp_socket_service_base(io_context)
   {
   }
 
+  // Destroy all user-defined handler objects owned by the service.
+  void shutdown()
+  {
+    this->base_shutdown();
+  }
+
   // Move-construct a new socket implementation.
   void move_construct(implementation_type& impl,
       implementation_type& other_impl)
@@ -277,6 +286,14 @@ public:
     return endpoint;
   }
 
+  // Disable sends or receives on the socket.
+  asio::error_code shutdown(base_implementation_type& impl,
+      socket_base::shutdown_type what, asio::error_code& ec)
+  {
+    socket_ops::shutdown(impl.socket_, what, ec);
+    return ec;
+  }
+
   // Send a datagram to the specified endpoint. Returns the number of bytes
   // sent.
   template <typename ConstBufferSequence>
@@ -298,7 +315,7 @@ public:
       asio::error_code& ec)
   {
     // Wait for socket to become ready.
-    socket_ops::poll_write(impl.socket_, impl.state_, ec);
+    socket_ops::poll_write(impl.socket_, impl.state_, -1, ec);
 
     return 0;
   }
@@ -316,7 +333,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(impl.cancel_token_, buffers, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_send_to"));
+    ASIO_HANDLER_CREATION((io_context_, *p.p, "socket",
+          &impl, impl.socket_, "async_send_to"));
 
     buffer_sequence_adapter<asio::const_buffer,
         ConstBufferSequence> bufs(buffers);
@@ -338,8 +356,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(impl.cancel_token_, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket",
-          &impl, "async_send_to(null_buffers)"));
+    ASIO_HANDLER_CREATION((io_context_, *p.p, "socket",
+          &impl, impl.socket_, "async_send_to(null_buffers)"));
 
     start_reactor_op(impl, select_reactor::write_op, p.p);
     p.v = p.p = 0;
@@ -373,7 +391,7 @@ public:
       socket_base::message_flags, asio::error_code& ec)
   {
     // Wait for socket to become ready.
-    socket_ops::poll_read(impl.socket_, impl.state_, ec);
+    socket_ops::poll_read(impl.socket_, impl.state_, -1, ec);
 
     // Reset endpoint since it can be given no sensible value at this time.
     sender_endpoint = endpoint_type();
@@ -396,7 +414,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(sender_endp, impl.cancel_token_, buffers, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_receive_from"));
+    ASIO_HANDLER_CREATION((io_context_, *p.p, "socket",
+          &impl, impl.socket_, "async_receive_from"));
 
     buffer_sequence_adapter<asio::mutable_buffer,
         MutableBufferSequence> bufs(buffers);
@@ -418,8 +437,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(impl.cancel_token_, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl,
-          "async_receive_from(null_buffers)"));
+    ASIO_HANDLER_CREATION((io_context_, *p.p, "socket",
+          &impl, impl.socket_, "async_receive_from(null_buffers)"));
 
     // Reset endpoint since it can be given no sensible value at this time.
     sender_endpoint = endpoint_type();
@@ -450,13 +469,42 @@ public:
     {
       if (peer_endpoint)
         peer_endpoint->resize(addr_len);
-      if (!peer.assign(impl.protocol_, new_socket.get(), ec))
+      peer.assign(impl.protocol_, new_socket.get(), ec);
+      if (!ec)
         new_socket.release();
     }
 
     return ec;
   }
 
+#if defined(ASIO_HAS_MOVE)
+  // Accept a new connection.
+  typename Protocol::socket accept(implementation_type& impl,
+      io_context* peer_io_context, endpoint_type* peer_endpoint,
+      asio::error_code& ec)
+  {
+    typename Protocol::socket peer(
+        peer_io_context ? *peer_io_context : io_context_);
+
+    std::size_t addr_len = peer_endpoint ? peer_endpoint->capacity() : 0;
+    socket_holder new_socket(socket_ops::sync_accept(impl.socket_,
+          impl.state_, peer_endpoint ? peer_endpoint->data() : 0,
+          peer_endpoint ? &addr_len : 0, ec));
+
+    // On success, assign new connection to peer socket object.
+    if (new_socket.get() != invalid_socket)
+    {
+      if (peer_endpoint)
+        peer_endpoint->resize(addr_len);
+      peer.assign(impl.protocol_, new_socket.get(), ec);
+      if (!ec)
+        new_socket.release();
+    }
+
+    return peer;
+  }
+#endif // defined(ASIO_HAS_MOVE)
+
   // Start an asynchronous accept. The peer and peer_endpoint objects
   // must be valid until the accept's handler is invoked.
   template <typename Socket, typename Handler>
@@ -472,7 +520,8 @@ public:
     p.p = new (p.v) op(*this, impl.socket_, peer, impl.protocol_,
         peer_endpoint, enable_connection_aborted, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_accept"));
+    ASIO_HANDLER_CREATION((io_context_, *p.p, "socket",
+          &impl, impl.socket_, "async_accept"));
 
     start_accept_op(impl, peer.is_open(), p.p->new_socket(),
         impl.protocol_.family(), impl.protocol_.type(),
@@ -481,6 +530,35 @@ public:
     p.v = p.p = 0;
   }
 
+#if defined(ASIO_HAS_MOVE)
+  // Start an asynchronous accept. The peer and peer_endpoint objects
+  // must be valid until the accept's handler is invoked.
+  template <typename Handler>
+  void async_accept(implementation_type& impl,
+      asio::io_context* peer_io_context,
+      endpoint_type* peer_endpoint, Handler& handler)
+  {
+    // Allocate and construct an operation to wrap the handler.
+    typedef win_iocp_socket_move_accept_op<protocol_type, Handler> op;
+    typename op::ptr p = { asio::detail::addressof(handler),
+      op::ptr::allocate(handler), 0 };
+    bool enable_connection_aborted =
+      (impl.state_ & socket_ops::enable_connection_aborted) != 0;
+    p.p = new (p.v) op(*this, impl.socket_, impl.protocol_,
+        peer_io_context ? *peer_io_context : io_context_,
+        peer_endpoint, enable_connection_aborted, handler);
+
+    ASIO_HANDLER_CREATION((io_context_, *p.p, "socket",
+          &impl, impl.socket_, "async_accept"));
+
+    start_accept_op(impl, false, p.p->new_socket(),
+        impl.protocol_.family(), impl.protocol_.type(),
+        impl.protocol_.protocol(), p.p->output_buffer(),
+        p.p->address_length(), p.p);
+    p.v = p.p = 0;
+  }
+#endif // defined(ASIO_HAS_MOVE)
+
   // Connect the socket to the specified endpoint.
   asio::error_code connect(implementation_type& impl,
       const endpoint_type& peer_endpoint, asio::error_code& ec)
@@ -501,7 +579,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(impl.socket_, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_connect"));
+    ASIO_HANDLER_CREATION((io_context_, *p.p, "socket",
+          &impl, impl.socket_, "async_connect"));
 
     start_connect_op(impl, impl.protocol_.family(), impl.protocol_.type(),
         peer_endpoint.data(), static_cast<int>(peer_endpoint.size()), p.p);
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_service_base.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_service_base.hpp
index a7106b1..9f22adc 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_service_base.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_socket_service_base.hpp
@@ -2,7 +2,7 @@
 // detail/win_iocp_socket_service_base.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -20,7 +20,7 @@
 #if defined(ASIO_HAS_IOCP)
 
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/socket_base.hpp"
 #include "asio/detail/bind_handler.hpp"
 #include "asio/detail/buffer_sequence_adapter.hpp"
@@ -35,7 +35,7 @@
 #include "asio/detail/socket_holder.hpp"
 #include "asio/detail/socket_ops.hpp"
 #include "asio/detail/socket_types.hpp"
-#include "asio/detail/win_iocp_io_service.hpp"
+#include "asio/detail/win_iocp_io_context.hpp"
 #include "asio/detail/win_iocp_null_buffers_op.hpp"
 #include "asio/detail/win_iocp_socket_connect_op.hpp"
 #include "asio/detail/win_iocp_socket_send_op.hpp"
@@ -86,10 +86,10 @@ public:
 
   // Constructor.
   ASIO_DECL win_iocp_socket_service_base(
-      asio::io_service& io_service);
+      asio::io_context& io_context);
 
   // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
+  ASIO_DECL void base_shutdown();
 
   // Construct a new socket implementation.
   ASIO_DECL void construct(base_implementation_type& impl);
@@ -180,14 +180,6 @@ public:
     return ec;
   }
 
-  // Disable sends or receives on the socket.
-  asio::error_code shutdown(base_implementation_type& impl,
-      socket_base::shutdown_type what, asio::error_code& ec)
-  {
-    socket_ops::shutdown(impl.socket_, what, ec);
-    return ec;
-  }
-
   // Wait for the socket to become ready to read, ready to write, or to have
   // pending error conditions.
   asio::error_code wait(base_implementation_type& impl,
@@ -196,13 +188,13 @@ public:
     switch (w)
     {
     case socket_base::wait_read:
-      socket_ops::poll_read(impl.socket_, impl.state_, ec);
+      socket_ops::poll_read(impl.socket_, impl.state_, -1, ec);
       break;
     case socket_base::wait_write:
-      socket_ops::poll_write(impl.socket_, impl.state_, ec);
+      socket_ops::poll_write(impl.socket_, impl.state_, -1, ec);
       break;
     case socket_base::wait_error:
-      socket_ops::poll_error(impl.socket_, impl.state_, ec);
+      socket_ops::poll_error(impl.socket_, impl.state_, -1, ec);
       break;
     default:
       ec = asio::error::invalid_argument;
@@ -227,7 +219,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(impl.cancel_token_, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_wait"));
+    ASIO_HANDLER_CREATION((io_context_, *p.p, "socket",
+          &impl, impl.socket_, "async_wait"));
 
     switch (w)
     {
@@ -267,7 +260,7 @@ public:
       socket_base::message_flags, asio::error_code& ec)
   {
     // Wait for socket to become ready.
-    socket_ops::poll_write(impl.socket_, impl.state_, ec);
+    socket_ops::poll_write(impl.socket_, impl.state_, -1, ec);
 
     return 0;
   }
@@ -285,7 +278,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(impl.cancel_token_, buffers, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_send"));
+    ASIO_HANDLER_CREATION((io_context_, *p.p, "socket",
+          &impl, impl.socket_, "async_send"));
 
     buffer_sequence_adapter<asio::const_buffer,
         ConstBufferSequence> bufs(buffers);
@@ -307,8 +301,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(impl.cancel_token_, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket",
-          &impl, "async_send(null_buffers)"));
+    ASIO_HANDLER_CREATION((io_context_, *p.p, "socket",
+          &impl, impl.socket_, "async_send(null_buffers)"));
 
     start_reactor_op(impl, select_reactor::write_op, p.p);
     p.v = p.p = 0;
@@ -332,7 +326,7 @@ public:
       socket_base::message_flags, asio::error_code& ec)
   {
     // Wait for socket to become ready.
-    socket_ops::poll_read(impl.socket_, impl.state_, ec);
+    socket_ops::poll_read(impl.socket_, impl.state_, -1, ec);
 
     return 0;
   }
@@ -350,7 +344,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(impl.state_, impl.cancel_token_, buffers, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_receive"));
+    ASIO_HANDLER_CREATION((io_context_, *p.p, "socket",
+          &impl, impl.socket_, "async_receive"));
 
     buffer_sequence_adapter<asio::mutable_buffer,
         MutableBufferSequence> bufs(buffers);
@@ -372,8 +367,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(impl.cancel_token_, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket",
-          &impl, "async_receive(null_buffers)"));
+    ASIO_HANDLER_CREATION((io_context_, *p.p, "socket",
+          &impl, impl.socket_, "async_receive(null_buffers)"));
 
     start_null_buffers_receive_op(impl, flags, p.p);
     p.v = p.p = 0;
@@ -400,7 +395,7 @@ public:
       socket_base::message_flags& out_flags, asio::error_code& ec)
   {
     // Wait for socket to become ready.
-    socket_ops::poll_read(impl.socket_, impl.state_, ec);
+    socket_ops::poll_read(impl.socket_, impl.state_, -1, ec);
 
     // Clear out_flags, since we cannot give it any other sensible value when
     // performing a null_buffers operation.
@@ -422,8 +417,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(impl.cancel_token_, buffers, out_flags, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket",
-          &impl, "async_receive_with_flags"));
+    ASIO_HANDLER_CREATION((io_context_, *p.p, "socket",
+          &impl, impl.socket_, "async_receive_with_flags"));
 
     buffer_sequence_adapter<asio::mutable_buffer,
         MutableBufferSequence> bufs(buffers);
@@ -444,8 +439,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(impl.cancel_token_, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl,
-          "async_receive_with_flags(null_buffers)"));
+    ASIO_HANDLER_CREATION((io_context_, *p.p, "socket",
+          &impl, impl.socket_, "async_receive_with_flags(null_buffers)"));
 
     // Reset out_flags since it can be given no sensible value at this time.
     out_flags = 0;
@@ -519,7 +514,7 @@ protected:
       base_implementation_type& impl);
 
   // Helper function to get the reactor. If no reactor has been created yet, a
-  // new one is obtained from the io_service and a pointer to it is cached in
+  // new one is obtained from the io_context and a pointer to it is cached in
   // this service.
   ASIO_DECL select_reactor& get_reactor();
 
@@ -545,12 +540,12 @@ protected:
   // - platform SDKs where MSVC's /Wp64 option causes spurious warnings.
   ASIO_DECL void* interlocked_exchange_pointer(void** dest, void* val);
 
-  // The io_service used to obtain the reactor, if required.
-  asio::io_service& io_service_;
+  // The io_context used to obtain the reactor, if required.
+  asio::io_context& io_context_;
 
   // The IOCP service used for running asynchronous operations and dispatching
   // handlers.
-  win_iocp_io_service& iocp_service_;
+  win_iocp_io_context& iocp_service_;
 
   // The reactor used for performing connect operations. This object is created
   // only if needed.
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_thread_info.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_thread_info.hpp
index 2b698d8..ae13dd4 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_thread_info.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_thread_info.hpp
@@ -2,7 +2,7 @@
 // detail/win_iocp_thread_info.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_wait_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_wait_op.hpp
index a996cb2..d5178d0 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_wait_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_iocp_wait_op.hpp
@@ -2,7 +2,7 @@
 // detail/win_iocp_wait_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -50,9 +50,9 @@ public:
     handler_work<Handler>::start(handler_);
   }
 
-  static bool do_perform(reactor_op*)
+  static status do_perform(reactor_op*)
   {
-    return true;
+    return done;
   }
 
   static void do_complete(void* owner, operation* base,
@@ -66,7 +66,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
     // The reactor may have stored a result in the operation object.
     if (o->ec_)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_mutex.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_mutex.hpp
index dd393de..350a02d 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_mutex.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_mutex.hpp
@@ -2,7 +2,7 @@
 // detail/win_mutex.hpp
 // ~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_object_handle_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_object_handle_service.hpp
index 21f9fe8..5960554 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_object_handle_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_object_handle_service.hpp
@@ -2,7 +2,7 @@
 // detail/win_object_handle_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2011 Boris Schaeling (boris@highscore.de)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -24,14 +24,15 @@
 #include "asio/detail/memory.hpp"
 #include "asio/detail/wait_handler.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 
 #include "asio/detail/push_options.hpp"
 
 namespace asio {
 namespace detail {
 
-class win_object_handle_service
+class win_object_handle_service :
+  public service_base<win_object_handle_service>
 {
 public:
   // The native type of an object handle.
@@ -79,10 +80,10 @@ public:
 
   // Constructor.
   ASIO_DECL win_object_handle_service(
-      asio::io_service& io_service);
+      asio::io_context& io_context);
 
   // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
+  ASIO_DECL void shutdown();
 
   // Construct a new handle implementation.
   ASIO_DECL void construct(implementation_type& impl);
@@ -137,7 +138,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(handler);
 
-    ASIO_HANDLER_CREATION((p.p, "object_handle", &impl, "async_wait"));
+    ASIO_HANDLER_CREATION((io_context_.context(), *p.p, "object_handle",
+          &impl, reinterpret_cast<uintmax_t>(impl.wait_handle_), "async_wait"));
 
     start_wait_op(impl, p.p);
     p.v = p.p = 0;
@@ -155,8 +157,8 @@ private:
   static ASIO_DECL VOID CALLBACK wait_callback(
       PVOID param, BOOLEAN timeout);
 
-  // The io_service implementation used to post completions.
-  io_service_impl& io_service_;
+  // The io_context implementation used to post completions.
+  io_context_impl& io_context_;
 
   // Mutex to protect access to internal state.
   mutex mutex_;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_static_mutex.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_static_mutex.hpp
index b4ff6ce..6f0e75b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_static_mutex.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_static_mutex.hpp
@@ -2,7 +2,7 @@
 // detail/win_static_mutex.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_thread.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_thread.hpp
index 20ab263..ab2ba8d 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_thread.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_thread.hpp
@@ -2,7 +2,7 @@
 // detail/win_thread.hpp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,7 +17,9 @@
 
 #include "asio/detail/config.hpp"
 
-#if defined(ASIO_WINDOWS) && !defined(UNDER_CE)
+#if defined(ASIO_WINDOWS) \
+  && !defined(ASIO_WINDOWS_APP) \
+  && !defined(UNDER_CE)
 
 #include <cstddef>
 #include "asio/detail/noncopyable.hpp"
@@ -138,6 +140,8 @@ private:
 # include "asio/detail/impl/win_thread.ipp"
 #endif // defined(ASIO_HEADER_ONLY)
 
-#endif // defined(ASIO_WINDOWS) && !defined(UNDER_CE)
+#endif // defined(ASIO_WINDOWS)
+       // && !defined(ASIO_WINDOWS_APP)
+       // && !defined(UNDER_CE)
 
 #endif // ASIO_DETAIL_WIN_THREAD_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_tss_ptr.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_tss_ptr.hpp
index 64a9ddf..490c705 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_tss_ptr.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/win_tss_ptr.hpp
@@ -2,7 +2,7 @@
 // detail/win_tss_ptr.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winapp_thread.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winapp_thread.hpp
new file mode 100644
index 0000000..4d13109
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winapp_thread.hpp
@@ -0,0 +1,124 @@
+//
+// detail/winapp_thread.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_DETAIL_WINAPP_THREAD_HPP
+#define ASIO_DETAIL_WINAPP_THREAD_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+
+#if defined(ASIO_WINDOWS) && defined(ASIO_WINDOWS_APP)
+
+#include "asio/detail/memory.hpp"
+#include "asio/detail/noncopyable.hpp"
+#include "asio/detail/socket_types.hpp"
+#include "asio/detail/throw_error.hpp"
+#include "asio/error.hpp"
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+namespace detail {
+
+DWORD WINAPI winapp_thread_function(LPVOID arg);
+
+class winapp_thread
+  : private noncopyable
+{
+public:
+  // Constructor.
+  template <typename Function>
+  winapp_thread(Function f, unsigned int = 0)
+  {
+    std::auto_ptr<func_base> arg(new func<Function>(f));
+    DWORD thread_id = 0;
+    thread_ = ::CreateThread(0, 0, winapp_thread_function,
+        arg.get(), 0, &thread_id);
+    if (!thread_)
+    {
+      DWORD last_error = ::GetLastError();
+      asio::error_code ec(last_error,
+          asio::error::get_system_category());
+      asio::detail::throw_error(ec, "thread");
+    }
+    arg.release();
+  }
+
+  // Destructor.
+  ~winapp_thread()
+  {
+    ::CloseHandle(thread_);
+  }
+
+  // Wait for the thread to exit.
+  void join()
+  {
+    ::WaitForSingleObjectEx(thread_, INFINITE, false);
+  }
+
+  // Get number of CPUs.
+  static std::size_t hardware_concurrency()
+  {
+    SYSTEM_INFO system_info;
+    ::GetNativeSystemInfo(&system_info);
+    return system_info.dwNumberOfProcessors;
+  }
+
+private:
+  friend DWORD WINAPI winapp_thread_function(LPVOID arg);
+
+  class func_base
+  {
+  public:
+    virtual ~func_base() {}
+    virtual void run() = 0;
+  };
+
+  template <typename Function>
+  class func
+    : public func_base
+  {
+  public:
+    func(Function f)
+      : f_(f)
+    {
+    }
+
+    virtual void run()
+    {
+      f_();
+    }
+
+  private:
+    Function f_;
+  };
+
+  ::HANDLE thread_;
+};
+
+inline DWORD WINAPI winapp_thread_function(LPVOID arg)
+{
+  std::auto_ptr<winapp_thread::func_base> func(
+      static_cast<winapp_thread::func_base*>(arg));
+  func->run();
+  return 0;
+}
+
+} // namespace detail
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // defined(ASIO_WINDOWS) && defined(ASIO_WINDOWS_APP)
+
+#endif // ASIO_DETAIL_WINAPP_THREAD_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/wince_thread.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/wince_thread.hpp
index a8518f7..5e0d4ec 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/wince_thread.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/wince_thread.hpp
@@ -2,7 +2,7 @@
 // detail/wince_thread.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -66,6 +66,14 @@ public:
     ::WaitForSingleObject(thread_, INFINITE);
   }
 
+  // Get number of CPUs.
+  static std::size_t hardware_concurrency()
+  {
+    SYSTEM_INFO system_info;
+    ::GetSystemInfo(&system_info);
+    return system_info.dwNumberOfProcessors;
+  }
+
 private:
   friend DWORD WINAPI wince_thread_function(LPVOID arg);
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_async_manager.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_async_manager.hpp
index 9799669..921dfdd 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_async_manager.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_async_manager.hpp
@@ -2,7 +2,7 @@
 // detail/winrt_async_manager.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -23,7 +23,7 @@
 #include "asio/detail/atomic_count.hpp"
 #include "asio/detail/winrt_async_op.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -35,9 +35,9 @@ class winrt_async_manager
 {
 public:
   // Constructor.
-  winrt_async_manager(asio::io_service& io_service)
-    : asio::detail::service_base<winrt_async_manager>(io_service),
-      io_service_(use_service<io_service_impl>(io_service)),
+  winrt_async_manager(asio::io_context& io_context)
+    : asio::detail::service_base<winrt_async_manager>(io_context),
+      io_context_(use_service<io_context_impl>(io_context)),
       outstanding_ops_(1)
   {
   }
@@ -48,7 +48,7 @@ public:
   }
 
   // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
+  void shutdown()
   {
     if (--outstanding_ops_ > 0)
     {
@@ -185,12 +185,12 @@ public:
               asio::system_category());
           break;
         }
-        io_service_.post_deferred_completion(handler);
+        io_context_.post_deferred_completion(handler);
         if (--outstanding_ops_ == 0)
           promise_.set_value();
       });
 
-    io_service_.work_started();
+    io_context_.work_started();
     ++outstanding_ops_;
     action->Completed = on_completed;
   }
@@ -222,12 +222,12 @@ public:
               asio::system_category());
           break;
         }
-        io_service_.post_deferred_completion(handler);
+        io_context_.post_deferred_completion(handler);
         if (--outstanding_ops_ == 0)
           promise_.set_value();
       });
 
-    io_service_.work_started();
+    io_context_.work_started();
     ++outstanding_ops_;
     operation->Completed = on_completed;
   }
@@ -263,19 +263,19 @@ public:
                 asio::system_category());
             break;
           }
-          io_service_.post_deferred_completion(handler);
+          io_context_.post_deferred_completion(handler);
           if (--outstanding_ops_ == 0)
             promise_.set_value();
         });
 
-    io_service_.work_started();
+    io_context_.work_started();
     ++outstanding_ops_;
     operation->Completed = on_completed;
   }
 
 private:
-  // The io_service implementation used to post completed handlers.
-  io_service_impl& io_service_;
+  // The io_context implementation used to post completed handlers.
+  io_context_impl& io_context_;
 
   // Count of outstanding operations.
   atomic_count outstanding_ops_;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_async_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_async_op.hpp
index 00bc0d1..2b18b43 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_async_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_async_op.hpp
@@ -2,7 +2,7 @@
 // detail/winrt_async_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_resolve_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_resolve_op.hpp
index 4bb1518..a197c3d 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_resolve_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_resolve_op.hpp
@@ -2,7 +2,7 @@
 // detail/winrt_resolve_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -25,7 +25,7 @@
 #include "asio/detail/handler_invoke_helpers.hpp"
 #include "asio/detail/memory.hpp"
 #include "asio/detail/winrt_async_op.hpp"
-#include "asio/ip/basic_resolver_iterator.hpp"
+#include "asio/ip/basic_resolver_results.hpp"
 #include "asio/error.hpp"
 
 #include "asio/detail/push_options.hpp"
@@ -44,7 +44,7 @@ public:
 
   typedef typename Protocol::endpoint endpoint_type;
   typedef asio::ip::basic_resolver_query<Protocol> query_type;
-  typedef asio::ip::basic_resolver_iterator<Protocol> iterator_type;
+  typedef asio::ip::basic_resolver_results<Protocol> results_type;
 
   winrt_resolve_op(const query_type& query, Handler& handler)
     : winrt_async_op<
@@ -65,15 +65,14 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
-    iterator_type iterator = iterator_type();
+    results_type results = results_type();
     if (!o->ec_)
     {
       try
       {
-        iterator = iterator_type::create(
-            o->result_, o->query_.hints(),
+        results = results_type::create(o->result_, o->query_.hints(),
             o->query_.host_name(), o->query_.service_name());
       }
       catch (Platform::Exception^ e)
@@ -89,8 +88,8 @@ public:
     // with the handler. Consequently, a local copy of the handler is required
     // to ensure that any owning sub-object remains valid until after we have
     // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, iterator_type>
-      handler(o->handler_, o->ec_, iterator);
+    detail::binder2<Handler, asio::error_code, results_type>
+      handler(o->handler_, o->ec_, results);
     p.h = asio::detail::addressof(handler.handler_);
     p.reset();
 
@@ -98,7 +97,7 @@ public:
     if (owner)
     {
       fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
+      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, "..."));
       w.complete(handler, handler.handler_);
       ASIO_HANDLER_INVOCATION_END;
     }
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_resolver_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_resolver_service.hpp
index 4405dba..8e38331 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_resolver_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_resolver_service.hpp
@@ -2,7 +2,7 @@
 // detail/winrt_resolver_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -19,8 +19,8 @@
 
 #if defined(ASIO_WINDOWS_RUNTIME)
 
-#include "asio/ip/basic_resolver_iterator.hpp"
 #include "asio/ip/basic_resolver_query.hpp"
+#include "asio/ip/basic_resolver_results.hpp"
 #include "asio/detail/bind_handler.hpp"
 #include "asio/detail/memory.hpp"
 #include "asio/detail/socket_ops.hpp"
@@ -34,7 +34,8 @@ namespace asio {
 namespace detail {
 
 template <typename Protocol>
-class winrt_resolver_service
+class winrt_resolver_service :
+  public service_base<winrt_resolver_service<Protocol> >
 {
 public:
   // The implementation type of the resolver. A cancellation token is used to
@@ -48,13 +49,14 @@ public:
   // The query type.
   typedef asio::ip::basic_resolver_query<Protocol> query_type;
 
-  // The iterator type.
-  typedef asio::ip::basic_resolver_iterator<Protocol> iterator_type;
+  // The results type.
+  typedef asio::ip::basic_resolver_results<Protocol> results_type;
 
   // Constructor.
-  winrt_resolver_service(asio::io_service& io_service)
-    : io_service_(use_service<io_service_impl>(io_service)),
-      async_manager_(use_service<winrt_async_manager>(io_service))
+  winrt_resolver_service(asio::io_context& io_context)
+    : service_base<winrt_resolver_service<Protocol> >(io_context),
+      io_context_(use_service<io_context_impl>(io_context)),
+      async_manager_(use_service<winrt_async_manager>(io_context))
   {
   }
 
@@ -64,12 +66,12 @@ public:
   }
 
   // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
+  void shutdown()
   {
   }
 
   // Perform any fork-related housekeeping.
-  void fork_service(asio::io_service::fork_event)
+  void notify_fork(asio::io_context::fork_event)
   {
   }
 
@@ -78,6 +80,18 @@ public:
   {
   }
 
+  // Move-construct a new resolver implementation.
+  void move_construct(implementation_type&,
+      implementation_type&)
+  {
+  }
+
+  // Move-assign from another resolver implementation.
+  void move_assign(implementation_type&,
+      winrt_resolver_service&, implementation_type&)
+  {
+  }
+
   // Destroy a resolver implementation.
   void destroy(implementation_type&)
   {
@@ -89,7 +103,7 @@ public:
   }
 
   // Resolve a query to a list of entries.
-  iterator_type resolve(implementation_type&,
+  results_type resolve(implementation_type&,
       const query_type& query, asio::error_code& ec)
   {
     try
@@ -101,9 +115,9 @@ public:
             winrt_utils::string(query.service_name())), ec);
 
       if (ec)
-        return iterator_type();
+        return results_type();
 
-      return iterator_type::create(
+      return results_type::create(
           endpoint_pairs, query.hints(),
           query.host_name(), query.service_name());
     }
@@ -111,13 +125,13 @@ public:
     {
       ec = asio::error_code(e->HResult,
           asio::system_category());
-      return iterator_type();
+      return results_type();
     }
   }
 
   // Asynchronously resolve a query to a list of entries.
   template <typename Handler>
-  void async_resolve(implementation_type&,
+  void async_resolve(implementation_type& impl,
       const query_type& query, Handler& handler)
   {
     bool is_continuation =
@@ -129,7 +143,9 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(query, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "resolver", &impl, "async_resolve"));
+    ASIO_HANDLER_CREATION((io_context_.context(),
+          *p.p, "resolver", &impl, 0, "async_resolve"));
+    (void)impl;
 
     try
     {
@@ -143,17 +159,17 @@ public:
     {
       p.p->ec_ = asio::error_code(
           e->HResult, asio::system_category());
-      io_service_.post_immediate_completion(p.p, is_continuation);
+      io_context_.post_immediate_completion(p.p, is_continuation);
       p.v = p.p = 0;
     }
   }
 
   // Resolve an endpoint to a list of entries.
-  iterator_type resolve(implementation_type&,
+  results_type resolve(implementation_type&,
       const endpoint_type&, asio::error_code& ec)
   {
     ec = asio::error::operation_not_supported;
-    return iterator_type();
+    return results_type();
   }
 
   // Asynchronously resolve an endpoint to a list of entries.
@@ -162,13 +178,13 @@ public:
       const endpoint_type&, Handler& handler)
   {
     asio::error_code ec = asio::error::operation_not_supported;
-    const iterator_type iterator;
-    io_service_.get_io_service().post(
-        detail::bind_handler(handler, ec, iterator));
+    const results_type results;
+    io_context_.get_io_context().post(
+        detail::bind_handler(handler, ec, results));
   }
 
 private:
-  io_service_impl& io_service_;
+  io_context_impl& io_context_;
   winrt_async_manager& async_manager_;
 };
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_socket_connect_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_socket_connect_op.hpp
index db6aeda..94b4048 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_socket_connect_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_socket_connect_op.hpp
@@ -2,7 +2,7 @@
 // detail/winrt_socket_connect_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -55,7 +55,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
     // Make a copy of the handler so that the memory can be deallocated before
     // the upcall is made. Even if we're not about to make an upcall, a
@@ -72,7 +72,7 @@ public:
     if (owner)
     {
       fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
+      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_));
       w.complete(handler, handler.handler_);
       ASIO_HANDLER_INVOCATION_END;
     }
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_socket_recv_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_socket_recv_op.hpp
index 959b89b..d19f1f7 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_socket_recv_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_socket_recv_op.hpp
@@ -2,7 +2,7 @@
 // detail/winrt_socket_recv_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -57,7 +57,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
     // Check whether buffers are still valid.
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_socket_send_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_socket_send_op.hpp
index ad5b052..6d16ef3 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_socket_send_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_socket_send_op.hpp
@@ -2,7 +2,7 @@
 // detail/winrt_socket_send_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -56,7 +56,7 @@ public:
     ptr p = { asio::detail::addressof(o->handler_), o, o };
     handler_work<Handler> w(o->handler_);
 
-    ASIO_HANDLER_COMPLETION((o));
+    ASIO_HANDLER_COMPLETION((*o));
 
 #if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
     // Check whether buffers are still valid.
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_ssocket_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_ssocket_service.hpp
index 7e68cc2..6f72bbe 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_ssocket_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_ssocket_service.hpp
@@ -2,7 +2,7 @@
 // detail/winrt_ssocket_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -20,7 +20,7 @@
 #if defined(ASIO_WINDOWS_RUNTIME)
 
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/detail/memory.hpp"
 #include "asio/detail/winrt_socket_connect_op.hpp"
 #include "asio/detail/winrt_ssocket_service_base.hpp"
@@ -33,6 +33,7 @@ namespace detail {
 
 template <typename Protocol>
 class winrt_ssocket_service :
+  public service_base<winrt_ssocket_service<Protocol> >,
   public winrt_ssocket_service_base
 {
 public:
@@ -60,11 +61,18 @@ public:
   };
 
   // Constructor.
-  winrt_ssocket_service(asio::io_service& io_service)
-    : winrt_ssocket_service_base(io_service)
+  winrt_ssocket_service(asio::io_context& io_context)
+    : service_base<winrt_ssocket_service<Protocol> >(io_context),
+      winrt_ssocket_service_base(io_context)
   {
   }
 
+  // Destroy all user-defined handler objects owned by the service.
+  void shutdown()
+  {
+    this->base_shutdown();
+  }
+
   // Move-construct a new socket implementation.
   void move_construct(implementation_type& impl,
       implementation_type& other_impl)
@@ -214,7 +222,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_connect"));
+    ASIO_HANDLER_CREATION((io_context_.context(),
+          *p.p, "socket", &impl, 0, "async_connect"));
 
     start_connect_op(impl, peer_endpoint.data(), p.p, is_continuation);
     p.v = p.p = 0;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_ssocket_service_base.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_ssocket_service_base.hpp
index 7419f0a..9192ffb 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_ssocket_service_base.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_ssocket_service_base.hpp
@@ -2,7 +2,7 @@
 // detail/winrt_ssocket_service_base.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -21,7 +21,7 @@
 
 #include "asio/buffer.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/socket_base.hpp"
 #include "asio/detail/buffer_sequence_adapter.hpp"
 #include "asio/detail/memory.hpp"
@@ -62,10 +62,10 @@ public:
 
   // Constructor.
   ASIO_DECL winrt_ssocket_service_base(
-      asio::io_service& io_service);
+      asio::io_context& io_context);
 
   // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
+  ASIO_DECL void base_shutdown();
 
   // Construct a new socket implementation.
   ASIO_DECL void construct(base_implementation_type&);
@@ -202,7 +202,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(buffers, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_send"));
+    ASIO_HANDLER_CREATION((io_context_.context(),
+          *p.p, "socket", &impl, 0, "async_send"));
 
     start_send_op(impl,
         buffer_sequence_adapter<asio::const_buffer,
@@ -218,7 +219,7 @@ public:
   {
     asio::error_code ec = asio::error::operation_not_supported;
     const std::size_t bytes_transferred = 0;
-    io_service_.get_io_service().post(
+    io_context_.get_io_context().post(
         detail::bind_handler(handler, ec, bytes_transferred));
   }
 
@@ -257,7 +258,8 @@ public:
       op::ptr::allocate(handler), 0 };
     p.p = new (p.v) op(buffers, handler);
 
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_receive"));
+    ASIO_HANDLER_CREATION((io_context_.context(),
+          *p.p, "socket", &impl, 0, "async_receive"));
 
     start_receive_op(impl,
         buffer_sequence_adapter<asio::mutable_buffer,
@@ -273,7 +275,7 @@ public:
   {
     asio::error_code ec = asio::error::operation_not_supported;
     const std::size_t bytes_transferred = 0;
-    io_service_.get_io_service().post(
+    io_context_.get_io_context().post(
         detail::bind_handler(handler, ec, bytes_transferred));
   }
 
@@ -326,8 +328,8 @@ protected:
       winrt_async_op<Windows::Storage::Streams::IBuffer^>* op,
       bool is_continuation);
 
-  // The io_service implementation used for delivering completions.
-  io_service_impl& io_service_;
+  // The io_context implementation used for delivering completions.
+  io_context_impl& io_context_;
 
   // The manager that keeps track of outstanding operations.
   winrt_async_manager& async_manager_;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_timer_scheduler.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_timer_scheduler.hpp
index 4c2d5b9..f3ffe61 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_timer_scheduler.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_timer_scheduler.hpp
@@ -2,7 +2,7 @@
 // detail/winrt_timer_scheduler.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -28,7 +28,7 @@
 #include "asio/detail/timer_queue_base.hpp"
 #include "asio/detail/timer_queue_set.hpp"
 #include "asio/detail/wait_op.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 
 #if defined(ASIO_HAS_IOCP)
 # include "asio/detail/thread.hpp"
@@ -44,17 +44,17 @@ class winrt_timer_scheduler
 {
 public:
   // Constructor.
-  ASIO_DECL winrt_timer_scheduler(asio::io_service& io_service);
+  ASIO_DECL winrt_timer_scheduler(asio::io_context& io_context);
 
   // Destructor.
   ASIO_DECL ~winrt_timer_scheduler();
 
   // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
+  ASIO_DECL void shutdown();
 
   // Recreate internal descriptors following a fork.
-  ASIO_DECL void fork_service(
-      asio::io_service::fork_event fork_ev);
+  ASIO_DECL void notify_fork(
+      asio::io_context::fork_event fork_ev);
 
   // Initialise the task. No effect as this class uses its own thread.
   ASIO_DECL void init_task();
@@ -100,8 +100,8 @@ private:
   // Helper function to remove a timer queue.
   ASIO_DECL void do_remove_timer_queue(timer_queue_base& queue);
 
-  // The io_service implementation used to post completions.
-  io_service_impl& io_service_;
+  // The io_context implementation used to post completions.
+  io_context_impl& io_context_;
 
   // Mutex used to protect internal variables.
   asio::detail::mutex mutex_;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_utils.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_utils.hpp
index 7c0f75a..52f7143 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_utils.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winrt_utils.hpp
@@ -2,7 +2,7 @@
 // detail/winrt_utils.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winsock_init.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winsock_init.hpp
index 425c9d6..b88cd51 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winsock_init.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/winsock_init.hpp
@@ -2,7 +2,7 @@
 // detail/winsock_init.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/work_dispatcher.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/work_dispatcher.hpp
index ab5ef18..460fbd6 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/work_dispatcher.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/work_dispatcher.hpp
@@ -2,7 +2,7 @@
 // detail/work_dispatcher.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -18,7 +18,7 @@
 #include "asio/detail/config.hpp"
 #include "asio/associated_executor.hpp"
 #include "asio/associated_allocator.hpp"
-#include "asio/executor_work.hpp"
+#include "asio/executor_work_guard.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -43,7 +43,7 @@ public:
   }
 
   work_dispatcher(work_dispatcher&& other)
-    : work_(ASIO_MOVE_CAST(executor_work<
+    : work_(ASIO_MOVE_CAST(executor_work_guard<
         typename associated_executor<Handler>::type>)(other.work_)),
       handler_(ASIO_MOVE_CAST(Handler)(other.handler_))
   {
@@ -60,7 +60,7 @@ public:
   }
 
 private:
-  executor_work<typename associated_executor<Handler>::type> work_;
+  executor_work_guard<typename associated_executor<Handler>::type> work_;
   Handler handler_;
 };
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/wrapped_handler.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/wrapped_handler.hpp
index 1b8edf7..aff903e 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/wrapped_handler.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/detail/wrapped_handler.hpp
@@ -2,7 +2,7 @@
 // detail/wrapped_handler.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/dispatch.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/dispatch.hpp
index 1ed5e7b..2addadc 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/dispatch.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/dispatch.hpp
@@ -2,7 +2,7 @@
 // dispatch.hpp
 // ~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/error.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/error.hpp
index 3ba6484..5d5767a 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/error.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/error.hpp
@@ -2,7 +2,7 @@
 // error.hpp
 // ~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -253,13 +253,13 @@ inline const asio::error_category& get_addrinfo_category()
 extern ASIO_DECL
 const asio::error_category& get_misc_category();
 
-ASIO_USED_VARIABLE static const asio::error_category& system_category
+static const asio::error_category& system_category
   = asio::error::get_system_category();
-ASIO_USED_VARIABLE static const asio::error_category& netdb_category
+static const asio::error_category& netdb_category
   = asio::error::get_netdb_category();
-ASIO_USED_VARIABLE static const asio::error_category& addrinfo_category
+static const asio::error_category& addrinfo_category
   = asio::error::get_addrinfo_category();
-ASIO_USED_VARIABLE static const asio::error_category& misc_category
+static const asio::error_category& misc_category
   = asio::error::get_misc_category();
 
 } // namespace error
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/error_code.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/error_code.hpp
index 843aba9..09a2acb 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/error_code.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/error_code.hpp
@@ -2,7 +2,7 @@
 // error_code.hpp
 // ~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -29,13 +29,6 @@
 
 #include "asio/detail/push_options.hpp"
 
-// Newer gcc needs some variables marked as used (used in error.hpp and ssl/error.hpp)
-#if defined(__GNUC__)
-#  define ASIO_USED_VARIABLE __attribute__((used))
-#else
-#  define ASIO_USED_VARIABLE
-#endif // defined(__GNUC__)
-
 namespace asio {
 
 #if defined(ASIO_HAS_STD_SYSTEM_ERROR)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/execution_context.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/execution_context.hpp
index 4d7d98e..0d91195 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/execution_context.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/execution_context.hpp
@@ -2,7 +2,7 @@
 // execution_context.hpp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -27,21 +27,21 @@
 namespace asio {
 
 class execution_context;
-class io_service;
+class io_context;
 
 #if !defined(GENERATING_DOCUMENTATION)
 template <typename Service> Service& use_service(execution_context&);
-template <typename Service> Service& use_service(io_service&);
+template <typename Service> Service& use_service(io_context&);
 template <typename Service> void add_service(execution_context&, Service*);
 template <typename Service> bool has_service(execution_context&);
-#endif // !defined(ASIO_NO_DEPRECATED)
+#endif // !defined(GENERATING_DOCUMENTATION)
 
 namespace detail { class service_registry; }
 
 /// A context for function object execution.
 /**
  * An execution context represents a place where function objects will be
- * executed. An @c io_service is an example of an execution context.
+ * executed. An @c io_context is an example of an execution context.
  *
  * @par The execution_context class and services
  *
@@ -79,12 +79,12 @@ namespace detail { class service_registry; }
  * @par The execution_context as a base class
  *
  * Class execution_context may be used only as a base class for concrete
- * execution context types. The @c io_service is an example of such a derived
+ * execution context types. The @c io_context is an example of such a derived
  * type.
  *
  * On destruction, a class that is derived from execution_context must perform
- * <tt>execution_context::shutdown_context()</tt> followed by
- * <tt>execution_context::destroy_context()</tt>.
+ * <tt>execution_context::shutdown()</tt> followed by
+ * <tt>execution_context::destroy()</tt>.
  *
  * This destruction sequence permits programs to simplify their resource
  * management by using @c shared_ptr<>. Where an object's lifetime is tied to
@@ -96,11 +96,11 @@ namespace detail { class service_registry; }
  * complete. The corresponding handler objects are destroyed, and all @c
  * shared_ptr references to the objects are destroyed.
  *
- * @li To shut down the whole program, the io_service function stop() is called
- * to terminate any run() calls as soon as possible. The io_service destructor
- * calls @c shutdown_context() and @c destroy_context() to destroy all pending
- * handlers, causing all @c shared_ptr references to all connection objects to
- * be destroyed.
+ * @li To shut down the whole program, the io_context function stop() is called
+ * to terminate any run() calls as soon as possible. The io_context destructor
+ * calls @c shutdown() and @c destroy() to destroy all pending handlers,
+ * causing all @c shared_ptr references to all connection objects to be
+ * destroyed.
  */
 class execution_context
   : private noncopyable
@@ -122,9 +122,9 @@ protected:
    *
    * @li For each service object @c svc in the execution_context set, in
    * reverse order of the beginning of service object lifetime, performs @c
-   * svc->shutdown_service().
+   * svc->shutdown().
    */
-  ASIO_DECL void shutdown_context();
+  ASIO_DECL void shutdown();
 
   /// Destroys all services in the context.
   /**
@@ -134,7 +134,7 @@ protected:
    * reverse order * of the beginning of service object lifetime, performs
    * <tt>delete static_cast<execution_context::service*>(svc)</tt>.
    */
-  ASIO_DECL void destroy_context();
+  ASIO_DECL void destroy();
 
 public:
   /// Fork-related event notifications.
@@ -185,7 +185,7 @@ public:
    * } @endcode
    *
    * @note For each service object @c svc in the execution_context set,
-   * performs <tt>svc->fork_service();</tt>. When processing the fork_prepare
+   * performs <tt>svc->notify_fork();</tt>. When processing the fork_prepare
    * event, services are visited in reverse order of the beginning of service
    * object lifetime. Otherwise, services are visited in order of the beginning
    * of service object lifetime.
@@ -210,18 +210,18 @@ public:
   /**
    * This function is used to locate a service object that corresponds to the
    * given service type. If there is no existing implementation of the service,
-   * then the io_service will create a new instance of the service.
+   * then the io_context will create a new instance of the service.
    *
-   * @param ios The io_service object that owns the service.
+   * @param ioc The io_context object that owns the service.
    *
    * @return The service interface implementing the specified service type.
    * Ownership of the service interface is not transferred to the caller.
    *
    * @note This overload is preserved for backwards compatibility with services
-   * that inherit from io_service::service.
+   * that inherit from io_context::service.
    */
   template <typename Service>
-  friend Service& use_service(io_service& ios);
+  friend Service& use_service(io_context& ioc);
 
 #if defined(GENERATING_DOCUMENTATION)
 
@@ -310,7 +310,7 @@ public:
   id() {}
 };
 
-/// Base class for all io_service services.
+/// Base class for all io_context services.
 class execution_context::service
   : private noncopyable
 {
@@ -330,7 +330,7 @@ protected:
 
 private:
   /// Destroy all user-defined handler objects owned by the service.
-  virtual void shutdown_service() = 0;
+  virtual void shutdown() = 0;
 
   /// Handle notification of a fork-related event to perform any necessary
   /// housekeeping.
@@ -338,7 +338,7 @@ private:
    * This function is not a pure virtual so that services only have to
    * implement it if necessary. The default implementation does nothing.
    */
-  ASIO_DECL virtual void fork_service(
+  ASIO_DECL virtual void notify_fork(
       execution_context::fork_event event);
 
   friend class asio::detail::service_registry;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/executor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/executor.hpp
index a3b5730..f22b991 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/executor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/executor.hpp
@@ -2,7 +2,7 @@
 // executor.hpp
 // ~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -19,8 +19,8 @@
 #include <typeinfo>
 #include "asio/detail/cstddef.hpp"
 #include "asio/detail/memory.hpp"
+#include "asio/detail/throw_exception.hpp"
 #include "asio/execution_context.hpp"
-#include "asio/is_executor.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -125,19 +125,19 @@ public:
   }
 
   /// Obtain the underlying execution context.
-  execution_context& context() ASIO_NOEXCEPT
+  execution_context& context() const ASIO_NOEXCEPT
   {
     return get_impl()->context();
   }
 
   /// Inform the executor that it has some outstanding work to do.
-  void on_work_started() ASIO_NOEXCEPT
+  void on_work_started() const ASIO_NOEXCEPT
   {
     get_impl()->on_work_started();
   }
 
   /// Inform the executor that some work is no longer outstanding.
-  void on_work_finished() ASIO_NOEXCEPT
+  void on_work_finished() const ASIO_NOEXCEPT
   {
     get_impl()->on_work_finished();
   }
@@ -156,7 +156,7 @@ public:
    * internal storage needed for function invocation.
    */
   template <typename Function, typename Allocator>
-  void dispatch(ASIO_MOVE_ARG(Function) f, const Allocator& a);
+  void dispatch(ASIO_MOVE_ARG(Function) f, const Allocator& a) const;
 
   /// Request the executor to invoke the given function object.
   /**
@@ -172,7 +172,7 @@ public:
    * internal storage needed for function invocation.
    */
   template <typename Function, typename Allocator>
-  void post(ASIO_MOVE_ARG(Function) f, const Allocator& a);
+  void post(ASIO_MOVE_ARG(Function) f, const Allocator& a) const;
 
   /// Request the executor to invoke the given function object.
   /**
@@ -188,7 +188,7 @@ public:
    * internal storage needed for function invocation.
    */
   template <typename Function, typename Allocator>
-  void defer(ASIO_MOVE_ARG(Function) f, const Allocator& a);
+  void defer(ASIO_MOVE_ARG(Function) f, const Allocator& a) const;
 
   struct unspecified_bool_type_t {};
   typedef void (*unspecified_bool_type)(unspecified_bool_type_t);
@@ -205,10 +205,17 @@ public:
    * @returns If @c *this has a target type of type @c T, <tt>typeid(T)</tt>;
    * otherwise, <tt>typeid(void)</tt>.
    */
+#if !defined(ASIO_NO_TYPEID) || defined(GENERATING_DOCUMENTATION)
   const std::type_info& target_type() const ASIO_NOEXCEPT
   {
     return impl_ ? impl_->target_type() : typeid(void);
   }
+#else // !defined(ASIO_NO_TYPEID) || defined(GENERATING_DOCUMENTATION)
+  const void* target_type() const ASIO_NOEXCEPT
+  {
+    return impl_ ? impl_->target_type() : 0;
+  }
+#endif // !defined(ASIO_NO_TYPEID) || defined(GENERATING_DOCUMENTATION)
 
   /// Obtain a pointer to the target executor object.
   /**
@@ -249,6 +256,23 @@ private:
   class function;
   template <typename, typename> class impl;
 
+#if !defined(ASIO_NO_TYPEID)
+  typedef const std::type_info& type_id_result_type;
+#else // !defined(ASIO_NO_TYPEID)
+  typedef const void* type_id_result_type;
+#endif // !defined(ASIO_NO_TYPEID)
+
+  template <typename T>
+  static type_id_result_type type_id()
+  {
+#if !defined(ASIO_NO_TYPEID)
+    return typeid(T);
+#else // !defined(ASIO_NO_TYPEID)
+    static int unique_id;
+    return &unique_id;
+#endif // !defined(ASIO_NO_TYPEID)
+  }
+
   // Base class for all polymorphic executor implementations.
   class impl_base
   {
@@ -261,7 +285,7 @@ private:
     virtual void dispatch(ASIO_MOVE_ARG(function)) = 0;
     virtual void post(ASIO_MOVE_ARG(function)) = 0;
     virtual void defer(ASIO_MOVE_ARG(function)) = 0;
-    virtual const std::type_info& target_type() const ASIO_NOEXCEPT = 0;
+    virtual type_id_result_type target_type() const ASIO_NOEXCEPT = 0;
     virtual void* target() ASIO_NOEXCEPT = 0;
     virtual const void* target() const ASIO_NOEXCEPT = 0;
     virtual bool equals(const impl_base* e) const ASIO_NOEXCEPT = 0;
@@ -276,9 +300,14 @@ private:
   };
 
   // Helper function to check and return the implementation pointer.
-  impl_base* get_impl()
+  impl_base* get_impl() const
   {
-    return impl_ ? impl_ : throw bad_executor();
+    if (!impl_)
+    {
+      bad_executor ex;
+      asio::detail::throw_exception(ex);
+    }
+    return impl_;
   }
 
   // Helper function to clone another implementation.
@@ -295,12 +324,8 @@ private:
   }
 
   impl_base* impl_;
-#endif // !defined(ASIO_NO_DEPRECATED)
-};
-
-#if !defined(GENERATING_DOCUMENTATION)
-template <> struct is_executor<executor> : true_type {};
 #endif // !defined(GENERATING_DOCUMENTATION)
+};
 
 } // namespace asio
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/executor_work.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/executor_work.hpp
deleted file mode 100644
index bc20eb3..0000000
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/executor_work.hpp
+++ /dev/null
@@ -1,168 +0,0 @@
-//
-// executor_work.hpp
-// ~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_EXECUTOR_WORK_HPP
-#define ASIO_EXECUTOR_WORK_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/associated_executor.hpp"
-#include "asio/detail/type_traits.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// An object of type @c executor_work controls ownership of executor work
-/// within a scope.
-template <typename Executor>
-class executor_work
-{
-public:
-  /// The underlying executor type.
-  typedef Executor executor_type;
-
-  /// Constructs a @c executor_work object for the specified executor.
-  /**
-   * Stores a copy of @c e and calls <tt>on_work_started()</tt> on it.
-   */
-  explicit executor_work(const executor_type& e) ASIO_NOEXCEPT
-    : executor_(e),
-      owns_(true)
-  {
-    executor_.on_work_started();
-  }
-
-  /// Copy constructor.
-  executor_work(const executor_work& other) ASIO_NOEXCEPT
-    : executor_(other.executor_),
-      owns_(other.owns_)
-  {
-    if (owns_)
-      executor_.on_work_started();
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move constructor.
-  executor_work(executor_work&& other)
-    : executor_(ASIO_MOVE_CAST(Executor)(other.executor_)),
-      owns_(other.owns_)
-  {
-    other.owns_ = false;
-  }
-#endif //  defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Destructor.
-  /**
-   * Unless the object has already been reset, or is in a moved-from state,
-   * calls <tt>on_work_finished()</tt> on the stored executor.
-   */
-  ~executor_work()
-  {
-    if (owns_)
-      executor_.on_work_finished();
-  }
-
-  /// Obtain the associated executor.
-  executor_type get_executor() const ASIO_NOEXCEPT
-  {
-    return executor_;
-  }
-
-  /// Whether the executor_work object owns some outstanding work.
-  bool owns_work() const ASIO_NOEXCEPT
-  {
-    return owns_;
-  }
-
-  /// Indicate that the work is no longer outstanding.
-  /*
-   * Unless the object has already been reset, or is in a moved-from state,
-   * calls <tt>on_work_finished()</tt> on the stored executor.
-   */
-  void reset() ASIO_NOEXCEPT
-  {
-    if (owns_)
-    {
-      executor_.on_work_finished();
-      owns_ = false;
-    }
-  }
-
-private:
-  // Disallow assignment.
-  executor_work& operator=(const executor_work&);
-
-  executor_type executor_;
-  bool owns_;
-};
-
-/// Create an @ref executor_work object.
-template <typename Executor>
-inline executor_work<Executor> make_work(const Executor& ex,
-    typename enable_if<is_executor<Executor>::value>::type* = 0)
-{
-  return executor_work<Executor>(ex);
-}
-
-/// Create an @ref executor_work object.
-template <typename ExecutionContext>
-inline executor_work<typename ExecutionContext::executor_type>
-make_work(ExecutionContext& ctx,
-    typename enable_if<
-      is_convertible<ExecutionContext&, execution_context&>::value>::type* = 0)
-{
-  return executor_work<typename ExecutionContext::executor_type>(
-      ctx.get_executor());
-}
-
-/// Create an @ref executor_work object.
-template <typename T>
-inline executor_work<typename associated_executor<T>::type>
-make_work(const T& t,
-    typename enable_if<!is_executor<T>::value &&
-      !is_convertible<T&, execution_context&>::value>::type* = 0)
-{
-  return executor_work<typename associated_executor<T>::type>(
-      associated_executor<T>::get(t));
-}
-
-/// Create an @ref executor_work object.
-template <typename T, typename Executor>
-inline executor_work<typename associated_executor<T, Executor>::type>
-make_work(const T& t, const Executor& ex,
-    typename enable_if<is_executor<Executor>::value>::type* = 0)
-{
-  return executor_work<typename associated_executor<T, Executor>::type>(
-      associated_executor<T, Executor>::get(t, ex));
-}
-
-/// Create an @ref executor_work object.
-template <typename T, typename ExecutionContext>
-inline executor_work<typename associated_executor<T,
-  typename ExecutionContext::executor_type>::type>
-make_work(const T& t, ExecutionContext& ctx,
-    typename enable_if<!is_executor<T>::value &&
-      !is_convertible<T&, execution_context&>::value>::type* = 0)
-{
-  return executor_work<typename associated_executor<T,
-    typename ExecutionContext::executor_type>::type>(
-      associated_executor<T, typename ExecutionContext::executor_type>::get(
-        t, ctx.get_executor()));
-}
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_EXECUTOR_WORK_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/executor_work_guard.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/executor_work_guard.hpp
new file mode 100644
index 0000000..a791dcd
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/executor_work_guard.hpp
@@ -0,0 +1,169 @@
+//
+// executor_work_guard.hpp
+// ~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_EXECUTOR_WORK_GUARD_HPP
+#define ASIO_EXECUTOR_WORK_GUARD_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+#include "asio/associated_executor.hpp"
+#include "asio/detail/type_traits.hpp"
+#include "asio/is_executor.hpp"
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+
+/// An object of type @c executor_work_guard controls ownership of executor work
+/// within a scope.
+template <typename Executor>
+class executor_work_guard
+{
+public:
+  /// The underlying executor type.
+  typedef Executor executor_type;
+
+  /// Constructs a @c executor_work_guard object for the specified executor.
+  /**
+   * Stores a copy of @c e and calls <tt>on_work_started()</tt> on it.
+   */
+  explicit executor_work_guard(const executor_type& e) ASIO_NOEXCEPT
+    : executor_(e),
+      owns_(true)
+  {
+    executor_.on_work_started();
+  }
+
+  /// Copy constructor.
+  executor_work_guard(const executor_work_guard& other) ASIO_NOEXCEPT
+    : executor_(other.executor_),
+      owns_(other.owns_)
+  {
+    if (owns_)
+      executor_.on_work_started();
+  }
+
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+  /// Move constructor.
+  executor_work_guard(executor_work_guard&& other)
+    : executor_(ASIO_MOVE_CAST(Executor)(other.executor_)),
+      owns_(other.owns_)
+  {
+    other.owns_ = false;
+  }
+#endif //  defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+
+  /// Destructor.
+  /**
+   * Unless the object has already been reset, or is in a moved-from state,
+   * calls <tt>on_work_finished()</tt> on the stored executor.
+   */
+  ~executor_work_guard()
+  {
+    if (owns_)
+      executor_.on_work_finished();
+  }
+
+  /// Obtain the associated executor.
+  executor_type get_executor() const ASIO_NOEXCEPT
+  {
+    return executor_;
+  }
+
+  /// Whether the executor_work_guard object owns some outstanding work.
+  bool owns_work() const ASIO_NOEXCEPT
+  {
+    return owns_;
+  }
+
+  /// Indicate that the work is no longer outstanding.
+  /*
+   * Unless the object has already been reset, or is in a moved-from state,
+   * calls <tt>on_work_finished()</tt> on the stored executor.
+   */
+  void reset() ASIO_NOEXCEPT
+  {
+    if (owns_)
+    {
+      executor_.on_work_finished();
+      owns_ = false;
+    }
+  }
+
+private:
+  // Disallow assignment.
+  executor_work_guard& operator=(const executor_work_guard&);
+
+  executor_type executor_;
+  bool owns_;
+};
+
+/// Create an @ref executor_work_guard object.
+template <typename Executor>
+inline executor_work_guard<Executor> make_work_guard(const Executor& ex,
+    typename enable_if<is_executor<Executor>::value>::type* = 0)
+{
+  return executor_work_guard<Executor>(ex);
+}
+
+/// Create an @ref executor_work_guard object.
+template <typename ExecutionContext>
+inline executor_work_guard<typename ExecutionContext::executor_type>
+make_work_guard(ExecutionContext& ctx,
+    typename enable_if<
+      is_convertible<ExecutionContext&, execution_context&>::value>::type* = 0)
+{
+  return executor_work_guard<typename ExecutionContext::executor_type>(
+      ctx.get_executor());
+}
+
+/// Create an @ref executor_work_guard object.
+template <typename T>
+inline executor_work_guard<typename associated_executor<T>::type>
+make_work_guard(const T& t,
+    typename enable_if<!is_executor<T>::value &&
+      !is_convertible<T&, execution_context&>::value>::type* = 0)
+{
+  return executor_work_guard<typename associated_executor<T>::type>(
+      associated_executor<T>::get(t));
+}
+
+/// Create an @ref executor_work_guard object.
+template <typename T, typename Executor>
+inline executor_work_guard<typename associated_executor<T, Executor>::type>
+make_work_guard(const T& t, const Executor& ex,
+    typename enable_if<is_executor<Executor>::value>::type* = 0)
+{
+  return executor_work_guard<typename associated_executor<T, Executor>::type>(
+      associated_executor<T, Executor>::get(t, ex));
+}
+
+/// Create an @ref executor_work_guard object.
+template <typename T, typename ExecutionContext>
+inline executor_work_guard<typename associated_executor<T,
+  typename ExecutionContext::executor_type>::type>
+make_work_guard(const T& t, ExecutionContext& ctx,
+    typename enable_if<!is_executor<T>::value &&
+      !is_convertible<T&, execution_context&>::value>::type* = 0)
+{
+  return executor_work_guard<typename associated_executor<T,
+    typename ExecutionContext::executor_type>::type>(
+      associated_executor<T, typename ExecutionContext::executor_type>::get(
+        t, ctx.get_executor()));
+}
+
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // ASIO_EXECUTOR_WORK_GUARD_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/basic_endpoint.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/basic_endpoint.hpp
index 9f5fbce..1faf4a1 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/basic_endpoint.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/basic_endpoint.hpp
@@ -2,7 +2,7 @@
 // generic/basic_endpoint.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/datagram_protocol.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/datagram_protocol.hpp
index 1cfd4f9..21a39de 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/datagram_protocol.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/datagram_protocol.hpp
@@ -2,7 +2,7 @@
 // generic/datagram_protocol.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/detail/endpoint.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/detail/endpoint.hpp
index d2eedec..8de7b2a 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/detail/endpoint.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/detail/endpoint.hpp
@@ -2,7 +2,7 @@
 // generic/detail/endpoint.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/detail/impl/endpoint.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/detail/impl/endpoint.ipp
index 7261819..1a66fb9 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/detail/impl/endpoint.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/detail/impl/endpoint.ipp
@@ -2,7 +2,7 @@
 // generic/detail/impl/endpoint.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/raw_protocol.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/raw_protocol.hpp
index b563258..9a74073 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/raw_protocol.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/raw_protocol.hpp
@@ -2,7 +2,7 @@
 // generic/raw_protocol.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/seq_packet_protocol.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/seq_packet_protocol.hpp
index ea55ce6..d01d9cb 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/seq_packet_protocol.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/seq_packet_protocol.hpp
@@ -2,7 +2,7 @@
 // generic/seq_packet_protocol.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/stream_protocol.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/stream_protocol.hpp
index 7f457b3..6917c19 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/stream_protocol.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/generic/stream_protocol.hpp
@@ -2,7 +2,7 @@
 // generic/stream_protocol.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/handler_alloc_hook.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/handler_alloc_hook.hpp
index 8d992ca..a05ad4c 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/handler_alloc_hook.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/handler_alloc_hook.hpp
@@ -2,7 +2,7 @@
 // handler_alloc_hook.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/handler_continuation_hook.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/handler_continuation_hook.hpp
index fd6051e..bea0cdc 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/handler_continuation_hook.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/handler_continuation_hook.hpp
@@ -2,7 +2,7 @@
 // handler_continuation_hook.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/handler_invoke_hook.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/handler_invoke_hook.hpp
index 8a2ed43..65c0d08 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/handler_invoke_hook.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/handler_invoke_hook.hpp
@@ -2,7 +2,7 @@
 // handler_invoke_hook.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -26,12 +26,12 @@ namespace asio {
  * @brief Default invoke function for handlers.
  *
  * Completion handlers for asynchronous operations are invoked by the
- * io_service associated with the corresponding object (e.g. a socket or
+ * io_context associated with the corresponding object (e.g. a socket or
  * deadline_timer). Certain guarantees are made on when the handler may be
  * invoked, in particular that a handler can only be invoked from a thread that
- * is currently calling @c run() on the corresponding io_service object.
+ * is currently calling @c run() on the corresponding io_context object.
  * Handlers may subsequently be invoked through other objects (such as
- * io_service::strand objects) that provide additional guarantees.
+ * io_context::strand objects) that provide additional guarantees.
  *
  * When asynchronous operations are composed from other asynchronous
  * operations, all intermediate handlers should be invoked using the same
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/handler_type.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/handler_type.hpp
index 260fbcb..49e7123 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/handler_type.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/handler_type.hpp
@@ -2,7 +2,7 @@
 // handler_type.hpp
 // ~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -22,7 +22,8 @@
 
 namespace asio {
 
-/// Default handler type traits provided for all completion token types.
+/// (Deprecated: Use two-parameter version of async_result.) Default handler
+/// type traits provided for all completion token types.
 /**
  * The handler_type traits class is used for determining the concrete handler
  * type to be used for an asynchronous operation. It allows the handler type to
@@ -46,7 +47,4 @@ struct handler_type
 
 #include "asio/detail/pop_options.hpp"
 
-#define ASIO_HANDLER_TYPE(h, sig) \
-  typename handler_type<h, sig>::type
-
 #endif // ASIO_HANDLER_TYPE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/high_resolution_timer.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/high_resolution_timer.hpp
index 6ab1324..dd9d485 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/high_resolution_timer.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/high_resolution_timer.hpp
@@ -2,7 +2,7 @@
 // high_resolution_timer.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,21 +17,13 @@
 
 #include "asio/detail/config.hpp"
 
-#if defined(ASIO_HAS_STD_CHRONO) \
-  || defined(ASIO_HAS_BOOST_CHRONO) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#if defined(ASIO_HAS_STD_CHRONO)
-# include <chrono>
-#elif defined(ASIO_HAS_BOOST_CHRONO)
-# include <boost/chrono/system_clocks.hpp>
-#endif
+#if defined(ASIO_HAS_CHRONO) || defined(GENERATING_DOCUMENTATION)
 
 #include "asio/basic_waitable_timer.hpp"
+#include "asio/detail/chrono.hpp"
 
 namespace asio {
 
-#if defined(GENERATING_DOCUMENTATION)
 /// Typedef for a timer based on the high resolution clock.
 /**
  * This typedef uses the C++11 @c &lt;chrono&gt; standard library facility, if
@@ -44,20 +36,9 @@ namespace asio {
 typedef basic_waitable_timer<
     chrono::high_resolution_clock>
   high_resolution_timer;
-#elif defined(ASIO_HAS_STD_CHRONO)
-typedef basic_waitable_timer<
-    std::chrono::high_resolution_clock>
-  high_resolution_timer;
-#elif defined(ASIO_HAS_BOOST_CHRONO)
-typedef basic_waitable_timer<
-    boost::chrono::high_resolution_clock>
-  high_resolution_timer;
-#endif
 
 } // namespace asio
 
-#endif // defined(ASIO_HAS_STD_CHRONO) 
-       //   || defined(ASIO_HAS_BOOST_CHRONO)
-       //   || defined(GENERATING_DOCUMENTATION)
+#endif // defined(ASIO_HAS_CHRONO) || defined(GENERATING_DOCUMENTATION)
 
 #endif // ASIO_HIGH_RESOLUTION_TIMER_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/buffered_read_stream.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/buffered_read_stream.hpp
index 77700b8..c1a2e14 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/buffered_read_stream.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/buffered_read_stream.hpp
@@ -2,7 +2,7 @@
 // impl/buffered_read_stream.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -191,7 +191,7 @@ buffered_read_stream<Stream>::async_fill(
         storage_.size() - previous_size),
       detail::buffered_fill_handler<ASIO_HANDLER_TYPE(
         ReadHandler, void (asio::error_code, std::size_t))>(
-        storage_, previous_size, init.handler));
+        storage_, previous_size, init.completion_handler));
 
   return init.result.get();
 }
@@ -381,18 +381,18 @@ buffered_read_stream<Stream>::async_read_some(
 
   if (asio::buffer_size(buffers) == 0 || !storage_.empty())
   {
-    next_layer_.async_read_some(asio::mutable_buffers_1(0, 0),
+    next_layer_.async_read_some(ASIO_MUTABLE_BUFFER(0, 0),
         detail::buffered_read_some_handler<
           MutableBufferSequence, ASIO_HANDLER_TYPE(
             ReadHandler, void (asio::error_code, std::size_t))>(
-            storage_, buffers, init.handler));
+            storage_, buffers, init.completion_handler));
   }
   else
   {
     this->async_fill(detail::buffered_read_some_handler<
           MutableBufferSequence, ASIO_HANDLER_TYPE(
             ReadHandler, void (asio::error_code, std::size_t))>(
-            storage_, buffers, init.handler));
+            storage_, buffers, init.completion_handler));
   }
 
   return init.result.get();
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/buffered_write_stream.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/buffered_write_stream.hpp
index 125bd31..4ce6e5e 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/buffered_write_stream.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/buffered_write_stream.hpp
@@ -2,7 +2,7 @@
 // impl/buffered_write_stream.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -172,7 +172,7 @@ buffered_write_stream<Stream>::async_flush(
   async_write(next_layer_, buffer(storage_.data(), storage_.size()),
       detail::buffered_flush_handler<ASIO_HANDLER_TYPE(
         WriteHandler, void (asio::error_code, std::size_t))>(
-        storage_, init.handler));
+        storage_, init.completion_handler));
 
   return init.result.get();
 }
@@ -368,18 +368,18 @@ buffered_write_stream<Stream>::async_write_some(
   if (asio::buffer_size(buffers) == 0
       || storage_.size() < storage_.capacity())
   {
-    next_layer_.async_write_some(asio::const_buffers_1(0, 0),
+    next_layer_.async_write_some(ASIO_CONST_BUFFER(0, 0),
         detail::buffered_write_some_handler<
           ConstBufferSequence, ASIO_HANDLER_TYPE(
             WriteHandler, void (asio::error_code, std::size_t))>(
-            storage_, buffers, init.handler));
+            storage_, buffers, init.completion_handler));
   }
   else
   {
     this->async_flush(detail::buffered_write_some_handler<
           ConstBufferSequence, ASIO_HANDLER_TYPE(
             WriteHandler, void (asio::error_code, std::size_t))>(
-            storage_, buffers, init.handler));
+            storage_, buffers, init.completion_handler));
   }
 
   return init.result.get();
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/connect.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/connect.hpp
index 57f57a8..2ab72f6 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/connect.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/connect.hpp
@@ -2,7 +2,7 @@
 // impl/connect.hpp
 // ~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -15,10 +15,10 @@
 # pragma once
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
+#include <algorithm>
 #include "asio/associated_allocator.hpp"
 #include "asio/associated_executor.hpp"
 #include "asio/detail/bind_handler.hpp"
-#include "asio/detail/consuming_buffers.hpp"
 #include "asio/detail/handler_alloc_helpers.hpp"
 #include "asio/detail/handler_cont_helpers.hpp"
 #include "asio/detail/handler_invoke_helpers.hpp"
@@ -35,16 +35,44 @@ namespace detail
 {
   struct default_connect_condition
   {
-    template <typename Iterator>
-    Iterator operator()(const asio::error_code&, Iterator next)
+    template <typename Endpoint>
+    bool operator()(const asio::error_code&, const Endpoint&)
     {
-      return next;
+      return true;
     }
   };
 }
 
-template <typename Protocol, typename SocketService, typename Iterator>
-Iterator connect(basic_socket<Protocol, SocketService>& s, Iterator begin)
+template <typename Protocol ASIO_SVC_TPARAM, typename EndpointSequence>
+typename Protocol::endpoint connect(
+    basic_socket<Protocol ASIO_SVC_TARG>& s,
+    const EndpointSequence& endpoints,
+    typename enable_if<is_endpoint_sequence<
+        EndpointSequence>::value>::type*)
+{
+  asio::error_code ec;
+  typename Protocol::endpoint result = connect(s, endpoints, ec);
+  asio::detail::throw_error(ec, "connect");
+  return result;
+}
+
+template <typename Protocol ASIO_SVC_TPARAM, typename EndpointSequence>
+typename Protocol::endpoint connect(
+    basic_socket<Protocol ASIO_SVC_TARG>& s,
+    const EndpointSequence& endpoints, asio::error_code& ec,
+    typename enable_if<is_endpoint_sequence<
+        EndpointSequence>::value>::type*)
+{
+  typename EndpointSequence::iterator iter = connect(
+      s, endpoints.begin(), endpoints.end(),
+      detail::default_connect_condition(), ec);
+  return ec ? typename Protocol::endpoint() : *iter;
+}
+
+#if !defined(ASIO_NO_DEPRECATED)
+template <typename Protocol ASIO_SVC_TPARAM, typename Iterator>
+Iterator connect(basic_socket<Protocol ASIO_SVC_TARG>& s, Iterator begin,
+    typename enable_if<!is_endpoint_sequence<Iterator>::value>::type*)
 {
   asio::error_code ec;
   Iterator result = connect(s, begin, ec);
@@ -52,15 +80,17 @@ Iterator connect(basic_socket<Protocol, SocketService>& s, Iterator begin)
   return result;
 }
 
-template <typename Protocol, typename SocketService, typename Iterator>
-inline Iterator connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, asio::error_code& ec)
+template <typename Protocol ASIO_SVC_TPARAM, typename Iterator>
+inline Iterator connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
+    Iterator begin, asio::error_code& ec,
+    typename enable_if<!is_endpoint_sequence<Iterator>::value>::type*)
 {
   return connect(s, begin, Iterator(), detail::default_connect_condition(), ec);
 }
+#endif // !defined(ASIO_NO_DEPRECATED)
 
-template <typename Protocol, typename SocketService, typename Iterator>
-Iterator connect(basic_socket<Protocol, SocketService>& s,
+template <typename Protocol ASIO_SVC_TPARAM, typename Iterator>
+Iterator connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
     Iterator begin, Iterator end)
 {
   asio::error_code ec;
@@ -69,17 +99,48 @@ Iterator connect(basic_socket<Protocol, SocketService>& s,
   return result;
 }
 
-template <typename Protocol, typename SocketService, typename Iterator>
-inline Iterator connect(basic_socket<Protocol, SocketService>& s,
+template <typename Protocol ASIO_SVC_TPARAM, typename Iterator>
+inline Iterator connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
     Iterator begin, Iterator end, asio::error_code& ec)
 {
   return connect(s, begin, end, detail::default_connect_condition(), ec);
 }
 
-template <typename Protocol, typename SocketService,
+template <typename Protocol ASIO_SVC_TPARAM,
+    typename EndpointSequence, typename ConnectCondition>
+typename Protocol::endpoint connect(
+    basic_socket<Protocol ASIO_SVC_TARG>& s,
+    const EndpointSequence& endpoints, ConnectCondition connect_condition,
+    typename enable_if<is_endpoint_sequence<
+        EndpointSequence>::value>::type*)
+{
+  asio::error_code ec;
+  typename Protocol::endpoint result = connect(
+      s, endpoints, connect_condition, ec);
+  asio::detail::throw_error(ec, "connect");
+  return result;
+}
+
+template <typename Protocol ASIO_SVC_TPARAM,
+    typename EndpointSequence, typename ConnectCondition>
+typename Protocol::endpoint connect(
+    basic_socket<Protocol ASIO_SVC_TARG>& s,
+    const EndpointSequence& endpoints, ConnectCondition connect_condition,
+    asio::error_code& ec,
+    typename enable_if<is_endpoint_sequence<
+        EndpointSequence>::value>::type*)
+{
+  typename EndpointSequence::iterator iter = connect(
+      s, endpoints.begin(), endpoints.end(), connect_condition, ec);
+  return ec ? typename Protocol::endpoint() : *iter;
+}
+
+#if !defined(ASIO_NO_DEPRECATED)
+template <typename Protocol ASIO_SVC_TPARAM,
     typename Iterator, typename ConnectCondition>
-Iterator connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, ConnectCondition connect_condition)
+Iterator connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
+    Iterator begin, ConnectCondition connect_condition,
+    typename enable_if<!is_endpoint_sequence<Iterator>::value>::type*)
 {
   asio::error_code ec;
   Iterator result = connect(s, begin, connect_condition, ec);
@@ -87,18 +148,20 @@ Iterator connect(basic_socket<Protocol, SocketService>& s,
   return result;
 }
 
-template <typename Protocol, typename SocketService,
+template <typename Protocol ASIO_SVC_TPARAM,
     typename Iterator, typename ConnectCondition>
-inline Iterator connect(basic_socket<Protocol, SocketService>& s,
+inline Iterator connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
     Iterator begin, ConnectCondition connect_condition,
-    asio::error_code& ec)
+    asio::error_code& ec,
+    typename enable_if<!is_endpoint_sequence<Iterator>::value>::type*)
 {
   return connect(s, begin, Iterator(), connect_condition, ec);
 }
+#endif // !defined(ASIO_NO_DEPRECATED)
 
-template <typename Protocol, typename SocketService,
+template <typename Protocol ASIO_SVC_TPARAM,
     typename Iterator, typename ConnectCondition>
-Iterator connect(basic_socket<Protocol, SocketService>& s,
+Iterator connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
     Iterator begin, Iterator end, ConnectCondition connect_condition)
 {
   asio::error_code ec;
@@ -107,9 +170,9 @@ Iterator connect(basic_socket<Protocol, SocketService>& s,
   return result;
 }
 
-template <typename Protocol, typename SocketService,
+template <typename Protocol ASIO_SVC_TPARAM,
     typename Iterator, typename ConnectCondition>
-Iterator connect(basic_socket<Protocol, SocketService>& s,
+Iterator connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
     Iterator begin, Iterator end, ConnectCondition connect_condition,
     asio::error_code& ec)
 {
@@ -117,8 +180,7 @@ Iterator connect(basic_socket<Protocol, SocketService>& s,
 
   for (Iterator iter = begin; iter != end; ++iter)
   {
-    iter = connect_condition(ec, iter);
-    if (iter != end)
+    if (connect_condition(ec, iter))
     {
       s.close(ec);
       s.connect(*iter, ec);
@@ -146,12 +208,11 @@ namespace detail
     {
     }
 
-    template <typename Iterator>
-    void check_condition(const asio::error_code& ec,
-        Iterator& iter, Iterator& end)
+    template <typename Endpoint>
+    bool check_condition(const asio::error_code& ec,
+        const Endpoint& endpoint)
     {
-      if (iter != end)
-        iter = connect_condition_(ec, static_cast<const Iterator&>(iter));
+      return connect_condition_(ec, endpoint);
     }
 
   private:
@@ -168,32 +229,193 @@ namespace detail
     {
     }
 
-    template <typename Iterator>
-    void check_condition(const asio::error_code&, Iterator&, Iterator&)
+    template <typename Endpoint>
+    bool check_condition(const asio::error_code&, const Endpoint&)
     {
+      return true;
     }
   };
 
-  template <typename Protocol, typename SocketService, typename Iterator,
-      typename ConnectCondition, typename ComposedConnectHandler>
-  class connect_op : base_from_connect_condition<ConnectCondition>
+  template <typename Protocol ASIO_SVC_TPARAM,
+      typename EndpointSequence, typename ConnectCondition,
+      typename RangeConnectHandler>
+  class range_connect_op : base_from_connect_condition<ConnectCondition>
   {
   public:
-    connect_op(basic_socket<Protocol, SocketService>& sock,
+    range_connect_op(basic_socket<Protocol ASIO_SVC_TARG>& sock,
+        const EndpointSequence& endpoints,
+        const ConnectCondition& connect_condition,
+        RangeConnectHandler& handler)
+      : base_from_connect_condition<ConnectCondition>(connect_condition),
+        socket_(sock),
+        endpoints_(endpoints),
+        index_(0),
+        start_(0),
+        handler_(ASIO_MOVE_CAST(RangeConnectHandler)(handler))
+    {
+    }
+
+#if defined(ASIO_HAS_MOVE)
+    range_connect_op(const range_connect_op& other)
+      : base_from_connect_condition<ConnectCondition>(other),
+        socket_(other.socket_),
+        endpoints_(other.endpoints_),
+        index_(other.index_),
+        start_(other.start_),
+        handler_(other.handler_)
+    {
+    }
+
+    range_connect_op(range_connect_op&& other)
+      : base_from_connect_condition<ConnectCondition>(other),
+        socket_(other.socket_),
+        endpoints_(other.endpoints_),
+        index_(other.index_),
+        start_(other.start_),
+        handler_(ASIO_MOVE_CAST(RangeConnectHandler)(other.handler_))
+    {
+    }
+#endif // defined(ASIO_HAS_MOVE)
+
+    void operator()(asio::error_code ec, int start = 0)
+    {
+      typename EndpointSequence::iterator iter = endpoints_.begin();
+      std::advance(iter, index_);
+      typename EndpointSequence::iterator end = endpoints_.end();
+
+      switch (start_ = start)
+      {
+        case 1:
+        for (;;)
+        {
+          for (; iter != end; ++iter, ++index_)
+            if (this->check_condition(ec, *iter))
+              break;
+
+          if (iter != end)
+          {
+            socket_.close(ec);
+            socket_.async_connect(*iter,
+                ASIO_MOVE_CAST(range_connect_op)(*this));
+            return;
+          }
+
+          if (start)
+          {
+            ec = asio::error::not_found;
+            asio::post(socket_.get_executor(),
+                detail::bind_handler(
+                  ASIO_MOVE_CAST(range_connect_op)(*this), ec));
+            return;
+          }
+
+          default:
+
+          if (iter == end)
+            break;
+
+          if (!socket_.is_open())
+          {
+            ec = asio::error::operation_aborted;
+            break;
+          }
+
+          if (!ec)
+            break;
+
+          ++iter;
+          ++index_;
+        }
+
+        handler_(static_cast<const asio::error_code&>(ec),
+            static_cast<const typename Protocol::endpoint&>(
+              ec || iter == end ? typename Protocol::endpoint() : *iter));
+      }
+    }
+
+  //private:
+    basic_socket<Protocol ASIO_SVC_TARG>& socket_;
+    EndpointSequence endpoints_;
+    std::size_t index_;
+    int start_;
+    RangeConnectHandler handler_;
+  };
+
+  template <typename Protocol ASIO_SVC_TPARAM,
+      typename EndpointSequence, typename ConnectCondition,
+      typename RangeConnectHandler>
+  inline void* asio_handler_allocate(std::size_t size,
+      range_connect_op<Protocol ASIO_SVC_TARG, EndpointSequence,
+        ConnectCondition, RangeConnectHandler>* this_handler)
+  {
+    return asio_handler_alloc_helpers::allocate(
+        size, this_handler->handler_);
+  }
+
+  template <typename Protocol ASIO_SVC_TPARAM,
+      typename EndpointSequence, typename ConnectCondition,
+      typename RangeConnectHandler>
+  inline void asio_handler_deallocate(void* pointer, std::size_t size,
+      range_connect_op<Protocol ASIO_SVC_TARG, EndpointSequence,
+        ConnectCondition, RangeConnectHandler>* this_handler)
+  {
+    asio_handler_alloc_helpers::deallocate(
+        pointer, size, this_handler->handler_);
+  }
+
+  template <typename Protocol ASIO_SVC_TPARAM,
+      typename EndpointSequence, typename ConnectCondition,
+      typename RangeConnectHandler>
+  inline bool asio_handler_is_continuation(
+      range_connect_op<Protocol ASIO_SVC_TARG, EndpointSequence,
+        ConnectCondition, RangeConnectHandler>* this_handler)
+  {
+    return asio_handler_cont_helpers::is_continuation(
+        this_handler->handler_);
+  }
+
+  template <typename Function, typename Protocol
+      ASIO_SVC_TPARAM, typename EndpointSequence,
+      typename ConnectCondition, typename RangeConnectHandler>
+  inline void asio_handler_invoke(Function& function,
+      range_connect_op<Protocol ASIO_SVC_TARG, EndpointSequence,
+        ConnectCondition, RangeConnectHandler>* this_handler)
+  {
+    asio_handler_invoke_helpers::invoke(
+        function, this_handler->handler_);
+  }
+
+  template <typename Function, typename Protocol
+      ASIO_SVC_TPARAM, typename EndpointSequence,
+      typename ConnectCondition, typename RangeConnectHandler>
+  inline void asio_handler_invoke(const Function& function,
+      range_connect_op<Protocol ASIO_SVC_TARG, EndpointSequence,
+        ConnectCondition, RangeConnectHandler>* this_handler)
+  {
+    asio_handler_invoke_helpers::invoke(
+        function, this_handler->handler_);
+  }
+
+  template <typename Protocol ASIO_SVC_TPARAM, typename Iterator,
+      typename ConnectCondition, typename IteratorConnectHandler>
+  class iterator_connect_op : base_from_connect_condition<ConnectCondition>
+  {
+  public:
+    iterator_connect_op(basic_socket<Protocol ASIO_SVC_TARG>& sock,
         const Iterator& begin, const Iterator& end,
         const ConnectCondition& connect_condition,
-        ComposedConnectHandler& handler)
+        IteratorConnectHandler& handler)
       : base_from_connect_condition<ConnectCondition>(connect_condition),
         socket_(sock),
         iter_(begin),
         end_(end),
         start_(0),
-        handler_(ASIO_MOVE_CAST(ComposedConnectHandler)(handler))
+        handler_(ASIO_MOVE_CAST(IteratorConnectHandler)(handler))
     {
     }
 
 #if defined(ASIO_HAS_MOVE)
-    connect_op(const connect_op& other)
+    iterator_connect_op(const iterator_connect_op& other)
       : base_from_connect_condition<ConnectCondition>(other),
         socket_(other.socket_),
         iter_(other.iter_),
@@ -203,13 +425,13 @@ namespace detail
     {
     }
 
-    connect_op(connect_op&& other)
+    iterator_connect_op(iterator_connect_op&& other)
       : base_from_connect_condition<ConnectCondition>(other),
         socket_(other.socket_),
         iter_(other.iter_),
         end_(other.end_),
         start_(other.start_),
-        handler_(ASIO_MOVE_CAST(ComposedConnectHandler)(other.handler_))
+        handler_(ASIO_MOVE_CAST(IteratorConnectHandler)(other.handler_))
     {
     }
 #endif // defined(ASIO_HAS_MOVE)
@@ -221,13 +443,15 @@ namespace detail
         case 1:
         for (;;)
         {
-          this->check_condition(ec, iter_, end_);
+          for (; iter_ != end_; ++iter_)
+            if (this->check_condition(ec, *iter_))
+              break;
 
           if (iter_ != end_)
           {
             socket_.close(ec);
             socket_.async_connect(*iter_,
-                ASIO_MOVE_CAST(connect_op)(*this));
+                ASIO_MOVE_CAST(iterator_connect_op)(*this));
             return;
           }
 
@@ -235,7 +459,8 @@ namespace detail
           {
             ec = asio::error::not_found;
             asio::post(socket_.get_executor(),
-                detail::bind_handler(*this, ec));
+                detail::bind_handler(
+                  ASIO_MOVE_CAST(iterator_connect_op)(*this), ec));
             return;
           }
 
@@ -262,60 +487,60 @@ namespace detail
     }
 
   //private:
-    basic_socket<Protocol, SocketService>& socket_;
+    basic_socket<Protocol ASIO_SVC_TARG>& socket_;
     Iterator iter_;
     Iterator end_;
     int start_;
-    ComposedConnectHandler handler_;
+    IteratorConnectHandler handler_;
   };
 
-  template <typename Protocol, typename SocketService, typename Iterator,
-      typename ConnectCondition, typename ComposedConnectHandler>
+  template <typename Protocol ASIO_SVC_TPARAM, typename Iterator,
+      typename ConnectCondition, typename IteratorConnectHandler>
   inline void* asio_handler_allocate(std::size_t size,
-      connect_op<Protocol, SocketService, Iterator,
-        ConnectCondition, ComposedConnectHandler>* this_handler)
+      iterator_connect_op<Protocol ASIO_SVC_TARG, Iterator,
+        ConnectCondition, IteratorConnectHandler>* this_handler)
   {
     return asio_handler_alloc_helpers::allocate(
         size, this_handler->handler_);
   }
 
-  template <typename Protocol, typename SocketService, typename Iterator,
-      typename ConnectCondition, typename ComposedConnectHandler>
+  template <typename Protocol ASIO_SVC_TPARAM, typename Iterator,
+      typename ConnectCondition, typename IteratorConnectHandler>
   inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      connect_op<Protocol, SocketService, Iterator,
-        ConnectCondition, ComposedConnectHandler>* this_handler)
+      iterator_connect_op<Protocol ASIO_SVC_TARG, Iterator,
+        ConnectCondition, IteratorConnectHandler>* this_handler)
   {
     asio_handler_alloc_helpers::deallocate(
         pointer, size, this_handler->handler_);
   }
 
-  template <typename Protocol, typename SocketService, typename Iterator,
-      typename ConnectCondition, typename ComposedConnectHandler>
+  template <typename Protocol ASIO_SVC_TPARAM, typename Iterator,
+      typename ConnectCondition, typename IteratorConnectHandler>
   inline bool asio_handler_is_continuation(
-      connect_op<Protocol, SocketService, Iterator,
-        ConnectCondition, ComposedConnectHandler>* this_handler)
+      iterator_connect_op<Protocol ASIO_SVC_TARG, Iterator,
+        ConnectCondition, IteratorConnectHandler>* this_handler)
   {
     return asio_handler_cont_helpers::is_continuation(
         this_handler->handler_);
   }
 
-  template <typename Function, typename Protocol,
-      typename SocketService, typename Iterator,
-      typename ConnectCondition, typename ComposedConnectHandler>
+  template <typename Function, typename Protocol
+      ASIO_SVC_TPARAM, typename Iterator,
+      typename ConnectCondition, typename IteratorConnectHandler>
   inline void asio_handler_invoke(Function& function,
-      connect_op<Protocol, SocketService, Iterator,
-        ConnectCondition, ComposedConnectHandler>* this_handler)
+      iterator_connect_op<Protocol ASIO_SVC_TARG, Iterator,
+        ConnectCondition, IteratorConnectHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
         function, this_handler->handler_);
   }
 
-  template <typename Function, typename Protocol,
-      typename SocketService, typename Iterator,
-      typename ConnectCondition, typename ComposedConnectHandler>
+  template <typename Function, typename Protocol
+      ASIO_SVC_TPARAM, typename Iterator,
+      typename ConnectCondition, typename IteratorConnectHandler>
   inline void asio_handler_invoke(const Function& function,
-      connect_op<Protocol, SocketService, Iterator,
-        ConnectCondition, ComposedConnectHandler>* this_handler)
+      iterator_connect_op<Protocol ASIO_SVC_TARG, Iterator,
+        ConnectCondition, IteratorConnectHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
         function, this_handler->handler_);
@@ -324,144 +549,249 @@ namespace detail
 
 #if !defined(GENERATING_DOCUMENTATION)
 
-template <typename Protocol, typename SocketService,
+template <typename Protocol ASIO_SVC_TPARAM,
+    typename EndpointSequence, typename ConnectCondition,
+    typename RangeConnectHandler, typename Allocator>
+struct associated_allocator<
+    detail::range_connect_op<Protocol ASIO_SVC_TARG,
+      EndpointSequence, ConnectCondition, RangeConnectHandler>,
+    Allocator>
+{
+  typedef typename associated_allocator<
+      RangeConnectHandler, Allocator>::type type;
+
+  static type get(
+      const detail::range_connect_op<Protocol ASIO_SVC_TARG,
+        EndpointSequence, ConnectCondition, RangeConnectHandler>& h,
+      const Allocator& a = Allocator()) ASIO_NOEXCEPT
+  {
+    return associated_allocator<RangeConnectHandler,
+        Allocator>::get(h.handler_, a);
+  }
+};
+
+template <typename Protocol ASIO_SVC_TPARAM,
+    typename EndpointSequence, typename ConnectCondition,
+    typename RangeConnectHandler, typename Executor>
+struct associated_executor<
+    detail::range_connect_op<Protocol ASIO_SVC_TARG,
+      EndpointSequence, ConnectCondition, RangeConnectHandler>,
+    Executor>
+{
+  typedef typename associated_executor<
+      RangeConnectHandler, Executor>::type type;
+
+  static type get(
+      const detail::range_connect_op<Protocol ASIO_SVC_TARG,
+        EndpointSequence, ConnectCondition, RangeConnectHandler>& h,
+      const Executor& ex = Executor()) ASIO_NOEXCEPT
+  {
+    return associated_executor<RangeConnectHandler,
+        Executor>::get(h.handler_, ex);
+  }
+};
+
+template <typename Protocol ASIO_SVC_TPARAM,
     typename Iterator, typename ConnectCondition,
-    typename ComposedConnectHandler, typename Allocator>
+    typename IteratorConnectHandler, typename Allocator>
 struct associated_allocator<
-    detail::connect_op<Protocol, SocketService, Iterator,
-      ConnectCondition, ComposedConnectHandler>,
+    detail::iterator_connect_op<Protocol ASIO_SVC_TARG, Iterator,
+      ConnectCondition, IteratorConnectHandler>,
     Allocator>
 {
   typedef typename associated_allocator<
-      ComposedConnectHandler, Allocator>::type type;
+      IteratorConnectHandler, Allocator>::type type;
 
   static type get(
-      const detail::connect_op<Protocol, SocketService,
-        Iterator, ConnectCondition, ComposedConnectHandler>& h,
+      const detail::iterator_connect_op<Protocol ASIO_SVC_TARG,
+        Iterator, ConnectCondition, IteratorConnectHandler>& h,
       const Allocator& a = Allocator()) ASIO_NOEXCEPT
   {
-    return associated_allocator<ComposedConnectHandler,
+    return associated_allocator<IteratorConnectHandler,
         Allocator>::get(h.handler_, a);
   }
 };
 
-template <typename Protocol, typename SocketService,
+template <typename Protocol ASIO_SVC_TPARAM,
     typename Iterator, typename ConnectCondition,
-    typename ComposedConnectHandler, typename Executor>
+    typename IteratorConnectHandler, typename Executor>
 struct associated_executor<
-    detail::connect_op<Protocol, SocketService, Iterator,
-      ConnectCondition, ComposedConnectHandler>,
+    detail::iterator_connect_op<Protocol ASIO_SVC_TARG, Iterator,
+      ConnectCondition, IteratorConnectHandler>,
     Executor>
 {
   typedef typename associated_executor<
-      ComposedConnectHandler, Executor>::type type;
+      IteratorConnectHandler, Executor>::type type;
 
   static type get(
-      const detail::connect_op<Protocol, SocketService,
-        Iterator, ConnectCondition, ComposedConnectHandler>& h,
+      const detail::iterator_connect_op<Protocol ASIO_SVC_TARG,
+        Iterator, ConnectCondition, IteratorConnectHandler>& h,
       const Executor& ex = Executor()) ASIO_NOEXCEPT
   {
-    return associated_executor<ComposedConnectHandler,
+    return associated_executor<IteratorConnectHandler,
         Executor>::get(h.handler_, ex);
   }
 };
 
 #endif // !defined(GENERATING_DOCUMENTATION)
 
-template <typename Protocol, typename SocketService,
-    typename Iterator, typename ComposedConnectHandler>
-inline ASIO_INITFN_RESULT_TYPE(ComposedConnectHandler,
+template <typename Protocol ASIO_SVC_TPARAM,
+    typename EndpointSequence, typename RangeConnectHandler>
+inline ASIO_INITFN_RESULT_TYPE(RangeConnectHandler,
+    void (asio::error_code, typename Protocol::endpoint))
+async_connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
+    const EndpointSequence& endpoints,
+    ASIO_MOVE_ARG(RangeConnectHandler) handler,
+    typename enable_if<is_endpoint_sequence<
+        EndpointSequence>::value>::type*)
+{
+  // If you get an error on the following line it means that your handler does
+  // not meet the documented type requirements for a RangeConnectHandler.
+  ASIO_RANGE_CONNECT_HANDLER_CHECK(
+      RangeConnectHandler, handler, typename Protocol::endpoint) type_check;
+
+  async_completion<RangeConnectHandler,
+    void (asio::error_code, typename Protocol::endpoint)>
+      init(handler);
+
+  detail::range_connect_op<Protocol ASIO_SVC_TARG, EndpointSequence,
+    detail::default_connect_condition,
+      ASIO_HANDLER_TYPE(RangeConnectHandler,
+        void (asio::error_code, typename Protocol::endpoint))>(s,
+          endpoints, detail::default_connect_condition(),
+            init.completion_handler)(asio::error_code(), 1);
+
+  return init.result.get();
+}
+
+#if !defined(ASIO_NO_DEPRECATED)
+template <typename Protocol ASIO_SVC_TPARAM,
+    typename Iterator, typename IteratorConnectHandler>
+inline ASIO_INITFN_RESULT_TYPE(IteratorConnectHandler,
     void (asio::error_code, Iterator))
-async_connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, ASIO_MOVE_ARG(ComposedConnectHandler) handler)
+async_connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
+    Iterator begin, ASIO_MOVE_ARG(IteratorConnectHandler) handler,
+    typename enable_if<!is_endpoint_sequence<Iterator>::value>::type*)
 {
   // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ComposedConnectHandler.
-  ASIO_COMPOSED_CONNECT_HANDLER_CHECK(
-      ComposedConnectHandler, handler, Iterator) type_check;
+  // not meet the documented type requirements for a IteratorConnectHandler.
+  ASIO_ITERATOR_CONNECT_HANDLER_CHECK(
+      IteratorConnectHandler, handler, Iterator) type_check;
 
-  async_completion<ComposedConnectHandler,
+  async_completion<IteratorConnectHandler,
     void (asio::error_code, Iterator)> init(handler);
 
-  detail::connect_op<Protocol, SocketService, Iterator,
+  detail::iterator_connect_op<Protocol ASIO_SVC_TARG, Iterator,
     detail::default_connect_condition, ASIO_HANDLER_TYPE(
-      ComposedConnectHandler, void (asio::error_code, Iterator))>(s,
-        begin, Iterator(), detail::default_connect_condition(), init.handler)(
-          asio::error_code(), 1);
+      IteratorConnectHandler, void (asio::error_code, Iterator))>(s,
+        begin, Iterator(), detail::default_connect_condition(),
+          init.completion_handler)(asio::error_code(), 1);
 
   return init.result.get();
 }
+#endif // !defined(ASIO_NO_DEPRECATED)
 
-template <typename Protocol, typename SocketService,
-    typename Iterator, typename ComposedConnectHandler>
-inline ASIO_INITFN_RESULT_TYPE(ComposedConnectHandler,
+template <typename Protocol ASIO_SVC_TPARAM,
+    typename Iterator, typename IteratorConnectHandler>
+inline ASIO_INITFN_RESULT_TYPE(IteratorConnectHandler,
     void (asio::error_code, Iterator))
-async_connect(basic_socket<Protocol, SocketService>& s,
+async_connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
     Iterator begin, Iterator end,
-    ASIO_MOVE_ARG(ComposedConnectHandler) handler)
+    ASIO_MOVE_ARG(IteratorConnectHandler) handler)
 {
   // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ComposedConnectHandler.
-  ASIO_COMPOSED_CONNECT_HANDLER_CHECK(
-      ComposedConnectHandler, handler, Iterator) type_check;
+  // not meet the documented type requirements for a IteratorConnectHandler.
+  ASIO_ITERATOR_CONNECT_HANDLER_CHECK(
+      IteratorConnectHandler, handler, Iterator) type_check;
 
-  async_completion<ComposedConnectHandler,
+  async_completion<IteratorConnectHandler,
     void (asio::error_code, Iterator)> init(handler);
 
-  detail::connect_op<Protocol, SocketService, Iterator,
+  detail::iterator_connect_op<Protocol ASIO_SVC_TARG, Iterator,
     detail::default_connect_condition, ASIO_HANDLER_TYPE(
-      ComposedConnectHandler, void (asio::error_code, Iterator))>(s,
-        begin, end, detail::default_connect_condition(), init.handler)(
+      IteratorConnectHandler, void (asio::error_code, Iterator))>(s,
+        begin, end, detail::default_connect_condition(),
+          init.completion_handler)(asio::error_code(), 1);
+
+  return init.result.get();
+}
+
+template <typename Protocol ASIO_SVC_TPARAM, typename EndpointSequence,
+    typename ConnectCondition, typename RangeConnectHandler>
+inline ASIO_INITFN_RESULT_TYPE(RangeConnectHandler,
+    void (asio::error_code, typename Protocol::endpoint))
+async_connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
+    const EndpointSequence& endpoints, ConnectCondition connect_condition,
+    ASIO_MOVE_ARG(RangeConnectHandler) handler,
+    typename enable_if<is_endpoint_sequence<
+        EndpointSequence>::value>::type*)
+{
+  // If you get an error on the following line it means that your handler does
+  // not meet the documented type requirements for a RangeConnectHandler.
+  ASIO_RANGE_CONNECT_HANDLER_CHECK(
+      RangeConnectHandler, handler, typename Protocol::endpoint) type_check;
+
+  async_completion<RangeConnectHandler,
+    void (asio::error_code, typename Protocol::endpoint)>
+      init(handler);
+
+  detail::range_connect_op<Protocol ASIO_SVC_TARG, EndpointSequence,
+    ConnectCondition, ASIO_HANDLER_TYPE(RangeConnectHandler,
+      void (asio::error_code, typename Protocol::endpoint))>(s,
+        endpoints, connect_condition, init.completion_handler)(
           asio::error_code(), 1);
 
   return init.result.get();
 }
 
-template <typename Protocol, typename SocketService, typename Iterator,
-    typename ConnectCondition, typename ComposedConnectHandler>
-inline ASIO_INITFN_RESULT_TYPE(ComposedConnectHandler,
+#if !defined(ASIO_NO_DEPRECATED)
+template <typename Protocol ASIO_SVC_TPARAM, typename Iterator,
+    typename ConnectCondition, typename IteratorConnectHandler>
+inline ASIO_INITFN_RESULT_TYPE(IteratorConnectHandler,
     void (asio::error_code, Iterator))
-async_connect(basic_socket<Protocol, SocketService>& s,
+async_connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
     Iterator begin, ConnectCondition connect_condition,
-    ASIO_MOVE_ARG(ComposedConnectHandler) handler)
+    ASIO_MOVE_ARG(IteratorConnectHandler) handler,
+    typename enable_if<!is_endpoint_sequence<Iterator>::value>::type*)
 {
   // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ComposedConnectHandler.
-  ASIO_COMPOSED_CONNECT_HANDLER_CHECK(
-      ComposedConnectHandler, handler, Iterator) type_check;
+  // not meet the documented type requirements for a IteratorConnectHandler.
+  ASIO_ITERATOR_CONNECT_HANDLER_CHECK(
+      IteratorConnectHandler, handler, Iterator) type_check;
 
-  async_completion<ComposedConnectHandler,
+  async_completion<IteratorConnectHandler,
     void (asio::error_code, Iterator)> init(handler);
 
-  detail::connect_op<Protocol, SocketService, Iterator,
+  detail::iterator_connect_op<Protocol ASIO_SVC_TARG, Iterator,
     ConnectCondition, ASIO_HANDLER_TYPE(
-      ComposedConnectHandler, void (asio::error_code, Iterator))>(s,
-        begin, Iterator(), connect_condition, init.handler)(
+      IteratorConnectHandler, void (asio::error_code, Iterator))>(s,
+        begin, Iterator(), connect_condition, init.completion_handler)(
           asio::error_code(), 1);
 
   return init.result.get();
 }
+#endif // !defined(ASIO_NO_DEPRECATED)
 
-template <typename Protocol, typename SocketService, typename Iterator,
-    typename ConnectCondition, typename ComposedConnectHandler>
-inline ASIO_INITFN_RESULT_TYPE(ComposedConnectHandler,
+template <typename Protocol ASIO_SVC_TPARAM, typename Iterator,
+    typename ConnectCondition, typename IteratorConnectHandler>
+inline ASIO_INITFN_RESULT_TYPE(IteratorConnectHandler,
     void (asio::error_code, Iterator))
-async_connect(basic_socket<Protocol, SocketService>& s,
+async_connect(basic_socket<Protocol ASIO_SVC_TARG>& s,
     Iterator begin, Iterator end, ConnectCondition connect_condition,
-    ASIO_MOVE_ARG(ComposedConnectHandler) handler)
+    ASIO_MOVE_ARG(IteratorConnectHandler) handler)
 {
   // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ComposedConnectHandler.
-  ASIO_COMPOSED_CONNECT_HANDLER_CHECK(
-      ComposedConnectHandler, handler, Iterator) type_check;
+  // not meet the documented type requirements for a IteratorConnectHandler.
+  ASIO_ITERATOR_CONNECT_HANDLER_CHECK(
+      IteratorConnectHandler, handler, Iterator) type_check;
 
-  async_completion<ComposedConnectHandler,
+  async_completion<IteratorConnectHandler,
     void (asio::error_code, Iterator)> init(handler);
 
-  detail::connect_op<Protocol, SocketService, Iterator,
+  detail::iterator_connect_op<Protocol ASIO_SVC_TARG, Iterator,
     ConnectCondition, ASIO_HANDLER_TYPE(
-      ComposedConnectHandler, void (asio::error_code, Iterator))>(s,
-        begin, end, connect_condition, init.handler)(
+      IteratorConnectHandler, void (asio::error_code, Iterator))>(s,
+        begin, end, connect_condition, init.completion_handler)(
           asio::error_code(), 1);
 
   return init.result.get();
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/defer.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/defer.hpp
index 5a12176..cf76ba5 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/defer.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/defer.hpp
@@ -2,7 +2,7 @@
 // impl/defer.hpp
 // ~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -28,18 +28,19 @@ template <typename CompletionToken>
 ASIO_INITFN_RESULT_TYPE(CompletionToken, void()) defer(
     ASIO_MOVE_ARG(CompletionToken) token)
 {
-  typedef typename handler_type<CompletionToken, void()>::type handler;
-  async_completion<CompletionToken, void()> completion(token);
+  typedef ASIO_HANDLER_TYPE(CompletionToken, void()) handler;
+
+  async_completion<CompletionToken, void()> init(token);
 
   typename associated_executor<handler>::type ex(
-      (get_associated_executor)(completion.handler));
+      (get_associated_executor)(init.completion_handler));
 
   typename associated_allocator<handler>::type alloc(
-      (get_associated_allocator)(completion.handler));
+      (get_associated_allocator)(init.completion_handler));
 
-  ex.defer(ASIO_MOVE_CAST(handler)(completion.handler), alloc);
+  ex.defer(ASIO_MOVE_CAST(handler)(init.completion_handler), alloc);
 
-  return completion.result.get();
+  return init.result.get();
 }
 
 template <typename Executor, typename CompletionToken>
@@ -47,17 +48,18 @@ ASIO_INITFN_RESULT_TYPE(CompletionToken, void()) defer(
     const Executor& ex, ASIO_MOVE_ARG(CompletionToken) token,
     typename enable_if<is_executor<Executor>::value>::type*)
 {
-  typedef typename handler_type<CompletionToken, void()>::type handler;
-  async_completion<CompletionToken, void()> completion(token);
+  typedef ASIO_HANDLER_TYPE(CompletionToken, void()) handler;
+
+  async_completion<CompletionToken, void()> init(token);
 
   Executor ex1(ex);
 
   typename associated_allocator<handler>::type alloc(
-      (get_associated_allocator)(completion.handler));
+      (get_associated_allocator)(init.completion_handler));
 
-  ex1.defer(detail::work_dispatcher<handler>(completion.handler), alloc);
+  ex1.defer(detail::work_dispatcher<handler>(init.completion_handler), alloc);
 
-  return completion.result.get();
+  return init.result.get();
 }
 
 template <typename ExecutionContext, typename CompletionToken>
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/dispatch.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/dispatch.hpp
index 42d5fa9..cfebc5c 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/dispatch.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/dispatch.hpp
@@ -2,7 +2,7 @@
 // impl/dispatch.hpp
 // ~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -28,18 +28,19 @@ template <typename CompletionToken>
 ASIO_INITFN_RESULT_TYPE(CompletionToken, void()) dispatch(
     ASIO_MOVE_ARG(CompletionToken) token)
 {
-  typedef typename handler_type<CompletionToken, void()>::type handler;
-  async_completion<CompletionToken, void()> completion(token);
+  typedef ASIO_HANDLER_TYPE(CompletionToken, void()) handler;
+
+  async_completion<CompletionToken, void()> init(token);
 
   typename associated_executor<handler>::type ex(
-      (get_associated_executor)(completion.handler));
+      (get_associated_executor)(init.completion_handler));
 
   typename associated_allocator<handler>::type alloc(
-      (get_associated_allocator)(completion.handler));
+      (get_associated_allocator)(init.completion_handler));
 
-  ex.dispatch(ASIO_MOVE_CAST(handler)(completion.handler), alloc);
+  ex.dispatch(ASIO_MOVE_CAST(handler)(init.completion_handler), alloc);
 
-  return completion.result.get();
+  return init.result.get();
 }
 
 template <typename Executor, typename CompletionToken>
@@ -47,17 +48,19 @@ ASIO_INITFN_RESULT_TYPE(CompletionToken, void()) dispatch(
     const Executor& ex, ASIO_MOVE_ARG(CompletionToken) token,
     typename enable_if<is_executor<Executor>::value>::type*)
 {
-  typedef typename handler_type<CompletionToken, void()>::type handler;
-  async_completion<CompletionToken, void()> completion(token);
+  typedef ASIO_HANDLER_TYPE(CompletionToken, void()) handler;
+
+  async_completion<CompletionToken, void()> init(token);
 
   Executor ex1(ex);
 
   typename associated_allocator<handler>::type alloc(
-      (get_associated_allocator)(completion.handler));
+      (get_associated_allocator)(init.completion_handler));
 
-  ex1.dispatch(detail::work_dispatcher<handler>(completion.handler), alloc);
+  ex1.dispatch(detail::work_dispatcher<handler>(
+        init.completion_handler), alloc);
 
-  return completion.result.get();
+  return init.result.get();
 }
 
 template <typename ExecutionContext, typename CompletionToken>
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/error.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/error.ipp
index fc59d0b..7351785 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/error.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/error.ipp
@@ -2,7 +2,7 @@
 // impl/error.ipp
 // ~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/error_code.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/error_code.ipp
index 4e7badb..c986812 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/error_code.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/error_code.ipp
@@ -2,7 +2,7 @@
 // impl/error_code.ipp
 // ~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -44,28 +44,14 @@ public:
 
   std::string message(int value) const
   {
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-    char* msg = 0;
-    DWORD length = ::FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER
-        | FORMAT_MESSAGE_FROM_SYSTEM
-        | FORMAT_MESSAGE_IGNORE_INSERTS, 0, value,
-        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (char*)&msg, 0, 0);
-    detail::local_free_on_block_exit local_free_obj(msg);
-    if (length && msg[length - 1] == '\n')
-      msg[--length] = '\0';
-    if (length && msg[length - 1] == '\r')
-      msg[--length] = '\0';
-    if (length)
-      return msg;
-    else
-      return "asio.system error";
-#elif defined(ASIO_WINDOWS_RUNTIME)
+#if defined(ASIO_WINDOWS_RUNTIME) || defined(ASIO_WINDOWS_APP)
     std::wstring wmsg(128, wchar_t());
     for (;;)
     {
       DWORD wlength = ::FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM
           | FORMAT_MESSAGE_IGNORE_INSERTS, 0, value,
-          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), &wmsg[0], wmsg.size(), 0);
+          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
+          &wmsg[0], static_cast<DWORD>(wmsg.size()), 0);
       if (wlength == 0 && ::GetLastError() == ERROR_INSUFFICIENT_BUFFER)
       {
         wmsg.resize(wmsg.size() + wmsg.size() / 2);
@@ -89,7 +75,22 @@ public:
       else
         return "asio.system error";
     }
-#else // defined(ASIO_WINDOWS)
+#elif defined(ASIO_WINDOWS) || defined(__CYGWIN__)
+    char* msg = 0;
+    DWORD length = ::FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER
+        | FORMAT_MESSAGE_FROM_SYSTEM
+        | FORMAT_MESSAGE_IGNORE_INSERTS, 0, value,
+        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (char*)&msg, 0, 0);
+    detail::local_free_on_block_exit local_free_obj(msg);
+    if (length && msg[length - 1] == '\n')
+      msg[--length] = '\0';
+    if (length && msg[length - 1] == '\r')
+      msg[--length] = '\0';
+    if (length)
+      return msg;
+    else
+      return "asio.system error";
+#else // defined(ASIO_WINDOWS_DESKTOP) || defined(__CYGWIN__)
 #if !defined(__sun)
     if (value == ECANCELED)
       return "Operation aborted.";
@@ -97,19 +98,12 @@ public:
 #if defined(__sun) || defined(__QNX__) || defined(__SYMBIAN32__)
     using namespace std;
     return strerror(value);
-#elif defined(__MACH__) && defined(__APPLE__) \
-  || defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__) \
-  || defined(_AIX) || defined(__hpux) || defined(__osf__) \
-  || defined(__ANDROID__)
-    char buf[256] = "";
-    using namespace std;
-    strerror_r(value, buf, sizeof(buf));
-    return buf;
 #else
     char buf[256] = "";
-    return strerror_r(value, buf, sizeof(buf));
+    using namespace std;
+    return strerror_result(strerror_r(value, buf, sizeof(buf)), buf);
 #endif
-#endif // defined(ASIO_WINDOWS)
+#endif // defined(ASIO_WINDOWS_DESKTOP) || defined(__CYGWIN__)
   }
 
 #if defined(ASIO_HAS_STD_ERROR_CODE)
@@ -190,6 +184,11 @@ public:
       return std::make_error_condition(ev, *this);
   }
 #endif // defined(ASIO_HAS_STD_ERROR_CODE)
+
+private:
+  // Helper function to adapt the result from glibc's variant of strerror_r.
+  static const char* strerror_result(int, const char* s) { return s; }
+  static const char* strerror_result(const char* s, const char*) { return s; }
 };
 
 } // namespace detail
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/execution_context.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/execution_context.hpp
index 06c64ad..2e44ec1 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/execution_context.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/execution_context.hpp
@@ -2,7 +2,7 @@
 // impl/execution_context.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -28,7 +28,6 @@ inline Service& use_service(execution_context& e)
 {
   // Check that Service meets the necessary type requirements.
   (void)static_cast<execution_context::service*>(static_cast<Service*>(0));
-  (void)static_cast<const execution_context::id*>(&Service::id);
 
   return e.service_registry_->template use_service<Service>();
 }
@@ -83,7 +82,6 @@ inline void add_service(execution_context& e, Service* svc)
 {
   // Check that Service meets the necessary type requirements.
   (void)static_cast<execution_context::service*>(static_cast<Service*>(0));
-  (void)static_cast<const execution_context::id*>(&Service::id);
 
   e.service_registry_->template add_service<Service>(svc);
 }
@@ -93,7 +91,6 @@ inline bool has_service(execution_context& e)
 {
   // Check that Service meets the necessary type requirements.
   (void)static_cast<execution_context::service*>(static_cast<Service*>(0));
-  (void)static_cast<const execution_context::id*>(&Service::id);
 
   return e.service_registry_->template has_service<Service>();
 }
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/execution_context.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/execution_context.ipp
index 5019b23..40bb263 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/execution_context.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/execution_context.ipp
@@ -2,7 +2,7 @@
 // impl/execution_context.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -30,17 +30,17 @@ execution_context::execution_context()
 
 execution_context::~execution_context()
 {
-  shutdown_context();
-  destroy_context();
+  shutdown();
+  destroy();
   delete service_registry_;
 }
 
-void execution_context::shutdown_context()
+void execution_context::shutdown()
 {
   service_registry_->shutdown_services();
 }
 
-void execution_context::destroy_context()
+void execution_context::destroy()
 {
   service_registry_->destroy_services();
 }
@@ -61,7 +61,7 @@ execution_context::service::~service()
 {
 }
 
-void execution_context::service::fork_service(execution_context::fork_event)
+void execution_context::service::notify_fork(execution_context::fork_event)
 {
 }
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/executor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/executor.hpp
index d8bc403..eb83e5c 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/executor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/executor.hpp
@@ -2,7 +2,7 @@
 // impl/executor.hpp
 // ~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -197,9 +197,9 @@ public:
     executor_.defer(ASIO_MOVE_CAST(function)(f), allocator_);
   }
 
-  const std::type_info& target_type() const ASIO_NOEXCEPT
+  type_id_result_type target_type() const ASIO_NOEXCEPT
   {
-    return typeid(Executor);
+    return type_id<Executor>();
   }
 
   void* target() ASIO_NOEXCEPT
@@ -306,9 +306,9 @@ public:
     executor_.defer(ASIO_MOVE_CAST(function)(f), allocator_);
   }
 
-  const std::type_info& target_type() const ASIO_NOEXCEPT
+  type_id_result_type target_type() const ASIO_NOEXCEPT
   {
-    return typeid(system_executor);
+    return type_id<system_executor>();
   }
 
   void* target() ASIO_NOEXCEPT
@@ -344,7 +344,8 @@ executor::executor(allocator_arg_t, const Allocator& a, Executor e)
 }
 
 template <typename Function, typename Allocator>
-void executor::dispatch(ASIO_MOVE_ARG(Function) f, const Allocator& a)
+void executor::dispatch(ASIO_MOVE_ARG(Function) f,
+    const Allocator& a) const
 {
   impl_base* i = get_impl();
   if (i->fast_dispatch_)
@@ -354,13 +355,15 @@ void executor::dispatch(ASIO_MOVE_ARG(Function) f, const Allocator& a)
 }
 
 template <typename Function, typename Allocator>
-void executor::post(ASIO_MOVE_ARG(Function) f, const Allocator& a)
+void executor::post(ASIO_MOVE_ARG(Function) f,
+    const Allocator& a) const
 {
   get_impl()->post(function(ASIO_MOVE_CAST(Function)(f), a));
 }
 
 template <typename Function, typename Allocator>
-void executor::defer(ASIO_MOVE_ARG(Function) f, const Allocator& a)
+void executor::defer(ASIO_MOVE_ARG(Function) f,
+    const Allocator& a) const
 {
   get_impl()->defer(function(ASIO_MOVE_CAST(Function)(f), a));
 }
@@ -368,18 +371,18 @@ void executor::defer(ASIO_MOVE_ARG(Function) f, const Allocator& a)
 template <typename Executor>
 Executor* executor::target() ASIO_NOEXCEPT
 {
-  return impl_ && impl_->target_type() == typeid(Executor)
+  return impl_ && impl_->target_type() == type_id<Executor>()
     ? static_cast<Executor*>(impl_->target()) : 0;
 }
 
 template <typename Executor>
 const Executor* executor::target() const ASIO_NOEXCEPT
 {
-  return impl_ && impl_->target_type() == typeid(Executor)
+  return impl_ && impl_->target_type() == type_id<Executor>()
     ? static_cast<Executor*>(impl_->target()) : 0;
 }
 
-#endif // !defined(ASIO_NO_DEPRECATED)
+#endif // !defined(GENERATING_DOCUMENTATION)
 
 } // namespace asio
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/executor.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/executor.ipp
index 23e3f08..605333e 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/executor.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/executor.ipp
@@ -2,7 +2,7 @@
 // impl/executor.ipp
 // ~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/handler_alloc_hook.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/handler_alloc_hook.ipp
index e8d52ba..f4bcdf9 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/handler_alloc_hook.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/handler_alloc_hook.ipp
@@ -2,7 +2,7 @@
 // impl/handler_alloc_hook.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/io_context.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/io_context.hpp
new file mode 100644
index 0000000..45805ae
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/io_context.hpp
@@ -0,0 +1,359 @@
+//
+// impl/io_context.hpp
+// ~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_IMPL_IO_CONTEXT_HPP
+#define ASIO_IMPL_IO_CONTEXT_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/completion_handler.hpp"
+#include "asio/detail/executor_op.hpp"
+#include "asio/detail/fenced_block.hpp"
+#include "asio/detail/handler_type_requirements.hpp"
+#include "asio/detail/recycling_allocator.hpp"
+#include "asio/detail/service_registry.hpp"
+#include "asio/detail/throw_error.hpp"
+#include "asio/detail/type_traits.hpp"
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+
+template <typename Service>
+inline Service& use_service(io_context& ioc)
+{
+  // Check that Service meets the necessary type requirements.
+  (void)static_cast<execution_context::service*>(static_cast<Service*>(0));
+  (void)static_cast<const execution_context::id*>(&Service::id);
+
+  return ioc.service_registry_->template use_service<Service>(ioc);
+}
+
+template <>
+inline detail::io_context_impl& use_service<detail::io_context_impl>(
+    io_context& ioc)
+{
+  return ioc.impl_;
+}
+
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#if defined(ASIO_HAS_IOCP)
+# include "asio/detail/win_iocp_io_context.hpp"
+#else
+# include "asio/detail/scheduler.hpp"
+#endif
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+
+inline io_context::executor_type
+io_context::get_executor() ASIO_NOEXCEPT
+{
+  return executor_type(*this);
+}
+
+#if defined(ASIO_HAS_CHRONO)
+
+template <typename Rep, typename Period>
+std::size_t io_context::run_for(
+    const chrono::duration<Rep, Period>& rel_time)
+{
+  return this->run_until(chrono::steady_clock::now() + rel_time);
+}
+
+template <typename Clock, typename Duration>
+std::size_t io_context::run_until(
+    const chrono::time_point<Clock, Duration>& abs_time)
+{
+  std::size_t n = 0;
+  while (this->run_one_until(abs_time))
+    if (n != (std::numeric_limits<std::size_t>::max)())
+      ++n;
+  return n;
+}
+
+template <typename Rep, typename Period>
+std::size_t io_context::run_one_for(
+    const chrono::duration<Rep, Period>& rel_time)
+{
+  return this->run_one_until(chrono::steady_clock::now() + rel_time);
+}
+
+template <typename Clock, typename Duration>
+std::size_t io_context::run_one_until(
+    const chrono::time_point<Clock, Duration>& abs_time)
+{
+  typename Clock::time_point now = Clock::now();
+  while (now < abs_time)
+  {
+    typename Clock::duration rel_time = abs_time - now;
+    if (rel_time > chrono::seconds(1))
+      rel_time = chrono::seconds(1);
+
+    asio::error_code ec;
+    std::size_t s = impl_.wait_one(
+        static_cast<long>(chrono::duration_cast<
+          chrono::microseconds>(rel_time).count()), ec);
+    asio::detail::throw_error(ec);
+
+    if (s || impl_.stopped())
+      return s;
+
+    now = Clock::now();
+  }
+
+  return 0;
+}
+
+#endif // defined(ASIO_HAS_CHRONO)
+
+#if !defined(ASIO_NO_DEPRECATED)
+
+inline void io_context::reset()
+{
+  restart();
+}
+
+template <typename CompletionHandler>
+ASIO_INITFN_RESULT_TYPE(CompletionHandler, void ())
+io_context::dispatch(ASIO_MOVE_ARG(CompletionHandler) handler)
+{
+  // If you get an error on the following line it means that your handler does
+  // not meet the documented type requirements for a CompletionHandler.
+  ASIO_COMPLETION_HANDLER_CHECK(CompletionHandler, handler) type_check;
+
+  async_completion<CompletionHandler, void ()> init(handler);
+
+  if (impl_.can_dispatch())
+  {
+    detail::fenced_block b(detail::fenced_block::full);
+    asio_handler_invoke_helpers::invoke(
+        init.completion_handler, init.completion_handler);
+  }
+  else
+  {
+    // Allocate and construct an operation to wrap the handler.
+    typedef detail::completion_handler<
+      typename handler_type<CompletionHandler, void ()>::type> op;
+    typename op::ptr p = { detail::addressof(init.completion_handler),
+      op::ptr::allocate(init.completion_handler), 0 };
+    p.p = new (p.v) op(init.completion_handler);
+
+    ASIO_HANDLER_CREATION((*this, *p.p,
+          "io_context", this, 0, "dispatch"));
+
+    impl_.do_dispatch(p.p);
+    p.v = p.p = 0;
+  }
+
+  return init.result.get();
+}
+
+template <typename CompletionHandler>
+ASIO_INITFN_RESULT_TYPE(CompletionHandler, void ())
+io_context::post(ASIO_MOVE_ARG(CompletionHandler) handler)
+{
+  // If you get an error on the following line it means that your handler does
+  // not meet the documented type requirements for a CompletionHandler.
+  ASIO_COMPLETION_HANDLER_CHECK(CompletionHandler, handler) type_check;
+
+  async_completion<CompletionHandler, void ()> init(handler);
+
+  bool is_continuation =
+    asio_handler_cont_helpers::is_continuation(init.completion_handler);
+
+  // Allocate and construct an operation to wrap the handler.
+  typedef detail::completion_handler<
+    typename handler_type<CompletionHandler, void ()>::type> op;
+  typename op::ptr p = { detail::addressof(init.completion_handler),
+      op::ptr::allocate(init.completion_handler), 0 };
+  p.p = new (p.v) op(init.completion_handler);
+
+  ASIO_HANDLER_CREATION((*this, *p.p,
+        "io_context", this, 0, "post"));
+
+  impl_.post_immediate_completion(p.p, is_continuation);
+  p.v = p.p = 0;
+
+  return init.result.get();
+}
+
+template <typename Handler>
+#if defined(GENERATING_DOCUMENTATION)
+unspecified
+#else
+inline detail::wrapped_handler<io_context&, Handler>
+#endif
+io_context::wrap(Handler handler)
+{
+  return detail::wrapped_handler<io_context&, Handler>(*this, handler);
+}
+
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+inline io_context&
+io_context::executor_type::context() const ASIO_NOEXCEPT
+{
+  return io_context_;
+}
+
+inline void
+io_context::executor_type::on_work_started() const ASIO_NOEXCEPT
+{
+  io_context_.impl_.work_started();
+}
+
+inline void
+io_context::executor_type::on_work_finished() const ASIO_NOEXCEPT
+{
+  io_context_.impl_.work_finished();
+}
+
+template <typename Function, typename Allocator>
+void io_context::executor_type::dispatch(
+    ASIO_MOVE_ARG(Function) f, const Allocator& a) const
+{
+  // Make a local, non-const copy of the function.
+  typedef typename decay<Function>::type function_type;
+  function_type tmp(ASIO_MOVE_CAST(Function)(f));
+
+  // Invoke immediately if we are already inside the thread pool.
+  if (io_context_.impl_.can_dispatch())
+  {
+    detail::fenced_block b(detail::fenced_block::full);
+    asio_handler_invoke_helpers::invoke(tmp, tmp);
+    return;
+  }
+
+  // Construct an allocator to be used for the operation.
+  typedef typename detail::get_recycling_allocator<Allocator>::type alloc_type;
+  alloc_type allocator(detail::get_recycling_allocator<Allocator>::get(a));
+
+  // Allocate and construct an operation to wrap the function.
+  typedef detail::executor_op<function_type, alloc_type, detail::operation> op;
+  typename op::ptr p = { allocator, 0, 0 };
+  p.v = p.a.allocate(1);
+  p.p = new (p.v) op(tmp, allocator);
+
+  ASIO_HANDLER_CREATION((this->context(), *p.p,
+        "io_context", &this->context(), 0, "post"));
+
+  io_context_.impl_.post_immediate_completion(p.p, false);
+  p.v = p.p = 0;
+}
+
+template <typename Function, typename Allocator>
+void io_context::executor_type::post(
+    ASIO_MOVE_ARG(Function) f, const Allocator& a) const
+{
+  // Make a local, non-const copy of the function.
+  typedef typename decay<Function>::type function_type;
+  function_type tmp(ASIO_MOVE_CAST(Function)(f));
+
+  // Construct an allocator to be used for the operation.
+  typedef typename detail::get_recycling_allocator<Allocator>::type alloc_type;
+  alloc_type allocator(detail::get_recycling_allocator<Allocator>::get(a));
+
+  // Allocate and construct an operation to wrap the function.
+  typedef detail::executor_op<function_type, alloc_type, detail::operation> op;
+  typename op::ptr p = { allocator, 0, 0 };
+  p.v = p.a.allocate(1);
+  p.p = new (p.v) op(tmp, allocator);
+
+  ASIO_HANDLER_CREATION((this->context(), *p.p,
+        "io_context", &this->context(), 0, "post"));
+
+  io_context_.impl_.post_immediate_completion(p.p, false);
+  p.v = p.p = 0;
+}
+
+template <typename Function, typename Allocator>
+void io_context::executor_type::defer(
+    ASIO_MOVE_ARG(Function) f, const Allocator& a) const
+{
+  // Make a local, non-const copy of the function.
+  typedef typename decay<Function>::type function_type;
+  function_type tmp(ASIO_MOVE_CAST(Function)(f));
+
+  // Construct an allocator to be used for the operation.
+  typedef typename detail::get_recycling_allocator<Allocator>::type alloc_type;
+  alloc_type allocator(detail::get_recycling_allocator<Allocator>::get(a));
+
+  // Allocate and construct an operation to wrap the function.
+  typedef detail::executor_op<function_type, alloc_type, detail::operation> op;
+  typename op::ptr p = { allocator, 0, 0 };
+  p.v = p.a.allocate(1);
+  p.p = new (p.v) op(tmp, allocator);
+
+  ASIO_HANDLER_CREATION((this->context(), *p.p,
+        "io_context", &this->context(), 0, "defer"));
+
+  io_context_.impl_.post_immediate_completion(p.p, true);
+  p.v = p.p = 0;
+}
+
+inline bool
+io_context::executor_type::running_in_this_thread() const ASIO_NOEXCEPT
+{
+  return io_context_.impl_.can_dispatch();
+}
+
+#if !defined(ASIO_NO_DEPRECATED)
+inline io_context::work::work(asio::io_context& io_context)
+  : io_context_impl_(io_context.impl_)
+{
+  io_context_impl_.work_started();
+}
+
+inline io_context::work::work(const work& other)
+  : io_context_impl_(other.io_context_impl_)
+{
+  io_context_impl_.work_started();
+}
+
+inline io_context::work::~work()
+{
+  io_context_impl_.work_finished();
+}
+
+inline asio::io_context& io_context::work::get_io_context()
+{
+  return static_cast<asio::io_context&>(io_context_impl_.context());
+}
+
+inline asio::io_context& io_context::work::get_io_service()
+{
+  return static_cast<asio::io_context&>(io_context_impl_.context());
+}
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+inline asio::io_context& io_context::service::get_io_context()
+{
+  return static_cast<asio::io_context&>(context());
+}
+
+#if !defined(ASIO_NO_DEPRECATED)
+inline asio::io_context& io_context::service::get_io_service()
+{
+  return static_cast<asio::io_context&>(context());
+}
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // ASIO_IMPL_IO_CONTEXT_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/io_context.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/io_context.ipp
new file mode 100644
index 0000000..b78ec1e
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/io_context.ipp
@@ -0,0 +1,174 @@
+//
+// impl/io_context.ipp
+// ~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_IMPL_IO_CONTEXT_IPP
+#define ASIO_IMPL_IO_CONTEXT_IPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+#include "asio/io_context.hpp"
+#include "asio/detail/concurrency_hint.hpp"
+#include "asio/detail/limits.hpp"
+#include "asio/detail/scoped_ptr.hpp"
+#include "asio/detail/service_registry.hpp"
+#include "asio/detail/throw_error.hpp"
+
+#if defined(ASIO_HAS_IOCP)
+# include "asio/detail/win_iocp_io_context.hpp"
+#else
+# include "asio/detail/scheduler.hpp"
+#endif
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+
+io_context::io_context()
+  : impl_(add_impl(new impl_type(*this, ASIO_CONCURRENCY_HINT_DEFAULT)))
+{
+}
+
+io_context::io_context(int concurrency_hint)
+  : impl_(add_impl(new impl_type(*this, concurrency_hint == 1
+          ? ASIO_CONCURRENCY_HINT_1 : concurrency_hint)))
+{
+}
+
+io_context::impl_type& io_context::add_impl(io_context::impl_type* impl)
+{
+  asio::detail::scoped_ptr<impl_type> scoped_impl(impl);
+  asio::add_service<impl_type>(*this, scoped_impl.get());
+  return *scoped_impl.release();
+}
+
+io_context::~io_context()
+{
+}
+
+io_context::count_type io_context::run()
+{
+  asio::error_code ec;
+  count_type s = impl_.run(ec);
+  asio::detail::throw_error(ec);
+  return s;
+}
+
+#if !defined(ASIO_NO_DEPRECATED)
+io_context::count_type io_context::run(asio::error_code& ec)
+{
+  return impl_.run(ec);
+}
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+io_context::count_type io_context::run_one()
+{
+  asio::error_code ec;
+  count_type s = impl_.run_one(ec);
+  asio::detail::throw_error(ec);
+  return s;
+}
+
+#if !defined(ASIO_NO_DEPRECATED)
+io_context::count_type io_context::run_one(asio::error_code& ec)
+{
+  return impl_.run_one(ec);
+}
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+io_context::count_type io_context::poll()
+{
+  asio::error_code ec;
+  count_type s = impl_.poll(ec);
+  asio::detail::throw_error(ec);
+  return s;
+}
+
+#if !defined(ASIO_NO_DEPRECATED)
+io_context::count_type io_context::poll(asio::error_code& ec)
+{
+  return impl_.poll(ec);
+}
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+io_context::count_type io_context::poll_one()
+{
+  asio::error_code ec;
+  count_type s = impl_.poll_one(ec);
+  asio::detail::throw_error(ec);
+  return s;
+}
+
+#if !defined(ASIO_NO_DEPRECATED)
+io_context::count_type io_context::poll_one(asio::error_code& ec)
+{
+  return impl_.poll_one(ec);
+}
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+void io_context::stop()
+{
+  impl_.stop();
+}
+
+bool io_context::stopped() const
+{
+  return impl_.stopped();
+}
+
+void io_context::restart()
+{
+  impl_.restart();
+}
+
+io_context::service::service(asio::io_context& owner)
+  : execution_context::service(owner)
+{
+}
+
+io_context::service::~service()
+{
+}
+
+void io_context::service::shutdown()
+{
+#if !defined(ASIO_NO_DEPRECATED)
+  shutdown_service();
+#endif // !defined(ASIO_NO_DEPRECATED)
+}
+
+#if !defined(ASIO_NO_DEPRECATED)
+void io_context::service::shutdown_service()
+{
+}
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+void io_context::service::notify_fork(io_context::fork_event ev)
+{
+#if !defined(ASIO_NO_DEPRECATED)
+  fork_service(ev);
+#else // !defined(ASIO_NO_DEPRECATED)
+  (void)ev;
+#endif // !defined(ASIO_NO_DEPRECATED)
+}
+
+#if !defined(ASIO_NO_DEPRECATED)
+void io_context::service::fork_service(io_context::fork_event)
+{
+}
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // ASIO_IMPL_IO_CONTEXT_IPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/io_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/io_service.hpp
deleted file mode 100644
index 658c9b4..0000000
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/io_service.hpp
+++ /dev/null
@@ -1,281 +0,0 @@
-//
-// impl/io_service.hpp
-// ~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IMPL_IO_SERVICE_HPP
-#define ASIO_IMPL_IO_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/completion_handler.hpp"
-#include "asio/detail/executor_op.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/recycling_allocator.hpp"
-#include "asio/detail/service_registry.hpp"
-#include "asio/detail/type_traits.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-template <typename Service>
-inline Service& use_service(io_service& ios)
-{
-  // Check that Service meets the necessary type requirements.
-  (void)static_cast<execution_context::service*>(static_cast<Service*>(0));
-  (void)static_cast<const execution_context::id*>(&Service::id);
-
-  return ios.service_registry_->template use_service<Service>(ios);
-}
-
-template <>
-inline detail::io_service_impl& use_service<detail::io_service_impl>(
-    io_service& ios)
-{
-  return ios.impl_;
-}
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-# include "asio/detail/win_iocp_io_service.hpp"
-#else
-# include "asio/detail/scheduler.hpp"
-#endif
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-inline io_service::executor_type
-io_service::get_executor() ASIO_NOEXCEPT
-{
-  return executor_type(*this);
-}
-
-#if !defined(ASIO_NO_DEPRECATED)
-
-inline void io_service::reset()
-{
-  restart();
-}
-
-template <typename CompletionHandler>
-ASIO_INITFN_RESULT_TYPE(CompletionHandler, void ())
-io_service::dispatch(ASIO_MOVE_ARG(CompletionHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a CompletionHandler.
-  ASIO_COMPLETION_HANDLER_CHECK(CompletionHandler, handler) type_check;
-
-  async_completion<CompletionHandler, void ()> init(handler);
-
-  if (impl_.can_dispatch())
-  {
-    detail::fenced_block b(detail::fenced_block::full);
-    asio_handler_invoke_helpers::invoke(init.handler, init.handler);
-  }
-  else
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef detail::completion_handler<
-      typename handler_type<CompletionHandler, void ()>::type> op;
-    typename op::ptr p = { detail::addressof(init.handler),
-      op::ptr::allocate(init.handler), 0 };
-    p.p = new (p.v) op(init.handler);
-
-    ASIO_HANDLER_CREATION((p.p, "io_service", this, "dispatch"));
-
-    impl_.do_dispatch(p.p);
-    p.v = p.p = 0;
-  }
-
-  return init.result.get();
-}
-
-template <typename CompletionHandler>
-ASIO_INITFN_RESULT_TYPE(CompletionHandler, void ())
-io_service::post(ASIO_MOVE_ARG(CompletionHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a CompletionHandler.
-  ASIO_COMPLETION_HANDLER_CHECK(CompletionHandler, handler) type_check;
-
-  async_completion<CompletionHandler, void ()> init(handler);
-
-  bool is_continuation =
-    asio_handler_cont_helpers::is_continuation(init.handler);
-
-  // Allocate and construct an operation to wrap the handler.
-  typedef detail::completion_handler<
-    typename handler_type<CompletionHandler, void ()>::type> op;
-  typename op::ptr p = { detail::addressof(init.handler),
-      op::ptr::allocate(init.handler), 0 };
-  p.p = new (p.v) op(init.handler);
-
-  ASIO_HANDLER_CREATION((p.p, "io_service", this, "post"));
-
-  impl_.post_immediate_completion(p.p, is_continuation);
-  p.v = p.p = 0;
-
-  return init.result.get();
-}
-
-template <typename Handler>
-#if defined(GENERATING_DOCUMENTATION)
-unspecified
-#else
-inline detail::wrapped_handler<io_service&, Handler>
-#endif
-io_service::wrap(Handler handler)
-{
-  return detail::wrapped_handler<io_service&, Handler>(*this, handler);
-}
-
-#endif // !defined(ASIO_NO_DEPRECATED)
-
-inline io_service&
-io_service::executor_type::context() ASIO_NOEXCEPT
-{
-  return io_service_;
-}
-
-inline void io_service::executor_type::on_work_started() ASIO_NOEXCEPT
-{
-  io_service_.impl_.work_started();
-}
-
-inline void io_service::executor_type::on_work_finished() ASIO_NOEXCEPT
-{
-  io_service_.impl_.work_finished();
-}
-
-template <typename Function, typename Allocator>
-void io_service::executor_type::dispatch(
-    ASIO_MOVE_ARG(Function) f, const Allocator& a)
-{
-  // Make a local, non-const copy of the function.
-  typedef typename decay<Function>::type function_type;
-  function_type tmp(ASIO_MOVE_CAST(Function)(f));
-
-  // Invoke immediately if we are already inside the thread pool.
-  if (io_service_.impl_.can_dispatch())
-  {
-    detail::fenced_block b(detail::fenced_block::full);
-    asio_handler_invoke_helpers::invoke(tmp, tmp);
-    return;
-  }
-
-  // Construct an allocator to be used for the operation.
-  typedef typename detail::get_recycling_allocator<Allocator>::type alloc_type;
-  alloc_type allocator(detail::get_recycling_allocator<Allocator>::get(a));
-
-  // Allocate and construct an operation to wrap the function.
-  typedef detail::executor_op<function_type, alloc_type, detail::operation> op;
-  typename op::ptr p = { allocator, 0, 0 };
-  p.v = p.a.allocate(1);
-  p.p = new (p.v) op(tmp, allocator);
-
-  ASIO_HANDLER_CREATION((p.p, "io_service", this, "post"));
-
-  io_service_.impl_.post_immediate_completion(p.p, false);
-  p.v = p.p = 0;
-}
-
-template <typename Function, typename Allocator>
-void io_service::executor_type::post(
-    ASIO_MOVE_ARG(Function) f, const Allocator& a)
-{
-  // Make a local, non-const copy of the function.
-  typedef typename decay<Function>::type function_type;
-  function_type tmp(ASIO_MOVE_CAST(Function)(f));
-
-  // Construct an allocator to be used for the operation.
-  typedef typename detail::get_recycling_allocator<Allocator>::type alloc_type;
-  alloc_type allocator(detail::get_recycling_allocator<Allocator>::get(a));
-
-  // Allocate and construct an operation to wrap the function.
-  typedef detail::executor_op<function_type, alloc_type, detail::operation> op;
-  typename op::ptr p = { allocator, 0, 0 };
-  p.v = p.a.allocate(1);
-  p.p = new (p.v) op(tmp, allocator);
-
-  ASIO_HANDLER_CREATION((p.p, "io_service", this, "post"));
-
-  io_service_.impl_.post_immediate_completion(p.p, false);
-  p.v = p.p = 0;
-}
-
-template <typename Function, typename Allocator>
-void io_service::executor_type::defer(
-    ASIO_MOVE_ARG(Function) f, const Allocator& a)
-{
-  // Make a local, non-const copy of the function.
-  typedef typename decay<Function>::type function_type;
-  function_type tmp(ASIO_MOVE_CAST(Function)(f));
-
-  // Construct an allocator to be used for the operation.
-  typedef typename detail::get_recycling_allocator<Allocator>::type alloc_type;
-  alloc_type allocator(detail::get_recycling_allocator<Allocator>::get(a));
-
-  // Allocate and construct an operation to wrap the function.
-  typedef detail::executor_op<function_type, alloc_type, detail::operation> op;
-  typename op::ptr p = { allocator, 0, 0 };
-  p.v = p.a.allocate(1);
-  p.p = new (p.v) op(tmp, allocator);
-
-  ASIO_HANDLER_CREATION((p.p, "io_service", this, "defer"));
-
-  io_service_.impl_.post_immediate_completion(p.p, true);
-  p.v = p.p = 0;
-}
-
-inline bool
-io_service::executor_type::running_in_this_thread() const ASIO_NOEXCEPT
-{
-  return io_service_.impl_.can_dispatch();
-}
-
-inline io_service::work::work(asio::io_service& io_service)
-  : io_service_impl_(io_service.impl_)
-{
-  io_service_impl_.work_started();
-}
-
-inline io_service::work::work(const work& other)
-  : io_service_impl_(other.io_service_impl_)
-{
-  io_service_impl_.work_started();
-}
-
-inline io_service::work::~work()
-{
-  io_service_impl_.work_finished();
-}
-
-inline asio::io_service& io_service::work::get_io_service()
-{
-  return static_cast<asio::io_service&>(io_service_impl_.context());
-}
-
-inline asio::io_service& io_service::service::get_io_service()
-{
-  return static_cast<asio::io_service&>(context());
-}
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IMPL_IO_SERVICE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/io_service.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/io_service.ipp
deleted file mode 100644
index 7088b81..0000000
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/io_service.ipp
+++ /dev/null
@@ -1,137 +0,0 @@
-//
-// impl/io_service.ipp
-// ~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IMPL_IO_SERVICE_IPP
-#define ASIO_IMPL_IO_SERVICE_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/io_service.hpp"
-#include "asio/detail/limits.hpp"
-#include "asio/detail/scoped_ptr.hpp"
-#include "asio/detail/service_registry.hpp"
-#include "asio/detail/throw_error.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-# include "asio/detail/win_iocp_io_service.hpp"
-#else
-# include "asio/detail/scheduler.hpp"
-#endif
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-io_service::io_service()
-  : impl_(create_impl())
-{
-}
-
-io_service::io_service(std::size_t concurrency_hint)
-  : impl_(create_impl(concurrency_hint))
-{
-}
-
-io_service::impl_type& io_service::create_impl(std::size_t concurrency_hint)
-{
-  asio::detail::scoped_ptr<impl_type> impl(
-      new impl_type(*this, concurrency_hint));
-  asio::add_service<impl_type>(*this, impl.get());
-  return *impl.release();
-}
-
-io_service::~io_service()
-{
-}
-
-std::size_t io_service::run()
-{
-  asio::error_code ec;
-  std::size_t s = impl_.run(ec);
-  asio::detail::throw_error(ec);
-  return s;
-}
-
-std::size_t io_service::run(asio::error_code& ec)
-{
-  return impl_.run(ec);
-}
-
-std::size_t io_service::run_one()
-{
-  asio::error_code ec;
-  std::size_t s = impl_.run_one(ec);
-  asio::detail::throw_error(ec);
-  return s;
-}
-
-std::size_t io_service::run_one(asio::error_code& ec)
-{
-  return impl_.run_one(ec);
-}
-
-std::size_t io_service::poll()
-{
-  asio::error_code ec;
-  std::size_t s = impl_.poll(ec);
-  asio::detail::throw_error(ec);
-  return s;
-}
-
-std::size_t io_service::poll(asio::error_code& ec)
-{
-  return impl_.poll(ec);
-}
-
-std::size_t io_service::poll_one()
-{
-  asio::error_code ec;
-  std::size_t s = impl_.poll_one(ec);
-  asio::detail::throw_error(ec);
-  return s;
-}
-
-std::size_t io_service::poll_one(asio::error_code& ec)
-{
-  return impl_.poll_one(ec);
-}
-
-void io_service::stop()
-{
-  impl_.stop();
-}
-
-bool io_service::stopped() const
-{
-  return impl_.stopped();
-}
-
-void io_service::restart()
-{
-  impl_.restart();
-}
-
-io_service::service::service(asio::io_service& owner)
-  : execution_context::service(owner)
-{
-}
-
-io_service::service::~service()
-{
-}
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IMPL_IO_SERVICE_IPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/post.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/post.hpp
index 5d034d0..293b387 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/post.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/post.hpp
@@ -2,7 +2,7 @@
 // impl/post.hpp
 // ~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -28,18 +28,19 @@ template <typename CompletionToken>
 ASIO_INITFN_RESULT_TYPE(CompletionToken, void()) post(
     ASIO_MOVE_ARG(CompletionToken) token)
 {
-  typedef typename handler_type<CompletionToken, void()>::type handler;
-  async_completion<CompletionToken, void()> completion(token);
+  typedef ASIO_HANDLER_TYPE(CompletionToken, void()) handler;
+
+  async_completion<CompletionToken, void()> init(token);
 
   typename associated_executor<handler>::type ex(
-      (get_associated_executor)(completion.handler));
+      (get_associated_executor)(init.completion_handler));
 
   typename associated_allocator<handler>::type alloc(
-      (get_associated_allocator)(completion.handler));
+      (get_associated_allocator)(init.completion_handler));
 
-  ex.post(ASIO_MOVE_CAST(handler)(completion.handler), alloc);
+  ex.post(ASIO_MOVE_CAST(handler)(init.completion_handler), alloc);
 
-  return completion.result.get();
+  return init.result.get();
 }
 
 template <typename Executor, typename CompletionToken>
@@ -47,17 +48,18 @@ ASIO_INITFN_RESULT_TYPE(CompletionToken, void()) post(
     const Executor& ex, ASIO_MOVE_ARG(CompletionToken) token,
     typename enable_if<is_executor<Executor>::value>::type*)
 {
-  typedef typename handler_type<CompletionToken, void()>::type handler;
-  async_completion<CompletionToken, void()> completion(token);
+  typedef ASIO_HANDLER_TYPE(CompletionToken, void()) handler;
+
+  async_completion<CompletionToken, void()> init(token);
 
   Executor ex1(ex);
 
   typename associated_allocator<handler>::type alloc(
-      (get_associated_allocator)(completion.handler));
+      (get_associated_allocator)(init.completion_handler));
 
-  ex1.post(detail::work_dispatcher<handler>(completion.handler), alloc);
+  ex1.post(detail::work_dispatcher<handler>(init.completion_handler), alloc);
 
-  return completion.result.get();
+  return init.result.get();
 }
 
 template <typename ExecutionContext, typename CompletionToken>
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/read.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/read.hpp
index 031a5b3..385a552 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/read.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/read.hpp
@@ -2,7 +2,7 @@
 // impl/read.hpp
 // ~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -36,6 +36,29 @@
 
 namespace asio {
 
+namespace detail
+{
+  template <typename SyncReadStream, typename MutableBufferSequence,
+      typename MutableBufferIterator, typename CompletionCondition>
+  std::size_t read_buffer_sequence(SyncReadStream& s,
+      const MutableBufferSequence& buffers, const MutableBufferIterator&,
+      CompletionCondition completion_condition, asio::error_code& ec)
+  {
+    ec = asio::error_code();
+    asio::detail::consuming_buffers<mutable_buffer,
+        MutableBufferSequence, MutableBufferIterator> tmp(buffers);
+    while (!tmp.empty())
+    {
+      if (std::size_t max_size = detail::adapt_completion_condition_result(
+            completion_condition(ec, tmp.total_consumed())))
+        tmp.consume(s.read_some(tmp.prepare(max_size), ec));
+      else
+        break;
+    }
+    return tmp.total_consumed();;
+  }
+} // namespace detail
+
 template <typename SyncReadStream, typename MutableBufferSequence,
     typename CompletionCondition>
 std::size_t read(SyncReadStream& s, const MutableBufferSequence& buffers,
@@ -44,21 +67,8 @@ std::size_t read(SyncReadStream& s, const MutableBufferSequence& buffers,
       is_mutable_buffer_sequence<MutableBufferSequence>::value
     >::type*)
 {
-  ec = asio::error_code();
-  asio::detail::consuming_buffers<
-    mutable_buffer, MutableBufferSequence> tmp(buffers);
-  std::size_t total_transferred = 0;
-  tmp.prepare(detail::adapt_completion_condition_result(
-        completion_condition(ec, total_transferred)));
-  while (tmp.begin() != tmp.end())
-  {
-    std::size_t bytes_transferred = s.read_some(tmp, ec);
-    tmp.consume(bytes_transferred);
-    total_transferred += bytes_transferred;
-    tmp.prepare(detail::adapt_completion_condition_result(
-          completion_condition(ec, total_transferred)));
-  }
-  return total_transferred;
+  return detail::read_buffer_sequence(s, buffers,
+      asio::buffer_sequence_begin(buffers), completion_condition, ec);
 }
 
 template <typename SyncReadStream, typename MutableBufferSequence>
@@ -97,17 +107,17 @@ inline std::size_t read(SyncReadStream& s, const MutableBufferSequence& buffers,
   return bytes_transferred;
 }
 
-template <typename SyncReadStream, typename DynamicBufferSequence,
+template <typename SyncReadStream, typename DynamicBuffer,
     typename CompletionCondition>
 std::size_t read(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     CompletionCondition completion_condition, asio::error_code& ec,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type*)
 {
-  typename decay<DynamicBufferSequence>::type b(
-      ASIO_MOVE_CAST(DynamicBufferSequence)(buffers));
+  typename decay<DynamicBuffer>::type b(
+      ASIO_MOVE_CAST(DynamicBuffer)(buffers));
 
   ec = asio::error_code();
   std::size_t total_transferred = 0;
@@ -130,49 +140,50 @@ std::size_t read(SyncReadStream& s,
   return total_transferred;
 }
 
-template <typename SyncReadStream, typename DynamicBufferSequence>
+template <typename SyncReadStream, typename DynamicBuffer>
 inline std::size_t read(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type*)
 {
   asio::error_code ec;
   std::size_t bytes_transferred = read(s,
-      ASIO_MOVE_CAST(DynamicBufferSequence)(buffers), transfer_all(), ec);
+      ASIO_MOVE_CAST(DynamicBuffer)(buffers), transfer_all(), ec);
   asio::detail::throw_error(ec, "read");
   return bytes_transferred;
 }
 
-template <typename SyncReadStream, typename DynamicBufferSequence>
+template <typename SyncReadStream, typename DynamicBuffer>
 inline std::size_t read(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     asio::error_code& ec,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type*)
 {
-  return read(s, ASIO_MOVE_CAST(DynamicBufferSequence)(buffers),
+  return read(s, ASIO_MOVE_CAST(DynamicBuffer)(buffers),
       transfer_all(), ec);
 }
 
-template <typename SyncReadStream, typename DynamicBufferSequence,
+template <typename SyncReadStream, typename DynamicBuffer,
     typename CompletionCondition>
 inline std::size_t read(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     CompletionCondition completion_condition,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type*)
 {
   asio::error_code ec;
   std::size_t bytes_transferred = read(s,
-      ASIO_MOVE_CAST(DynamicBufferSequence)(buffers),
+      ASIO_MOVE_CAST(DynamicBuffer)(buffers),
       completion_condition, ec);
   asio::detail::throw_error(ec, "read");
   return bytes_transferred;
 }
 
+#if !defined(ASIO_NO_EXTENSIONS)
 #if !defined(ASIO_NO_IOSTREAM)
 
 template <typename SyncReadStream, typename Allocator,
@@ -209,11 +220,13 @@ inline std::size_t read(SyncReadStream& s,
 }
 
 #endif // !defined(ASIO_NO_IOSTREAM)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 namespace detail
 {
   template <typename AsyncReadStream, typename MutableBufferSequence,
-      typename CompletionCondition, typename ReadHandler>
+      typename MutableBufferIterator, typename CompletionCondition,
+      typename ReadHandler>
   class read_op
     : detail::base_from_completion_cond<CompletionCondition>
   {
@@ -225,7 +238,6 @@ namespace detail
         stream_(stream),
         buffers_(buffers),
         start_(0),
-        total_transferred_(0),
         handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
     {
     }
@@ -236,7 +248,6 @@ namespace detail
         stream_(other.stream_),
         buffers_(other.buffers_),
         start_(other.start_),
-        total_transferred_(other.total_transferred_),
         handler_(other.handler_)
     {
     }
@@ -246,7 +257,6 @@ namespace detail
         stream_(other.stream_),
         buffers_(other.buffers_),
         start_(other.start_),
-        total_transferred_(other.total_transferred_),
         handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
     {
     }
@@ -255,285 +265,39 @@ namespace detail
     void operator()(const asio::error_code& ec,
         std::size_t bytes_transferred, int start = 0)
     {
+      std::size_t max_size;
       switch (start_ = start)
       {
         case 1:
-        buffers_.prepare(this->check_for_completion(ec, total_transferred_));
-        for (;;)
+        max_size = this->check_for_completion(ec, buffers_.total_consumed());
+        do
         {
-          stream_.async_read_some(buffers_,
+          stream_.async_read_some(buffers_.prepare(max_size),
               ASIO_MOVE_CAST(read_op)(*this));
           return; default:
-          total_transferred_ += bytes_transferred;
           buffers_.consume(bytes_transferred);
-          buffers_.prepare(this->check_for_completion(ec, total_transferred_));
-          if ((!ec && bytes_transferred == 0)
-              || buffers_.begin() == buffers_.end())
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncReadStream& stream_;
-    asio::detail::consuming_buffers<
-      mutable_buffer, MutableBufferSequence> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    ReadHandler handler_;
-  };
-
-  template <typename AsyncReadStream,
-      typename CompletionCondition, typename ReadHandler>
-  class read_op<AsyncReadStream, asio::mutable_buffers_1,
-      CompletionCondition, ReadHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    read_op(AsyncReadStream& stream,
-        const asio::mutable_buffers_1& buffers,
-        CompletionCondition completion_condition, ReadHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        stream_(stream),
-        buffer_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    read_op(const read_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    read_op(read_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          stream_.async_read_some(
-              asio::buffer(buffer_ + total_transferred_, n),
-              ASIO_MOVE_CAST(read_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == asio::buffer_size(buffer_))
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncReadStream& stream_;
-    asio::mutable_buffer buffer_;
-    int start_;
-    std::size_t total_transferred_;
-    ReadHandler handler_;
-  };
-
-  template <typename AsyncReadStream, typename Elem,
-      typename CompletionCondition, typename ReadHandler>
-  class read_op<AsyncReadStream, boost::array<Elem, 2>,
-      CompletionCondition, ReadHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    read_op(AsyncReadStream& stream, const boost::array<Elem, 2>& buffers,
-        CompletionCondition completion_condition, ReadHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        stream_(stream),
-        buffers_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    read_op(const read_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    read_op(read_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      typename asio::detail::dependent_type<Elem,
-          boost::array<asio::mutable_buffer, 2> >::type bufs = {{
-        asio::mutable_buffer(buffers_[0]),
-        asio::mutable_buffer(buffers_[1]) }};
-      std::size_t buffer_size0 = asio::buffer_size(bufs[0]);
-      std::size_t buffer_size1 = asio::buffer_size(bufs[1]);
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          bufs[0] = asio::buffer(bufs[0] + total_transferred_, n);
-          bufs[1] = asio::buffer(
-              bufs[1] + (total_transferred_ < buffer_size0
-                ? 0 : total_transferred_ - buffer_size0),
-              n - asio::buffer_size(bufs[0]));
-          stream_.async_read_some(bufs, ASIO_MOVE_CAST(read_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == buffer_size0 + buffer_size1)
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncReadStream& stream_;
-    boost::array<Elem, 2> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    ReadHandler handler_;
-  };
-
-#if defined(ASIO_HAS_STD_ARRAY)
-
-  template <typename AsyncReadStream, typename Elem,
-      typename CompletionCondition, typename ReadHandler>
-  class read_op<AsyncReadStream, std::array<Elem, 2>,
-      CompletionCondition, ReadHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    read_op(AsyncReadStream& stream, const std::array<Elem, 2>& buffers,
-        CompletionCondition completion_condition, ReadHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        stream_(stream),
-        buffers_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    read_op(const read_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    read_op(read_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      typename asio::detail::dependent_type<Elem,
-          std::array<asio::mutable_buffer, 2> >::type bufs = {{
-        asio::mutable_buffer(buffers_[0]),
-        asio::mutable_buffer(buffers_[1]) }};
-      std::size_t buffer_size0 = asio::buffer_size(bufs[0]);
-      std::size_t buffer_size1 = asio::buffer_size(bufs[1]);
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          bufs[0] = asio::buffer(bufs[0] + total_transferred_, n);
-          bufs[1] = asio::buffer(
-              bufs[1] + (total_transferred_ < buffer_size0
-                ? 0 : total_transferred_ - buffer_size0),
-              n - asio::buffer_size(bufs[0]));
-          stream_.async_read_some(bufs, ASIO_MOVE_CAST(read_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == buffer_size0 + buffer_size1)
+          if ((!ec && bytes_transferred == 0) || buffers_.empty())
             break;
-        }
+          max_size = this->check_for_completion(ec, buffers_.total_consumed());
+        } while (max_size > 0);
 
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
+        handler_(ec, buffers_.total_consumed());
       }
     }
 
   //private:
     AsyncReadStream& stream_;
-    std::array<Elem, 2> buffers_;
+    asio::detail::consuming_buffers<mutable_buffer,
+        MutableBufferSequence, MutableBufferIterator> buffers_;
     int start_;
-    std::size_t total_transferred_;
     ReadHandler handler_;
   };
 
-#endif // defined(ASIO_HAS_STD_ARRAY)
-
   template <typename AsyncReadStream, typename MutableBufferSequence,
-      typename CompletionCondition, typename ReadHandler>
+      typename MutableBufferIterator, typename CompletionCondition,
+      typename ReadHandler>
   inline void* asio_handler_allocate(std::size_t size,
-      read_op<AsyncReadStream, MutableBufferSequence,
+      read_op<AsyncReadStream, MutableBufferSequence, MutableBufferIterator,
         CompletionCondition, ReadHandler>* this_handler)
   {
     return asio_handler_alloc_helpers::allocate(
@@ -541,9 +305,10 @@ namespace detail
   }
 
   template <typename AsyncReadStream, typename MutableBufferSequence,
-      typename CompletionCondition, typename ReadHandler>
+      typename MutableBufferIterator, typename CompletionCondition,
+      typename ReadHandler>
   inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      read_op<AsyncReadStream, MutableBufferSequence,
+      read_op<AsyncReadStream, MutableBufferSequence, MutableBufferIterator,
         CompletionCondition, ReadHandler>* this_handler)
   {
     asio_handler_alloc_helpers::deallocate(
@@ -551,9 +316,10 @@ namespace detail
   }
 
   template <typename AsyncReadStream, typename MutableBufferSequence,
-      typename CompletionCondition, typename ReadHandler>
+      typename MutableBufferIterator, typename CompletionCondition,
+      typename ReadHandler>
   inline bool asio_handler_is_continuation(
-      read_op<AsyncReadStream, MutableBufferSequence,
+      read_op<AsyncReadStream, MutableBufferSequence, MutableBufferIterator,
         CompletionCondition, ReadHandler>* this_handler)
   {
     return this_handler->start_ == 0 ? true
@@ -562,10 +328,10 @@ namespace detail
   }
 
   template <typename Function, typename AsyncReadStream,
-      typename MutableBufferSequence, typename CompletionCondition,
-      typename ReadHandler>
+      typename MutableBufferSequence, typename MutableBufferIterator,
+      typename CompletionCondition, typename ReadHandler>
   inline void asio_handler_invoke(Function& function,
-      read_op<AsyncReadStream, MutableBufferSequence,
+      read_op<AsyncReadStream, MutableBufferSequence, MutableBufferIterator,
         CompletionCondition, ReadHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
@@ -573,31 +339,45 @@ namespace detail
   }
 
   template <typename Function, typename AsyncReadStream,
-      typename MutableBufferSequence, typename CompletionCondition,
-      typename ReadHandler>
+      typename MutableBufferSequence, typename MutableBufferIterator,
+      typename CompletionCondition, typename ReadHandler>
   inline void asio_handler_invoke(const Function& function,
-      read_op<AsyncReadStream, MutableBufferSequence,
+      read_op<AsyncReadStream, MutableBufferSequence, MutableBufferIterator,
         CompletionCondition, ReadHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
         function, this_handler->handler_);
   }
+
+  template <typename AsyncReadStream, typename MutableBufferSequence,
+      typename MutableBufferIterator, typename CompletionCondition,
+      typename ReadHandler>
+  inline void start_read_buffer_sequence_op(AsyncReadStream& stream,
+      const MutableBufferSequence& buffers, const MutableBufferIterator&,
+      CompletionCondition completion_condition, ReadHandler& handler)
+  {
+    detail::read_op<AsyncReadStream, MutableBufferSequence,
+      MutableBufferIterator, CompletionCondition, ReadHandler>(
+        stream, buffers, completion_condition, handler)(
+          asio::error_code(), 0, 1);
+  }
 } // namespace detail
 
 #if !defined(GENERATING_DOCUMENTATION)
 
 template <typename AsyncReadStream, typename MutableBufferSequence,
-    typename CompletionCondition, typename ReadHandler, typename Allocator>
+    typename MutableBufferIterator, typename CompletionCondition,
+    typename ReadHandler, typename Allocator>
 struct associated_allocator<
     detail::read_op<AsyncReadStream, MutableBufferSequence,
-      CompletionCondition, ReadHandler>,
+      MutableBufferIterator, CompletionCondition, ReadHandler>,
     Allocator>
 {
   typedef typename associated_allocator<ReadHandler, Allocator>::type type;
 
   static type get(
       const detail::read_op<AsyncReadStream, MutableBufferSequence,
-        CompletionCondition, ReadHandler>& h,
+        MutableBufferIterator, CompletionCondition, ReadHandler>& h,
       const Allocator& a = Allocator()) ASIO_NOEXCEPT
   {
     return associated_allocator<ReadHandler, Allocator>::get(h.handler_, a);
@@ -605,17 +385,18 @@ struct associated_allocator<
 };
 
 template <typename AsyncReadStream, typename MutableBufferSequence,
-    typename CompletionCondition, typename ReadHandler, typename Executor>
+    typename MutableBufferIterator, typename CompletionCondition,
+    typename ReadHandler, typename Executor>
 struct associated_executor<
     detail::read_op<AsyncReadStream, MutableBufferSequence,
-      CompletionCondition, ReadHandler>,
+      MutableBufferIterator, CompletionCondition, ReadHandler>,
     Executor>
 {
   typedef typename associated_executor<ReadHandler, Executor>::type type;
 
   static type get(
       const detail::read_op<AsyncReadStream, MutableBufferSequence,
-        CompletionCondition, ReadHandler>& h,
+        MutableBufferIterator, CompletionCondition, ReadHandler>& h,
       const Executor& ex = Executor()) ASIO_NOEXCEPT
   {
     return associated_executor<ReadHandler, Executor>::get(h.handler_, ex);
@@ -642,11 +423,9 @@ async_read(AsyncReadStream& s, const MutableBufferSequence& buffers,
   async_completion<ReadHandler,
     void (asio::error_code, std::size_t)> init(handler);
 
-  detail::read_op<AsyncReadStream, MutableBufferSequence,
-    CompletionCondition, ASIO_HANDLER_TYPE(
-      ReadHandler, void (asio::error_code, std::size_t))>(
-        s, buffers, completion_condition, init.handler)(
-          asio::error_code(), 0, 1);
+  detail::start_read_buffer_sequence_op(s, buffers,
+      asio::buffer_sequence_begin(buffers), completion_condition,
+      init.completion_handler);
 
   return init.result.get();
 }
@@ -668,18 +447,16 @@ async_read(AsyncReadStream& s, const MutableBufferSequence& buffers,
   async_completion<ReadHandler,
     void (asio::error_code, std::size_t)> init(handler);
 
-  detail::read_op<AsyncReadStream, MutableBufferSequence,
-    detail::transfer_all_t, ASIO_HANDLER_TYPE(
-      ReadHandler, void (asio::error_code, std::size_t))>(
-        s, buffers, transfer_all(), init.handler)(
-          asio::error_code(), 0, 1);
+  detail::start_read_buffer_sequence_op(s, buffers,
+      asio::buffer_sequence_begin(buffers), transfer_all(),
+      init.completion_handler);
 
   return init.result.get();
 }
 
 namespace detail
 {
-  template <typename AsyncReadStream, typename DynamicBufferSequence,
+  template <typename AsyncReadStream, typename DynamicBuffer,
       typename CompletionCondition, typename ReadHandler>
   class read_dynbuf_op
     : detail::base_from_completion_cond<CompletionCondition>
@@ -713,7 +490,7 @@ namespace detail
     read_dynbuf_op(read_dynbuf_op&& other)
       : detail::base_from_completion_cond<CompletionCondition>(other),
         stream_(other.stream_),
-        buffers_(ASIO_MOVE_CAST(DynamicBufferSequence)(other.buffers_)),
+        buffers_(ASIO_MOVE_CAST(DynamicBuffer)(other.buffers_)),
         start_(other.start_),
         total_transferred_(other.total_transferred_),
         handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
@@ -757,36 +534,36 @@ namespace detail
 
   //private:
     AsyncReadStream& stream_;
-    DynamicBufferSequence buffers_;
+    DynamicBuffer buffers_;
     int start_;
     std::size_t total_transferred_;
     ReadHandler handler_;
   };
 
-  template <typename AsyncReadStream, typename DynamicBufferSequence,
+  template <typename AsyncReadStream, typename DynamicBuffer,
       typename CompletionCondition, typename ReadHandler>
   inline void* asio_handler_allocate(std::size_t size,
-      read_dynbuf_op<AsyncReadStream, DynamicBufferSequence,
+      read_dynbuf_op<AsyncReadStream, DynamicBuffer,
         CompletionCondition, ReadHandler>* this_handler)
   {
     return asio_handler_alloc_helpers::allocate(
         size, this_handler->handler_);
   }
 
-  template <typename AsyncReadStream, typename DynamicBufferSequence,
+  template <typename AsyncReadStream, typename DynamicBuffer,
       typename CompletionCondition, typename ReadHandler>
   inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      read_dynbuf_op<AsyncReadStream, DynamicBufferSequence,
+      read_dynbuf_op<AsyncReadStream, DynamicBuffer,
         CompletionCondition, ReadHandler>* this_handler)
   {
     asio_handler_alloc_helpers::deallocate(
         pointer, size, this_handler->handler_);
   }
 
-  template <typename AsyncReadStream, typename DynamicBufferSequence,
+  template <typename AsyncReadStream, typename DynamicBuffer,
       typename CompletionCondition, typename ReadHandler>
   inline bool asio_handler_is_continuation(
-      read_dynbuf_op<AsyncReadStream, DynamicBufferSequence,
+      read_dynbuf_op<AsyncReadStream, DynamicBuffer,
         CompletionCondition, ReadHandler>* this_handler)
   {
     return this_handler->start_ == 0 ? true
@@ -795,10 +572,10 @@ namespace detail
   }
 
   template <typename Function, typename AsyncReadStream,
-      typename DynamicBufferSequence, typename CompletionCondition,
+      typename DynamicBuffer, typename CompletionCondition,
       typename ReadHandler>
   inline void asio_handler_invoke(Function& function,
-      read_dynbuf_op<AsyncReadStream, DynamicBufferSequence,
+      read_dynbuf_op<AsyncReadStream, DynamicBuffer,
         CompletionCondition, ReadHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
@@ -806,10 +583,10 @@ namespace detail
   }
 
   template <typename Function, typename AsyncReadStream,
-      typename DynamicBufferSequence, typename CompletionCondition,
+      typename DynamicBuffer, typename CompletionCondition,
       typename ReadHandler>
   inline void asio_handler_invoke(const Function& function,
-      read_dynbuf_op<AsyncReadStream, DynamicBufferSequence,
+      read_dynbuf_op<AsyncReadStream, DynamicBuffer,
         CompletionCondition, ReadHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
@@ -819,36 +596,36 @@ namespace detail
 
 #if !defined(GENERATING_DOCUMENTATION)
 
-template <typename AsyncReadStream, typename DynamicBufferSequence,
+template <typename AsyncReadStream, typename DynamicBuffer,
     typename CompletionCondition, typename ReadHandler, typename Allocator>
 struct associated_allocator<
     detail::read_dynbuf_op<AsyncReadStream,
-      DynamicBufferSequence, CompletionCondition, ReadHandler>,
+      DynamicBuffer, CompletionCondition, ReadHandler>,
     Allocator>
 {
   typedef typename associated_allocator<ReadHandler, Allocator>::type type;
 
   static type get(
       const detail::read_dynbuf_op<AsyncReadStream,
-        DynamicBufferSequence, CompletionCondition, ReadHandler>& h,
+        DynamicBuffer, CompletionCondition, ReadHandler>& h,
       const Allocator& a = Allocator()) ASIO_NOEXCEPT
   {
     return associated_allocator<ReadHandler, Allocator>::get(h.handler_, a);
   }
 };
 
-template <typename AsyncReadStream, typename DynamicBufferSequence,
+template <typename AsyncReadStream, typename DynamicBuffer,
     typename CompletionCondition, typename ReadHandler, typename Executor>
 struct associated_executor<
     detail::read_dynbuf_op<AsyncReadStream,
-      DynamicBufferSequence, CompletionCondition, ReadHandler>,
+      DynamicBuffer, CompletionCondition, ReadHandler>,
     Executor>
 {
   typedef typename associated_executor<ReadHandler, Executor>::type type;
 
   static type get(
       const detail::read_dynbuf_op<AsyncReadStream,
-        DynamicBufferSequence, CompletionCondition, ReadHandler>& h,
+        DynamicBuffer, CompletionCondition, ReadHandler>& h,
       const Executor& ex = Executor()) ASIO_NOEXCEPT
   {
     return associated_executor<ReadHandler, Executor>::get(h.handler_, ex);
@@ -858,31 +635,31 @@ struct associated_executor<
 #endif // !defined(GENERATING_DOCUMENTATION)
 
 template <typename AsyncReadStream,
-    typename DynamicBufferSequence, typename ReadHandler>
+    typename DynamicBuffer, typename ReadHandler>
 inline ASIO_INITFN_RESULT_TYPE(ReadHandler,
     void (asio::error_code, std::size_t))
 async_read(AsyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     ASIO_MOVE_ARG(ReadHandler) handler,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type*)
 {
   return async_read(s,
-      ASIO_MOVE_CAST(DynamicBufferSequence)(buffers),
+      ASIO_MOVE_CAST(DynamicBuffer)(buffers),
       transfer_all(), ASIO_MOVE_CAST(ReadHandler)(handler));
 }
 
-template <typename AsyncReadStream, typename DynamicBufferSequence,
+template <typename AsyncReadStream, typename DynamicBuffer,
     typename CompletionCondition, typename ReadHandler>
 inline ASIO_INITFN_RESULT_TYPE(ReadHandler,
     void (asio::error_code, std::size_t))
 async_read(AsyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     CompletionCondition completion_condition,
     ASIO_MOVE_ARG(ReadHandler) handler,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type*)
 {
   // If you get an error on the following line it means that your handler does
@@ -893,16 +670,17 @@ async_read(AsyncReadStream& s,
     void (asio::error_code, std::size_t)> init(handler);
 
   detail::read_dynbuf_op<AsyncReadStream,
-    typename decay<DynamicBufferSequence>::type,
+    typename decay<DynamicBuffer>::type,
       CompletionCondition, ASIO_HANDLER_TYPE(
         ReadHandler, void (asio::error_code, std::size_t))>(
-          s, ASIO_MOVE_CAST(DynamicBufferSequence)(buffers),
-            completion_condition, init.handler)(
+          s, ASIO_MOVE_CAST(DynamicBuffer)(buffers),
+            completion_condition, init.completion_handler)(
               asio::error_code(), 0, 1);
 
   return init.result.get();
 }
 
+#if !defined(ASIO_NO_EXTENSIONS)
 #if !defined(ASIO_NO_IOSTREAM)
 
 template <typename AsyncReadStream, typename Allocator, typename ReadHandler>
@@ -928,6 +706,7 @@ async_read(AsyncReadStream& s, basic_streambuf<Allocator>& b,
 }
 
 #endif // !defined(ASIO_NO_IOSTREAM)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 } // namespace asio
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/read_at.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/read_at.hpp
index 634f035..273312f 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/read_at.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/read_at.hpp
@@ -2,7 +2,7 @@
 // impl/read_at.hpp
 // ~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -36,28 +36,41 @@
 
 namespace asio {
 
+namespace detail
+{
+  template <typename SyncRandomAccessReadDevice, typename MutableBufferSequence,
+      typename MutableBufferIterator, typename CompletionCondition>
+  std::size_t read_at_buffer_sequence(SyncRandomAccessReadDevice& d,
+      uint64_t offset, const MutableBufferSequence& buffers,
+      const MutableBufferIterator&, CompletionCondition completion_condition,
+      asio::error_code& ec)
+  {
+    ec = asio::error_code();
+    asio::detail::consuming_buffers<mutable_buffer,
+        MutableBufferSequence, MutableBufferIterator> tmp(buffers);
+    while (!tmp.empty())
+    {
+      if (std::size_t max_size = detail::adapt_completion_condition_result(
+            completion_condition(ec, tmp.total_consumed())))
+      {
+        tmp.consume(d.read_some_at(offset + tmp.total_consumed(),
+              tmp.prepare(max_size), ec));
+      }
+      else
+        break;
+    }
+    return tmp.total_consumed();;
+  }
+} // namespace detail
+
 template <typename SyncRandomAccessReadDevice, typename MutableBufferSequence,
     typename CompletionCondition>
 std::size_t read_at(SyncRandomAccessReadDevice& d,
     uint64_t offset, const MutableBufferSequence& buffers,
     CompletionCondition completion_condition, asio::error_code& ec)
 {
-  ec = asio::error_code();
-  asio::detail::consuming_buffers<
-    mutable_buffer, MutableBufferSequence> tmp(buffers);
-  std::size_t total_transferred = 0;
-  tmp.prepare(detail::adapt_completion_condition_result(
-        completion_condition(ec, total_transferred)));
-  while (tmp.begin() != tmp.end())
-  {
-    std::size_t bytes_transferred = d.read_some_at(
-        offset + total_transferred, tmp, ec);
-    tmp.consume(bytes_transferred);
-    total_transferred += bytes_transferred;
-    tmp.prepare(detail::adapt_completion_condition_result(
-          completion_condition(ec, total_transferred)));
-  }
-  return total_transferred;
+  return detail::read_at_buffer_sequence(d, offset, buffers,
+      asio::buffer_sequence_begin(buffers), completion_condition, ec);
 }
 
 template <typename SyncRandomAccessReadDevice, typename MutableBufferSequence>
@@ -92,6 +105,7 @@ inline std::size_t read_at(SyncRandomAccessReadDevice& d,
   return bytes_transferred;
 }
 
+#if !defined(ASIO_NO_EXTENSIONS)
 #if !defined(ASIO_NO_IOSTREAM)
 
 template <typename SyncRandomAccessReadDevice, typename Allocator,
@@ -151,12 +165,13 @@ inline std::size_t read_at(SyncRandomAccessReadDevice& d,
 }
 
 #endif // !defined(ASIO_NO_IOSTREAM)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 namespace detail
 {
   template <typename AsyncRandomAccessReadDevice,
-      typename MutableBufferSequence, typename CompletionCondition,
-      typename ReadHandler>
+      typename MutableBufferSequence, typename MutableBufferIterator,
+      typename CompletionCondition, typename ReadHandler>
   class read_at_op
     : detail::base_from_completion_cond<CompletionCondition>
   {
@@ -170,7 +185,6 @@ namespace detail
         offset_(offset),
         buffers_(buffers),
         start_(0),
-        total_transferred_(0),
         handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
     {
     }
@@ -182,7 +196,6 @@ namespace detail
         offset_(other.offset_),
         buffers_(other.buffers_),
         start_(other.start_),
-        total_transferred_(other.total_transferred_),
         handler_(other.handler_)
     {
     }
@@ -193,7 +206,6 @@ namespace detail
         offset_(other.offset_),
         buffers_(other.buffers_),
         start_(other.start_),
-        total_transferred_(other.total_transferred_),
         handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
     {
     }
@@ -202,326 +214,64 @@ namespace detail
     void operator()(const asio::error_code& ec,
         std::size_t bytes_transferred, int start = 0)
     {
+      std::size_t max_size;
       switch (start_ = start)
       {
         case 1:
-        buffers_.prepare(this->check_for_completion(ec, total_transferred_));
-        for (;;)
+        max_size = this->check_for_completion(ec, buffers_.total_consumed());
+        do
         {
-          device_.async_read_some_at(offset_ + total_transferred_,
-              buffers_, ASIO_MOVE_CAST(read_at_op)(*this));
+          device_.async_read_some_at(
+              offset_ + buffers_.total_consumed(), buffers_.prepare(max_size),
+              ASIO_MOVE_CAST(read_at_op)(*this));
           return; default:
-          total_transferred_ += bytes_transferred;
           buffers_.consume(bytes_transferred);
-          buffers_.prepare(this->check_for_completion(ec, total_transferred_));
-          if ((!ec && bytes_transferred == 0)
-              || buffers_.begin() == buffers_.end())
+          if ((!ec && bytes_transferred == 0) || buffers_.empty())
             break;
-        }
+          max_size = this->check_for_completion(ec, buffers_.total_consumed());
+        } while (max_size > 0);
 
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
+        handler_(ec, buffers_.total_consumed());
       }
     }
 
   //private:
     AsyncRandomAccessReadDevice& device_;
     uint64_t offset_;
-    asio::detail::consuming_buffers<
-      mutable_buffer, MutableBufferSequence> buffers_;
+    asio::detail::consuming_buffers<mutable_buffer,
+        MutableBufferSequence, MutableBufferIterator> buffers_;
     int start_;
-    std::size_t total_transferred_;
     ReadHandler handler_;
   };
 
   template <typename AsyncRandomAccessReadDevice,
+      typename MutableBufferSequence, typename MutableBufferIterator,
       typename CompletionCondition, typename ReadHandler>
-  class read_at_op<AsyncRandomAccessReadDevice,
-      asio::mutable_buffers_1, CompletionCondition, ReadHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    read_at_op(AsyncRandomAccessReadDevice& device,
-        uint64_t offset, const asio::mutable_buffers_1& buffers,
-        CompletionCondition completion_condition, ReadHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        device_(device),
-        offset_(offset),
-        buffer_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    read_at_op(const read_at_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    read_at_op(read_at_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          device_.async_read_some_at(offset_ + total_transferred_,
-              asio::buffer(buffer_ + total_transferred_, n),
-              ASIO_MOVE_CAST(read_at_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == asio::buffer_size(buffer_))
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncRandomAccessReadDevice& device_;
-    uint64_t offset_;
-    asio::mutable_buffer buffer_;
-    int start_;
-    std::size_t total_transferred_;
-    ReadHandler handler_;
-  };
-
-  template <typename AsyncRandomAccessReadDevice, typename Elem,
-      typename CompletionCondition, typename ReadHandler>
-  class read_at_op<AsyncRandomAccessReadDevice, boost::array<Elem, 2>,
-      CompletionCondition, ReadHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    read_at_op(AsyncRandomAccessReadDevice& device,
-        uint64_t offset, const boost::array<Elem, 2>& buffers,
-        CompletionCondition completion_condition, ReadHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        device_(device),
-        offset_(offset),
-        buffers_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    read_at_op(const read_at_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    read_at_op(read_at_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      typename asio::detail::dependent_type<Elem,
-          boost::array<asio::mutable_buffer, 2> >::type bufs = {{
-        asio::mutable_buffer(buffers_[0]),
-        asio::mutable_buffer(buffers_[1]) }};
-      std::size_t buffer_size0 = asio::buffer_size(bufs[0]);
-      std::size_t buffer_size1 = asio::buffer_size(bufs[1]);
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          bufs[0] = asio::buffer(bufs[0] + total_transferred_, n);
-          bufs[1] = asio::buffer(
-              bufs[1] + (total_transferred_ < buffer_size0
-                ? 0 : total_transferred_ - buffer_size0),
-              n - asio::buffer_size(bufs[0]));
-          device_.async_read_some_at(offset_ + total_transferred_,
-              bufs, ASIO_MOVE_CAST(read_at_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == buffer_size0 + buffer_size1)
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncRandomAccessReadDevice& device_;
-    uint64_t offset_;
-    boost::array<Elem, 2> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    ReadHandler handler_;
-  };
-
-#if defined(ASIO_HAS_STD_ARRAY)
-
-  template <typename AsyncRandomAccessReadDevice, typename Elem,
-      typename CompletionCondition, typename ReadHandler>
-  class read_at_op<AsyncRandomAccessReadDevice, std::array<Elem, 2>,
-      CompletionCondition, ReadHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    read_at_op(AsyncRandomAccessReadDevice& device,
-        uint64_t offset, const std::array<Elem, 2>& buffers,
-        CompletionCondition completion_condition, ReadHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        device_(device),
-        offset_(offset),
-        buffers_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    read_at_op(const read_at_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    read_at_op(read_at_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      typename asio::detail::dependent_type<Elem,
-          std::array<asio::mutable_buffer, 2> >::type bufs = {{
-        asio::mutable_buffer(buffers_[0]),
-        asio::mutable_buffer(buffers_[1]) }};
-      std::size_t buffer_size0 = asio::buffer_size(bufs[0]);
-      std::size_t buffer_size1 = asio::buffer_size(bufs[1]);
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          bufs[0] = asio::buffer(bufs[0] + total_transferred_, n);
-          bufs[1] = asio::buffer(
-              bufs[1] + (total_transferred_ < buffer_size0
-                ? 0 : total_transferred_ - buffer_size0),
-              n - asio::buffer_size(bufs[0]));
-          device_.async_read_some_at(offset_ + total_transferred_,
-              bufs, ASIO_MOVE_CAST(read_at_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == buffer_size0 + buffer_size1)
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncRandomAccessReadDevice& device_;
-    uint64_t offset_;
-    std::array<Elem, 2> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    ReadHandler handler_;
-  };
-
-#endif // defined(ASIO_HAS_STD_ARRAY)
-
-  template <typename AsyncRandomAccessReadDevice,
-      typename MutableBufferSequence, typename CompletionCondition,
-      typename ReadHandler>
   inline void* asio_handler_allocate(std::size_t size,
       read_at_op<AsyncRandomAccessReadDevice, MutableBufferSequence,
-        CompletionCondition, ReadHandler>* this_handler)
+        MutableBufferIterator, CompletionCondition, ReadHandler>* this_handler)
   {
     return asio_handler_alloc_helpers::allocate(
         size, this_handler->handler_);
   }
 
   template <typename AsyncRandomAccessReadDevice,
-      typename MutableBufferSequence, typename CompletionCondition,
-      typename ReadHandler>
+      typename MutableBufferSequence, typename MutableBufferIterator,
+      typename CompletionCondition, typename ReadHandler>
   inline void asio_handler_deallocate(void* pointer, std::size_t size,
       read_at_op<AsyncRandomAccessReadDevice, MutableBufferSequence,
-        CompletionCondition, ReadHandler>* this_handler)
+        MutableBufferIterator, CompletionCondition, ReadHandler>* this_handler)
   {
     asio_handler_alloc_helpers::deallocate(
         pointer, size, this_handler->handler_);
   }
 
   template <typename AsyncRandomAccessReadDevice,
-      typename MutableBufferSequence, typename CompletionCondition,
-      typename ReadHandler>
+      typename MutableBufferSequence, typename MutableBufferIterator,
+      typename CompletionCondition, typename ReadHandler>
   inline bool asio_handler_is_continuation(
       read_at_op<AsyncRandomAccessReadDevice, MutableBufferSequence,
-        CompletionCondition, ReadHandler>* this_handler)
+        MutableBufferIterator, CompletionCondition, ReadHandler>* this_handler)
   {
     return this_handler->start_ == 0 ? true
       : asio_handler_cont_helpers::is_continuation(
@@ -529,74 +279,78 @@ namespace detail
   }
 
   template <typename Function, typename AsyncRandomAccessReadDevice,
-      typename MutableBufferSequence, typename CompletionCondition,
-      typename ReadHandler>
+      typename MutableBufferSequence, typename MutableBufferIterator,
+      typename CompletionCondition, typename ReadHandler>
   inline void asio_handler_invoke(Function& function,
       read_at_op<AsyncRandomAccessReadDevice, MutableBufferSequence,
-        CompletionCondition, ReadHandler>* this_handler)
+        MutableBufferIterator, CompletionCondition, ReadHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
         function, this_handler->handler_);
   }
 
   template <typename Function, typename AsyncRandomAccessReadDevice,
-      typename MutableBufferSequence, typename CompletionCondition,
-      typename ReadHandler>
+      typename MutableBufferSequence, typename MutableBufferIterator,
+      typename CompletionCondition, typename ReadHandler>
   inline void asio_handler_invoke(const Function& function,
       read_at_op<AsyncRandomAccessReadDevice, MutableBufferSequence,
-        CompletionCondition, ReadHandler>* this_handler)
+        MutableBufferIterator, CompletionCondition, ReadHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
         function, this_handler->handler_);
   }
 
   template <typename AsyncRandomAccessReadDevice,
-      typename MutableBufferSequence, typename CompletionCondition,
-      typename ReadHandler>
-  inline read_at_op<AsyncRandomAccessReadDevice,
-      MutableBufferSequence, CompletionCondition, ReadHandler>
-  make_read_at_op(AsyncRandomAccessReadDevice& d,
+      typename MutableBufferSequence, typename MutableBufferIterator,
+      typename CompletionCondition, typename ReadHandler>
+  inline void start_read_at_buffer_sequence_op(AsyncRandomAccessReadDevice& d,
       uint64_t offset, const MutableBufferSequence& buffers,
-      CompletionCondition completion_condition, ReadHandler handler)
+      const MutableBufferIterator&, CompletionCondition completion_condition,
+      ReadHandler& handler)
   {
-    return read_at_op<AsyncRandomAccessReadDevice,
-      MutableBufferSequence, CompletionCondition, ReadHandler>(
-        d, offset, buffers, completion_condition, handler);
+    detail::read_at_op<AsyncRandomAccessReadDevice, MutableBufferSequence,
+      MutableBufferIterator, CompletionCondition, ReadHandler>(
+        d, offset, buffers, completion_condition, handler)(
+          asio::error_code(), 0, 1);
   }
 } // namespace detail
 
 #if !defined(GENERATING_DOCUMENTATION)
 
-template <typename AsyncRandomAccessReadDevice, typename MutableBufferSequence,
+template <typename AsyncRandomAccessReadDevice,
+    typename MutableBufferSequence, typename MutableBufferIterator,
     typename CompletionCondition, typename ReadHandler, typename Allocator>
 struct associated_allocator<
-    detail::read_at_op<AsyncRandomAccessReadDevice,
-      MutableBufferSequence, CompletionCondition, ReadHandler>,
+    detail::read_at_op<AsyncRandomAccessReadDevice, MutableBufferSequence,
+    MutableBufferIterator, CompletionCondition, ReadHandler>,
     Allocator>
 {
   typedef typename associated_allocator<ReadHandler, Allocator>::type type;
 
   static type get(
       const detail::read_at_op<AsyncRandomAccessReadDevice,
-        MutableBufferSequence, CompletionCondition, ReadHandler>& h,
+      MutableBufferSequence, MutableBufferIterator,
+      CompletionCondition, ReadHandler>& h,
       const Allocator& a = Allocator()) ASIO_NOEXCEPT
   {
     return associated_allocator<ReadHandler, Allocator>::get(h.handler_, a);
   }
 };
 
-template <typename AsyncRandomAccessReadDevice, typename MutableBufferSequence,
+template <typename AsyncRandomAccessReadDevice,
+    typename MutableBufferSequence, typename MutableBufferIterator,
     typename CompletionCondition, typename ReadHandler, typename Executor>
 struct associated_executor<
-    detail::read_at_op<AsyncRandomAccessReadDevice,
-      MutableBufferSequence, CompletionCondition, ReadHandler>,
+    detail::read_at_op<AsyncRandomAccessReadDevice, MutableBufferSequence,
+    MutableBufferIterator, CompletionCondition, ReadHandler>,
     Executor>
 {
   typedef typename associated_executor<ReadHandler, Executor>::type type;
 
   static type get(
       const detail::read_at_op<AsyncRandomAccessReadDevice,
-        MutableBufferSequence, CompletionCondition, ReadHandler>& h,
+      MutableBufferSequence, MutableBufferIterator,
+      CompletionCondition, ReadHandler>& h,
       const Executor& ex = Executor()) ASIO_NOEXCEPT
   {
     return associated_executor<ReadHandler, Executor>::get(h.handler_, ex);
@@ -621,11 +375,9 @@ async_read_at(AsyncRandomAccessReadDevice& d,
   async_completion<ReadHandler,
     void (asio::error_code, std::size_t)> init(handler);
 
-  detail::read_at_op<AsyncRandomAccessReadDevice, MutableBufferSequence,
-    CompletionCondition, ASIO_HANDLER_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))>(
-        d, offset, buffers, completion_condition, init.handler)(
-          asio::error_code(), 0, 1);
+  detail::start_read_at_buffer_sequence_op(d, offset, buffers,
+      asio::buffer_sequence_begin(buffers), completion_condition,
+      init.completion_handler);
 
   return init.result.get();
 }
@@ -645,15 +397,14 @@ async_read_at(AsyncRandomAccessReadDevice& d,
   async_completion<ReadHandler,
     void (asio::error_code, std::size_t)> init(handler);
 
-  detail::read_at_op<AsyncRandomAccessReadDevice, MutableBufferSequence,
-    detail::transfer_all_t, ASIO_HANDLER_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))>(
-        d, offset, buffers, transfer_all(), init.handler)(
-          asio::error_code(), 0, 1);
+  detail::start_read_at_buffer_sequence_op(d, offset, buffers,
+      asio::buffer_sequence_begin(buffers), transfer_all(),
+      init.completion_handler);
 
   return init.result.get();
 }
 
+#if !defined(ASIO_NO_EXTENSIONS)
 #if !defined(ASIO_NO_IOSTREAM)
 
 namespace detail
@@ -849,7 +600,7 @@ async_read_at(AsyncRandomAccessReadDevice& d,
   detail::read_at_streambuf_op<AsyncRandomAccessReadDevice, Allocator,
     CompletionCondition, ASIO_HANDLER_TYPE(ReadHandler,
       void (asio::error_code, std::size_t))>(
-        d, offset, b, completion_condition, init.handler)(
+        d, offset, b, completion_condition, init.completion_handler)(
           asio::error_code(), 0, 1);
 
   return init.result.get();
@@ -873,13 +624,14 @@ async_read_at(AsyncRandomAccessReadDevice& d,
   detail::read_at_streambuf_op<AsyncRandomAccessReadDevice, Allocator,
     detail::transfer_all_t, ASIO_HANDLER_TYPE(ReadHandler,
       void (asio::error_code, std::size_t))>(
-        d, offset, b, transfer_all(), init.handler)(
+        d, offset, b, transfer_all(), init.completion_handler)(
           asio::error_code(), 0, 1);
 
   return init.result.get();
 }
 
 #endif // !defined(ASIO_NO_IOSTREAM)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 } // namespace asio
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/read_until.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/read_until.hpp
index fc84d1d..c0a435e 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/read_until.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/read_until.hpp
@@ -2,7 +2,7 @@
 // impl/read_until.hpp
 // ~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -35,30 +35,30 @@
 
 namespace asio {
 
-template <typename SyncReadStream, typename DynamicBufferSequence>
+template <typename SyncReadStream, typename DynamicBuffer>
 inline std::size_t read_until(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers, char delim)
+    ASIO_MOVE_ARG(DynamicBuffer) buffers, char delim)
 {
   asio::error_code ec;
   std::size_t bytes_transferred = read_until(s,
-      ASIO_MOVE_CAST(DynamicBufferSequence)(buffers), delim, ec);
+      ASIO_MOVE_CAST(DynamicBuffer)(buffers), delim, ec);
   asio::detail::throw_error(ec, "read_until");
   return bytes_transferred;
 }
 
-template <typename SyncReadStream, typename DynamicBufferSequence>
+template <typename SyncReadStream, typename DynamicBuffer>
 std::size_t read_until(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     char delim, asio::error_code& ec)
 {
-  typename decay<DynamicBufferSequence>::type b(
-      ASIO_MOVE_CAST(DynamicBufferSequence)(buffers));
+  typename decay<DynamicBuffer>::type b(
+      ASIO_MOVE_CAST(DynamicBuffer)(buffers));
 
   std::size_t search_position = 0;
   for (;;)
   {
     // Determine the range of the data to be searched.
-    typedef typename DynamicBufferSequence::const_buffers_type buffers_type;
+    typedef typename DynamicBuffer::const_buffers_type buffers_type;
     typedef buffers_iterator<buffers_type> iterator;
     buffers_type data_buffers = b.data();
     iterator begin = iterator::begin(data_buffers);
@@ -96,14 +96,14 @@ std::size_t read_until(SyncReadStream& s,
   }
 }
 
-template <typename SyncReadStream, typename DynamicBufferSequence>
+template <typename SyncReadStream, typename DynamicBuffer>
 inline std::size_t read_until(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
-    const std::string& delim)
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
+    ASIO_STRING_VIEW_PARAM delim)
 {
   asio::error_code ec;
   std::size_t bytes_transferred = read_until(s,
-      ASIO_MOVE_CAST(DynamicBufferSequence)(buffers), delim, ec);
+      ASIO_MOVE_CAST(DynamicBuffer)(buffers), delim, ec);
   asio::detail::throw_error(ec, "read_until");
   return bytes_transferred;
 }
@@ -143,19 +143,19 @@ namespace detail
   }
 } // namespace detail
 
-template <typename SyncReadStream, typename DynamicBufferSequence>
+template <typename SyncReadStream, typename DynamicBuffer>
 std::size_t read_until(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
-    const std::string& delim, asio::error_code& ec)
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
+    ASIO_STRING_VIEW_PARAM delim, asio::error_code& ec)
 {
-  typename decay<DynamicBufferSequence>::type b(
-      ASIO_MOVE_CAST(DynamicBufferSequence)(buffers));
+  typename decay<DynamicBuffer>::type b(
+      ASIO_MOVE_CAST(DynamicBuffer)(buffers));
 
   std::size_t search_position = 0;
   for (;;)
   {
     // Determine the range of the data to be searched.
-    typedef typename DynamicBufferSequence::const_buffers_type buffers_type;
+    typedef typename DynamicBuffer::const_buffers_type buffers_type;
     typedef buffers_iterator<buffers_type> iterator;
     buffers_type data_buffers = b.data();
     iterator begin = iterator::begin(data_buffers);
@@ -202,33 +202,34 @@ std::size_t read_until(SyncReadStream& s,
   }
 }
 
+#if !defined(ASIO_NO_EXTENSIONS)
 #if defined(ASIO_HAS_BOOST_REGEX)
 
-template <typename SyncReadStream, typename DynamicBufferSequence>
+template <typename SyncReadStream, typename DynamicBuffer>
 inline std::size_t read_until(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     const boost::regex& expr)
 {
   asio::error_code ec;
   std::size_t bytes_transferred = read_until(s,
-      ASIO_MOVE_CAST(DynamicBufferSequence)(buffers), expr, ec);
+      ASIO_MOVE_CAST(DynamicBuffer)(buffers), expr, ec);
   asio::detail::throw_error(ec, "read_until");
   return bytes_transferred;
 }
 
-template <typename SyncReadStream, typename DynamicBufferSequence>
+template <typename SyncReadStream, typename DynamicBuffer>
 std::size_t read_until(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     const boost::regex& expr, asio::error_code& ec)
 {
-  typename decay<DynamicBufferSequence>::type b(
-      ASIO_MOVE_CAST(DynamicBufferSequence)(buffers));
+  typename decay<DynamicBuffer>::type b(
+      ASIO_MOVE_CAST(DynamicBuffer)(buffers));
 
   std::size_t search_position = 0;
   for (;;)
   {
     // Determine the range of the data to be searched.
-    typedef typename DynamicBufferSequence::const_buffers_type buffers_type;
+    typedef typename DynamicBuffer::const_buffers_type buffers_type;
     typedef buffers_iterator<buffers_type> iterator;
     buffers_type data_buffers = b.data();
     iterator begin = iterator::begin(data_buffers);
@@ -278,35 +279,35 @@ std::size_t read_until(SyncReadStream& s,
 #endif // defined(ASIO_HAS_BOOST_REGEX)
 
 template <typename SyncReadStream,
-    typename DynamicBufferSequence, typename MatchCondition>
+    typename DynamicBuffer, typename MatchCondition>
 inline std::size_t read_until(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     MatchCondition match_condition,
     typename enable_if<is_match_condition<MatchCondition>::value>::type*)
 {
   asio::error_code ec;
   std::size_t bytes_transferred = read_until(s,
-      ASIO_MOVE_CAST(DynamicBufferSequence)(buffers),
+      ASIO_MOVE_CAST(DynamicBuffer)(buffers),
       match_condition, ec);
   asio::detail::throw_error(ec, "read_until");
   return bytes_transferred;
 }
 
 template <typename SyncReadStream,
-    typename DynamicBufferSequence, typename MatchCondition>
+    typename DynamicBuffer, typename MatchCondition>
 std::size_t read_until(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     MatchCondition match_condition, asio::error_code& ec,
     typename enable_if<is_match_condition<MatchCondition>::value>::type*)
 {
-  typename decay<DynamicBufferSequence>::type b(
-      ASIO_MOVE_CAST(DynamicBufferSequence)(buffers));
+  typename decay<DynamicBuffer>::type b(
+      ASIO_MOVE_CAST(DynamicBuffer)(buffers));
 
   std::size_t search_position = 0;
   for (;;)
   {
     // Determine the range of the data to be searched.
-    typedef typename DynamicBufferSequence::const_buffers_type buffers_type;
+    typedef typename DynamicBuffer::const_buffers_type buffers_type;
     typedef buffers_iterator<buffers_type> iterator;
     buffers_type data_buffers = b.data();
     iterator begin = iterator::begin(data_buffers);
@@ -368,15 +369,16 @@ inline std::size_t read_until(SyncReadStream& s,
 
 template <typename SyncReadStream, typename Allocator>
 inline std::size_t read_until(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, const std::string& delim)
+    asio::basic_streambuf<Allocator>& b,
+    ASIO_STRING_VIEW_PARAM delim)
 {
   return read_until(s, basic_streambuf_ref<Allocator>(b), delim);
 }
 
 template <typename SyncReadStream, typename Allocator>
 inline std::size_t read_until(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, const std::string& delim,
-    asio::error_code& ec)
+    asio::basic_streambuf<Allocator>& b,
+    ASIO_STRING_VIEW_PARAM delim, asio::error_code& ec)
 {
   return read_until(s, basic_streambuf_ref<Allocator>(b), delim, ec);
 }
@@ -418,11 +420,12 @@ inline std::size_t read_until(SyncReadStream& s,
 }
 
 #endif // !defined(ASIO_NO_IOSTREAM)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 namespace detail
 {
   template <typename AsyncReadStream,
-      typename DynamicBufferSequence, typename ReadHandler>
+      typename DynamicBuffer, typename ReadHandler>
   class read_until_delim_op
   {
   public:
@@ -452,7 +455,7 @@ namespace detail
 
     read_until_delim_op(read_until_delim_op&& other)
       : stream_(other.stream_),
-        buffers_(ASIO_MOVE_CAST(DynamicBufferSequence)(other.buffers_)),
+        buffers_(ASIO_MOVE_CAST(DynamicBuffer)(other.buffers_)),
         delim_(other.delim_),
         start_(other.start_),
         search_position_(other.search_position_),
@@ -473,7 +476,7 @@ namespace detail
         {
           {
             // Determine the range of the data to be searched.
-            typedef typename DynamicBufferSequence::const_buffers_type
+            typedef typename DynamicBuffer::const_buffers_type
               buffers_type;
             typedef buffers_iterator<buffers_type> iterator;
             buffers_type data_buffers = buffers_.data();
@@ -537,7 +540,7 @@ namespace detail
 
   //private:
     AsyncReadStream& stream_;
-    DynamicBufferSequence buffers_;
+    DynamicBuffer buffers_;
     char delim_;
     int start_;
     std::size_t search_position_;
@@ -545,30 +548,30 @@ namespace detail
   };
 
   template <typename AsyncReadStream,
-      typename DynamicBufferSequence, typename ReadHandler>
+      typename DynamicBuffer, typename ReadHandler>
   inline void* asio_handler_allocate(std::size_t size,
       read_until_delim_op<AsyncReadStream,
-        DynamicBufferSequence, ReadHandler>* this_handler)
+        DynamicBuffer, ReadHandler>* this_handler)
   {
     return asio_handler_alloc_helpers::allocate(
         size, this_handler->handler_);
   }
 
   template <typename AsyncReadStream,
-      typename DynamicBufferSequence, typename ReadHandler>
+      typename DynamicBuffer, typename ReadHandler>
   inline void asio_handler_deallocate(void* pointer, std::size_t size,
       read_until_delim_op<AsyncReadStream,
-        DynamicBufferSequence, ReadHandler>* this_handler)
+        DynamicBuffer, ReadHandler>* this_handler)
   {
     asio_handler_alloc_helpers::deallocate(
         pointer, size, this_handler->handler_);
   }
 
   template <typename AsyncReadStream,
-      typename DynamicBufferSequence, typename ReadHandler>
+      typename DynamicBuffer, typename ReadHandler>
   inline bool asio_handler_is_continuation(
       read_until_delim_op<AsyncReadStream,
-        DynamicBufferSequence, ReadHandler>* this_handler)
+        DynamicBuffer, ReadHandler>* this_handler)
   {
     return this_handler->start_ == 0 ? true
       : asio_handler_cont_helpers::is_continuation(
@@ -576,20 +579,20 @@ namespace detail
   }
 
   template <typename Function, typename AsyncReadStream,
-      typename DynamicBufferSequence, typename ReadHandler>
+      typename DynamicBuffer, typename ReadHandler>
   inline void asio_handler_invoke(Function& function,
       read_until_delim_op<AsyncReadStream,
-        DynamicBufferSequence, ReadHandler>* this_handler)
+        DynamicBuffer, ReadHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
         function, this_handler->handler_);
   }
 
   template <typename Function, typename AsyncReadStream,
-      typename DynamicBufferSequence, typename ReadHandler>
+      typename DynamicBuffer, typename ReadHandler>
   inline void asio_handler_invoke(const Function& function,
       read_until_delim_op<AsyncReadStream,
-        DynamicBufferSequence, ReadHandler>* this_handler)
+        DynamicBuffer, ReadHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
         function, this_handler->handler_);
@@ -598,36 +601,36 @@ namespace detail
 
 #if !defined(GENERATING_DOCUMENTATION)
 
-template <typename AsyncReadStream, typename DynamicBufferSequence,
+template <typename AsyncReadStream, typename DynamicBuffer,
     typename ReadHandler, typename Allocator>
 struct associated_allocator<
     detail::read_until_delim_op<AsyncReadStream,
-      DynamicBufferSequence, ReadHandler>,
+      DynamicBuffer, ReadHandler>,
     Allocator>
 {
   typedef typename associated_allocator<ReadHandler, Allocator>::type type;
 
   static type get(
       const detail::read_until_delim_op<AsyncReadStream,
-        DynamicBufferSequence, ReadHandler>& h,
+        DynamicBuffer, ReadHandler>& h,
       const Allocator& a = Allocator()) ASIO_NOEXCEPT
   {
     return associated_allocator<ReadHandler, Allocator>::get(h.handler_, a);
   }
 };
 
-template <typename AsyncReadStream, typename DynamicBufferSequence,
+template <typename AsyncReadStream, typename DynamicBuffer,
     typename ReadHandler, typename Executor>
 struct associated_executor<
     detail::read_until_delim_op<AsyncReadStream,
-      DynamicBufferSequence, ReadHandler>,
+      DynamicBuffer, ReadHandler>,
     Executor>
 {
   typedef typename associated_executor<ReadHandler, Executor>::type type;
 
   static type get(
       const detail::read_until_delim_op<AsyncReadStream,
-        DynamicBufferSequence, ReadHandler>& h,
+        DynamicBuffer, ReadHandler>& h,
       const Executor& ex = Executor()) ASIO_NOEXCEPT
   {
     return associated_executor<ReadHandler, Executor>::get(h.handler_, ex);
@@ -637,11 +640,11 @@ struct associated_executor<
 #endif // !defined(GENERATING_DOCUMENTATION)
 
 template <typename AsyncReadStream,
-    typename DynamicBufferSequence, typename ReadHandler>
+    typename DynamicBuffer, typename ReadHandler>
 ASIO_INITFN_RESULT_TYPE(ReadHandler,
     void (asio::error_code, std::size_t))
 async_read_until(AsyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     char delim, ASIO_MOVE_ARG(ReadHandler) handler)
 {
   // If you get an error on the following line it means that your handler does
@@ -652,11 +655,11 @@ async_read_until(AsyncReadStream& s,
     void (asio::error_code, std::size_t)> init(handler);
 
   detail::read_until_delim_op<AsyncReadStream,
-    typename decay<DynamicBufferSequence>::type,
+    typename decay<DynamicBuffer>::type,
       ASIO_HANDLER_TYPE(ReadHandler,
         void (asio::error_code, std::size_t))>(
-          s, ASIO_MOVE_CAST(DynamicBufferSequence)(buffers),
-            delim, init.handler)(asio::error_code(), 0, 1);
+          s, ASIO_MOVE_CAST(DynamicBuffer)(buffers),
+            delim, init.completion_handler)(asio::error_code(), 0, 1);
 
   return init.result.get();
 }
@@ -664,7 +667,7 @@ async_read_until(AsyncReadStream& s,
 namespace detail
 {
   template <typename AsyncReadStream,
-      typename DynamicBufferSequence, typename ReadHandler>
+      typename DynamicBuffer, typename ReadHandler>
   class read_until_delim_string_op
   {
   public:
@@ -694,7 +697,7 @@ namespace detail
 
     read_until_delim_string_op(read_until_delim_string_op&& other)
       : stream_(other.stream_),
-        buffers_(ASIO_MOVE_CAST(DynamicBufferSequence)(other.buffers_)),
+        buffers_(ASIO_MOVE_CAST(DynamicBuffer)(other.buffers_)),
         delim_(ASIO_MOVE_CAST(std::string)(other.delim_)),
         start_(other.start_),
         search_position_(other.search_position_),
@@ -715,7 +718,7 @@ namespace detail
         {
           {
             // Determine the range of the data to be searched.
-            typedef typename DynamicBufferSequence::const_buffers_type
+            typedef typename DynamicBuffer::const_buffers_type
               buffers_type;
             typedef buffers_iterator<buffers_type> iterator;
             buffers_type data_buffers = buffers_.data();
@@ -790,7 +793,7 @@ namespace detail
 
   //private:
     AsyncReadStream& stream_;
-    DynamicBufferSequence buffers_;
+    DynamicBuffer buffers_;
     std::string delim_;
     int start_;
     std::size_t search_position_;
@@ -798,30 +801,30 @@ namespace detail
   };
 
   template <typename AsyncReadStream,
-      typename DynamicBufferSequence, typename ReadHandler>
+      typename DynamicBuffer, typename ReadHandler>
   inline void* asio_handler_allocate(std::size_t size,
       read_until_delim_string_op<AsyncReadStream,
-        DynamicBufferSequence, ReadHandler>* this_handler)
+        DynamicBuffer, ReadHandler>* this_handler)
   {
     return asio_handler_alloc_helpers::allocate(
         size, this_handler->handler_);
   }
 
   template <typename AsyncReadStream,
-      typename DynamicBufferSequence, typename ReadHandler>
+      typename DynamicBuffer, typename ReadHandler>
   inline void asio_handler_deallocate(void* pointer, std::size_t size,
       read_until_delim_string_op<AsyncReadStream,
-        DynamicBufferSequence, ReadHandler>* this_handler)
+        DynamicBuffer, ReadHandler>* this_handler)
   {
     asio_handler_alloc_helpers::deallocate(
         pointer, size, this_handler->handler_);
   }
 
   template <typename AsyncReadStream,
-      typename DynamicBufferSequence, typename ReadHandler>
+      typename DynamicBuffer, typename ReadHandler>
   inline bool asio_handler_is_continuation(
       read_until_delim_string_op<AsyncReadStream,
-        DynamicBufferSequence, ReadHandler>* this_handler)
+        DynamicBuffer, ReadHandler>* this_handler)
   {
     return this_handler->start_ == 0 ? true
       : asio_handler_cont_helpers::is_continuation(
@@ -829,20 +832,20 @@ namespace detail
   }
 
   template <typename Function, typename AsyncReadStream,
-      typename DynamicBufferSequence, typename ReadHandler>
+      typename DynamicBuffer, typename ReadHandler>
   inline void asio_handler_invoke(Function& function,
       read_until_delim_string_op<AsyncReadStream,
-        DynamicBufferSequence, ReadHandler>* this_handler)
+        DynamicBuffer, ReadHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
         function, this_handler->handler_);
   }
 
   template <typename Function, typename AsyncReadStream,
-      typename DynamicBufferSequence, typename ReadHandler>
+      typename DynamicBuffer, typename ReadHandler>
   inline void asio_handler_invoke(const Function& function,
       read_until_delim_string_op<AsyncReadStream,
-        DynamicBufferSequence, ReadHandler>* this_handler)
+        DynamicBuffer, ReadHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
         function, this_handler->handler_);
@@ -851,36 +854,36 @@ namespace detail
 
 #if !defined(GENERATING_DOCUMENTATION)
 
-template <typename AsyncReadStream, typename DynamicBufferSequence,
+template <typename AsyncReadStream, typename DynamicBuffer,
     typename ReadHandler, typename Allocator>
 struct associated_allocator<
     detail::read_until_delim_string_op<AsyncReadStream,
-      DynamicBufferSequence, ReadHandler>,
+      DynamicBuffer, ReadHandler>,
     Allocator>
 {
   typedef typename associated_allocator<ReadHandler, Allocator>::type type;
 
   static type get(
       const detail::read_until_delim_string_op<AsyncReadStream,
-        DynamicBufferSequence, ReadHandler>& h,
+        DynamicBuffer, ReadHandler>& h,
       const Allocator& a = Allocator()) ASIO_NOEXCEPT
   {
     return associated_allocator<ReadHandler, Allocator>::get(h.handler_, a);
   }
 };
 
-template <typename AsyncReadStream, typename DynamicBufferSequence,
+template <typename AsyncReadStream, typename DynamicBuffer,
     typename ReadHandler, typename Executor>
 struct associated_executor<
     detail::read_until_delim_string_op<AsyncReadStream,
-      DynamicBufferSequence, ReadHandler>,
+      DynamicBuffer, ReadHandler>,
     Executor>
 {
   typedef typename associated_executor<ReadHandler, Executor>::type type;
 
   static type get(
       const detail::read_until_delim_string_op<AsyncReadStream,
-        DynamicBufferSequence, ReadHandler>& h,
+        DynamicBuffer, ReadHandler>& h,
       const Executor& ex = Executor()) ASIO_NOEXCEPT
   {
     return associated_executor<ReadHandler, Executor>::get(h.handler_, ex);
@@ -890,12 +893,13 @@ struct associated_executor<
 #endif // !defined(GENERATING_DOCUMENTATION)
 
 template <typename AsyncReadStream,
-    typename DynamicBufferSequence, typename ReadHandler>
+    typename DynamicBuffer, typename ReadHandler>
 ASIO_INITFN_RESULT_TYPE(ReadHandler,
     void (asio::error_code, std::size_t))
 async_read_until(AsyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
-    const std::string& delim, ASIO_MOVE_ARG(ReadHandler) handler)
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
+    ASIO_STRING_VIEW_PARAM delim,
+    ASIO_MOVE_ARG(ReadHandler) handler)
 {
   // If you get an error on the following line it means that your handler does
   // not meet the documented type requirements for a ReadHandler.
@@ -905,20 +909,22 @@ async_read_until(AsyncReadStream& s,
     void (asio::error_code, std::size_t)> init(handler);
 
   detail::read_until_delim_string_op<AsyncReadStream,
-    typename decay<DynamicBufferSequence>::type,
+    typename decay<DynamicBuffer>::type,
       ASIO_HANDLER_TYPE(ReadHandler,
         void (asio::error_code, std::size_t))>(
-          s, ASIO_MOVE_CAST(DynamicBufferSequence)(buffers),
-            delim, init.handler)(asio::error_code(), 0, 1);
+          s, ASIO_MOVE_CAST(DynamicBuffer)(buffers),
+            static_cast<std::string>(delim),
+              init.completion_handler)(asio::error_code(), 0, 1);
 
   return init.result.get();
 }
 
+#if !defined(ASIO_NO_EXTENSIONS)
 #if defined(ASIO_HAS_BOOST_REGEX)
 
 namespace detail
 {
-  template <typename AsyncReadStream, typename DynamicBufferSequence,
+  template <typename AsyncReadStream, typename DynamicBuffer,
       typename RegEx, typename ReadHandler>
   class read_until_expr_op
   {
@@ -949,7 +955,7 @@ namespace detail
 
     read_until_expr_op(read_until_expr_op&& other)
       : stream_(other.stream_),
-        buffers_(ASIO_MOVE_CAST(DynamicBufferSequence)(other.buffers)),
+        buffers_(ASIO_MOVE_CAST(DynamicBuffer)(other.buffers_)),
         expr_(other.expr_),
         start_(other.start_),
         search_position_(other.search_position_),
@@ -970,7 +976,7 @@ namespace detail
         {
           {
             // Determine the range of the data to be searched.
-            typedef typename DynamicBufferSequence::const_buffers_type
+            typedef typename DynamicBuffer::const_buffers_type
               buffers_type;
             typedef buffers_iterator<buffers_type> iterator;
             buffers_type data_buffers = buffers_.data();
@@ -1048,38 +1054,38 @@ namespace detail
 
   //private:
     AsyncReadStream& stream_;
-    DynamicBufferSequence buffers_;
+    DynamicBuffer buffers_;
     RegEx expr_;
     int start_;
     std::size_t search_position_;
     ReadHandler handler_;
   };
 
-  template <typename AsyncReadStream, typename DynamicBufferSequence,
+  template <typename AsyncReadStream, typename DynamicBuffer,
       typename RegEx, typename ReadHandler>
   inline void* asio_handler_allocate(std::size_t size,
       read_until_expr_op<AsyncReadStream,
-        DynamicBufferSequence, RegEx, ReadHandler>* this_handler)
+        DynamicBuffer, RegEx, ReadHandler>* this_handler)
   {
     return asio_handler_alloc_helpers::allocate(
         size, this_handler->handler_);
   }
 
-  template <typename AsyncReadStream, typename DynamicBufferSequence,
+  template <typename AsyncReadStream, typename DynamicBuffer,
       typename RegEx, typename ReadHandler>
   inline void asio_handler_deallocate(void* pointer, std::size_t size,
       read_until_expr_op<AsyncReadStream,
-        DynamicBufferSequence, RegEx, ReadHandler>* this_handler)
+        DynamicBuffer, RegEx, ReadHandler>* this_handler)
   {
     asio_handler_alloc_helpers::deallocate(
         pointer, size, this_handler->handler_);
   }
 
-  template <typename AsyncReadStream, typename DynamicBufferSequence,
+  template <typename AsyncReadStream, typename DynamicBuffer,
       typename RegEx, typename ReadHandler>
   inline bool asio_handler_is_continuation(
       read_until_expr_op<AsyncReadStream,
-        DynamicBufferSequence, RegEx, ReadHandler>* this_handler)
+        DynamicBuffer, RegEx, ReadHandler>* this_handler)
   {
     return this_handler->start_ == 0 ? true
       : asio_handler_cont_helpers::is_continuation(
@@ -1087,20 +1093,20 @@ namespace detail
   }
 
   template <typename Function, typename AsyncReadStream,
-      typename DynamicBufferSequence, typename RegEx, typename ReadHandler>
+      typename DynamicBuffer, typename RegEx, typename ReadHandler>
   inline void asio_handler_invoke(Function& function,
       read_until_expr_op<AsyncReadStream,
-        DynamicBufferSequence, RegEx, ReadHandler>* this_handler)
+        DynamicBuffer, RegEx, ReadHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
         function, this_handler->handler_);
   }
 
   template <typename Function, typename AsyncReadStream,
-      typename DynamicBufferSequence, typename RegEx, typename ReadHandler>
+      typename DynamicBuffer, typename RegEx, typename ReadHandler>
   inline void asio_handler_invoke(const Function& function,
       read_until_expr_op<AsyncReadStream,
-        DynamicBufferSequence, RegEx, ReadHandler>* this_handler)
+        DynamicBuffer, RegEx, ReadHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
         function, this_handler->handler_);
@@ -1109,36 +1115,36 @@ namespace detail
 
 #if !defined(GENERATING_DOCUMENTATION)
 
-template <typename AsyncReadStream, typename DynamicBufferSequence,
+template <typename AsyncReadStream, typename DynamicBuffer,
     typename RegEx, typename ReadHandler, typename Allocator>
 struct associated_allocator<
     detail::read_until_expr_op<AsyncReadStream,
-      DynamicBufferSequence, RegEx, ReadHandler>,
+      DynamicBuffer, RegEx, ReadHandler>,
     Allocator>
 {
   typedef typename associated_allocator<ReadHandler, Allocator>::type type;
 
   static type get(
       const detail::read_until_expr_op<AsyncReadStream,
-        DynamicBufferSequence, RegEx, ReadHandler>& h,
+        DynamicBuffer, RegEx, ReadHandler>& h,
       const Allocator& a = Allocator()) ASIO_NOEXCEPT
   {
     return associated_allocator<ReadHandler, Allocator>::get(h.handler_, a);
   }
 };
 
-template <typename AsyncReadStream, typename DynamicBufferSequence,
+template <typename AsyncReadStream, typename DynamicBuffer,
     typename RegEx, typename ReadHandler, typename Executor>
 struct associated_executor<
     detail::read_until_expr_op<AsyncReadStream,
-      DynamicBufferSequence, RegEx, ReadHandler>,
+      DynamicBuffer, RegEx, ReadHandler>,
     Executor>
 {
   typedef typename associated_executor<ReadHandler, Executor>::type type;
 
   static type get(
       const detail::read_until_expr_op<AsyncReadStream,
-        DynamicBufferSequence, RegEx, ReadHandler>& h,
+        DynamicBuffer, RegEx, ReadHandler>& h,
       const Executor& ex = Executor()) ASIO_NOEXCEPT
   {
     return associated_executor<ReadHandler, Executor>::get(h.handler_, ex);
@@ -1148,11 +1154,11 @@ struct associated_executor<
 #endif // !defined(GENERATING_DOCUMENTATION)
 
 template <typename AsyncReadStream,
-    typename DynamicBufferSequence, typename ReadHandler>
+    typename DynamicBuffer, typename ReadHandler>
 ASIO_INITFN_RESULT_TYPE(ReadHandler,
     void (asio::error_code, std::size_t))
 async_read_until(AsyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     const boost::regex& expr,
     ASIO_MOVE_ARG(ReadHandler) handler)
 {
@@ -1164,11 +1170,11 @@ async_read_until(AsyncReadStream& s,
     void (asio::error_code, std::size_t)> init(handler);
 
   detail::read_until_expr_op<AsyncReadStream,
-    typename decay<DynamicBufferSequence>::type,
+    typename decay<DynamicBuffer>::type,
       boost::regex, ASIO_HANDLER_TYPE(ReadHandler,
         void (asio::error_code, std::size_t))>(
-          s, ASIO_MOVE_CAST(DynamicBufferSequence)(buffers),
-            expr, init.handler)(asio::error_code(), 0, 1);
+          s, ASIO_MOVE_CAST(DynamicBuffer)(buffers),
+            expr, init.completion_handler)(asio::error_code(), 0, 1);
 
   return init.result.get();
 }
@@ -1177,7 +1183,7 @@ async_read_until(AsyncReadStream& s,
 
 namespace detail
 {
-  template <typename AsyncReadStream, typename DynamicBufferSequence,
+  template <typename AsyncReadStream, typename DynamicBuffer,
       typename MatchCondition, typename ReadHandler>
   class read_until_match_op
   {
@@ -1208,7 +1214,7 @@ namespace detail
 
     read_until_match_op(read_until_match_op&& other)
       : stream_(other.stream_),
-        buffers_(ASIO_MOVE_CAST(DynamicBufferSequence)(other.buffers_)),
+        buffers_(ASIO_MOVE_CAST(DynamicBuffer)(other.buffers_)),
         match_condition_(other.match_condition_),
         start_(other.start_),
         search_position_(other.search_position_),
@@ -1229,7 +1235,7 @@ namespace detail
         {
           {
             // Determine the range of the data to be searched.
-            typedef typename DynamicBufferSequence::const_buffers_type
+            typedef typename DynamicBuffer::const_buffers_type
               buffers_type;
             typedef buffers_iterator<buffers_type> iterator;
             buffers_type data_buffers = buffers_.data();
@@ -1303,37 +1309,37 @@ namespace detail
 
   //private:
     AsyncReadStream& stream_;
-    DynamicBufferSequence buffers_;
+    DynamicBuffer buffers_;
     MatchCondition match_condition_;
     int start_;
     std::size_t search_position_;
     ReadHandler handler_;
   };
 
-  template <typename AsyncReadStream, typename DynamicBufferSequence,
+  template <typename AsyncReadStream, typename DynamicBuffer,
       typename MatchCondition, typename ReadHandler>
   inline void* asio_handler_allocate(std::size_t size,
-      read_until_match_op<AsyncReadStream, DynamicBufferSequence,
+      read_until_match_op<AsyncReadStream, DynamicBuffer,
         MatchCondition, ReadHandler>* this_handler)
   {
     return asio_handler_alloc_helpers::allocate(
         size, this_handler->handler_);
   }
 
-  template <typename AsyncReadStream, typename DynamicBufferSequence,
+  template <typename AsyncReadStream, typename DynamicBuffer,
       typename MatchCondition, typename ReadHandler>
   inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      read_until_match_op<AsyncReadStream, DynamicBufferSequence,
+      read_until_match_op<AsyncReadStream, DynamicBuffer,
         MatchCondition, ReadHandler>* this_handler)
   {
     asio_handler_alloc_helpers::deallocate(
         pointer, size, this_handler->handler_);
   }
 
-  template <typename AsyncReadStream, typename DynamicBufferSequence,
+  template <typename AsyncReadStream, typename DynamicBuffer,
       typename MatchCondition, typename ReadHandler>
   inline bool asio_handler_is_continuation(
-      read_until_match_op<AsyncReadStream, DynamicBufferSequence,
+      read_until_match_op<AsyncReadStream, DynamicBuffer,
         MatchCondition, ReadHandler>* this_handler)
   {
     return this_handler->start_ == 0 ? true
@@ -1342,10 +1348,10 @@ namespace detail
   }
 
   template <typename Function, typename AsyncReadStream,
-      typename DynamicBufferSequence, typename MatchCondition,
+      typename DynamicBuffer, typename MatchCondition,
       typename ReadHandler>
   inline void asio_handler_invoke(Function& function,
-      read_until_match_op<AsyncReadStream, DynamicBufferSequence,
+      read_until_match_op<AsyncReadStream, DynamicBuffer,
         MatchCondition, ReadHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
@@ -1353,10 +1359,10 @@ namespace detail
   }
 
   template <typename Function, typename AsyncReadStream,
-      typename DynamicBufferSequence, typename MatchCondition,
+      typename DynamicBuffer, typename MatchCondition,
       typename ReadHandler>
   inline void asio_handler_invoke(const Function& function,
-      read_until_match_op<AsyncReadStream, DynamicBufferSequence,
+      read_until_match_op<AsyncReadStream, DynamicBuffer,
       MatchCondition, ReadHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
@@ -1366,36 +1372,36 @@ namespace detail
 
 #if !defined(GENERATING_DOCUMENTATION)
 
-template <typename AsyncReadStream, typename DynamicBufferSequence,
+template <typename AsyncReadStream, typename DynamicBuffer,
     typename MatchCondition, typename ReadHandler, typename Allocator>
 struct associated_allocator<
     detail::read_until_match_op<AsyncReadStream,
-      DynamicBufferSequence, MatchCondition, ReadHandler>,
+      DynamicBuffer, MatchCondition, ReadHandler>,
     Allocator>
 {
   typedef typename associated_allocator<ReadHandler, Allocator>::type type;
 
   static type get(
       const detail::read_until_match_op<AsyncReadStream,
-        DynamicBufferSequence, MatchCondition, ReadHandler>& h,
+        DynamicBuffer, MatchCondition, ReadHandler>& h,
       const Allocator& a = Allocator()) ASIO_NOEXCEPT
   {
     return associated_allocator<ReadHandler, Allocator>::get(h.handler_, a);
   }
 };
 
-template <typename AsyncReadStream, typename DynamicBufferSequence,
+template <typename AsyncReadStream, typename DynamicBuffer,
     typename MatchCondition, typename ReadHandler, typename Executor>
 struct associated_executor<
     detail::read_until_match_op<AsyncReadStream,
-      DynamicBufferSequence, MatchCondition, ReadHandler>,
+      DynamicBuffer, MatchCondition, ReadHandler>,
     Executor>
 {
   typedef typename associated_executor<ReadHandler, Executor>::type type;
 
   static type get(
       const detail::read_until_match_op<AsyncReadStream,
-        DynamicBufferSequence, MatchCondition, ReadHandler>& h,
+        DynamicBuffer, MatchCondition, ReadHandler>& h,
       const Executor& ex = Executor()) ASIO_NOEXCEPT
   {
     return associated_executor<ReadHandler, Executor>::get(h.handler_, ex);
@@ -1404,12 +1410,12 @@ struct associated_executor<
 
 #endif // !defined(GENERATING_DOCUMENTATION)
 
-template <typename AsyncReadStream, typename DynamicBufferSequence,
+template <typename AsyncReadStream, typename DynamicBuffer,
     typename MatchCondition, typename ReadHandler>
 ASIO_INITFN_RESULT_TYPE(ReadHandler,
     void (asio::error_code, std::size_t))
 async_read_until(AsyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     MatchCondition match_condition, ASIO_MOVE_ARG(ReadHandler) handler,
     typename enable_if<is_match_condition<MatchCondition>::value>::type*)
 {
@@ -1421,11 +1427,12 @@ async_read_until(AsyncReadStream& s,
     void (asio::error_code, std::size_t)> init(handler);
 
   detail::read_until_match_op<AsyncReadStream,
-    typename decay<DynamicBufferSequence>::type,
+    typename decay<DynamicBuffer>::type,
       MatchCondition, ASIO_HANDLER_TYPE(ReadHandler,
         void (asio::error_code, std::size_t))>(
-          s, ASIO_MOVE_CAST(DynamicBufferSequence)(buffers),
-            match_condition, init.handler)(asio::error_code(), 0, 1);
+          s, ASIO_MOVE_CAST(DynamicBuffer)(buffers),
+            match_condition, init.completion_handler)(
+              asio::error_code(), 0, 1);
 
   return init.result.get();
 }
@@ -1447,7 +1454,8 @@ template <typename AsyncReadStream, typename Allocator, typename ReadHandler>
 inline ASIO_INITFN_RESULT_TYPE(ReadHandler,
     void (asio::error_code, std::size_t))
 async_read_until(AsyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, const std::string& delim,
+    asio::basic_streambuf<Allocator>& b,
+    ASIO_STRING_VIEW_PARAM delim,
     ASIO_MOVE_ARG(ReadHandler) handler)
 {
   return async_read_until(s, basic_streambuf_ref<Allocator>(b),
@@ -1483,6 +1491,7 @@ async_read_until(AsyncReadStream& s,
 }
 
 #endif // !defined(ASIO_NO_IOSTREAM)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 } // namespace asio
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/serial_port_base.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/serial_port_base.hpp
index abb8cde..c118d93 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/serial_port_base.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/serial_port_base.hpp
@@ -2,7 +2,7 @@
 // impl/serial_port_base.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/serial_port_base.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/serial_port_base.ipp
index 57306d9..748c8ca 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/serial_port_base.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/serial_port_base.ipp
@@ -2,7 +2,7 @@
 // impl/serial_port_base.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -37,7 +37,7 @@
 
 namespace asio {
 
-asio::error_code serial_port_base::baud_rate::store(
+ASIO_SYNC_OP_VOID serial_port_base::baud_rate::store(
     ASIO_OPTION_STORAGE& storage, asio::error_code& ec) const
 {
 #if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
@@ -111,7 +111,7 @@ asio::error_code serial_port_base::baud_rate::store(
 # endif
   default:
     ec = asio::error::invalid_argument;
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 # if defined(_BSD_SOURCE)
   ::cfsetspeed(&storage, baud);
@@ -121,10 +121,10 @@ asio::error_code serial_port_base::baud_rate::store(
 # endif
 #endif
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
-asio::error_code serial_port_base::baud_rate::load(
+ASIO_SYNC_OP_VOID serial_port_base::baud_rate::load(
     const ASIO_OPTION_STORAGE& storage, asio::error_code& ec)
 {
 #if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
@@ -199,11 +199,11 @@ asio::error_code serial_port_base::baud_rate::load(
   default:
     value_ = 0;
     ec = asio::error::invalid_argument;
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 #endif
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 serial_port_base::flow_control::flow_control(
@@ -217,7 +217,7 @@ serial_port_base::flow_control::flow_control(
   }
 }
 
-asio::error_code serial_port_base::flow_control::store(
+ASIO_SYNC_OP_VOID serial_port_base::flow_control::store(
     ASIO_OPTION_STORAGE& storage, asio::error_code& ec) const
 {
 #if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
@@ -274,17 +274,17 @@ asio::error_code serial_port_base::flow_control::store(
     break;
 # else
     ec = asio::error::operation_not_supported;
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
 # endif
   default:
     break;
   }
 #endif
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
-asio::error_code serial_port_base::flow_control::load(
+ASIO_SYNC_OP_VOID serial_port_base::flow_control::load(
     const ASIO_OPTION_STORAGE& storage, asio::error_code& ec)
 {
 #if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
@@ -322,7 +322,7 @@ asio::error_code serial_port_base::flow_control::load(
   }
 #endif
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 serial_port_base::parity::parity(serial_port_base::parity::type t)
@@ -335,7 +335,7 @@ serial_port_base::parity::parity(serial_port_base::parity::type t)
   }
 }
 
-asio::error_code serial_port_base::parity::store(
+ASIO_SYNC_OP_VOID serial_port_base::parity::store(
     ASIO_OPTION_STORAGE& storage, asio::error_code& ec) const
 {
 #if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
@@ -379,10 +379,10 @@ asio::error_code serial_port_base::parity::store(
   }
 #endif
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
-asio::error_code serial_port_base::parity::load(
+ASIO_SYNC_OP_VOID serial_port_base::parity::load(
     const ASIO_OPTION_STORAGE& storage, asio::error_code& ec)
 {
 #if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
@@ -416,7 +416,7 @@ asio::error_code serial_port_base::parity::load(
   }
 #endif
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 serial_port_base::stop_bits::stop_bits(
@@ -430,7 +430,7 @@ serial_port_base::stop_bits::stop_bits(
   }
 }
 
-asio::error_code serial_port_base::stop_bits::store(
+ASIO_SYNC_OP_VOID serial_port_base::stop_bits::store(
     ASIO_OPTION_STORAGE& storage, asio::error_code& ec) const
 {
 #if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
@@ -459,14 +459,14 @@ asio::error_code serial_port_base::stop_bits::store(
     break;
   default:
     ec = asio::error::operation_not_supported;
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 #endif
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
-asio::error_code serial_port_base::stop_bits::load(
+ASIO_SYNC_OP_VOID serial_port_base::stop_bits::load(
     const ASIO_OPTION_STORAGE& storage, asio::error_code& ec)
 {
 #if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
@@ -490,7 +490,7 @@ asio::error_code serial_port_base::stop_bits::load(
   value_ = (storage.c_cflag & CSTOPB) ? two : one;
 #endif
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 serial_port_base::character_size::character_size(unsigned int t)
@@ -503,7 +503,7 @@ serial_port_base::character_size::character_size(unsigned int t)
   }
 }
 
-asio::error_code serial_port_base::character_size::store(
+ASIO_SYNC_OP_VOID serial_port_base::character_size::store(
     ASIO_OPTION_STORAGE& storage, asio::error_code& ec) const
 {
 #if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
@@ -520,10 +520,10 @@ asio::error_code serial_port_base::character_size::store(
   }
 #endif
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
-asio::error_code serial_port_base::character_size::load(
+ASIO_SYNC_OP_VOID serial_port_base::character_size::load(
     const ASIO_OPTION_STORAGE& storage, asio::error_code& ec)
 {
 #if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
@@ -540,7 +540,7 @@ asio::error_code serial_port_base::character_size::load(
   }
 #endif
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 } // namespace asio
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/spawn.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/spawn.hpp
index 2efc1f9..82a05f0 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/spawn.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/spawn.hpp
@@ -2,7 +2,7 @@
 // impl/spawn.hpp
 // ~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -19,15 +19,15 @@
 #include "asio/associated_allocator.hpp"
 #include "asio/associated_executor.hpp"
 #include "asio/async_result.hpp"
+#include "asio/bind_executor.hpp"
 #include "asio/detail/atomic_count.hpp"
 #include "asio/detail/handler_alloc_helpers.hpp"
 #include "asio/detail/handler_cont_helpers.hpp"
 #include "asio/detail/handler_invoke_helpers.hpp"
 #include "asio/detail/memory.hpp"
 #include "asio/detail/noncopyable.hpp"
-#include "asio/handler_type.hpp"
+#include "asio/detail/type_traits.hpp"
 #include "asio/system_error.hpp"
-#include "asio/wrap.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -146,11 +146,140 @@ namespace detail {
         function, this_handler->handler_);
   }
 
+  template <typename Handler, typename T>
+  class coro_async_result
+  {
+  public:
+    typedef coro_handler<Handler, T> completion_handler_type;
+    typedef T return_type;
+
+    explicit coro_async_result(completion_handler_type& h)
+      : handler_(h),
+        ca_(h.ca_),
+        ready_(2)
+    {
+      h.ready_ = &ready_;
+      out_ec_ = h.ec_;
+      if (!out_ec_) h.ec_ = &ec_;
+      h.value_ = &value_;
+    }
+
+    return_type get()
+    {
+      // Must not hold shared_ptr to coro while suspended.
+      handler_.coro_.reset();
+
+      if (--ready_ != 0)
+        ca_();
+      if (!out_ec_ && ec_) throw asio::system_error(ec_);
+      return ASIO_MOVE_CAST(return_type)(value_);
+    }
+
+  private:
+    completion_handler_type& handler_;
+    typename basic_yield_context<Handler>::caller_type& ca_;
+    atomic_count ready_;
+    asio::error_code* out_ec_;
+    asio::error_code ec_;
+    return_type value_;
+  };
+
+  template <typename Handler>
+  class coro_async_result<Handler, void>
+  {
+  public:
+    typedef coro_handler<Handler, void> completion_handler_type;
+    typedef void return_type;
+
+    explicit coro_async_result(completion_handler_type& h)
+      : handler_(h),
+        ca_(h.ca_),
+        ready_(2)
+    {
+      h.ready_ = &ready_;
+      out_ec_ = h.ec_;
+      if (!out_ec_) h.ec_ = &ec_;
+    }
+
+    void get()
+    {
+      // Must not hold shared_ptr to coro while suspended.
+      handler_.coro_.reset();
+
+      if (--ready_ != 0)
+        ca_();
+      if (!out_ec_ && ec_) throw asio::system_error(ec_);
+    }
+
+  private:
+    completion_handler_type& handler_;
+    typename basic_yield_context<Handler>::caller_type& ca_;
+    atomic_count ready_;
+    asio::error_code* out_ec_;
+    asio::error_code ec_;
+  };
+
 } // namespace detail
 
 #if !defined(GENERATING_DOCUMENTATION)
 
 template <typename Handler, typename ReturnType>
+class async_result<basic_yield_context<Handler>, ReturnType()>
+  : public detail::coro_async_result<Handler, void>
+{
+public:
+  explicit async_result(
+    typename detail::coro_async_result<Handler,
+      void>::completion_handler_type& h)
+    : detail::coro_async_result<Handler, void>(h)
+  {
+  }
+};
+
+template <typename Handler, typename ReturnType, typename Arg1>
+class async_result<basic_yield_context<Handler>, ReturnType(Arg1)>
+  : public detail::coro_async_result<Handler, typename decay<Arg1>::type>
+{
+public:
+  explicit async_result(
+    typename detail::coro_async_result<Handler,
+      typename decay<Arg1>::type>::completion_handler_type& h)
+    : detail::coro_async_result<Handler, Arg1>(h)
+  {
+  }
+};
+
+template <typename Handler, typename ReturnType>
+class async_result<basic_yield_context<Handler>,
+    ReturnType(asio::error_code)>
+  : public detail::coro_async_result<Handler, void>
+{
+public:
+  explicit async_result(
+    typename detail::coro_async_result<Handler,
+      void>::completion_handler_type& h)
+    : detail::coro_async_result<Handler, void>(h)
+  {
+  }
+};
+
+template <typename Handler, typename ReturnType, typename Arg2>
+class async_result<basic_yield_context<Handler>,
+    ReturnType(asio::error_code, Arg2)>
+  : public detail::coro_async_result<Handler, typename decay<Arg2>::type>
+{
+public:
+  explicit async_result(
+    typename detail::coro_async_result<Handler,
+      typename decay<Arg2>::type>::completion_handler_type& h)
+    : detail::coro_async_result<Handler, Arg2>(h)
+  {
+  }
+};
+
+#if !defined(ASIO_NO_DEPRECATED)
+
+template <typename Handler, typename ReturnType>
 struct handler_type<basic_yield_context<Handler>, ReturnType()>
 {
   typedef detail::coro_handler<Handler, void> type;
@@ -159,7 +288,7 @@ struct handler_type<basic_yield_context<Handler>, ReturnType()>
 template <typename Handler, typename ReturnType, typename Arg1>
 struct handler_type<basic_yield_context<Handler>, ReturnType(Arg1)>
 {
-  typedef detail::coro_handler<Handler, Arg1> type;
+  typedef detail::coro_handler<Handler, typename decay<Arg1>::type> type;
 };
 
 template <typename Handler, typename ReturnType>
@@ -173,75 +302,25 @@ template <typename Handler, typename ReturnType, typename Arg2>
 struct handler_type<basic_yield_context<Handler>,
     ReturnType(asio::error_code, Arg2)>
 {
-  typedef detail::coro_handler<Handler, Arg2> type;
+  typedef detail::coro_handler<Handler, typename decay<Arg2>::type> type;
 };
 
 template <typename Handler, typename T>
 class async_result<detail::coro_handler<Handler, T> >
+  : public detail::coro_async_result<Handler, T>
 {
 public:
-  typedef T type;
+  typedef typename detail::coro_async_result<Handler, T>::return_type type;
 
-  explicit async_result(detail::coro_handler<Handler, T>& h)
-    : handler_(h),
-      ca_(h.ca_),
-      ready_(2)
+  explicit async_result(
+    typename detail::coro_async_result<Handler,
+      void>::completion_handler_type& h)
+    : detail::coro_async_result<Handler, T>(h)
   {
-    h.ready_ = &ready_;
-    out_ec_ = h.ec_;
-    if (!out_ec_) h.ec_ = &ec_;
-    h.value_ = &value_;
   }
-
-  type get()
-  {
-    handler_.coro_.reset(); // Must not hold shared_ptr to coro while suspended.
-    if (--ready_ != 0)
-      ca_();
-    if (!out_ec_ && ec_) throw asio::system_error(ec_);
-    return ASIO_MOVE_CAST(type)(value_);
-  }
-
-private:
-  detail::coro_handler<Handler, T>& handler_;
-  typename basic_yield_context<Handler>::caller_type& ca_;
-  detail::atomic_count ready_;
-  asio::error_code* out_ec_;
-  asio::error_code ec_;
-  type value_;
 };
 
-template <typename Handler>
-class async_result<detail::coro_handler<Handler, void> >
-{
-public:
-  typedef void type;
-
-  explicit async_result(detail::coro_handler<Handler, void>& h)
-    : handler_(h),
-      ca_(h.ca_),
-      ready_(2)
-  {
-    h.ready_ = &ready_;
-    out_ec_ = h.ec_;
-    if (!out_ec_) h.ec_ = &ec_;
-  }
-
-  void get()
-  {
-    handler_.coro_.reset(); // Must not hold shared_ptr to coro while suspended.
-    if (--ready_ != 0)
-      ca_();
-    if (!out_ec_ && ec_) throw asio::system_error(ec_);
-  }
-
-private:
-  detail::coro_handler<Handler, void>& handler_;
-  typename basic_yield_context<Handler>::caller_type& ca_;
-  detail::atomic_count ready_;
-  asio::error_code* out_ec_;
-  asio::error_code ec_;
-};
+#endif // !defined(ASIO_NO_DEPRECATED)
 
 template <typename Handler, typename T, typename Allocator>
 struct associated_allocator<detail::coro_handler<Handler, T>, Allocator>
@@ -417,16 +496,18 @@ inline void spawn(const strand<Executor>& ex,
     ASIO_MOVE_ARG(Function) function,
     const boost::coroutines::attributes& attributes)
 {
-  asio::spawn(asio::wrap(ex, &detail::default_spawn_handler),
+  asio::spawn(asio::bind_executor(
+        ex, &detail::default_spawn_handler),
       ASIO_MOVE_CAST(Function)(function), attributes);
 }
 
 template <typename Function>
-inline void spawn(const asio::io_service::strand& s,
+inline void spawn(const asio::io_context::strand& s,
     ASIO_MOVE_ARG(Function) function,
     const boost::coroutines::attributes& attributes)
 {
-  asio::spawn(asio::wrap(s, &detail::default_spawn_handler),
+  asio::spawn(asio::bind_executor(
+        s, &detail::default_spawn_handler),
       ASIO_MOVE_CAST(Function)(function), attributes);
 }
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/src.cpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/src.cpp
index bcd882f..fe56a79 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/src.cpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/src.cpp
@@ -2,7 +2,7 @@
 // impl/src.cpp
 // ~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/src.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/src.hpp
index 2ed7efc..a22b1fb 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/src.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/src.hpp
@@ -2,7 +2,7 @@
 // impl/src.hpp
 // ~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -24,7 +24,7 @@
 #include "asio/impl/execution_context.ipp"
 #include "asio/impl/executor.ipp"
 #include "asio/impl/handler_alloc_hook.ipp"
-#include "asio/impl/io_service.ipp"
+#include "asio/impl/io_context.ipp"
 #include "asio/impl/serial_port_base.ipp"
 #include "asio/impl/system_executor.ipp"
 #include "asio/impl/thread_pool.ipp"
@@ -35,6 +35,7 @@
 #include "asio/detail/impl/eventfd_select_interrupter.ipp"
 #include "asio/detail/impl/handler_tracking.ipp"
 #include "asio/detail/impl/kqueue_reactor.ipp"
+#include "asio/detail/impl/null_event.ipp"
 #include "asio/detail/impl/pipe_select_interrupter.ipp"
 #include "asio/detail/impl/posix_event.ipp"
 #include "asio/detail/impl/posix_mutex.ipp"
@@ -56,7 +57,7 @@
 #include "asio/detail/impl/timer_queue_ptime.ipp"
 #include "asio/detail/impl/timer_queue_set.ipp"
 #include "asio/detail/impl/win_iocp_handle_service.ipp"
-#include "asio/detail/impl/win_iocp_io_service.ipp"
+#include "asio/detail/impl/win_iocp_io_context.ipp"
 #include "asio/detail/impl/win_iocp_serial_port_service.ipp"
 #include "asio/detail/impl/win_iocp_socket_service_base.ipp"
 #include "asio/detail/impl/win_event.ipp"
@@ -74,6 +75,7 @@
 #include "asio/ip/impl/address_v6.ipp"
 #include "asio/ip/impl/host_name.ipp"
 #include "asio/ip/impl/network_v4.ipp"
+#include "asio/ip/impl/network_v6.ipp"
 #include "asio/ip/detail/impl/endpoint.ipp"
 #include "asio/local/detail/impl/endpoint.ipp"
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/system_executor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/system_executor.hpp
index d1cdd6c..12ca9b9 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/system_executor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/system_executor.hpp
@@ -2,7 +2,7 @@
 // impl/system_executor.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -25,14 +25,14 @@
 
 namespace asio {
 
-inline execution_context& system_executor::context() ASIO_NOEXCEPT
+inline execution_context& system_executor::context() const ASIO_NOEXCEPT
 {
   return detail::global<context_impl>();
 }
 
 template <typename Function, typename Allocator>
 void system_executor::dispatch(
-    ASIO_MOVE_ARG(Function) f, const Allocator&)
+    ASIO_MOVE_ARG(Function) f, const Allocator&) const
 {
   typename decay<Function>::type tmp(ASIO_MOVE_CAST(Function)(f));
   asio_handler_invoke_helpers::invoke(tmp, tmp);
@@ -40,8 +40,10 @@ void system_executor::dispatch(
 
 template <typename Function, typename Allocator>
 void system_executor::post(
-    ASIO_MOVE_ARG(Function) f, const Allocator& a)
+    ASIO_MOVE_ARG(Function) f, const Allocator& a) const
 {
+  context_impl& ctx = detail::global<context_impl>();
+
   // Make a local, non-const copy of the function.
   typedef typename decay<Function>::type function_type;
   function_type tmp(ASIO_MOVE_CAST(Function)(f));
@@ -56,17 +58,19 @@ void system_executor::post(
   p.v = p.a.allocate(1);
   p.p = new (p.v) op(tmp, allocator);
 
-  ASIO_HANDLER_CREATION((p.p, "system_executor", this, "post"));
+  ASIO_HANDLER_CREATION((ctx, *p.p,
+        "system_executor", &this->context(), 0, "post"));
 
-  context_impl& ctx = detail::global<context_impl>();
   ctx.scheduler_.post_immediate_completion(p.p, false);
   p.v = p.p = 0;
 }
 
 template <typename Function, typename Allocator>
 void system_executor::defer(
-    ASIO_MOVE_ARG(Function) f, const Allocator& a)
+    ASIO_MOVE_ARG(Function) f, const Allocator& a) const
 {
+  context_impl& ctx = detail::global<context_impl>();
+
   // Make a local, non-const copy of the function.
   typedef typename decay<Function>::type function_type;
   function_type tmp(ASIO_MOVE_CAST(Function)(f));
@@ -81,9 +85,9 @@ void system_executor::defer(
   p.v = p.a.allocate(1);
   p.p = new (p.v) op(tmp, allocator);
 
-  ASIO_HANDLER_CREATION((p.p, "system_executor", this, "defer"));
+  ASIO_HANDLER_CREATION((ctx, *p.p,
+        "system_executor", &this->context(), 0, "defer"));
 
-  context_impl& ctx = detail::global<context_impl>();
   ctx.scheduler_.post_immediate_completion(p.p, true);
   p.v = p.p = 0;
 }
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/system_executor.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/system_executor.ipp
index a9951a3..6e5b16e 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/system_executor.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/system_executor.ipp
@@ -2,7 +2,7 @@
 // impl/system_executor.ipp
 // ~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/thread_pool.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/thread_pool.hpp
index 0b7af1e..db7d5c0 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/thread_pool.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/thread_pool.hpp
@@ -2,7 +2,7 @@
 // impl/thread_pool.hpp
 // ~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -32,24 +32,26 @@ thread_pool::get_executor() ASIO_NOEXCEPT
 }
 
 inline thread_pool&
-thread_pool::executor_type::context() ASIO_NOEXCEPT
+thread_pool::executor_type::context() const ASIO_NOEXCEPT
 {
   return pool_;
 }
 
-inline void thread_pool::executor_type::on_work_started() ASIO_NOEXCEPT
+inline void
+thread_pool::executor_type::on_work_started() const ASIO_NOEXCEPT
 {
   pool_.scheduler_.work_started();
 }
 
-inline void thread_pool::executor_type::on_work_finished() ASIO_NOEXCEPT
+inline void thread_pool::executor_type::on_work_finished()
+const ASIO_NOEXCEPT
 {
   pool_.scheduler_.work_finished();
 }
 
 template <typename Function, typename Allocator>
 void thread_pool::executor_type::dispatch(
-    ASIO_MOVE_ARG(Function) f, const Allocator& a)
+    ASIO_MOVE_ARG(Function) f, const Allocator& a) const
 {
   // Make a local, non-const copy of the function.
   typedef typename decay<Function>::type function_type;
@@ -73,7 +75,8 @@ void thread_pool::executor_type::dispatch(
   p.v = p.a.allocate(1);
   p.p = new (p.v) op(tmp, allocator);
 
-  ASIO_HANDLER_CREATION((p.p, "thread_pool", this, "post"));
+  ASIO_HANDLER_CREATION((pool_, *p.p,
+        "thread_pool", &this->context(), 0, "dispatch"));
 
   pool_.scheduler_.post_immediate_completion(p.p, false);
   p.v = p.p = 0;
@@ -81,7 +84,7 @@ void thread_pool::executor_type::dispatch(
 
 template <typename Function, typename Allocator>
 void thread_pool::executor_type::post(
-    ASIO_MOVE_ARG(Function) f, const Allocator& a)
+    ASIO_MOVE_ARG(Function) f, const Allocator& a) const
 {
   // Make a local, non-const copy of the function.
   typedef typename decay<Function>::type function_type;
@@ -97,7 +100,8 @@ void thread_pool::executor_type::post(
   p.v = p.a.allocate(1);
   p.p = new (p.v) op(tmp, allocator);
 
-  ASIO_HANDLER_CREATION((p.p, "thread_pool", this, "post"));
+  ASIO_HANDLER_CREATION((pool_, *p.p,
+        "thread_pool", &this->context(), 0, "post"));
 
   pool_.scheduler_.post_immediate_completion(p.p, false);
   p.v = p.p = 0;
@@ -105,7 +109,7 @@ void thread_pool::executor_type::post(
 
 template <typename Function, typename Allocator>
 void thread_pool::executor_type::defer(
-    ASIO_MOVE_ARG(Function) f, const Allocator& a)
+    ASIO_MOVE_ARG(Function) f, const Allocator& a) const
 {
   // Make a local, non-const copy of the function.
   typedef typename decay<Function>::type function_type;
@@ -121,7 +125,8 @@ void thread_pool::executor_type::defer(
   p.v = p.a.allocate(1);
   p.p = new (p.v) op(tmp, allocator);
 
-  ASIO_HANDLER_CREATION((p.p, "thread_pool", this, "defer"));
+  ASIO_HANDLER_CREATION((pool_, *p.p,
+        "thread_pool", &this->context(), 0, "defer"));
 
   pool_.scheduler_.post_immediate_completion(p.p, true);
   p.v = p.p = 0;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/thread_pool.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/thread_pool.ipp
index c60fd46..f56b94a 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/thread_pool.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/thread_pool.ipp
@@ -2,7 +2,7 @@
 // impl/thread_pool.ipp
 // ~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/use_future.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/use_future.hpp
index fd3857f..e06c400 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/use_future.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/use_future.hpp
@@ -2,7 +2,7 @@
 // impl/use_future.hpp
 // ~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,152 +17,892 @@
 
 #include "asio/detail/config.hpp"
 #include <future>
+#include <tuple>
 #include "asio/async_result.hpp"
+#include "asio/detail/memory.hpp"
 #include "asio/error_code.hpp"
-#include "asio/handler_type.hpp"
+#include "asio/packaged_task.hpp"
 #include "asio/system_error.hpp"
+#include "asio/system_executor.hpp"
 
 #include "asio/detail/push_options.hpp"
 
 namespace asio {
 namespace detail {
 
-  // Completion handler to adapt a promise as a completion handler.
-  template <typename T>
-  class promise_handler
+#if defined(ASIO_HAS_VARIADIC_TEMPLATES)
+
+template <typename T, typename F, typename... Args>
+inline void promise_invoke_and_set(std::promise<T>& p,
+    F& f, ASIO_MOVE_ARG(Args)... args)
+{
+#if !defined(ASIO_NO_EXCEPTIONS)
+  try
+#endif // !defined(ASIO_NO_EXCEPTIONS)
   {
-  public:
-    // Construct from use_future special value.
-    template <typename Allocator>
-    promise_handler(use_future_t<Allocator> uf)
-      : promise_(std::allocate_shared<std::promise<T> >(
-            uf.get_allocator(), std::allocator_arg, uf.get_allocator()))
-    {
-    }
+    p.set_value(f(ASIO_MOVE_CAST(Args)(args)...));
+  }
+#if !defined(ASIO_NO_EXCEPTIONS)
+  catch (...)
+  {
+    p.set_exception(std::current_exception());
+  }
+#endif // !defined(ASIO_NO_EXCEPTIONS)
+}
+
+template <typename F, typename... Args>
+inline void promise_invoke_and_set(std::promise<void>& p,
+    F& f, ASIO_MOVE_ARG(Args)... args)
+{
+#if !defined(ASIO_NO_EXCEPTIONS)
+  try
+#endif // !defined(ASIO_NO_EXCEPTIONS)
+  {
+    f(ASIO_MOVE_CAST(Args)(args)...);
+    p.set_value();
+  }
+#if !defined(ASIO_NO_EXCEPTIONS)
+  catch (...)
+  {
+    p.set_exception(std::current_exception());
+  }
+#endif // !defined(ASIO_NO_EXCEPTIONS)
+}
+
+#else // defined(ASIO_HAS_VARIADIC_TEMPLATES)
 
-    void operator()(T t)
+template <typename T, typename F>
+inline void promise_invoke_and_set(std::promise<T>& p, F& f)
+{
+#if !defined(ASIO_NO_EXCEPTIONS)
+  try
+#endif // !defined(ASIO_NO_EXCEPTIONS)
+  {
+    p.set_value(f());
+  }
+#if !defined(ASIO_NO_EXCEPTIONS)
+  catch (...)
+  {
+    p.set_exception(std::current_exception());
+  }
+#endif // !defined(ASIO_NO_EXCEPTIONS)
+}
+
+template <typename F, typename Args>
+inline void promise_invoke_and_set(std::promise<void>& p, F& f)
+{
+#if !defined(ASIO_NO_EXCEPTIONS)
+  try
+#endif // !defined(ASIO_NO_EXCEPTIONS)
+  {
+    f();
+    p.set_value();
+#if !defined(ASIO_NO_EXCEPTIONS)
+  }
+  catch (...)
+  {
+    p.set_exception(std::current_exception());
+  }
+#endif // !defined(ASIO_NO_EXCEPTIONS)
+}
+
+#if defined(ASIO_NO_EXCEPTIONS)
+
+#define ASIO_PRIVATE_PROMISE_INVOKE_DEF(n) \
+  template <typename T, typename F, ASIO_VARIADIC_TPARAMS(n)> \
+  inline void promise_invoke_and_set(std::promise<T>& p, \
+      F& f, ASIO_VARIADIC_MOVE_PARAMS(n)) \
+  { \
+    p.set_value(f(ASIO_VARIADIC_MOVE_ARGS(n))); \
+  } \
+  \
+  template <typename F, ASIO_VARIADIC_TPARAMS(n)> \
+  inline void promise_invoke_and_set(std::promise<void>& p, \
+      F& f, ASIO_VARIADIC_MOVE_PARAMS(n)) \
+  { \
+    f(ASIO_VARIADIC_MOVE_ARGS(n)); \
+    p.set_value(); \
+  } \
+  /**/
+  ASIO_VARIADIC_GENERATE(ASIO_PRIVATE_PROMISE_INVOKE_DEF)
+#undef ASIO_PRIVATE_PROMISE_INVOKE_DEF
+
+#else // defined(ASIO_NO_EXCEPTIONS)
+
+#define ASIO_PRIVATE_PROMISE_INVOKE_DEF(n) \
+  template <typename T, typename F, ASIO_VARIADIC_TPARAMS(n)> \
+  inline void promise_invoke_and_set(std::promise<T>& p, \
+      F& f, ASIO_VARIADIC_MOVE_PARAMS(n)) \
+  { \
+    try \
+    { \
+      p.set_value(f(ASIO_VARIADIC_MOVE_ARGS(n))); \
+    } \
+    catch (...) \
+    { \
+      p.set_exception(std::current_exception()); \
+    } \
+  } \
+  \
+  template <typename F, ASIO_VARIADIC_TPARAMS(n)> \
+  inline void promise_invoke_and_set(std::promise<void>& p, \
+      F& f, ASIO_VARIADIC_MOVE_PARAMS(n)) \
+  { \
+    try \
+    { \
+      f(ASIO_VARIADIC_MOVE_ARGS(n)); \
+      p.set_value(); \
+    } \
+    catch (...) \
+    { \
+      p.set_exception(std::current_exception()); \
+    } \
+  } \
+  /**/
+  ASIO_VARIADIC_GENERATE(ASIO_PRIVATE_PROMISE_INVOKE_DEF)
+#undef ASIO_PRIVATE_PROMISE_INVOKE_DEF
+
+#endif // defined(ASIO_NO_EXCEPTIONS)
+
+#endif // defined(ASIO_HAS_VARIADIC_TEMPLATES)
+
+// A function object adapter to invoke a nullary function object and capture
+// any exception thrown into a promise.
+template <typename T, typename F>
+class promise_invoker
+{
+public:
+  promise_invoker(const shared_ptr<std::promise<T> >& p,
+      ASIO_MOVE_ARG(F) f)
+    : p_(p), f_(f)
+  {
+  }
+
+  void operator()()
+  {
+#if !defined(ASIO_NO_EXCEPTIONS)
+    try
+#endif // !defined(ASIO_NO_EXCEPTIONS)
     {
-      promise_->set_value(t);
+      f_();
     }
-
-    void operator()(const asio::error_code& ec, T t)
+#if !defined(ASIO_NO_EXCEPTIONS)
+    catch (...)
     {
-      if (ec)
-        promise_->set_exception(
-            std::make_exception_ptr(
-              asio::system_error(ec)));
-      else
-        promise_->set_value(t);
+      p_->set_exception(std::current_exception());
     }
+#endif // !defined(ASIO_NO_EXCEPTIONS)
+  }
+
+private:
+  shared_ptr<std::promise<T> > p_;
+  typename decay<F>::type f_;
+};
+
+// An executor that adapts the system_executor to capture any exeption thrown
+// by a submitted function object and save it into a promise.
+template <typename T>
+class promise_executor
+{
+public:
+  explicit promise_executor(const shared_ptr<std::promise<T> >& p)
+    : p_(p)
+  {
+  }
+
+  execution_context& context() const ASIO_NOEXCEPT
+  {
+    return system_executor().context();
+  }
+
+  void on_work_started() const ASIO_NOEXCEPT {}
+  void on_work_finished() const ASIO_NOEXCEPT {}
+
+  template <typename F, typename A>
+  void dispatch(ASIO_MOVE_ARG(F) f, const A&) const
+  {
+    promise_invoker<T, F>(p_, ASIO_MOVE_CAST(F)(f))();
+  }
+
+  template <typename F, typename A>
+  void post(ASIO_MOVE_ARG(F) f, const A& a) const
+  {
+    system_executor().post(
+        promise_invoker<T, F>(p_, ASIO_MOVE_CAST(F)(f)), a);
+  }
+
+  template <typename F, typename A>
+  void defer(ASIO_MOVE_ARG(F) f, const A& a) const
+  {
+    system_executor().defer(
+        promise_invoker<T, F>(p_, ASIO_MOVE_CAST(F)(f)), a);
+  }
+
+  friend bool operator==(const promise_executor& a,
+      const promise_executor& b) ASIO_NOEXCEPT
+  {
+    return a.p_ == b.p_;
+  }
+
+  friend bool operator!=(const promise_executor& a,
+      const promise_executor& b) ASIO_NOEXCEPT
+  {
+    return a.p_ != b.p_;
+  }
+
+private:
+  shared_ptr<std::promise<T> > p_;
+};
+
+// The base class for all completion handlers that create promises.
+template <typename T>
+class promise_creator
+{
+public:
+  typedef promise_executor<T> executor_type;
+
+  executor_type get_executor() const ASIO_NOEXCEPT
+  {
+    return executor_type(p_);
+  }
+
+  typedef std::future<T> future_type;
 
-  //private:
-    std::shared_ptr<std::promise<T> > promise_;
-  };
+  future_type get_future()
+  {
+    return p_->get_future();
+  }
 
-  // Completion handler to adapt a void promise as a completion handler.
-  template <>
-  class promise_handler<void>
+protected:
+  template <typename Allocator>
+  void create_promise(const Allocator& a)
   {
-  public:
-    // Construct from use_future special value. Used during rebinding.
-    template <typename Allocator>
-    promise_handler(use_future_t<Allocator> uf)
-      : promise_(std::allocate_shared<std::promise<void> >(
-            uf.get_allocator(), std::allocator_arg, uf.get_allocator()))
+    p_ = std::allocate_shared<std::promise<T>>(
+        typename Allocator::template rebind<char>::other(a),
+        std::allocator_arg,
+        typename Allocator::template rebind<char>::other(a));
+  }
+
+  shared_ptr<std::promise<T> > p_;
+};
+
+// For completion signature void().
+class promise_handler_0
+  : public promise_creator<void>
+{
+public:
+  void operator()()
+  {
+    this->p_->set_value();
+  }
+};
+
+// For completion signature void(error_code).
+class promise_handler_ec_0
+  : public promise_creator<void>
+{
+public:
+  void operator()(const asio::error_code& ec)
+  {
+    if (ec)
     {
+      this->p_->set_exception(
+          std::make_exception_ptr(
+            asio::system_error(ec)));
     }
+    else
+    {
+      this->p_->set_value();
+    }
+  }
+};
 
-    void operator()()
+// For completion signature void(exception_ptr).
+class promise_handler_ex_0
+  : public promise_creator<void>
+{
+public:
+  void operator()(const std::exception_ptr& ex)
+  {
+    if (ex)
     {
-      promise_->set_value();
+      this->p_->set_exception(ex);
     }
+    else
+    {
+      this->p_->set_value();
+    }
+  }
+};
 
-    void operator()(const asio::error_code& ec)
+// For completion signature void(T).
+template <typename T>
+class promise_handler_1
+  : public promise_creator<T>
+{
+public:
+  template <typename Arg>
+  void operator()(ASIO_MOVE_ARG(Arg) arg)
+  {
+    this->p_->set_value(ASIO_MOVE_CAST(Arg)(arg));
+  }
+};
+
+// For completion signature void(error_code, T).
+template <typename T>
+class promise_handler_ec_1
+  : public promise_creator<T>
+{
+public:
+  template <typename Arg>
+  void operator()(const asio::error_code& ec,
+      ASIO_MOVE_ARG(Arg) arg)
+  {
+    if (ec)
     {
-      if (ec)
-        promise_->set_exception(
-            std::make_exception_ptr(
-              asio::system_error(ec)));
-      else
-        promise_->set_value();
+      this->p_->set_exception(
+          std::make_exception_ptr(
+            asio::system_error(ec)));
     }
+    else
+      this->p_->set_value(ASIO_MOVE_CAST(Arg)(arg));
+  }
+};
+
+// For completion signature void(exception_ptr, T).
+template <typename T>
+class promise_handler_ex_1
+  : public promise_creator<T>
+{
+public:
+  template <typename Arg>
+  void operator()(const std::exception_ptr& ex,
+      ASIO_MOVE_ARG(Arg) arg)
+  {
+    if (ex)
+      this->p_->set_exception(ex);
+    else
+      this->p_->set_value(ASIO_MOVE_CAST(Arg)(arg));
+  }
+};
 
-  //private:
-    std::shared_ptr<std::promise<void> > promise_;
-  };
+// For completion signature void(T1, ..., Tn);
+template <typename T>
+class promise_handler_n
+  : public promise_creator<T>
+{
+public:
+#if defined(ASIO_HAS_VARIADIC_TEMPLATES)
 
-  // Ensure any exceptions thrown from the handler are propagated back to the
-  // caller via the future.
-  template <typename Function, typename T>
-  void asio_handler_invoke(Function f, promise_handler<T>* h)
+  template <typename... Args>
+  void operator()(ASIO_MOVE_ARG(Args)... args)
   {
-    std::shared_ptr<std::promise<T> > p(h->promise_);
-    try
+    this->p_->set_value(
+        std::forward_as_tuple(
+          ASIO_MOVE_CAST(Args)(args)...));
+  }
+
+#else // defined(ASIO_HAS_VARIADIC_TEMPLATES)
+
+#define ASIO_PRIVATE_CALL_OP_DEF(n) \
+  template <ASIO_VARIADIC_TPARAMS(n)> \
+  void operator()(ASIO_VARIADIC_MOVE_PARAMS(n)) \
+  {\
+    this->p_->set_value( \
+        std::forward_as_tuple( \
+          ASIO_VARIADIC_MOVE_ARGS(n))); \
+  } \
+  /**/
+  ASIO_VARIADIC_GENERATE(ASIO_PRIVATE_CALL_OP_DEF)
+#undef ASIO_PRIVATE_CALL_OP_DEF
+
+#endif // defined(ASIO_HAS_VARIADIC_TEMPLATES)
+};
+
+// For completion signature void(error_code, T1, ..., Tn);
+template <typename T>
+class promise_handler_ec_n
+  : public promise_creator<T>
+{
+public:
+#if defined(ASIO_HAS_VARIADIC_TEMPLATES)
+
+  template <typename... Args>
+  void operator()(const asio::error_code& ec,
+      ASIO_MOVE_ARG(Args)... args)
+  {
+    if (ec)
     {
-      f();
+      this->p_->set_exception(
+          std::make_exception_ptr(
+            asio::system_error(ec)));
     }
-    catch (...)
+    else
     {
-      p->set_exception(std::current_exception());
+      this->p_->set_value(
+          std::forward_as_tuple(
+            ASIO_MOVE_CAST(Args)(args)...));
     }
   }
 
-} // namespace detail
+#else // defined(ASIO_HAS_VARIADIC_TEMPLATES)
 
-#if !defined(GENERATING_DOCUMENTATION)
+#define ASIO_PRIVATE_CALL_OP_DEF(n) \
+  template <ASIO_VARIADIC_TPARAMS(n)> \
+  void operator()(const asio::error_code& ec, \
+      ASIO_VARIADIC_MOVE_PARAMS(n)) \
+  {\
+    if (ec) \
+    { \
+      this->p_->set_exception( \
+          std::make_exception_ptr( \
+            asio::system_error(ec))); \
+    } \
+    else \
+    { \
+      this->p_->set_value( \
+          std::forward_as_tuple( \
+            ASIO_VARIADIC_MOVE_ARGS(n))); \
+    } \
+  } \
+  /**/
+  ASIO_VARIADIC_GENERATE(ASIO_PRIVATE_CALL_OP_DEF)
+#undef ASIO_PRIVATE_CALL_OP_DEF
+
+#endif // defined(ASIO_HAS_VARIADIC_TEMPLATES)
+};
 
-// Handler traits specialisation for promise_handler.
+// For completion signature void(exception_ptr, T1, ..., Tn);
 template <typename T>
-class async_result<detail::promise_handler<T> >
+class promise_handler_ex_n
+  : public promise_creator<T>
+{
+public:
+#if defined(ASIO_HAS_VARIADIC_TEMPLATES)
+
+  template <typename... Args>
+  void operator()(const std::exception_ptr& ex,
+      ASIO_MOVE_ARG(Args)... args)
+  {
+    if (ex)
+      this->p_->set_exception(ex);
+    else
+    {
+      this->p_->set_value(
+          std::forward_as_tuple(
+            ASIO_MOVE_CAST(Args)(args)...));
+    }
+  }
+
+#else // defined(ASIO_HAS_VARIADIC_TEMPLATES)
+
+#define ASIO_PRIVATE_CALL_OP_DEF(n) \
+  template <ASIO_VARIADIC_TPARAMS(n)> \
+  void operator()(const std::exception_ptr& ex, \
+      ASIO_VARIADIC_MOVE_PARAMS(n)) \
+  {\
+    if (ex) \
+      this->p_->set_exception(ex); \
+    else \
+    { \
+      this->p_->set_value( \
+          std::forward_as_tuple( \
+            ASIO_VARIADIC_MOVE_ARGS(n))); \
+    } \
+  } \
+  /**/
+  ASIO_VARIADIC_GENERATE(ASIO_PRIVATE_CALL_OP_DEF)
+#undef ASIO_PRIVATE_CALL_OP_DEF
+
+#endif // defined(ASIO_HAS_VARIADIC_TEMPLATES)
+};
+
+// Helper template to choose the appropriate concrete promise handler
+// implementation based on the supplied completion signature.
+template <typename> class promise_handler_selector;
+
+template <>
+class promise_handler_selector<void()>
+  : public promise_handler_0 {};
+
+template <>
+class promise_handler_selector<void(asio::error_code)>
+  : public promise_handler_ec_0 {};
+
+template <>
+class promise_handler_selector<void(std::exception_ptr)>
+  : public promise_handler_ex_0 {};
+
+template <typename Arg>
+class promise_handler_selector<void(Arg)>
+  : public promise_handler_1<Arg> {};
+
+template <typename Arg>
+class promise_handler_selector<void(asio::error_code, Arg)>
+  : public promise_handler_ec_1<Arg> {};
+
+template <typename Arg>
+class promise_handler_selector<void(std::exception_ptr, Arg)>
+  : public promise_handler_ex_1<Arg> {};
+
+template <typename... Arg>
+class promise_handler_selector<void(Arg...)>
+  : public promise_handler_n<std::tuple<Arg...> > {};
+
+template <typename... Arg>
+class promise_handler_selector<void(asio::error_code, Arg...)>
+  : public promise_handler_ec_n<std::tuple<Arg...> > {};
+
+template <typename... Arg>
+class promise_handler_selector<void(std::exception_ptr, Arg...)>
+  : public promise_handler_ex_n<std::tuple<Arg...> > {};
+
+// Completion handlers produced from the use_future completion token, when not
+// using use_future::operator().
+template <typename Signature, typename Allocator>
+class promise_handler
+  : public promise_handler_selector<Signature>
+{
+public:
+  typedef Allocator allocator_type;
+  typedef void result_type;
+
+  promise_handler(use_future_t<Allocator> u)
+    : allocator_(u.get_allocator())
+  {
+    this->create_promise(allocator_);
+  }
+
+  allocator_type get_allocator() const ASIO_NOEXCEPT
+  {
+    return allocator_;
+  }
+
+private:
+  Allocator allocator_;
+};
+
+template <typename Function, typename Signature, typename Allocator>
+inline void asio_handler_invoke(Function& f,
+    promise_handler<Signature, Allocator>* h)
+{
+  typename promise_handler<Signature, Allocator>::executor_type
+    ex(h->get_executor());
+  ex.dispatch(ASIO_MOVE_CAST(Function)(f), std::allocator<void>());
+}
+
+template <typename Function, typename Signature, typename Allocator>
+inline void asio_handler_invoke(const Function& f,
+    promise_handler<Signature, Allocator>* h)
+{
+  typename promise_handler<Signature, Allocator>::executor_type
+    ex(h->get_executor());
+  ex.dispatch(f, std::allocator<void>());
+}
+
+// Helper base class for async_result specialisation.
+template <typename Signature, typename Allocator>
+class promise_async_result
+{
+public:
+  typedef promise_handler<Signature, Allocator> completion_handler_type;
+  typedef typename completion_handler_type::future_type return_type;
+
+  explicit promise_async_result(completion_handler_type& h)
+    : future_(h.get_future())
+  {
+  }
+
+  return_type get()
+  {
+    return ASIO_MOVE_CAST(return_type)(future_);
+  }
+
+private:
+  return_type future_;
+};
+
+// Return value from use_future::operator().
+template <typename Function, typename Allocator>
+class packaged_token
+{
+public:
+  packaged_token(Function f, const Allocator& a)
+    : function_(ASIO_MOVE_CAST(Function)(f)),
+      allocator_(a)
+  {
+  }
+
+//private:
+  Function function_;
+  Allocator allocator_;
+};
+
+// Completion handlers produced from the use_future completion token, when
+// using use_future::operator().
+template <typename Function, typename Allocator, typename Result>
+class packaged_handler
+  : public promise_creator<Result>
+{
+public:
+  typedef Allocator allocator_type;
+  typedef void result_type;
+
+  packaged_handler(packaged_token<Function, Allocator> t)
+    : function_(ASIO_MOVE_CAST(Function)(t.function_)),
+      allocator_(t.allocator_)
+  {
+    this->create_promise(allocator_);
+  }
+
+  allocator_type get_allocator() const ASIO_NOEXCEPT
+  {
+    return allocator_;
+  }
+
+#if defined(ASIO_HAS_VARIADIC_TEMPLATES)
+
+  template <typename... Args>
+  void operator()(ASIO_MOVE_ARG(Args)... args)
+  {
+    (promise_invoke_and_set)(*this->p_,
+        function_, ASIO_MOVE_CAST(Args)(args)...);
+  }
+
+#else // defined(ASIO_HAS_VARIADIC_TEMPLATES)
+
+  void operator()()
+  {
+    (promise_invoke_and_set)(*this->p_, function_);
+  }
+
+#define ASIO_PRIVATE_CALL_OP_DEF(n) \
+  template <ASIO_VARIADIC_TPARAMS(n)> \
+  void operator()(ASIO_VARIADIC_MOVE_PARAMS(n)) \
+  {\
+    (promise_invoke_and_set)(*this->p_, \
+        function_, ASIO_VARIADIC_MOVE_ARGS(n)); \
+  } \
+  /**/
+  ASIO_VARIADIC_GENERATE(ASIO_PRIVATE_CALL_OP_DEF)
+#undef ASIO_PRIVATE_CALL_OP_DEF
+
+#endif // defined(ASIO_HAS_VARIADIC_TEMPLATES)
+
+private:
+  Function function_;
+  Allocator allocator_;
+};
+
+template <typename Function,
+    typename Function1, typename Allocator, typename Result>
+inline void asio_handler_invoke(Function& f,
+    packaged_handler<Function1, Allocator, Result>* h)
+{
+  typename packaged_handler<Function1, Allocator, Result>::executor_type
+    ex(h->get_executor());
+  ex.dispatch(ASIO_MOVE_CAST(Function)(f), std::allocator<void>());
+}
+
+template <typename Function,
+    typename Function1, typename Allocator, typename Result>
+inline void asio_handler_invoke(const Function& f,
+    packaged_handler<Function1, Allocator, Result>* h)
+{
+  typename packaged_handler<Function1, Allocator, Result>::executor_type
+    ex(h->get_executor());
+  ex.dispatch(f, std::allocator<void>());
+}
+
+// Helper base class for async_result specialisation.
+template <typename Function, typename Allocator, typename Result>
+class packaged_async_result
 {
 public:
-  // The initiating function will return a future.
-  typedef std::future<T> type;
+  typedef packaged_handler<Function, Allocator, Result> completion_handler_type;
+  typedef typename completion_handler_type::future_type return_type;
 
-  // Constructor creates a new promise for the async operation, and obtains the
-  // corresponding future.
-  explicit async_result(detail::promise_handler<T>& h)
+  explicit packaged_async_result(completion_handler_type& h)
+    : future_(h.get_future())
   {
-    value_ = h.promise_->get_future();
   }
 
-  // Obtain the future to be returned from the initiating function.
-  type get() { return std::move(value_); }
+  return_type get()
+  {
+    return ASIO_MOVE_CAST(return_type)(future_);
+  }
 
 private:
-  type value_;
+  return_type future_;
 };
 
-// Handler type specialisation for use_future.
-template <typename Allocator, typename ReturnType>
-struct handler_type<use_future_t<Allocator>, ReturnType()>
+} // namespace detail
+
+template <typename Allocator> template <typename Function>
+inline detail::packaged_token<typename decay<Function>::type, Allocator>
+use_future_t<Allocator>::operator()(ASIO_MOVE_ARG(Function) f) const
 {
-  typedef detail::promise_handler<void> type;
+  return detail::packaged_token<typename decay<Function>::type, Allocator>(
+      ASIO_MOVE_CAST(Function)(f), allocator_);
+}
+
+#if !defined(GENERATING_DOCUMENTATION)
+
+#if defined(ASIO_HAS_VARIADIC_TEMPLATES)
+
+template <typename Allocator, typename Result, typename... Args>
+class async_result<use_future_t<Allocator>, Result(Args...)>
+  : public detail::promise_async_result<
+      void(typename decay<Args>::type...), Allocator>
+{
+public:
+  explicit async_result(
+    typename detail::promise_async_result<void(typename decay<Args>::type...),
+      Allocator>::completion_handler_type& h)
+    : detail::promise_async_result<
+        void(typename decay<Args>::type...), Allocator>(h)
+  {
+  }
 };
 
-// Handler type specialisation for use_future.
-template <typename Allocator, typename ReturnType, typename Arg1>
-struct handler_type<use_future_t<Allocator>, ReturnType(Arg1)>
+template <typename Function, typename Allocator,
+    typename Result, typename... Args>
+class async_result<detail::packaged_token<Function, Allocator>, Result(Args...)>
+  : public detail::packaged_async_result<Function, Allocator,
+      typename result_of<Function(Args...)>::type>
 {
-  typedef detail::promise_handler<Arg1> type;
+public:
+  explicit async_result(
+    typename detail::packaged_async_result<Function, Allocator,
+      typename result_of<Function(Args...)>::type>::completion_handler_type& h)
+    : detail::packaged_async_result<Function, Allocator,
+        typename result_of<Function(Args...)>::type>(h)
+  {
+  }
+};
+
+#else // defined(ASIO_HAS_VARIADIC_TEMPLATES)
+
+template <typename Allocator, typename Result>
+class async_result<use_future_t<Allocator>, Result()>
+  : public detail::promise_async_result<void(), Allocator>
+{
+public:
+  explicit async_result(
+    typename detail::promise_async_result<
+      void(), Allocator>::completion_handler_type& h)
+    : detail::promise_async_result<void(), Allocator>(h)
+  {
+  }
+};
+
+template <typename Function, typename Allocator, typename Result>
+class async_result<detail::packaged_token<Function, Allocator>, Result()>
+  : public detail::packaged_async_result<Function, Allocator,
+      typename result_of<Function()>::type>
+{
+public:
+  explicit async_result(
+    typename detail::packaged_async_result<Function, Allocator,
+      typename result_of<Function()>::type>::completion_handler_type& h)
+    : detail::packaged_async_result<Function, Allocator,
+        typename result_of<Function()>::type>(h)
+  {
+  }
+};
+
+#define ASIO_PRIVATE_ASYNC_RESULT_DEF(n) \
+  template <typename Allocator, \
+      typename Result, ASIO_VARIADIC_TPARAMS(n)> \
+  class async_result<use_future_t<Allocator>, \
+      Result(ASIO_VARIADIC_TARGS(n))> \
+    : public detail::promise_async_result< \
+        void(ASIO_VARIADIC_DECAY(n)), Allocator> \
+  { \
+  public: \
+    explicit async_result( \
+      typename detail::promise_async_result< \
+        void(ASIO_VARIADIC_DECAY(n)), \
+        Allocator>::completion_handler_type& h) \
+      : detail::promise_async_result< \
+          void(ASIO_VARIADIC_DECAY(n)), Allocator>(h) \
+    { \
+    } \
+  }; \
+  \
+  template <typename Function, typename Allocator, \
+      typename Result, ASIO_VARIADIC_TPARAMS(n)> \
+  class async_result<detail::packaged_token<Function, Allocator>, \
+      Result(ASIO_VARIADIC_TARGS(n))> \
+    : public detail::packaged_async_result<Function, Allocator, \
+        typename result_of<Function(ASIO_VARIADIC_TARGS(n))>::type> \
+  { \
+  public: \
+    explicit async_result( \
+      typename detail::packaged_async_result<Function, Allocator, \
+        typename result_of<Function(ASIO_VARIADIC_TARGS(n))>::type \
+        >::completion_handler_type& h) \
+      : detail::packaged_async_result<Function, Allocator, \
+          typename result_of<Function(ASIO_VARIADIC_TARGS(n))>::type>(h) \
+    { \
+    } \
+  }; \
+  /**/
+  ASIO_VARIADIC_GENERATE(ASIO_PRIVATE_ASYNC_RESULT_DEF)
+#undef ASIO_PRIVATE_ASYNC_RESULT_DEF
+
+#endif // defined(ASIO_HAS_VARIADIC_TEMPLATES)
+
+#if !defined(ASIO_NO_DEPRECATED)
+
+template <typename Allocator, typename Signature>
+struct handler_type<use_future_t<Allocator>, Signature>
+{
+  typedef typename async_result<use_future_t<Allocator>,
+    Signature>::completion_handler_type type;
 };
 
-// Handler type specialisation for use_future.
-template <typename Allocator, typename ReturnType>
-struct handler_type<use_future_t<Allocator>,
-    ReturnType(asio::error_code)>
+template <typename Signature, typename Allocator>
+class async_result<detail::promise_handler<Signature, Allocator> >
+  : public detail::promise_async_result<Signature, Allocator>
 {
-  typedef detail::promise_handler<void> type;
+public:
+  typedef typename detail::promise_async_result<
+    Signature, Allocator>::return_type type;
+
+  explicit async_result(
+    typename detail::promise_async_result<
+      Signature, Allocator>::completion_handler_type& h)
+    : detail::promise_async_result<Signature, Allocator>(h)
+  {
+  }
 };
 
-// Handler type specialisation for use_future.
-template <typename Allocator, typename ReturnType, typename Arg2>
-struct handler_type<use_future_t<Allocator>,
-    ReturnType(asio::error_code, Arg2)>
+template <typename Function, typename Allocator, typename Signature>
+struct handler_type<detail::packaged_token<Function, Allocator>, Signature>
 {
-  typedef detail::promise_handler<Arg2> type;
+  typedef typename async_result<detail::packaged_token<Function, Allocator>,
+    Signature>::completion_handler_type type;
 };
 
+template <typename Function, typename Allocator, typename Result>
+class async_result<detail::packaged_handler<Function, Allocator, Result> >
+  : public detail::packaged_async_result<Function, Allocator, Result>
+{
+public:
+  typedef typename detail::packaged_async_result<
+    Function, Allocator, Result>::return_type type;
+
+  explicit async_result(
+    typename detail::packaged_async_result<
+      Function, Allocator, Result>::completion_handler_type& h)
+    : detail::packaged_async_result<Function, Allocator, Result>(h)
+  {
+  }
+};
+
+#endif // !defined(ASIO_NO_DEPRECATED)
+
 #endif // !defined(GENERATING_DOCUMENTATION)
 
 } // namespace asio
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/write.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/write.hpp
index 34f882e..8250aa3 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/write.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/write.hpp
@@ -2,7 +2,7 @@
 // impl/write.hpp
 // ~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -34,29 +34,39 @@
 
 namespace asio {
 
+namespace detail
+{
+  template <typename SyncWriteStream, typename ConstBufferSequence,
+      typename ConstBufferIterator, typename CompletionCondition>
+  std::size_t write_buffer_sequence(SyncWriteStream& s,
+      const ConstBufferSequence& buffers, const ConstBufferIterator&,
+      CompletionCondition completion_condition, asio::error_code& ec)
+  {
+    ec = asio::error_code();
+    asio::detail::consuming_buffers<const_buffer,
+        ConstBufferSequence, ConstBufferIterator> tmp(buffers);
+    while (!tmp.empty())
+    {
+      if (std::size_t max_size = detail::adapt_completion_condition_result(
+            completion_condition(ec, tmp.total_consumed())))
+        tmp.consume(s.write_some(tmp.prepare(max_size), ec));
+      else
+        break;
+    }
+    return tmp.total_consumed();;
+  }
+} // namespace detail
+
 template <typename SyncWriteStream, typename ConstBufferSequence,
     typename CompletionCondition>
-std::size_t write(SyncWriteStream& s, const ConstBufferSequence& buffers,
+inline std::size_t write(SyncWriteStream& s, const ConstBufferSequence& buffers,
     CompletionCondition completion_condition, asio::error_code& ec,
     typename enable_if<
       is_const_buffer_sequence<ConstBufferSequence>::value
     >::type*)
 {
-  ec = asio::error_code();
-  asio::detail::consuming_buffers<
-    const_buffer, ConstBufferSequence> tmp(buffers);
-  std::size_t total_transferred = 0;
-  tmp.prepare(detail::adapt_completion_condition_result(
-        completion_condition(ec, total_transferred)));
-  while (tmp.begin() != tmp.end())
-  {
-    std::size_t bytes_transferred = s.write_some(tmp, ec);
-    tmp.consume(bytes_transferred);
-    total_transferred += bytes_transferred;
-    tmp.prepare(detail::adapt_completion_condition_result(
-          completion_condition(ec, total_transferred)));
-  }
-  return total_transferred;
+  return detail::write_buffer_sequence(s, buffers,
+      asio::buffer_sequence_begin(buffers), completion_condition, ec);
 }
 
 template <typename SyncWriteStream, typename ConstBufferSequence>
@@ -95,67 +105,68 @@ inline std::size_t write(SyncWriteStream& s, const ConstBufferSequence& buffers,
   return bytes_transferred;
 }
 
-template <typename SyncWriteStream, typename DynamicBufferSequence,
+template <typename SyncWriteStream, typename DynamicBuffer,
     typename CompletionCondition>
 std::size_t write(SyncWriteStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     CompletionCondition completion_condition, asio::error_code& ec,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type*)
 {
-  typename decay<DynamicBufferSequence>::type b(
-      ASIO_MOVE_CAST(DynamicBufferSequence)(buffers));
+  typename decay<DynamicBuffer>::type b(
+      ASIO_MOVE_CAST(DynamicBuffer)(buffers));
 
   std::size_t bytes_transferred = write(s, b.data(), completion_condition, ec);
   b.consume(bytes_transferred);
   return bytes_transferred;
 }
 
-template <typename SyncWriteStream, typename DynamicBufferSequence>
+template <typename SyncWriteStream, typename DynamicBuffer>
 inline std::size_t write(SyncWriteStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type*)
 {
   asio::error_code ec;
   std::size_t bytes_transferred = write(s,
-      ASIO_MOVE_CAST(DynamicBufferSequence)(buffers),
+      ASIO_MOVE_CAST(DynamicBuffer)(buffers),
       transfer_all(), ec);
   asio::detail::throw_error(ec, "write");
   return bytes_transferred;
 }
 
-template <typename SyncWriteStream, typename DynamicBufferSequence>
+template <typename SyncWriteStream, typename DynamicBuffer>
 inline std::size_t write(SyncWriteStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     asio::error_code& ec,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type*)
 {
-  return write(s, ASIO_MOVE_CAST(DynamicBufferSequence)(buffers),
+  return write(s, ASIO_MOVE_CAST(DynamicBuffer)(buffers),
       transfer_all(), ec);
 }
 
-template <typename SyncWriteStream, typename DynamicBufferSequence,
+template <typename SyncWriteStream, typename DynamicBuffer,
     typename CompletionCondition>
 inline std::size_t write(SyncWriteStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     CompletionCondition completion_condition,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type*)
 {
   asio::error_code ec;
   std::size_t bytes_transferred = write(s,
-      ASIO_MOVE_CAST(DynamicBufferSequence)(buffers),
+      ASIO_MOVE_CAST(DynamicBuffer)(buffers),
       completion_condition, ec);
   asio::detail::throw_error(ec, "write");
   return bytes_transferred;
 }
 
+#if !defined(ASIO_NO_EXTENSIONS)
 #if !defined(ASIO_NO_IOSTREAM)
 
 template <typename SyncWriteStream, typename Allocator,
@@ -192,11 +203,13 @@ inline std::size_t write(SyncWriteStream& s,
 }
 
 #endif // !defined(ASIO_NO_IOSTREAM)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 namespace detail
 {
   template <typename AsyncWriteStream, typename ConstBufferSequence,
-      typename CompletionCondition, typename WriteHandler>
+      typename ConstBufferIterator, typename CompletionCondition,
+      typename WriteHandler>
   class write_op
     : detail::base_from_completion_cond<CompletionCondition>
   {
@@ -208,7 +221,6 @@ namespace detail
         stream_(stream),
         buffers_(buffers),
         start_(0),
-        total_transferred_(0),
         handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
     {
     }
@@ -219,7 +231,6 @@ namespace detail
         stream_(other.stream_),
         buffers_(other.buffers_),
         start_(other.start_),
-        total_transferred_(other.total_transferred_),
         handler_(other.handler_)
     {
     }
@@ -229,7 +240,6 @@ namespace detail
         stream_(other.stream_),
         buffers_(other.buffers_),
         start_(other.start_),
-        total_transferred_(other.total_transferred_),
         handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
     {
     }
@@ -238,362 +248,39 @@ namespace detail
     void operator()(const asio::error_code& ec,
         std::size_t bytes_transferred, int start = 0)
     {
+      std::size_t max_size;
       switch (start_ = start)
       {
         case 1:
-        buffers_.prepare(this->check_for_completion(ec, total_transferred_));
-        for (;;)
+        max_size = this->check_for_completion(ec, buffers_.total_consumed());
+        do
         {
-          stream_.async_write_some(buffers_,
+          stream_.async_write_some(buffers_.prepare(max_size),
               ASIO_MOVE_CAST(write_op)(*this));
           return; default:
-          total_transferred_ += bytes_transferred;
           buffers_.consume(bytes_transferred);
-          buffers_.prepare(this->check_for_completion(ec, total_transferred_));
-          if ((!ec && bytes_transferred == 0)
-              || buffers_.begin() == buffers_.end())
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncWriteStream& stream_;
-    asio::detail::consuming_buffers<
-      const_buffer, ConstBufferSequence> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    WriteHandler handler_;
-  };
-
-  template <typename AsyncWriteStream,
-      typename CompletionCondition, typename WriteHandler>
-  class write_op<AsyncWriteStream, asio::mutable_buffers_1,
-      CompletionCondition, WriteHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    write_op(AsyncWriteStream& stream,
-        const asio::mutable_buffers_1& buffers,
-        CompletionCondition completion_condition,
-        WriteHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        stream_(stream),
-        buffer_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    write_op(const write_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    write_op(write_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          stream_.async_write_some(
-              asio::buffer(buffer_ + total_transferred_, n),
-              ASIO_MOVE_CAST(write_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == asio::buffer_size(buffer_))
+          if ((!ec && bytes_transferred == 0) || buffers_.empty())
             break;
-        }
+          max_size = this->check_for_completion(ec, buffers_.total_consumed());
+        } while (max_size > 0);
 
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
+        handler_(ec, buffers_.total_consumed());
       }
     }
 
   //private:
     AsyncWriteStream& stream_;
-    asio::mutable_buffer buffer_;
+    asio::detail::consuming_buffers<const_buffer,
+        ConstBufferSequence, ConstBufferIterator> buffers_;
     int start_;
-    std::size_t total_transferred_;
     WriteHandler handler_;
   };
 
-  template <typename AsyncWriteStream,
-      typename CompletionCondition, typename WriteHandler>
-  class write_op<AsyncWriteStream, asio::const_buffers_1,
-      CompletionCondition, WriteHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    write_op(AsyncWriteStream& stream,
-        const asio::const_buffers_1& buffers,
-        CompletionCondition completion_condition,
-        WriteHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        stream_(stream),
-        buffer_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    write_op(const write_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    write_op(write_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          stream_.async_write_some(
-              asio::buffer(buffer_ + total_transferred_, n),
-              ASIO_MOVE_CAST(write_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == asio::buffer_size(buffer_))
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncWriteStream& stream_;
-    asio::const_buffer buffer_;
-    int start_;
-    std::size_t total_transferred_;
-    WriteHandler handler_;
-  };
-
-  template <typename AsyncWriteStream, typename Elem,
-      typename CompletionCondition, typename WriteHandler>
-  class write_op<AsyncWriteStream, boost::array<Elem, 2>,
-      CompletionCondition, WriteHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    write_op(AsyncWriteStream& stream, const boost::array<Elem, 2>& buffers,
-        CompletionCondition completion_condition, WriteHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        stream_(stream),
-        buffers_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    write_op(const write_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    write_op(write_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      typename asio::detail::dependent_type<Elem,
-          boost::array<asio::const_buffer, 2> >::type bufs = {{
-        asio::const_buffer(buffers_[0]),
-        asio::const_buffer(buffers_[1]) }};
-      std::size_t buffer_size0 = asio::buffer_size(bufs[0]);
-      std::size_t buffer_size1 = asio::buffer_size(bufs[1]);
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          bufs[0] = asio::buffer(bufs[0] + total_transferred_, n);
-          bufs[1] = asio::buffer(
-              bufs[1] + (total_transferred_ < buffer_size0
-                ? 0 : total_transferred_ - buffer_size0),
-              n - asio::buffer_size(bufs[0]));
-          stream_.async_write_some(bufs, ASIO_MOVE_CAST(write_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == buffer_size0 + buffer_size1)
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncWriteStream& stream_;
-    boost::array<Elem, 2> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    WriteHandler handler_;
-  };
-
-#if defined(ASIO_HAS_STD_ARRAY)
-
-  template <typename AsyncWriteStream, typename Elem,
-      typename CompletionCondition, typename WriteHandler>
-  class write_op<AsyncWriteStream, std::array<Elem, 2>,
-      CompletionCondition, WriteHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    write_op(AsyncWriteStream& stream, const std::array<Elem, 2>& buffers,
-        CompletionCondition completion_condition, WriteHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        stream_(stream),
-        buffers_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    write_op(const write_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    write_op(write_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      typename asio::detail::dependent_type<Elem,
-          std::array<asio::const_buffer, 2> >::type bufs = {{
-        asio::const_buffer(buffers_[0]),
-        asio::const_buffer(buffers_[1]) }};
-      std::size_t buffer_size0 = asio::buffer_size(bufs[0]);
-      std::size_t buffer_size1 = asio::buffer_size(bufs[1]);
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          bufs[0] = asio::buffer(bufs[0] + total_transferred_, n);
-          bufs[1] = asio::buffer(
-              bufs[1] + (total_transferred_ < buffer_size0
-                ? 0 : total_transferred_ - buffer_size0),
-              n - asio::buffer_size(bufs[0]));
-          stream_.async_write_some(bufs, ASIO_MOVE_CAST(write_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == buffer_size0 + buffer_size1)
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncWriteStream& stream_;
-    std::array<Elem, 2> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    WriteHandler handler_;
-  };
-
-#endif // defined(ASIO_HAS_STD_ARRAY)
-
   template <typename AsyncWriteStream, typename ConstBufferSequence,
-      typename CompletionCondition, typename WriteHandler>
+      typename ConstBufferIterator, typename CompletionCondition,
+      typename WriteHandler>
   inline void* asio_handler_allocate(std::size_t size,
-      write_op<AsyncWriteStream, ConstBufferSequence,
+      write_op<AsyncWriteStream, ConstBufferSequence, ConstBufferIterator,
         CompletionCondition, WriteHandler>* this_handler)
   {
     return asio_handler_alloc_helpers::allocate(
@@ -601,9 +288,10 @@ namespace detail
   }
 
   template <typename AsyncWriteStream, typename ConstBufferSequence,
-      typename CompletionCondition, typename WriteHandler>
+      typename ConstBufferIterator, typename CompletionCondition,
+      typename WriteHandler>
   inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      write_op<AsyncWriteStream, ConstBufferSequence,
+      write_op<AsyncWriteStream, ConstBufferSequence, ConstBufferIterator,
         CompletionCondition, WriteHandler>* this_handler)
   {
     asio_handler_alloc_helpers::deallocate(
@@ -611,9 +299,10 @@ namespace detail
   }
 
   template <typename AsyncWriteStream, typename ConstBufferSequence,
-      typename CompletionCondition, typename WriteHandler>
+      typename ConstBufferIterator, typename CompletionCondition,
+      typename WriteHandler>
   inline bool asio_handler_is_continuation(
-      write_op<AsyncWriteStream, ConstBufferSequence,
+      write_op<AsyncWriteStream, ConstBufferSequence, ConstBufferIterator,
         CompletionCondition, WriteHandler>* this_handler)
   {
     return this_handler->start_ == 0 ? true
@@ -622,10 +311,10 @@ namespace detail
   }
 
   template <typename Function, typename AsyncWriteStream,
-      typename ConstBufferSequence, typename CompletionCondition,
-      typename WriteHandler>
+      typename ConstBufferSequence, typename ConstBufferIterator,
+      typename CompletionCondition, typename WriteHandler>
   inline void asio_handler_invoke(Function& function,
-      write_op<AsyncWriteStream, ConstBufferSequence,
+      write_op<AsyncWriteStream, ConstBufferSequence, ConstBufferIterator,
         CompletionCondition, WriteHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
@@ -633,31 +322,46 @@ namespace detail
   }
 
   template <typename Function, typename AsyncWriteStream,
-      typename ConstBufferSequence, typename CompletionCondition,
-      typename WriteHandler>
+      typename ConstBufferSequence, typename ConstBufferIterator,
+      typename CompletionCondition, typename WriteHandler>
   inline void asio_handler_invoke(const Function& function,
-      write_op<AsyncWriteStream, ConstBufferSequence,
+      write_op<AsyncWriteStream, ConstBufferSequence, ConstBufferIterator,
         CompletionCondition, WriteHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
         function, this_handler->handler_);
   }
+
+  template <typename AsyncWriteStream, typename ConstBufferSequence,
+      typename ConstBufferIterator, typename CompletionCondition,
+      typename WriteHandler>
+  inline void start_write_buffer_sequence_op(AsyncWriteStream& stream,
+      const ConstBufferSequence& buffers, const ConstBufferIterator&,
+      CompletionCondition completion_condition, WriteHandler& handler)
+  {
+    detail::write_op<AsyncWriteStream, ConstBufferSequence,
+      ConstBufferIterator, CompletionCondition, WriteHandler>(
+        stream, buffers, completion_condition, handler)(
+          asio::error_code(), 0, 1);
+  }
+
 } // namespace detail
 
 #if !defined(GENERATING_DOCUMENTATION)
 
 template <typename AsyncWriteStream, typename ConstBufferSequence,
-    typename CompletionCondition, typename WriteHandler, typename Allocator>
+    typename ConstBufferIterator, typename CompletionCondition,
+    typename WriteHandler, typename Allocator>
 struct associated_allocator<
     detail::write_op<AsyncWriteStream, ConstBufferSequence,
-      CompletionCondition, WriteHandler>,
+      ConstBufferIterator, CompletionCondition, WriteHandler>,
     Allocator>
 {
   typedef typename associated_allocator<WriteHandler, Allocator>::type type;
 
   static type get(
       const detail::write_op<AsyncWriteStream, ConstBufferSequence,
-        CompletionCondition, WriteHandler>& h,
+        ConstBufferIterator, CompletionCondition, WriteHandler>& h,
       const Allocator& a = Allocator()) ASIO_NOEXCEPT
   {
     return associated_allocator<WriteHandler, Allocator>::get(h.handler_, a);
@@ -665,17 +369,18 @@ struct associated_allocator<
 };
 
 template <typename AsyncWriteStream, typename ConstBufferSequence,
-    typename CompletionCondition, typename WriteHandler, typename Executor>
+    typename ConstBufferIterator, typename CompletionCondition,
+    typename WriteHandler, typename Executor>
 struct associated_executor<
     detail::write_op<AsyncWriteStream, ConstBufferSequence,
-      CompletionCondition, WriteHandler>,
+      ConstBufferIterator, CompletionCondition, WriteHandler>,
     Executor>
 {
   typedef typename associated_executor<WriteHandler, Executor>::type type;
 
   static type get(
       const detail::write_op<AsyncWriteStream, ConstBufferSequence,
-        CompletionCondition, WriteHandler>& h,
+        ConstBufferIterator, CompletionCondition, WriteHandler>& h,
       const Executor& ex = Executor()) ASIO_NOEXCEPT
   {
     return associated_executor<WriteHandler, Executor>::get(h.handler_, ex);
@@ -702,11 +407,9 @@ async_write(AsyncWriteStream& s, const ConstBufferSequence& buffers,
   async_completion<WriteHandler,
     void (asio::error_code, std::size_t)> init(handler);
 
-  detail::write_op<AsyncWriteStream, ConstBufferSequence,
-    CompletionCondition, ASIO_HANDLER_TYPE(
-      WriteHandler, void (asio::error_code, std::size_t))>(
-        s, buffers, completion_condition, init.handler)(
-          asio::error_code(), 0, 1);
+  detail::start_write_buffer_sequence_op(s, buffers,
+      asio::buffer_sequence_begin(buffers), completion_condition,
+      init.completion_handler);
 
   return init.result.get();
 }
@@ -728,18 +431,16 @@ async_write(AsyncWriteStream& s, const ConstBufferSequence& buffers,
   async_completion<WriteHandler,
     void (asio::error_code, std::size_t)> init(handler);
 
-  detail::write_op<AsyncWriteStream, ConstBufferSequence,
-    detail::transfer_all_t, ASIO_HANDLER_TYPE(
-      WriteHandler, void (asio::error_code, std::size_t))>(
-        s, buffers, transfer_all(), init.handler)(
-          asio::error_code(), 0, 1);
+  detail::start_write_buffer_sequence_op(s, buffers,
+      asio::buffer_sequence_begin(buffers), transfer_all(),
+      init.completion_handler);
 
   return init.result.get();
 }
 
 namespace detail
 {
-  template <typename AsyncWriteStream, typename DynamicBufferSequence,
+  template <typename AsyncWriteStream, typename DynamicBuffer,
       typename CompletionCondition, typename WriteHandler>
   class write_dynbuf_op
   {
@@ -767,7 +468,7 @@ namespace detail
 
     write_dynbuf_op(write_dynbuf_op&& other)
       : stream_(other.stream_),
-        buffers_(ASIO_MOVE_CAST(DynamicBufferSequence)(other.buffers_)),
+        buffers_(ASIO_MOVE_CAST(DynamicBuffer)(other.buffers_)),
         completion_condition_(
           ASIO_MOVE_CAST(CompletionCondition)(
             other.completion_condition_)),
@@ -792,35 +493,35 @@ namespace detail
 
   //private:
     AsyncWriteStream& stream_;
-    DynamicBufferSequence buffers_;
+    DynamicBuffer buffers_;
     CompletionCondition completion_condition_;
     WriteHandler handler_;
   };
 
-  template <typename AsyncWriteStream, typename DynamicBufferSequence,
+  template <typename AsyncWriteStream, typename DynamicBuffer,
       typename CompletionCondition, typename WriteHandler>
   inline void* asio_handler_allocate(std::size_t size,
-      write_dynbuf_op<AsyncWriteStream, DynamicBufferSequence,
+      write_dynbuf_op<AsyncWriteStream, DynamicBuffer,
         CompletionCondition, WriteHandler>* this_handler)
   {
     return asio_handler_alloc_helpers::allocate(
         size, this_handler->handler_);
   }
 
-  template <typename AsyncWriteStream, typename DynamicBufferSequence,
+  template <typename AsyncWriteStream, typename DynamicBuffer,
       typename CompletionCondition, typename WriteHandler>
   inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      write_dynbuf_op<AsyncWriteStream, DynamicBufferSequence,
+      write_dynbuf_op<AsyncWriteStream, DynamicBuffer,
         CompletionCondition, WriteHandler>* this_handler)
   {
     asio_handler_alloc_helpers::deallocate(
         pointer, size, this_handler->handler_);
   }
 
-  template <typename AsyncWriteStream, typename DynamicBufferSequence,
+  template <typename AsyncWriteStream, typename DynamicBuffer,
       typename CompletionCondition, typename WriteHandler>
   inline bool asio_handler_is_continuation(
-      write_dynbuf_op<AsyncWriteStream, DynamicBufferSequence,
+      write_dynbuf_op<AsyncWriteStream, DynamicBuffer,
         CompletionCondition, WriteHandler>* this_handler)
   {
     return asio_handler_cont_helpers::is_continuation(
@@ -828,10 +529,10 @@ namespace detail
   }
 
   template <typename Function, typename AsyncWriteStream,
-      typename DynamicBufferSequence, typename CompletionCondition,
+      typename DynamicBuffer, typename CompletionCondition,
       typename WriteHandler>
   inline void asio_handler_invoke(Function& function,
-      write_dynbuf_op<AsyncWriteStream, DynamicBufferSequence,
+      write_dynbuf_op<AsyncWriteStream, DynamicBuffer,
         CompletionCondition, WriteHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
@@ -839,10 +540,10 @@ namespace detail
   }
 
   template <typename Function, typename AsyncWriteStream,
-      typename DynamicBufferSequence, typename CompletionCondition,
+      typename DynamicBuffer, typename CompletionCondition,
       typename WriteHandler>
   inline void asio_handler_invoke(const Function& function,
-      write_dynbuf_op<AsyncWriteStream, DynamicBufferSequence,
+      write_dynbuf_op<AsyncWriteStream, DynamicBuffer,
         CompletionCondition, WriteHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
@@ -852,36 +553,36 @@ namespace detail
 
 #if !defined(GENERATING_DOCUMENTATION)
 
-template <typename AsyncWriteStream, typename DynamicBufferSequence,
+template <typename AsyncWriteStream, typename DynamicBuffer,
     typename CompletionCondition, typename WriteHandler, typename Allocator>
 struct associated_allocator<
     detail::write_dynbuf_op<AsyncWriteStream,
-      DynamicBufferSequence, CompletionCondition, WriteHandler>,
+      DynamicBuffer, CompletionCondition, WriteHandler>,
     Allocator>
 {
   typedef typename associated_allocator<WriteHandler, Allocator>::type type;
 
   static type get(
       const detail::write_dynbuf_op<AsyncWriteStream,
-        DynamicBufferSequence, CompletionCondition, WriteHandler>& h,
+        DynamicBuffer, CompletionCondition, WriteHandler>& h,
       const Allocator& a = Allocator()) ASIO_NOEXCEPT
   {
     return associated_allocator<WriteHandler, Allocator>::get(h.handler_, a);
   }
 };
 
-template <typename AsyncWriteStream, typename DynamicBufferSequence,
+template <typename AsyncWriteStream, typename DynamicBuffer,
     typename CompletionCondition, typename WriteHandler, typename Executor>
 struct associated_executor<
     detail::write_dynbuf_op<AsyncWriteStream,
-      DynamicBufferSequence, CompletionCondition, WriteHandler>,
+      DynamicBuffer, CompletionCondition, WriteHandler>,
     Executor>
 {
   typedef typename associated_executor<WriteHandler, Executor>::type type;
 
   static type get(
       const detail::write_dynbuf_op<AsyncWriteStream,
-        DynamicBufferSequence, CompletionCondition, WriteHandler>& h,
+        DynamicBuffer, CompletionCondition, WriteHandler>& h,
       const Executor& ex = Executor()) ASIO_NOEXCEPT
   {
     return associated_executor<WriteHandler, Executor>::get(h.handler_, ex);
@@ -891,31 +592,31 @@ struct associated_executor<
 #endif // !defined(GENERATING_DOCUMENTATION)
 
 template <typename AsyncWriteStream,
-    typename DynamicBufferSequence, typename WriteHandler>
+    typename DynamicBuffer, typename WriteHandler>
 inline ASIO_INITFN_RESULT_TYPE(WriteHandler,
     void (asio::error_code, std::size_t))
 async_write(AsyncWriteStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     ASIO_MOVE_ARG(WriteHandler) handler,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type*)
 {
   return async_write(s,
-      ASIO_MOVE_CAST(DynamicBufferSequence)(buffers),
+      ASIO_MOVE_CAST(DynamicBuffer)(buffers),
       transfer_all(), ASIO_MOVE_CAST(WriteHandler)(handler));
 }
 
-template <typename AsyncWriteStream, typename DynamicBufferSequence,
+template <typename AsyncWriteStream, typename DynamicBuffer,
     typename CompletionCondition, typename WriteHandler>
 inline ASIO_INITFN_RESULT_TYPE(WriteHandler,
     void (asio::error_code, std::size_t))
 async_write(AsyncWriteStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     CompletionCondition completion_condition,
     ASIO_MOVE_ARG(WriteHandler) handler,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type*)
 {
   // If you get an error on the following line it means that your handler does
@@ -926,16 +627,17 @@ async_write(AsyncWriteStream& s,
     void (asio::error_code, std::size_t)> init(handler);
 
   detail::write_dynbuf_op<AsyncWriteStream,
-    typename decay<DynamicBufferSequence>::type,
+    typename decay<DynamicBuffer>::type,
       CompletionCondition, ASIO_HANDLER_TYPE(
         WriteHandler, void (asio::error_code, std::size_t))>(
-          s, ASIO_MOVE_CAST(DynamicBufferSequence)(buffers),
-            completion_condition, init.handler)(
+          s, ASIO_MOVE_CAST(DynamicBuffer)(buffers),
+            completion_condition, init.completion_handler)(
               asio::error_code(), 0, 1);
 
   return init.result.get();
 }
 
+#if !defined(ASIO_NO_EXTENSIONS)
 #if !defined(ASIO_NO_IOSTREAM)
 
 template <typename AsyncWriteStream, typename Allocator, typename WriteHandler>
@@ -963,6 +665,7 @@ async_write(AsyncWriteStream& s,
 }
 
 #endif // !defined(ASIO_NO_IOSTREAM)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 } // namespace asio
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/write_at.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/write_at.hpp
index fb539df..9e06bd2 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/write_at.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/impl/write_at.hpp
@@ -2,7 +2,7 @@
 // impl/write_at.hpp
 // ~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -34,28 +34,41 @@
 
 namespace asio {
 
+namespace detail
+{
+  template <typename SyncRandomAccessWriteDevice, typename ConstBufferSequence,
+      typename ConstBufferIterator, typename CompletionCondition>
+  std::size_t write_at_buffer_sequence(SyncRandomAccessWriteDevice& d,
+      uint64_t offset, const ConstBufferSequence& buffers,
+      const ConstBufferIterator&, CompletionCondition completion_condition,
+      asio::error_code& ec)
+  {
+    ec = asio::error_code();
+    asio::detail::consuming_buffers<const_buffer,
+        ConstBufferSequence, ConstBufferIterator> tmp(buffers);
+    while (!tmp.empty())
+    {
+      if (std::size_t max_size = detail::adapt_completion_condition_result(
+            completion_condition(ec, tmp.total_consumed())))
+      {
+        tmp.consume(d.write_some_at(offset + tmp.total_consumed(),
+              tmp.prepare(max_size), ec));
+      }
+      else
+        break;
+    }
+    return tmp.total_consumed();;
+  }
+} // namespace detail
+
 template <typename SyncRandomAccessWriteDevice, typename ConstBufferSequence,
     typename CompletionCondition>
 std::size_t write_at(SyncRandomAccessWriteDevice& d,
     uint64_t offset, const ConstBufferSequence& buffers,
     CompletionCondition completion_condition, asio::error_code& ec)
 {
-  ec = asio::error_code();
-  asio::detail::consuming_buffers<
-    const_buffer, ConstBufferSequence> tmp(buffers);
-  std::size_t total_transferred = 0;
-  tmp.prepare(detail::adapt_completion_condition_result(
-        completion_condition(ec, total_transferred)));
-  while (tmp.begin() != tmp.end())
-  {
-    std::size_t bytes_transferred = d.write_some_at(
-        offset + total_transferred, tmp, ec);
-    tmp.consume(bytes_transferred);
-    total_transferred += bytes_transferred;
-    tmp.prepare(detail::adapt_completion_condition_result(
-          completion_condition(ec, total_transferred)));
-  }
-  return total_transferred;
+  return detail::write_at_buffer_sequence(d, offset, buffers,
+      asio::buffer_sequence_begin(buffers), completion_condition, ec);
 }
 
 template <typename SyncRandomAccessWriteDevice, typename ConstBufferSequence>
@@ -90,6 +103,7 @@ inline std::size_t write_at(SyncRandomAccessWriteDevice& d,
   return bytes_transferred;
 }
 
+#if !defined(ASIO_NO_EXTENSIONS)
 #if !defined(ASIO_NO_IOSTREAM)
 
 template <typename SyncRandomAccessWriteDevice, typename Allocator,
@@ -136,10 +150,12 @@ inline std::size_t write_at(SyncRandomAccessWriteDevice& d,
 }
 
 #endif // !defined(ASIO_NO_IOSTREAM)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 namespace detail
 {
-  template <typename AsyncRandomAccessWriteDevice, typename ConstBufferSequence,
+  template <typename AsyncRandomAccessWriteDevice,
+      typename ConstBufferSequence, typename ConstBufferIterator,
       typename CompletionCondition, typename WriteHandler>
   class write_at_op
     : detail::base_from_completion_cond<CompletionCondition>
@@ -154,7 +170,6 @@ namespace detail
         offset_(offset),
         buffers_(buffers),
         start_(0),
-        total_transferred_(0),
         handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
     {
     }
@@ -166,7 +181,6 @@ namespace detail
         offset_(other.offset_),
         buffers_(other.buffers_),
         start_(other.start_),
-        total_transferred_(other.total_transferred_),
         handler_(other.handler_)
     {
     }
@@ -177,7 +191,6 @@ namespace detail
         offset_(other.offset_),
         buffers_(other.buffers_),
         start_(other.start_),
-        total_transferred_(other.total_transferred_),
         handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
     {
     }
@@ -186,405 +199,64 @@ namespace detail
     void operator()(const asio::error_code& ec,
         std::size_t bytes_transferred, int start = 0)
     {
+      std::size_t max_size;
       switch (start_ = start)
       {
         case 1:
-        buffers_.prepare(this->check_for_completion(ec, total_transferred_));
-        for (;;)
+        max_size = this->check_for_completion(ec, buffers_.total_consumed());
+        do
         {
           device_.async_write_some_at(
-              offset_ + total_transferred_, buffers_,
+              offset_ + buffers_.total_consumed(), buffers_.prepare(max_size),
               ASIO_MOVE_CAST(write_at_op)(*this));
           return; default:
-          total_transferred_ += bytes_transferred;
           buffers_.consume(bytes_transferred);
-          buffers_.prepare(this->check_for_completion(ec, total_transferred_));
-          if ((!ec && bytes_transferred == 0)
-              || buffers_.begin() == buffers_.end())
+          if ((!ec && bytes_transferred == 0) || buffers_.empty())
             break;
-        }
+          max_size = this->check_for_completion(ec, buffers_.total_consumed());
+        } while (max_size > 0);
 
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
+        handler_(ec, buffers_.total_consumed());
       }
     }
 
   //private:
     AsyncRandomAccessWriteDevice& device_;
     uint64_t offset_;
-    asio::detail::consuming_buffers<
-      const_buffer, ConstBufferSequence> buffers_;
+    asio::detail::consuming_buffers<const_buffer,
+        ConstBufferSequence, ConstBufferIterator> buffers_;
     int start_;
-    std::size_t total_transferred_;
     WriteHandler handler_;
   };
 
   template <typename AsyncRandomAccessWriteDevice,
-      typename CompletionCondition, typename WriteHandler>
-  class write_at_op<AsyncRandomAccessWriteDevice,
-      asio::mutable_buffers_1, CompletionCondition, WriteHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    write_at_op(AsyncRandomAccessWriteDevice& device,
-        uint64_t offset, const asio::mutable_buffers_1& buffers,
-        CompletionCondition completion_condition,
-        WriteHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        device_(device),
-        offset_(offset),
-        buffer_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    write_at_op(const write_at_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    write_at_op(write_at_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          device_.async_write_some_at(offset_ + total_transferred_,
-              asio::buffer(buffer_ + total_transferred_, n),
-              ASIO_MOVE_CAST(write_at_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == asio::buffer_size(buffer_))
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncRandomAccessWriteDevice& device_;
-    uint64_t offset_;
-    asio::mutable_buffer buffer_;
-    int start_;
-    std::size_t total_transferred_;
-    WriteHandler handler_;
-  };
-
-  template <typename AsyncRandomAccessWriteDevice,
-      typename CompletionCondition, typename WriteHandler>
-  class write_at_op<AsyncRandomAccessWriteDevice, asio::const_buffers_1,
-      CompletionCondition, WriteHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    write_at_op(AsyncRandomAccessWriteDevice& device,
-        uint64_t offset, const asio::const_buffers_1& buffers,
-        CompletionCondition completion_condition,
-        WriteHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        device_(device),
-        offset_(offset),
-        buffer_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    write_at_op(const write_at_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    write_at_op(write_at_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          device_.async_write_some_at(offset_ + total_transferred_,
-              asio::buffer(buffer_ + total_transferred_, n),
-              ASIO_MOVE_CAST(write_at_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == asio::buffer_size(buffer_))
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncRandomAccessWriteDevice& device_;
-    uint64_t offset_;
-    asio::const_buffer buffer_;
-    int start_;
-    std::size_t total_transferred_;
-    WriteHandler handler_;
-  };
-
-  template <typename AsyncRandomAccessWriteDevice, typename Elem,
-      typename CompletionCondition, typename WriteHandler>
-  class write_at_op<AsyncRandomAccessWriteDevice, boost::array<Elem, 2>,
-      CompletionCondition, WriteHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    write_at_op(AsyncRandomAccessWriteDevice& device,
-        uint64_t offset, const boost::array<Elem, 2>& buffers,
-        CompletionCondition completion_condition, WriteHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        device_(device),
-        offset_(offset),
-        buffers_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    write_at_op(const write_at_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    write_at_op(write_at_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      typename asio::detail::dependent_type<Elem,
-          boost::array<asio::const_buffer, 2> >::type bufs = {{
-        asio::const_buffer(buffers_[0]),
-        asio::const_buffer(buffers_[1]) }};
-      std::size_t buffer_size0 = asio::buffer_size(bufs[0]);
-      std::size_t buffer_size1 = asio::buffer_size(bufs[1]);
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          bufs[0] = asio::buffer(bufs[0] + total_transferred_, n);
-          bufs[1] = asio::buffer(
-              bufs[1] + (total_transferred_ < buffer_size0
-                ? 0 : total_transferred_ - buffer_size0),
-              n - asio::buffer_size(bufs[0]));
-          device_.async_write_some_at(offset_ + total_transferred_,
-              bufs, ASIO_MOVE_CAST(write_at_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == buffer_size0 + buffer_size1)
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncRandomAccessWriteDevice& device_;
-    uint64_t offset_;
-    boost::array<Elem, 2> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    WriteHandler handler_;
-  };
-
-#if defined(ASIO_HAS_STD_ARRAY)
-
-  template <typename AsyncRandomAccessWriteDevice, typename Elem,
-      typename CompletionCondition, typename WriteHandler>
-  class write_at_op<AsyncRandomAccessWriteDevice, std::array<Elem, 2>,
-      CompletionCondition, WriteHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    write_at_op(AsyncRandomAccessWriteDevice& device,
-        uint64_t offset, const std::array<Elem, 2>& buffers,
-        CompletionCondition completion_condition, WriteHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        device_(device),
-        offset_(offset),
-        buffers_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    write_at_op(const write_at_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    write_at_op(write_at_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      typename asio::detail::dependent_type<Elem,
-          std::array<asio::const_buffer, 2> >::type bufs = {{
-        asio::const_buffer(buffers_[0]),
-        asio::const_buffer(buffers_[1]) }};
-      std::size_t buffer_size0 = asio::buffer_size(bufs[0]);
-      std::size_t buffer_size1 = asio::buffer_size(bufs[1]);
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          bufs[0] = asio::buffer(bufs[0] + total_transferred_, n);
-          bufs[1] = asio::buffer(
-              bufs[1] + (total_transferred_ < buffer_size0
-                ? 0 : total_transferred_ - buffer_size0),
-              n - asio::buffer_size(bufs[0]));
-          device_.async_write_some_at(offset_ + total_transferred_,
-              bufs, ASIO_MOVE_CAST(write_at_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == buffer_size0 + buffer_size1)
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncRandomAccessWriteDevice& device_;
-    uint64_t offset_;
-    std::array<Elem, 2> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    WriteHandler handler_;
-  };
-
-#endif // defined(ASIO_HAS_STD_ARRAY)
-
-  template <typename AsyncRandomAccessWriteDevice, typename ConstBufferSequence,
+      typename ConstBufferSequence, typename ConstBufferIterator,
       typename CompletionCondition, typename WriteHandler>
   inline void* asio_handler_allocate(std::size_t size,
       write_at_op<AsyncRandomAccessWriteDevice, ConstBufferSequence,
-        CompletionCondition, WriteHandler>* this_handler)
+        ConstBufferIterator, CompletionCondition, WriteHandler>* this_handler)
   {
     return asio_handler_alloc_helpers::allocate(
         size, this_handler->handler_);
   }
 
-  template <typename AsyncRandomAccessWriteDevice, typename ConstBufferSequence,
+  template <typename AsyncRandomAccessWriteDevice,
+      typename ConstBufferSequence, typename ConstBufferIterator,
       typename CompletionCondition, typename WriteHandler>
   inline void asio_handler_deallocate(void* pointer, std::size_t size,
       write_at_op<AsyncRandomAccessWriteDevice, ConstBufferSequence,
-        CompletionCondition, WriteHandler>* this_handler)
+        ConstBufferIterator, CompletionCondition, WriteHandler>* this_handler)
   {
     asio_handler_alloc_helpers::deallocate(
         pointer, size, this_handler->handler_);
   }
 
-  template <typename AsyncRandomAccessWriteDevice, typename ConstBufferSequence,
+  template <typename AsyncRandomAccessWriteDevice,
+      typename ConstBufferSequence, typename ConstBufferIterator,
       typename CompletionCondition, typename WriteHandler>
   inline bool asio_handler_is_continuation(
       write_at_op<AsyncRandomAccessWriteDevice, ConstBufferSequence,
-        CompletionCondition, WriteHandler>* this_handler)
+        ConstBufferIterator, CompletionCondition, WriteHandler>* this_handler)
   {
     return this_handler->start_ == 0 ? true
       : asio_handler_cont_helpers::is_continuation(
@@ -592,73 +264,78 @@ namespace detail
   }
 
   template <typename Function, typename AsyncRandomAccessWriteDevice,
-      typename ConstBufferSequence, typename CompletionCondition,
-      typename WriteHandler>
+      typename ConstBufferSequence, typename ConstBufferIterator,
+      typename CompletionCondition, typename WriteHandler>
   inline void asio_handler_invoke(Function& function,
       write_at_op<AsyncRandomAccessWriteDevice, ConstBufferSequence,
-        CompletionCondition, WriteHandler>* this_handler)
+        ConstBufferIterator, CompletionCondition, WriteHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
         function, this_handler->handler_);
   }
 
   template <typename Function, typename AsyncRandomAccessWriteDevice,
-      typename ConstBufferSequence, typename CompletionCondition,
-      typename WriteHandler>
+      typename ConstBufferSequence, typename ConstBufferIterator,
+      typename CompletionCondition, typename WriteHandler>
   inline void asio_handler_invoke(const Function& function,
       write_at_op<AsyncRandomAccessWriteDevice, ConstBufferSequence,
-        CompletionCondition, WriteHandler>* this_handler)
+        ConstBufferIterator, CompletionCondition, WriteHandler>* this_handler)
   {
     asio_handler_invoke_helpers::invoke(
         function, this_handler->handler_);
   }
 
-  template <typename AsyncRandomAccessWriteDevice, typename ConstBufferSequence,
+  template <typename AsyncRandomAccessWriteDevice,
+      typename ConstBufferSequence, typename ConstBufferIterator,
       typename CompletionCondition, typename WriteHandler>
-  inline write_at_op<AsyncRandomAccessWriteDevice,
-      ConstBufferSequence, CompletionCondition, WriteHandler>
-  make_write_at_op(AsyncRandomAccessWriteDevice& d,
+  inline void start_write_at_buffer_sequence_op(AsyncRandomAccessWriteDevice& d,
       uint64_t offset, const ConstBufferSequence& buffers,
-      CompletionCondition completion_condition, WriteHandler handler)
+      const ConstBufferIterator&, CompletionCondition completion_condition,
+      WriteHandler& handler)
   {
-    return write_at_op<AsyncRandomAccessWriteDevice,
-      ConstBufferSequence, CompletionCondition, WriteHandler>(
-        d, offset, buffers, completion_condition, handler);
+    detail::write_at_op<AsyncRandomAccessWriteDevice, ConstBufferSequence,
+      ConstBufferIterator, CompletionCondition, WriteHandler>(
+        d, offset, buffers, completion_condition, handler)(
+          asio::error_code(), 0, 1);
   }
 } // namespace detail
 
 #if !defined(GENERATING_DOCUMENTATION)
 
-template <typename AsyncRandomAccessWriteDevice, typename ConstBufferSequence,
+template <typename AsyncRandomAccessWriteDevice,
+    typename ConstBufferSequence, typename ConstBufferIterator,
     typename CompletionCondition, typename WriteHandler, typename Allocator>
 struct associated_allocator<
-    detail::write_at_op<AsyncRandomAccessWriteDevice,
-      ConstBufferSequence, CompletionCondition, WriteHandler>,
+    detail::write_at_op<AsyncRandomAccessWriteDevice, ConstBufferSequence,
+      ConstBufferIterator, CompletionCondition, WriteHandler>,
     Allocator>
 {
   typedef typename associated_allocator<WriteHandler, Allocator>::type type;
 
   static type get(
       const detail::write_at_op<AsyncRandomAccessWriteDevice,
-        ConstBufferSequence, CompletionCondition, WriteHandler>& h,
+        ConstBufferSequence, ConstBufferIterator,
+        CompletionCondition, WriteHandler>& h,
       const Allocator& a = Allocator()) ASIO_NOEXCEPT
   {
     return associated_allocator<WriteHandler, Allocator>::get(h.handler_, a);
   }
 };
 
-template <typename AsyncRandomAccessWriteDevice, typename ConstBufferSequence,
+template <typename AsyncRandomAccessWriteDevice,
+    typename ConstBufferSequence, typename ConstBufferIterator,
     typename CompletionCondition, typename WriteHandler, typename Executor>
 struct associated_executor<
-    detail::write_at_op<AsyncRandomAccessWriteDevice,
-      ConstBufferSequence, CompletionCondition, WriteHandler>,
+    detail::write_at_op<AsyncRandomAccessWriteDevice, ConstBufferSequence,
+      ConstBufferIterator, CompletionCondition, WriteHandler>,
     Executor>
 {
   typedef typename associated_executor<WriteHandler, Executor>::type type;
 
   static type get(
       const detail::write_at_op<AsyncRandomAccessWriteDevice,
-        ConstBufferSequence, CompletionCondition, WriteHandler>& h,
+        ConstBufferSequence, ConstBufferIterator,
+        CompletionCondition, WriteHandler>& h,
       const Executor& ex = Executor()) ASIO_NOEXCEPT
   {
     return associated_executor<WriteHandler, Executor>::get(h.handler_, ex);
@@ -683,11 +360,9 @@ async_write_at(AsyncRandomAccessWriteDevice& d,
   async_completion<WriteHandler,
     void (asio::error_code, std::size_t)> init(handler);
 
-  detail::write_at_op<AsyncRandomAccessWriteDevice, ConstBufferSequence,
-    CompletionCondition, ASIO_HANDLER_TYPE(
-      WriteHandler, void (asio::error_code, std::size_t))>(
-        d, offset, buffers, completion_condition, init.handler)(
-          asio::error_code(), 0, 1);
+  detail::start_write_at_buffer_sequence_op(d, offset, buffers,
+      asio::buffer_sequence_begin(buffers), completion_condition,
+      init.completion_handler);
 
   return init.result.get();
 }
@@ -707,15 +382,14 @@ async_write_at(AsyncRandomAccessWriteDevice& d,
   async_completion<WriteHandler,
     void (asio::error_code, std::size_t)> init(handler);
 
-  detail::write_at_op<AsyncRandomAccessWriteDevice, ConstBufferSequence,
-    detail::transfer_all_t, ASIO_HANDLER_TYPE(
-      WriteHandler, void (asio::error_code, std::size_t))>(
-        d, offset, buffers, transfer_all(), init.handler)(
-          asio::error_code(), 0, 1);
+  detail::start_write_at_buffer_sequence_op(d, offset, buffers,
+      asio::buffer_sequence_begin(buffers), transfer_all(),
+      init.completion_handler);
 
   return init.result.get();
 }
 
+#if !defined(ASIO_NO_EXTENSIONS)
 #if !defined(ASIO_NO_IOSTREAM)
 
 namespace detail
@@ -860,7 +534,7 @@ async_write_at(AsyncRandomAccessWriteDevice& d,
   async_write_at(d, offset, b.data(), completion_condition,
     detail::write_at_streambuf_op<Allocator, ASIO_HANDLER_TYPE(
       WriteHandler, void (asio::error_code, std::size_t))>(
-        b, init.handler));
+        b, init.completion_handler));
 
   return init.result.get();
 }
@@ -883,12 +557,13 @@ async_write_at(AsyncRandomAccessWriteDevice& d,
   async_write_at(d, offset, b.data(), transfer_all(),
     detail::write_at_streambuf_op<Allocator, ASIO_HANDLER_TYPE(
       WriteHandler, void (asio::error_code, std::size_t))>(
-        b, init.handler));
+        b, init.completion_handler));
 
   return init.result.get();
 }
 
 #endif // !defined(ASIO_NO_IOSTREAM)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 } // namespace asio
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/io_context.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/io_context.hpp
new file mode 100644
index 0000000..44fe432
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/io_context.hpp
@@ -0,0 +1,834 @@
+//
+// io_context.hpp
+// ~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_IO_CONTEXT_HPP
+#define ASIO_IO_CONTEXT_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+#include <cstddef>
+#include <stdexcept>
+#include <typeinfo>
+#include "asio/async_result.hpp"
+#include "asio/detail/noncopyable.hpp"
+#include "asio/detail/wrapped_handler.hpp"
+#include "asio/error_code.hpp"
+#include "asio/execution_context.hpp"
+
+#if defined(ASIO_HAS_CHRONO)
+# include "asio/detail/chrono.hpp"
+#endif // defined(ASIO_HAS_CHRONO)
+
+#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
+# include "asio/detail/winsock_init.hpp"
+#elif defined(__sun) || defined(__QNX__) || defined(__hpux) || defined(_AIX) \
+  || defined(__osf__)
+# include "asio/detail/signal_init.hpp"
+#endif
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+
+namespace detail {
+#if defined(ASIO_HAS_IOCP)
+  typedef class win_iocp_io_context io_context_impl;
+  class win_iocp_overlapped_ptr;
+#else
+  typedef class scheduler io_context_impl;
+#endif
+} // namespace detail
+
+/// Provides core I/O functionality.
+/**
+ * The io_context class provides the core I/O functionality for users of the
+ * asynchronous I/O objects, including:
+ *
+ * @li asio::ip::tcp::socket
+ * @li asio::ip::tcp::acceptor
+ * @li asio::ip::udp::socket
+ * @li asio::deadline_timer.
+ *
+ * The io_context class also includes facilities intended for developers of
+ * custom asynchronous services.
+ *
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Safe, with the specific exceptions of the restart() and
+ * notify_fork() functions. Calling restart() while there are unfinished run(),
+ * run_one(), poll() or poll_one() calls results in undefined behaviour. The
+ * notify_fork() function should not be called while any io_context function,
+ * or any function on an I/O object that is associated with the io_context, is
+ * being called in another thread.
+ *
+ * @par Concepts:
+ * Dispatcher.
+ *
+ * @par Synchronous and asynchronous operations
+ *
+ * Synchronous operations on I/O objects implicitly run the io_context object
+ * for an individual operation. The io_context functions run(), run_one(),
+ * poll() or poll_one() must be called for the io_context to perform
+ * asynchronous operations on behalf of a C++ program. Notification that an
+ * asynchronous operation has completed is delivered by invocation of the
+ * associated handler. Handlers are invoked only by a thread that is currently
+ * calling any overload of run(), run_one(), poll() or poll_one() for the
+ * io_context.
+ *
+ * @par Effect of exceptions thrown from handlers
+ *
+ * If an exception is thrown from a handler, the exception is allowed to
+ * propagate through the throwing thread's invocation of run(), run_one(),
+ * poll() or poll_one(). No other threads that are calling any of these
+ * functions are affected. It is then the responsibility of the application to
+ * catch the exception.
+ *
+ * After the exception has been caught, the run(), run_one(), poll() or
+ * poll_one() call may be restarted @em without the need for an intervening
+ * call to restart(). This allows the thread to rejoin the io_context object's
+ * thread pool without impacting any other threads in the pool.
+ *
+ * For example:
+ *
+ * @code
+ * asio::io_context io_context;
+ * ...
+ * for (;;)
+ * {
+ *   try
+ *   {
+ *     io_context.run();
+ *     break; // run() exited normally
+ *   }
+ *   catch (my_exception& e)
+ *   {
+ *     // Deal with exception as appropriate.
+ *   }
+ * }
+ * @endcode
+ *
+ * @par Stopping the io_context from running out of work
+ *
+ * Some applications may need to prevent an io_context object's run() call from
+ * returning when there is no more work to do. For example, the io_context may
+ * be being run in a background thread that is launched prior to the
+ * application's asynchronous operations. The run() call may be kept running by
+ * creating an object of type
+ * asio::executor_work_guard<io_context::executor_type>:
+ *
+ * @code asio::io_context io_context;
+ * asio::executor_work_guard<asio::io_context::executor_type>
+ *   = asio::make_work_guard(io_context);
+ * ... @endcode
+ *
+ * To effect a shutdown, the application will then need to call the io_context
+ * object's stop() member function. This will cause the io_context run() call
+ * to return as soon as possible, abandoning unfinished operations and without
+ * permitting ready handlers to be dispatched.
+ *
+ * Alternatively, if the application requires that all operations and handlers
+ * be allowed to finish normally, the work object may be explicitly reset.
+ *
+ * @code asio::io_context io_context;
+ * asio::executor_work_guard<asio::io_context::executor_type>
+ *   = asio::make_work_guard(io_context);
+ * ...
+ * work.reset(); // Allow run() to exit. @endcode
+ */
+class io_context
+  : public execution_context
+{
+private:
+  typedef detail::io_context_impl impl_type;
+#if defined(ASIO_HAS_IOCP)
+  friend class detail::win_iocp_overlapped_ptr;
+#endif
+
+public:
+  class executor_type;
+  friend class executor_type;
+
+#if !defined(ASIO_NO_DEPRECATED)
+  class work;
+  friend class work;
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  class service;
+
+#if !defined(ASIO_NO_EXTENSIONS)
+  class strand;
+#endif // !defined(ASIO_NO_EXTENSIONS)
+
+  /// The type used to count the number of handlers executed by the context.
+  typedef std::size_t count_type;
+
+  /// Constructor.
+  ASIO_DECL io_context();
+
+  /// Constructor.
+  /**
+   * Construct with a hint about the required level of concurrency.
+   *
+   * @param concurrency_hint A suggestion to the implementation on how many
+   * threads it should allow to run simultaneously.
+   */
+  ASIO_DECL explicit io_context(int concurrency_hint);
+
+  /// Destructor.
+  /**
+   * On destruction, the io_context performs the following sequence of
+   * operations:
+   *
+   * @li For each service object @c svc in the io_context set, in reverse order
+   * of the beginning of service object lifetime, performs
+   * @c svc->shutdown().
+   *
+   * @li Uninvoked handler objects that were scheduled for deferred invocation
+   * on the io_context, or any associated strand, are destroyed.
+   *
+   * @li For each service object @c svc in the io_context set, in reverse order
+   * of the beginning of service object lifetime, performs
+   * <tt>delete static_cast<io_context::service*>(svc)</tt>.
+   *
+   * @note The destruction sequence described above permits programs to
+   * simplify their resource management by using @c shared_ptr<>. Where an
+   * object's lifetime is tied to the lifetime of a connection (or some other
+   * sequence of asynchronous operations), a @c shared_ptr to the object would
+   * be bound into the handlers for all asynchronous operations associated with
+   * it. This works as follows:
+   *
+   * @li When a single connection ends, all associated asynchronous operations
+   * complete. The corresponding handler objects are destroyed, and all
+   * @c shared_ptr references to the objects are destroyed.
+   *
+   * @li To shut down the whole program, the io_context function stop() is
+   * called to terminate any run() calls as soon as possible. The io_context
+   * destructor defined above destroys all handlers, causing all @c shared_ptr
+   * references to all connection objects to be destroyed.
+   */
+  ASIO_DECL ~io_context();
+
+  /// Obtains the executor associated with the io_context.
+  executor_type get_executor() ASIO_NOEXCEPT;
+
+  /// Run the io_context object's event processing loop.
+  /**
+   * The run() function blocks until all work has finished and there are no
+   * more handlers to be dispatched, or until the io_context has been stopped.
+   *
+   * Multiple threads may call the run() function to set up a pool of threads
+   * from which the io_context may execute handlers. All threads that are
+   * waiting in the pool are equivalent and the io_context may choose any one
+   * of them to invoke a handler.
+   *
+   * A normal exit from the run() function implies that the io_context object
+   * is stopped (the stopped() function returns @c true). Subsequent calls to
+   * run(), run_one(), poll() or poll_one() will return immediately unless there
+   * is a prior call to restart().
+   *
+   * @return The number of handlers that were executed.
+   *
+   * @note The run() function must not be called from a thread that is currently
+   * calling one of run(), run_one(), poll() or poll_one() on the same
+   * io_context object.
+   *
+   * The poll() function may also be used to dispatch ready handlers, but
+   * without blocking.
+   */
+  ASIO_DECL count_type run();
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use non-error_code overload.) Run the io_context object's
+  /// event processing loop.
+  /**
+   * The run() function blocks until all work has finished and there are no
+   * more handlers to be dispatched, or until the io_context has been stopped.
+   *
+   * Multiple threads may call the run() function to set up a pool of threads
+   * from which the io_context may execute handlers. All threads that are
+   * waiting in the pool are equivalent and the io_context may choose any one
+   * of them to invoke a handler.
+   *
+   * A normal exit from the run() function implies that the io_context object
+   * is stopped (the stopped() function returns @c true). Subsequent calls to
+   * run(), run_one(), poll() or poll_one() will return immediately unless there
+   * is a prior call to restart().
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @return The number of handlers that were executed.
+   *
+   * @note The run() function must not be called from a thread that is currently
+   * calling one of run(), run_one(), poll() or poll_one() on the same
+   * io_context object.
+   *
+   * The poll() function may also be used to dispatch ready handlers, but
+   * without blocking.
+   */
+  ASIO_DECL count_type run(asio::error_code& ec);
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+#if defined(ASIO_HAS_CHRONO) || defined(GENERATING_DOCUMENTATION)
+  /// Run the io_context object's event processing loop for a specified
+  /// duration.
+  /**
+   * The run_for() function blocks until all work has finished and there are no
+   * more handlers to be dispatched, until the io_context has been stopped, or
+   * until the specified duration has elapsed.
+   *
+   * @param rel_time The duration for which the call may block.
+   *
+   * @return The number of handlers that were executed.
+   */
+  template <typename Rep, typename Period>
+  std::size_t run_for(const chrono::duration<Rep, Period>& rel_time);
+
+  /// Run the io_context object's event processing loop until a specified time.
+  /**
+   * The run_until() function blocks until all work has finished and there are
+   * no more handlers to be dispatched, until the io_context has been stopped,
+   * or until the specified time has been reached.
+   *
+   * @param abs_time The time point until which the call may block.
+   *
+   * @return The number of handlers that were executed.
+   */
+  template <typename Clock, typename Duration>
+  std::size_t run_until(const chrono::time_point<Clock, Duration>& abs_time);
+#endif // defined(ASIO_HAS_CHRONO) || defined(GENERATING_DOCUMENTATION)
+
+  /// Run the io_context object's event processing loop to execute at most one
+  /// handler.
+  /**
+   * The run_one() function blocks until one handler has been dispatched, or
+   * until the io_context has been stopped.
+   *
+   * @return The number of handlers that were executed. A zero return value
+   * implies that the io_context object is stopped (the stopped() function
+   * returns @c true). Subsequent calls to run(), run_one(), poll() or
+   * poll_one() will return immediately unless there is a prior call to
+   * restart().
+   */
+  ASIO_DECL count_type run_one();
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use non-error_code overlaod.) Run the io_context object's
+  /// event processing loop to execute at most one handler.
+  /**
+   * The run_one() function blocks until one handler has been dispatched, or
+   * until the io_context has been stopped.
+   *
+   * @return The number of handlers that were executed. A zero return value
+   * implies that the io_context object is stopped (the stopped() function
+   * returns @c true). Subsequent calls to run(), run_one(), poll() or
+   * poll_one() will return immediately unless there is a prior call to
+   * restart().
+   *
+   * @return The number of handlers that were executed.
+   */
+  ASIO_DECL count_type run_one(asio::error_code& ec);
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+#if defined(ASIO_HAS_CHRONO) || defined(GENERATING_DOCUMENTATION)
+  /// Run the io_context object's event processing loop for a specified duration
+  /// to execute at most one handler.
+  /**
+   * The run_one_for() function blocks until one handler has been dispatched,
+   * until the io_context has been stopped, or until the specified duration has
+   * elapsed.
+   *
+   * @param rel_time The duration for which the call may block.
+   *
+   * @return The number of handlers that were executed.
+   */
+  template <typename Rep, typename Period>
+  std::size_t run_one_for(const chrono::duration<Rep, Period>& rel_time);
+
+  /// Run the io_context object's event processing loop until a specified time
+  /// to execute at most one handler.
+  /**
+   * The run_one_until() function blocks until one handler has been dispatched,
+   * until the io_context has been stopped, or until the specified time has
+   * been reached.
+   *
+   * @param abs_time The time point until which the call may block.
+   *
+   * @return The number of handlers that were executed.
+   */
+  template <typename Clock, typename Duration>
+  std::size_t run_one_until(
+      const chrono::time_point<Clock, Duration>& abs_time);
+#endif // defined(ASIO_HAS_CHRONO) || defined(GENERATING_DOCUMENTATION)
+
+  /// Run the io_context object's event processing loop to execute ready
+  /// handlers.
+  /**
+   * The poll() function runs handlers that are ready to run, without blocking,
+   * until the io_context has been stopped or there are no more ready handlers.
+   *
+   * @return The number of handlers that were executed.
+   */
+  ASIO_DECL count_type poll();
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use non-error_code overload.) Run the io_context object's
+  /// event processing loop to execute ready handlers.
+  /**
+   * The poll() function runs handlers that are ready to run, without blocking,
+   * until the io_context has been stopped or there are no more ready handlers.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @return The number of handlers that were executed.
+   */
+  ASIO_DECL count_type poll(asio::error_code& ec);
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// Run the io_context object's event processing loop to execute one ready
+  /// handler.
+  /**
+   * The poll_one() function runs at most one handler that is ready to run,
+   * without blocking.
+   *
+   * @return The number of handlers that were executed.
+   */
+  ASIO_DECL count_type poll_one();
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use non-error_code overload.) Run the io_context object's
+  /// event processing loop to execute one ready handler.
+  /**
+   * The poll_one() function runs at most one handler that is ready to run,
+   * without blocking.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @return The number of handlers that were executed.
+   */
+  ASIO_DECL count_type poll_one(asio::error_code& ec);
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// Stop the io_context object's event processing loop.
+  /**
+   * This function does not block, but instead simply signals the io_context to
+   * stop. All invocations of its run() or run_one() member functions should
+   * return as soon as possible. Subsequent calls to run(), run_one(), poll()
+   * or poll_one() will return immediately until restart() is called.
+   */
+  ASIO_DECL void stop();
+
+  /// Determine whether the io_context object has been stopped.
+  /**
+   * This function is used to determine whether an io_context object has been
+   * stopped, either through an explicit call to stop(), or due to running out
+   * of work. When an io_context object is stopped, calls to run(), run_one(),
+   * poll() or poll_one() will return immediately without invoking any
+   * handlers.
+   *
+   * @return @c true if the io_context object is stopped, otherwise @c false.
+   */
+  ASIO_DECL bool stopped() const;
+
+  /// Restart the io_context in preparation for a subsequent run() invocation.
+  /**
+   * This function must be called prior to any second or later set of
+   * invocations of the run(), run_one(), poll() or poll_one() functions when a
+   * previous invocation of these functions returned due to the io_context
+   * being stopped or running out of work. After a call to restart(), the
+   * io_context object's stopped() function will return @c false.
+   *
+   * This function must not be called while there are any unfinished calls to
+   * the run(), run_one(), poll() or poll_one() functions.
+   */
+  ASIO_DECL void restart();
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use restart().) Reset the io_context in preparation for a
+  /// subsequent run() invocation.
+  /**
+   * This function must be called prior to any second or later set of
+   * invocations of the run(), run_one(), poll() or poll_one() functions when a
+   * previous invocation of these functions returned due to the io_context
+   * being stopped or running out of work. After a call to restart(), the
+   * io_context object's stopped() function will return @c false.
+   *
+   * This function must not be called while there are any unfinished calls to
+   * the run(), run_one(), poll() or poll_one() functions.
+   */
+  void reset();
+
+  /// (Deprecated: Use asio::dispatch().) Request the io_context to
+  /// invoke the given handler.
+  /**
+   * This function is used to ask the io_context to execute the given handler.
+   *
+   * The io_context guarantees that the handler will only be called in a thread
+   * in which the run(), run_one(), poll() or poll_one() member functions is
+   * currently being invoked. The handler may be executed inside this function
+   * if the guarantee can be met.
+   *
+   * @param handler The handler to be called. The io_context will make
+   * a copy of the handler object as required. The function signature of the
+   * handler must be: @code void handler(); @endcode
+   *
+   * @note This function throws an exception only if:
+   *
+   * @li the handler's @c asio_handler_allocate function; or
+   *
+   * @li the handler's copy constructor
+   *
+   * throws an exception.
+   */
+  template <typename CompletionHandler>
+  ASIO_INITFN_RESULT_TYPE(CompletionHandler, void ())
+  dispatch(ASIO_MOVE_ARG(CompletionHandler) handler);
+
+  /// (Deprecated: Use asio::post().) Request the io_context to invoke
+  /// the given handler and return immediately.
+  /**
+   * This function is used to ask the io_context to execute the given handler,
+   * but without allowing the io_context to call the handler from inside this
+   * function.
+   *
+   * The io_context guarantees that the handler will only be called in a thread
+   * in which the run(), run_one(), poll() or poll_one() member functions is
+   * currently being invoked.
+   *
+   * @param handler The handler to be called. The io_context will make
+   * a copy of the handler object as required. The function signature of the
+   * handler must be: @code void handler(); @endcode
+   *
+   * @note This function throws an exception only if:
+   *
+   * @li the handler's @c asio_handler_allocate function; or
+   *
+   * @li the handler's copy constructor
+   *
+   * throws an exception.
+   */
+  template <typename CompletionHandler>
+  ASIO_INITFN_RESULT_TYPE(CompletionHandler, void ())
+  post(ASIO_MOVE_ARG(CompletionHandler) handler);
+
+  /// (Deprecated: Use asio::bind_executor().) Create a new handler that
+  /// automatically dispatches the wrapped handler on the io_context.
+  /**
+   * This function is used to create a new handler function object that, when
+   * invoked, will automatically pass the wrapped handler to the io_context
+   * object's dispatch function.
+   *
+   * @param handler The handler to be wrapped. The io_context will make a copy
+   * of the handler object as required. The function signature of the handler
+   * must be: @code void handler(A1 a1, ... An an); @endcode
+   *
+   * @return A function object that, when invoked, passes the wrapped handler to
+   * the io_context object's dispatch function. Given a function object with the
+   * signature:
+   * @code R f(A1 a1, ... An an); @endcode
+   * If this function object is passed to the wrap function like so:
+   * @code io_context.wrap(f); @endcode
+   * then the return value is a function object with the signature
+   * @code void g(A1 a1, ... An an); @endcode
+   * that, when invoked, executes code equivalent to:
+   * @code io_context.dispatch(boost::bind(f, a1, ... an)); @endcode
+   */
+  template <typename Handler>
+#if defined(GENERATING_DOCUMENTATION)
+  unspecified
+#else
+  detail::wrapped_handler<io_context&, Handler>
+#endif
+  wrap(Handler handler);
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+private:
+  // Helper function to add the implementation.
+  ASIO_DECL impl_type& add_impl(impl_type* impl);
+
+  // Backwards compatible overload for use with services derived from
+  // io_context::service.
+  template <typename Service>
+  friend Service& use_service(io_context& ioc);
+
+#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
+  detail::winsock_init<> init_;
+#elif defined(__sun) || defined(__QNX__) || defined(__hpux) || defined(_AIX) \
+  || defined(__osf__)
+  detail::signal_init<> init_;
+#endif
+
+  // The implementation.
+  impl_type& impl_;
+};
+
+/// Executor used to submit functions to an io_context.
+class io_context::executor_type
+{
+public:
+  /// Obtain the underlying execution context.
+  io_context& context() const ASIO_NOEXCEPT;
+
+  /// Inform the io_context that it has some outstanding work to do.
+  /**
+   * This function is used to inform the io_context that some work has begun.
+   * This ensures that the io_context's run() and run_one() functions do not
+   * exit while the work is underway.
+   */
+  void on_work_started() const ASIO_NOEXCEPT;
+
+  /// Inform the io_context that some work is no longer outstanding.
+  /**
+   * This function is used to inform the io_context that some work has
+   * finished. Once the count of unfinished work reaches zero, the io_context
+   * is stopped and the run() and run_one() functions may exit.
+   */
+  void on_work_finished() const ASIO_NOEXCEPT;
+
+  /// Request the io_context to invoke the given function object.
+  /**
+   * This function is used to ask the io_context to execute the given function
+   * object. If the current thread is running the io_context, @c dispatch()
+   * executes the function before returning. Otherwise, the function will be
+   * scheduled to run on the io_context.
+   *
+   * @param f The function object to be called. The executor will make a copy
+   * of the handler object as required. The function signature of the function
+   * object must be: @code void function(); @endcode
+   *
+   * @param a An allocator that may be used by the executor to allocate the
+   * internal storage needed for function invocation.
+   */
+  template <typename Function, typename Allocator>
+  void dispatch(ASIO_MOVE_ARG(Function) f, const Allocator& a) const;
+
+  /// Request the io_context to invoke the given function object.
+  /**
+   * This function is used to ask the io_context to execute the given function
+   * object. The function object will never be executed inside @c post().
+   * Instead, it will be scheduled to run on the io_context.
+   *
+   * @param f The function object to be called. The executor will make a copy
+   * of the handler object as required. The function signature of the function
+   * object must be: @code void function(); @endcode
+   *
+   * @param a An allocator that may be used by the executor to allocate the
+   * internal storage needed for function invocation.
+   */
+  template <typename Function, typename Allocator>
+  void post(ASIO_MOVE_ARG(Function) f, const Allocator& a) const;
+
+  /// Request the io_context to invoke the given function object.
+  /**
+   * This function is used to ask the io_context to execute the given function
+   * object. The function object will never be executed inside @c defer().
+   * Instead, it will be scheduled to run on the io_context.
+   *
+   * If the current thread belongs to the io_context, @c defer() will delay
+   * scheduling the function object until the current thread returns control to
+   * the pool.
+   *
+   * @param f The function object to be called. The executor will make a copy
+   * of the handler object as required. The function signature of the function
+   * object must be: @code void function(); @endcode
+   *
+   * @param a An allocator that may be used by the executor to allocate the
+   * internal storage needed for function invocation.
+   */
+  template <typename Function, typename Allocator>
+  void defer(ASIO_MOVE_ARG(Function) f, const Allocator& a) const;
+
+  /// Determine whether the io_context is running in the current thread.
+  /**
+   * @return @c true if the current thread is running the io_context. Otherwise
+   * returns @c false.
+   */
+  bool running_in_this_thread() const ASIO_NOEXCEPT;
+
+  /// Compare two executors for equality.
+  /**
+   * Two executors are equal if they refer to the same underlying io_context.
+   */
+  friend bool operator==(const executor_type& a,
+      const executor_type& b) ASIO_NOEXCEPT
+  {
+    return &a.io_context_ == &b.io_context_;
+  }
+
+  /// Compare two executors for inequality.
+  /**
+   * Two executors are equal if they refer to the same underlying io_context.
+   */
+  friend bool operator!=(const executor_type& a,
+      const executor_type& b) ASIO_NOEXCEPT
+  {
+    return &a.io_context_ != &b.io_context_;
+  }
+
+private:
+  friend class io_context;
+
+  // Constructor.
+  explicit executor_type(io_context& i) : io_context_(i) {}
+
+  // The underlying io_context.
+  io_context& io_context_;
+};
+
+#if !defined(ASIO_NO_DEPRECATED)
+/// (Deprecated: Use executor_work_guard.) Class to inform the io_context when
+/// it has work to do.
+/**
+ * The work class is used to inform the io_context when work starts and
+ * finishes. This ensures that the io_context object's run() function will not
+ * exit while work is underway, and that it does exit when there is no
+ * unfinished work remaining.
+ *
+ * The work class is copy-constructible so that it may be used as a data member
+ * in a handler class. It is not assignable.
+ */
+class io_context::work
+{
+public:
+  /// Constructor notifies the io_context that work is starting.
+  /**
+   * The constructor is used to inform the io_context that some work has begun.
+   * This ensures that the io_context object's run() function will not exit
+   * while the work is underway.
+   */
+  explicit work(asio::io_context& io_context);
+
+  /// Copy constructor notifies the io_context that work is starting.
+  /**
+   * The constructor is used to inform the io_context that some work has begun.
+   * This ensures that the io_context object's run() function will not exit
+   * while the work is underway.
+   */
+  work(const work& other);
+
+  /// Destructor notifies the io_context that the work is complete.
+  /**
+   * The destructor is used to inform the io_context that some work has
+   * finished. Once the count of unfinished work reaches zero, the io_context
+   * object's run() function is permitted to exit.
+   */
+  ~work();
+
+  /// Get the io_context associated with the work.
+  asio::io_context& get_io_context();
+
+  /// (Deprecated: Use get_io_context().) Get the io_context associated with the
+  /// work.
+  asio::io_context& get_io_service();
+
+private:
+  // Prevent assignment.
+  void operator=(const work& other);
+
+  // The io_context implementation.
+  detail::io_context_impl& io_context_impl_;
+};
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+/// Base class for all io_context services.
+class io_context::service
+  : public execution_context::service
+{
+public:
+  /// Get the io_context object that owns the service.
+  asio::io_context& get_io_context();
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// Get the io_context object that owns the service.
+  asio::io_context& get_io_service();
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+private:
+  /// Destroy all user-defined handler objects owned by the service.
+  ASIO_DECL virtual void shutdown();
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use shutdown().) Destroy all user-defined handler objects
+  /// owned by the service.
+  ASIO_DECL virtual void shutdown_service();
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// Handle notification of a fork-related event to perform any necessary
+  /// housekeeping.
+  /**
+   * This function is not a pure virtual so that services only have to
+   * implement it if necessary. The default implementation does nothing.
+   */
+  ASIO_DECL virtual void notify_fork(
+      execution_context::fork_event event);
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use notify_fork().) Handle notification of a fork-related
+  /// event to perform any necessary housekeeping.
+  /**
+   * This function is not a pure virtual so that services only have to
+   * implement it if necessary. The default implementation does nothing.
+   */
+  ASIO_DECL virtual void fork_service(
+      execution_context::fork_event event);
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+protected:
+  /// Constructor.
+  /**
+   * @param owner The io_context object that owns the service.
+   */
+  ASIO_DECL service(asio::io_context& owner);
+
+  /// Destructor.
+  ASIO_DECL virtual ~service();
+};
+
+namespace detail {
+
+// Special service base class to keep classes header-file only.
+template <typename Type>
+class service_base
+  : public asio::io_context::service
+{
+public:
+  static asio::detail::service_id<Type> id;
+
+  // Constructor.
+  service_base(asio::io_context& io_context)
+    : asio::io_context::service(io_context)
+  {
+  }
+};
+
+template <typename Type>
+asio::detail::service_id<Type> service_base<Type>::id;
+
+} // namespace detail
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#include "asio/impl/io_context.hpp"
+#if defined(ASIO_HEADER_ONLY)
+# include "asio/impl/io_context.ipp"
+#endif // defined(ASIO_HEADER_ONLY)
+
+// If both io_context.hpp and strand.hpp have been included, automatically
+// include the header file needed for the io_context::strand class.
+#if !defined(ASIO_NO_EXTENSIONS)
+# if defined(ASIO_STRAND_HPP)
+#  include "asio/io_context_strand.hpp"
+# endif // defined(ASIO_STRAND_HPP)
+#endif // !defined(ASIO_NO_EXTENSIONS)
+
+#endif // ASIO_IO_CONTEXT_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/io_context_strand.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/io_context_strand.hpp
new file mode 100644
index 0000000..53a6c46
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/io_context_strand.hpp
@@ -0,0 +1,382 @@
+//
+// io_context_strand.hpp
+// ~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_IO_CONTEXT_STRAND_HPP
+#define ASIO_IO_CONTEXT_STRAND_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+
+#if !defined(ASIO_NO_EXTENSIONS)
+
+#include "asio/async_result.hpp"
+#include "asio/detail/handler_type_requirements.hpp"
+#include "asio/detail/strand_service.hpp"
+#include "asio/detail/wrapped_handler.hpp"
+#include "asio/io_context.hpp"
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+
+/// Provides serialised handler execution.
+/**
+ * The io_context::strand class provides the ability to post and dispatch
+ * handlers with the guarantee that none of those handlers will execute
+ * concurrently.
+ *
+ * @par Order of handler invocation
+ * Given:
+ *
+ * @li a strand object @c s
+ *
+ * @li an object @c a meeting completion handler requirements
+ *
+ * @li an object @c a1 which is an arbitrary copy of @c a made by the
+ * implementation
+ *
+ * @li an object @c b meeting completion handler requirements
+ *
+ * @li an object @c b1 which is an arbitrary copy of @c b made by the
+ * implementation
+ *
+ * if any of the following conditions are true:
+ *
+ * @li @c s.post(a) happens-before @c s.post(b)
+ * 
+ * @li @c s.post(a) happens-before @c s.dispatch(b), where the latter is
+ * performed outside the strand
+ * 
+ * @li @c s.dispatch(a) happens-before @c s.post(b), where the former is
+ * performed outside the strand
+ * 
+ * @li @c s.dispatch(a) happens-before @c s.dispatch(b), where both are
+ * performed outside the strand
+ *   
+ * then @c asio_handler_invoke(a1, &a1) happens-before
+ * @c asio_handler_invoke(b1, &b1).
+ * 
+ * Note that in the following case:
+ * @code async_op_1(..., s.wrap(a));
+ * async_op_2(..., s.wrap(b)); @endcode
+ * the completion of the first async operation will perform @c s.dispatch(a),
+ * and the second will perform @c s.dispatch(b), but the order in which those
+ * are performed is unspecified. That is, you cannot state whether one
+ * happens-before the other. Therefore none of the above conditions are met and
+ * no ordering guarantee is made.
+ *
+ * @note The implementation makes no guarantee that handlers posted or
+ * dispatched through different @c strand objects will be invoked concurrently.
+ *
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Safe.
+ *
+ * @par Concepts:
+ * Dispatcher.
+ */
+class io_context::strand
+{
+public:
+  /// Constructor.
+  /**
+   * Constructs the strand.
+   *
+   * @param io_context The io_context object that the strand will use to
+   * dispatch handlers that are ready to be run.
+   */
+  explicit strand(asio::io_context& io_context)
+    : service_(asio::use_service<
+        asio::detail::strand_service>(io_context))
+  {
+    service_.construct(impl_);
+  }
+
+  /// Destructor.
+  /**
+   * Destroys a strand.
+   *
+   * Handlers posted through the strand that have not yet been invoked will
+   * still be dispatched in a way that meets the guarantee of non-concurrency.
+   */
+  ~strand()
+  {
+  }
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use context().) Get the io_context associated with the
+  /// strand.
+  /**
+   * This function may be used to obtain the io_context object that the strand
+   * uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the strand will use to
+   * dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_context()
+  {
+    return service_.get_io_context();
+  }
+
+  /// (Deprecated: Use context().) Get the io_context associated with the
+  /// strand.
+  /**
+   * This function may be used to obtain the io_context object that the strand
+   * uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the strand will use to
+   * dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_service()
+  {
+    return service_.get_io_context();
+  }
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// Obtain the underlying execution context.
+  asio::io_context& context() ASIO_NOEXCEPT
+  {
+    return service_.get_io_context();
+  }
+
+  /// Inform the strand that it has some outstanding work to do.
+  /**
+   * The strand delegates this call to its underlying io_context.
+   */
+  void on_work_started() ASIO_NOEXCEPT
+  {
+    context().get_executor().on_work_started();
+  }
+
+  /// Inform the strand that some work is no longer outstanding.
+  /**
+   * The strand delegates this call to its underlying io_context.
+   */
+  void on_work_finished() ASIO_NOEXCEPT
+  {
+    context().get_executor().on_work_finished();
+  }
+
+  /// Request the strand to invoke the given function object.
+  /**
+   * This function is used to ask the strand to execute the given function
+   * object on its underlying io_context. The function object will be executed
+   * inside this function if the strand is not otherwise busy and if the
+   * underlying io_context's executor's @c dispatch() function is also able to
+   * execute the function before returning.
+   *
+   * @param f The function object to be called. The executor will make
+   * a copy of the handler object as required. The function signature of the
+   * function object must be: @code void function(); @endcode
+   *
+   * @param a An allocator that may be used by the executor to allocate the
+   * internal storage needed for function invocation.
+   */
+  template <typename Function, typename Allocator>
+  void dispatch(ASIO_MOVE_ARG(Function) f, const Allocator& a)
+  {
+    typename decay<Function>::type tmp(ASIO_MOVE_CAST(Function)(f));
+    service_.dispatch(impl_, tmp);
+    (void)a;
+  }
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use asio::dispatch().) Request the strand to invoke
+  /// the given handler.
+  /**
+   * This function is used to ask the strand to execute the given handler.
+   *
+   * The strand object guarantees that handlers posted or dispatched through
+   * the strand will not be executed concurrently. The handler may be executed
+   * inside this function if the guarantee can be met. If this function is
+   * called from within a handler that was posted or dispatched through the same
+   * strand, then the new handler will be executed immediately.
+   *
+   * The strand's guarantee is in addition to the guarantee provided by the
+   * underlying io_context. The io_context guarantees that the handler will only
+   * be called in a thread in which the io_context's run member function is
+   * currently being invoked.
+   *
+   * @param handler The handler to be called. The strand will make a copy of the
+   * handler object as required. The function signature of the handler must be:
+   * @code void handler(); @endcode
+   */
+  template <typename CompletionHandler>
+  ASIO_INITFN_RESULT_TYPE(CompletionHandler, void ())
+  dispatch(ASIO_MOVE_ARG(CompletionHandler) handler)
+  {
+    // If you get an error on the following line it means that your handler does
+    // not meet the documented type requirements for a CompletionHandler.
+    ASIO_COMPLETION_HANDLER_CHECK(CompletionHandler, handler) type_check;
+
+    async_completion<CompletionHandler, void ()> init(handler);
+
+    service_.dispatch(impl_, init.completion_handler);
+
+    return init.result.get();
+  }
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// Request the strand to invoke the given function object.
+  /**
+   * This function is used to ask the executor to execute the given function
+   * object. The function object will never be executed inside this function.
+   * Instead, it will be scheduled to run by the underlying io_context.
+   *
+   * @param f The function object to be called. The executor will make
+   * a copy of the handler object as required. The function signature of the
+   * function object must be: @code void function(); @endcode
+   *
+   * @param a An allocator that may be used by the executor to allocate the
+   * internal storage needed for function invocation.
+   */
+  template <typename Function, typename Allocator>
+  void post(ASIO_MOVE_ARG(Function) f, const Allocator& a)
+  {
+    typename decay<Function>::type tmp(ASIO_MOVE_CAST(Function)(f));
+    service_.post(impl_, tmp);
+    (void)a;
+  }
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use asio::post().) Request the strand to invoke the
+  /// given handler and return immediately.
+  /**
+   * This function is used to ask the strand to execute the given handler, but
+   * without allowing the strand to call the handler from inside this function.
+   *
+   * The strand object guarantees that handlers posted or dispatched through
+   * the strand will not be executed concurrently. The strand's guarantee is in
+   * addition to the guarantee provided by the underlying io_context. The
+   * io_context guarantees that the handler will only be called in a thread in
+   * which the io_context's run member function is currently being invoked.
+   *
+   * @param handler The handler to be called. The strand will make a copy of the
+   * handler object as required. The function signature of the handler must be:
+   * @code void handler(); @endcode
+   */
+  template <typename CompletionHandler>
+  ASIO_INITFN_RESULT_TYPE(CompletionHandler, void ())
+  post(ASIO_MOVE_ARG(CompletionHandler) handler)
+  {
+    // If you get an error on the following line it means that your handler does
+    // not meet the documented type requirements for a CompletionHandler.
+    ASIO_COMPLETION_HANDLER_CHECK(CompletionHandler, handler) type_check;
+
+    async_completion<CompletionHandler, void ()> init(handler);
+
+    service_.post(impl_, init.completion_handler);
+
+    return init.result.get();
+  }
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// Request the strand to invoke the given function object.
+  /**
+   * This function is used to ask the executor to execute the given function
+   * object. The function object will never be executed inside this function.
+   * Instead, it will be scheduled to run by the underlying io_context.
+   *
+   * @param f The function object to be called. The executor will make
+   * a copy of the handler object as required. The function signature of the
+   * function object must be: @code void function(); @endcode
+   *
+   * @param a An allocator that may be used by the executor to allocate the
+   * internal storage needed for function invocation.
+   */
+  template <typename Function, typename Allocator>
+  void defer(ASIO_MOVE_ARG(Function) f, const Allocator& a)
+  {
+    typename decay<Function>::type tmp(ASIO_MOVE_CAST(Function)(f));
+    service_.post(impl_, tmp);
+    (void)a;
+  }
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use asio::bind_executor().) Create a new handler that
+  /// automatically dispatches the wrapped handler on the strand.
+  /**
+   * This function is used to create a new handler function object that, when
+   * invoked, will automatically pass the wrapped handler to the strand's
+   * dispatch function.
+   *
+   * @param handler The handler to be wrapped. The strand will make a copy of
+   * the handler object as required. The function signature of the handler must
+   * be: @code void handler(A1 a1, ... An an); @endcode
+   *
+   * @return A function object that, when invoked, passes the wrapped handler to
+   * the strand's dispatch function. Given a function object with the signature:
+   * @code R f(A1 a1, ... An an); @endcode
+   * If this function object is passed to the wrap function like so:
+   * @code strand.wrap(f); @endcode
+   * then the return value is a function object with the signature
+   * @code void g(A1 a1, ... An an); @endcode
+   * that, when invoked, executes code equivalent to:
+   * @code strand.dispatch(boost::bind(f, a1, ... an)); @endcode
+   */
+  template <typename Handler>
+#if defined(GENERATING_DOCUMENTATION)
+  unspecified
+#else
+  detail::wrapped_handler<strand, Handler, detail::is_continuation_if_running>
+#endif
+  wrap(Handler handler)
+  {
+    return detail::wrapped_handler<io_context::strand, Handler,
+        detail::is_continuation_if_running>(*this, handler);
+  }
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// Determine whether the strand is running in the current thread.
+  /**
+   * @return @c true if the current thread is executing a handler that was
+   * submitted to the strand using post(), dispatch() or wrap(). Otherwise
+   * returns @c false.
+   */
+  bool running_in_this_thread() const ASIO_NOEXCEPT
+  {
+    return service_.running_in_this_thread(impl_);
+  }
+
+  /// Compare two strands for equality.
+  /**
+   * Two strands are equal if they refer to the same ordered, non-concurrent
+   * state.
+   */
+  friend bool operator==(const strand& a, const strand& b) ASIO_NOEXCEPT
+  {
+    return a.impl_ == b.impl_;
+  }
+
+  /// Compare two strands for inequality.
+  /**
+   * Two strands are equal if they refer to the same ordered, non-concurrent
+   * state.
+   */
+  friend bool operator!=(const strand& a, const strand& b) ASIO_NOEXCEPT
+  {
+    return a.impl_ != b.impl_;
+  }
+
+private:
+  asio::detail::strand_service& service_;
+  asio::detail::strand_service::implementation_type impl_;
+};
+
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // !defined(ASIO_NO_EXTENSIONS)
+
+#endif // ASIO_IO_CONTEXT_STRAND_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/io_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/io_service.hpp
index 9d7c489..73772a0 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/io_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/io_service.hpp
@@ -2,7 +2,7 @@
 // io_service.hpp
 // ~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -15,709 +15,19 @@
 # pragma once
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include <stdexcept>
-#include <typeinfo>
-#include "asio/async_result.hpp"
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/wrapped_handler.hpp"
-#include "asio/error_code.hpp"
-#include "asio/execution_context.hpp"
-#include "asio/is_executor.hpp"
-
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-# include "asio/detail/winsock_init.hpp"
-#elif defined(__sun) || defined(__QNX__) || defined(__hpux) || defined(_AIX) \
-  || defined(__osf__)
-# include "asio/detail/signal_init.hpp"
-#endif
+#include "asio/io_context.hpp"
 
 #include "asio/detail/push_options.hpp"
 
 namespace asio {
 
-namespace detail {
-#if defined(ASIO_HAS_IOCP)
-  typedef class win_iocp_io_service io_service_impl;
-  class win_iocp_overlapped_ptr;
-#else
-  typedef class scheduler io_service_impl;
-#endif
-} // namespace detail
-
-/// Provides core I/O functionality.
-/**
- * The io_service class provides the core I/O functionality for users of the
- * asynchronous I/O objects, including:
- *
- * @li asio::ip::tcp::socket
- * @li asio::ip::tcp::acceptor
- * @li asio::ip::udp::socket
- * @li asio::deadline_timer.
- *
- * The io_service class also includes facilities intended for developers of
- * custom asynchronous services.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Safe, with the specific exceptions of the restart() and
- * notify_fork() functions. Calling restart() while there are unfinished run(),
- * run_one(), poll() or poll_one() calls results in undefined behaviour. The
- * notify_fork() function should not be called while any io_service function,
- * or any function on an I/O object that is associated with the io_service, is
- * being called in another thread.
- *
- * @par Concepts:
- * Dispatcher.
- *
- * @par Synchronous and asynchronous operations
- *
- * Synchronous operations on I/O objects implicitly run the io_service object
- * for an individual operation. The io_service functions run(), run_one(),
- * poll() or poll_one() must be called for the io_service to perform
- * asynchronous operations on behalf of a C++ program. Notification that an
- * asynchronous operation has completed is delivered by invocation of the
- * associated handler. Handlers are invoked only by a thread that is currently
- * calling any overload of run(), run_one(), poll() or poll_one() for the
- * io_service.
- *
- * @par Effect of exceptions thrown from handlers
- *
- * If an exception is thrown from a handler, the exception is allowed to
- * propagate through the throwing thread's invocation of run(), run_one(),
- * poll() or poll_one(). No other threads that are calling any of these
- * functions are affected. It is then the responsibility of the application to
- * catch the exception.
- *
- * After the exception has been caught, the run(), run_one(), poll() or
- * poll_one() call may be restarted @em without the need for an intervening
- * call to restart(). This allows the thread to rejoin the io_service object's
- * thread pool without impacting any other threads in the pool.
- *
- * For example:
- *
- * @code
- * asio::io_service io_service;
- * ...
- * for (;;)
- * {
- *   try
- *   {
- *     io_service.run();
- *     break; // run() exited normally
- *   }
- *   catch (my_exception& e)
- *   {
- *     // Deal with exception as appropriate.
- *   }
- * }
- * @endcode
- *
- * @par Stopping the io_service from running out of work
- *
- * Some applications may need to prevent an io_service object's run() call from
- * returning when there is no more work to do. For example, the io_service may
- * be being run in a background thread that is launched prior to the
- * application's asynchronous operations. The run() call may be kept running by
- * creating an object of type asio::io_service::work:
- *
- * @code asio::io_service io_service;
- * asio::io_service::work work(io_service);
- * ... @endcode
- *
- * To effect a shutdown, the application will then need to call the io_service
- * object's stop() member function. This will cause the io_service run() call
- * to return as soon as possible, abandoning unfinished operations and without
- * permitting ready handlers to be dispatched.
- *
- * Alternatively, if the application requires that all operations and handlers
- * be allowed to finish normally, the work object may be explicitly destroyed.
- *
- * @code asio::io_service io_service;
- * auto_ptr<asio::io_service::work> work(
- *     new asio::io_service::work(io_service));
- * ...
- * work.reset(); // Allow run() to exit. @endcode
- */
-class io_service
-  : public execution_context
-{
-private:
-  typedef detail::io_service_impl impl_type;
-#if defined(ASIO_HAS_IOCP)
-  friend class detail::win_iocp_overlapped_ptr;
-#endif
-
-public:
-  class executor_type;
-  friend class executor_type;
-
-  class work;
-  friend class work;
-
-  class service;
-
-  class strand;
-
-  /// Constructor.
-  ASIO_DECL io_service();
-
-  /// Constructor.
-  /**
-   * Construct with a hint about the required level of concurrency.
-   *
-   * @param concurrency_hint A suggestion to the implementation on how many
-   * threads it should allow to run simultaneously.
-   */
-  ASIO_DECL explicit io_service(std::size_t concurrency_hint);
-
-  /// Destructor.
-  /**
-   * On destruction, the io_service performs the following sequence of
-   * operations:
-   *
-   * @li For each service object @c svc in the io_service set, in reverse order
-   * of the beginning of service object lifetime, performs
-   * @c svc->shutdown_service().
-   *
-   * @li Uninvoked handler objects that were scheduled for deferred invocation
-   * on the io_service, or any associated strand, are destroyed.
-   *
-   * @li For each service object @c svc in the io_service set, in reverse order
-   * of the beginning of service object lifetime, performs
-   * <tt>delete static_cast<io_service::service*>(svc)</tt>.
-   *
-   * @note The destruction sequence described above permits programs to
-   * simplify their resource management by using @c shared_ptr<>. Where an
-   * object's lifetime is tied to the lifetime of a connection (or some other
-   * sequence of asynchronous operations), a @c shared_ptr to the object would
-   * be bound into the handlers for all asynchronous operations associated with
-   * it. This works as follows:
-   *
-   * @li When a single connection ends, all associated asynchronous operations
-   * complete. The corresponding handler objects are destroyed, and all
-   * @c shared_ptr references to the objects are destroyed.
-   *
-   * @li To shut down the whole program, the io_service function stop() is
-   * called to terminate any run() calls as soon as possible. The io_service
-   * destructor defined above destroys all handlers, causing all @c shared_ptr
-   * references to all connection objects to be destroyed.
-   */
-  ASIO_DECL ~io_service();
-
-  /// Obtains the executor associated with the io_service.
-  executor_type get_executor() ASIO_NOEXCEPT;
-
-  /// Run the io_service object's event processing loop.
-  /**
-   * The run() function blocks until all work has finished and there are no
-   * more handlers to be dispatched, or until the io_service has been stopped.
-   *
-   * Multiple threads may call the run() function to set up a pool of threads
-   * from which the io_service may execute handlers. All threads that are
-   * waiting in the pool are equivalent and the io_service may choose any one
-   * of them to invoke a handler.
-   *
-   * A normal exit from the run() function implies that the io_service object
-   * is stopped (the stopped() function returns @c true). Subsequent calls to
-   * run(), run_one(), poll() or poll_one() will return immediately unless there
-   * is a prior call to restart().
-   *
-   * @return The number of handlers that were executed.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note The run() function must not be called from a thread that is currently
-   * calling one of run(), run_one(), poll() or poll_one() on the same
-   * io_service object.
-   *
-   * The poll() function may also be used to dispatch ready handlers, but
-   * without blocking.
-   */
-  ASIO_DECL std::size_t run();
-
-  /// Run the io_service object's event processing loop.
-  /**
-   * The run() function blocks until all work has finished and there are no
-   * more handlers to be dispatched, or until the io_service has been stopped.
-   *
-   * Multiple threads may call the run() function to set up a pool of threads
-   * from which the io_service may execute handlers. All threads that are
-   * waiting in the pool are equivalent and the io_service may choose any one
-   * of them to invoke a handler.
-   *
-   * A normal exit from the run() function implies that the io_service object
-   * is stopped (the stopped() function returns @c true). Subsequent calls to
-   * run(), run_one(), poll() or poll_one() will return immediately unless there
-   * is a prior call to restart().
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @return The number of handlers that were executed.
-   *
-   * @note The run() function must not be called from a thread that is currently
-   * calling one of run(), run_one(), poll() or poll_one() on the same
-   * io_service object.
-   *
-   * The poll() function may also be used to dispatch ready handlers, but
-   * without blocking.
-   */
-  ASIO_DECL std::size_t run(asio::error_code& ec);
-
-  /// Run the io_service object's event processing loop to execute at most one
-  /// handler.
-  /**
-   * The run_one() function blocks until one handler has been dispatched, or
-   * until the io_service has been stopped.
-   *
-   * @return The number of handlers that were executed. A zero return value
-   * implies that the io_service object is stopped (the stopped() function
-   * returns @c true). Subsequent calls to run(), run_one(), poll() or
-   * poll_one() will return immediately unless there is a prior call to
-   * restart().
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  ASIO_DECL std::size_t run_one();
-
-  /// Run the io_service object's event processing loop to execute at most one
-  /// handler.
-  /**
-   * The run_one() function blocks until one handler has been dispatched, or
-   * until the io_service has been stopped.
-   *
-   * @return The number of handlers that were executed. A zero return value
-   * implies that the io_service object is stopped (the stopped() function
-   * returns @c true). Subsequent calls to run(), run_one(), poll() or
-   * poll_one() will return immediately unless there is a prior call to
-   * restart().
-   *
-   * @return The number of handlers that were executed.
-   */
-  ASIO_DECL std::size_t run_one(asio::error_code& ec);
-
-  /// Run the io_service object's event processing loop to execute ready
-  /// handlers.
-  /**
-   * The poll() function runs handlers that are ready to run, without blocking,
-   * until the io_service has been stopped or there are no more ready handlers.
-   *
-   * @return The number of handlers that were executed.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  ASIO_DECL std::size_t poll();
-
-  /// Run the io_service object's event processing loop to execute ready
-  /// handlers.
-  /**
-   * The poll() function runs handlers that are ready to run, without blocking,
-   * until the io_service has been stopped or there are no more ready handlers.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @return The number of handlers that were executed.
-   */
-  ASIO_DECL std::size_t poll(asio::error_code& ec);
-
-  /// Run the io_service object's event processing loop to execute one ready
-  /// handler.
-  /**
-   * The poll_one() function runs at most one handler that is ready to run,
-   * without blocking.
-   *
-   * @return The number of handlers that were executed.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  ASIO_DECL std::size_t poll_one();
-
-  /// Run the io_service object's event processing loop to execute one ready
-  /// handler.
-  /**
-   * The poll_one() function runs at most one handler that is ready to run,
-   * without blocking.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @return The number of handlers that were executed.
-   */
-  ASIO_DECL std::size_t poll_one(asio::error_code& ec);
-
-  /// Stop the io_service object's event processing loop.
-  /**
-   * This function does not block, but instead simply signals the io_service to
-   * stop. All invocations of its run() or run_one() member functions should
-   * return as soon as possible. Subsequent calls to run(), run_one(), poll()
-   * or poll_one() will return immediately until restart() is called.
-   */
-  ASIO_DECL void stop();
-
-  /// Determine whether the io_service object has been stopped.
-  /**
-   * This function is used to determine whether an io_service object has been
-   * stopped, either through an explicit call to stop(), or due to running out
-   * of work. When an io_service object is stopped, calls to run(), run_one(),
-   * poll() or poll_one() will return immediately without invoking any
-   * handlers.
-   *
-   * @return @c true if the io_service object is stopped, otherwise @c false.
-   */
-  ASIO_DECL bool stopped() const;
-
-  /// Restart the io_service in preparation for a subsequent run() invocation.
-  /**
-   * This function must be called prior to any second or later set of
-   * invocations of the run(), run_one(), poll() or poll_one() functions when a
-   * previous invocation of these functions returned due to the io_service
-   * being stopped or running out of work. After a call to restart(), the
-   * io_service object's stopped() function will return @c false.
-   *
-   * This function must not be called while there are any unfinished calls to
-   * the run(), run_one(), poll() or poll_one() functions.
-   */
-  ASIO_DECL void restart();
-
 #if !defined(ASIO_NO_DEPRECATED)
-  /// (Deprecated: Use restart().) Reset the io_service in preparation for a
-  /// subsequent run() invocation.
-  /**
-   * This function must be called prior to any second or later set of
-   * invocations of the run(), run_one(), poll() or poll_one() functions when a
-   * previous invocation of these functions returned due to the io_service
-   * being stopped or running out of work. After a call to restart(), the
-   * io_service object's stopped() function will return @c false.
-   *
-   * This function must not be called while there are any unfinished calls to
-   * the run(), run_one(), poll() or poll_one() functions.
-   */
-  void reset();
-
-  /// (Deprecated: Use asio::dispatch().) Request the io_service to
-  /// invoke the given handler.
-  /**
-   * This function is used to ask the io_service to execute the given handler.
-   *
-   * The io_service guarantees that the handler will only be called in a thread
-   * in which the run(), run_one(), poll() or poll_one() member functions is
-   * currently being invoked. The handler may be executed inside this function
-   * if the guarantee can be met.
-   *
-   * @param handler The handler to be called. The io_service will make
-   * a copy of the handler object as required. The function signature of the
-   * handler must be: @code void handler(); @endcode
-   *
-   * @note This function throws an exception only if:
-   *
-   * @li the handler's @c asio_handler_allocate function; or
-   *
-   * @li the handler's copy constructor
-   *
-   * throws an exception.
-   */
-  template <typename CompletionHandler>
-  ASIO_INITFN_RESULT_TYPE(CompletionHandler, void ())
-  dispatch(ASIO_MOVE_ARG(CompletionHandler) handler);
-
-  /// (Deprecated: Use asio::post().) Request the io_service to invoke
-  /// the given handler and return immediately.
-  /**
-   * This function is used to ask the io_service to execute the given handler,
-   * but without allowing the io_service to call the handler from inside this
-   * function.
-   *
-   * The io_service guarantees that the handler will only be called in a thread
-   * in which the run(), run_one(), poll() or poll_one() member functions is
-   * currently being invoked.
-   *
-   * @param handler The handler to be called. The io_service will make
-   * a copy of the handler object as required. The function signature of the
-   * handler must be: @code void handler(); @endcode
-   *
-   * @note This function throws an exception only if:
-   *
-   * @li the handler's @c asio_handler_allocate function; or
-   *
-   * @li the handler's copy constructor
-   *
-   * throws an exception.
-   */
-  template <typename CompletionHandler>
-  ASIO_INITFN_RESULT_TYPE(CompletionHandler, void ())
-  post(ASIO_MOVE_ARG(CompletionHandler) handler);
-
-  /// (Deprecated: Use asio::wrap().) Create a new handler that
-  /// automatically dispatches the wrapped handler on the io_service.
-  /**
-   * This function is used to create a new handler function object that, when
-   * invoked, will automatically pass the wrapped handler to the io_service
-   * object's dispatch function.
-   *
-   * @param handler The handler to be wrapped. The io_service will make a copy
-   * of the handler object as required. The function signature of the handler
-   * must be: @code void handler(A1 a1, ... An an); @endcode
-   *
-   * @return A function object that, when invoked, passes the wrapped handler to
-   * the io_service object's dispatch function. Given a function object with the
-   * signature:
-   * @code R f(A1 a1, ... An an); @endcode
-   * If this function object is passed to the wrap function like so:
-   * @code io_service.wrap(f); @endcode
-   * then the return value is a function object with the signature
-   * @code void g(A1 a1, ... An an); @endcode
-   * that, when invoked, executes code equivalent to:
-   * @code io_service.dispatch(boost::bind(f, a1, ... an)); @endcode
-   */
-  template <typename Handler>
-#if defined(GENERATING_DOCUMENTATION)
-  unspecified
-#else
-  detail::wrapped_handler<io_service&, Handler>
-#endif
-  wrap(Handler handler);
+/// Typedef for backwards compatibility.
+typedef io_context io_service;
 #endif // !defined(ASIO_NO_DEPRECATED)
 
-private:
-  // Helper function to create the implementation.
-  ASIO_DECL impl_type& create_impl(std::size_t concurrency_hint = 0);
-
-  // Backwards compatible overload for use with services derived from
-  // io_service::service.
-  template <typename Service>
-  friend Service& use_service(io_service& ios);
-
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  detail::winsock_init<> init_;
-#elif defined(__sun) || defined(__QNX__) || defined(__hpux) || defined(_AIX) \
-  || defined(__osf__)
-  detail::signal_init<> init_;
-#endif
-
-  // The implementation.
-  impl_type& impl_;
-};
-
-/// Executor used to submit functions to an io_service.
-class io_service::executor_type
-{
-public:
-  /// Obtain the underlying execution context.
-  io_service& context() ASIO_NOEXCEPT;
-
-  /// Inform the io_service that it has some outstanding work to do.
-  /**
-   * This function is used to inform the io_service that some work has begun.
-   * This ensures that the io_service's run() and run_one() functions do not
-   * exit while the work is underway.
-   */
-  void on_work_started() ASIO_NOEXCEPT;
-
-  /// Inform the io_service that some work is no longer outstanding.
-  /**
-   * This function is used to inform the io_service that some work has
-   * finished. Once the count of unfinished work reaches zero, the io_service
-   * is stopped and the run() and run_one() functions may exit.
-   */
-  void on_work_finished() ASIO_NOEXCEPT;
-
-  /// Request the io_service to invoke the given function object.
-  /**
-   * This function is used to ask the io_service to execute the given function
-   * object. If the current thread is running the io_service, @c dispatch()
-   * executes the function before returning. Otherwise, the function will be
-   * scheduled to run on the io_service.
-   *
-   * @param f The function object to be called. The executor will make a copy
-   * of the handler object as required. The function signature of the function
-   * object must be: @code void function(); @endcode
-   *
-   * @param a An allocator that may be used by the executor to allocate the
-   * internal storage needed for function invocation.
-   */
-  template <typename Function, typename Allocator>
-  void dispatch(ASIO_MOVE_ARG(Function) f, const Allocator& a);
-
-  /// Request the io_service to invoke the given function object.
-  /**
-   * This function is used to ask the io_service to execute the given function
-   * object. The function object will never be executed inside @c post().
-   * Instead, it will be scheduled to run on the io_service.
-   *
-   * @param f The function object to be called. The executor will make a copy
-   * of the handler object as required. The function signature of the function
-   * object must be: @code void function(); @endcode
-   *
-   * @param a An allocator that may be used by the executor to allocate the
-   * internal storage needed for function invocation.
-   */
-  template <typename Function, typename Allocator>
-  void post(ASIO_MOVE_ARG(Function) f, const Allocator& a);
-
-  /// Request the io_service to invoke the given function object.
-  /**
-   * This function is used to ask the io_service to execute the given function
-   * object. The function object will never be executed inside @c defer().
-   * Instead, it will be scheduled to run on the io_service.
-   *
-   * If the current thread belongs to the io_service, @c defer() will delay
-   * scheduling the function object until the current thread returns control to
-   * the pool.
-   *
-   * @param f The function object to be called. The executor will make a copy
-   * of the handler object as required. The function signature of the function
-   * object must be: @code void function(); @endcode
-   *
-   * @param a An allocator that may be used by the executor to allocate the
-   * internal storage needed for function invocation.
-   */
-  template <typename Function, typename Allocator>
-  void defer(ASIO_MOVE_ARG(Function) f, const Allocator& a);
-
-  /// Determine whether the io_service is running in the current thread.
-  /**
-   * @return @c true if the current thread is running the io_service. Otherwise
-   * returns @c false.
-   */
-  bool running_in_this_thread() const ASIO_NOEXCEPT;
-
-  /// Compare two executors for equality.
-  /**
-   * Two executors are equal if they refer to the same underlying io_service.
-   */
-  friend bool operator==(const executor_type& a,
-      const executor_type& b) ASIO_NOEXCEPT
-  {
-    return &a.io_service_ == &b.io_service_;
-  }
-
-  /// Compare two executors for inequality.
-  /**
-   * Two executors are equal if they refer to the same underlying io_service.
-   */
-  friend bool operator!=(const executor_type& a,
-      const executor_type& b) ASIO_NOEXCEPT
-  {
-    return &a.io_service_ != &b.io_service_;
-  }
-
-private:
-  friend class io_service;
-
-  // Constructor.
-  explicit executor_type(io_service& i) : io_service_(i) {}
-
-  // The underlying io_service.
-  io_service& io_service_;
-};
-
-#if !defined(GENERATING_DOCUMENTATION)
-template <> struct is_executor<io_service::executor_type> : true_type {};
-#endif // !defined(GENERATING_DOCUMENTATION)
-
-
-/// (Deprecated: Use executor_work.) Class to inform the io_service when it has
-/// work to do.
-/**
- * The work class is used to inform the io_service when work starts and
- * finishes. This ensures that the io_service object's run() function will not
- * exit while work is underway, and that it does exit when there is no
- * unfinished work remaining.
- *
- * The work class is copy-constructible so that it may be used as a data member
- * in a handler class. It is not assignable.
- */
-class io_service::work
-{
-public:
-  /// Constructor notifies the io_service that work is starting.
-  /**
-   * The constructor is used to inform the io_service that some work has begun.
-   * This ensures that the io_service object's run() function will not exit
-   * while the work is underway.
-   */
-  explicit work(asio::io_service& io_service);
-
-  /// Copy constructor notifies the io_service that work is starting.
-  /**
-   * The constructor is used to inform the io_service that some work has begun.
-   * This ensures that the io_service object's run() function will not exit
-   * while the work is underway.
-   */
-  work(const work& other);
-
-  /// Destructor notifies the io_service that the work is complete.
-  /**
-   * The destructor is used to inform the io_service that some work has
-   * finished. Once the count of unfinished work reaches zero, the io_service
-   * object's run() function is permitted to exit.
-   */
-  ~work();
-
-  /// Get the io_service associated with the work.
-  asio::io_service& get_io_service();
-
-private:
-  // Prevent assignment.
-  void operator=(const work& other);
-
-  // The io_service implementation.
-  detail::io_service_impl& io_service_impl_;
-};
-
-/// Base class for all io_service services.
-class io_service::service
-  : public execution_context::service
-{
-public:
-  /// Get the io_service object that owns the service.
-  asio::io_service& get_io_service();
-
-protected:
-  /// Constructor.
-  /**
-   * @param owner The io_service object that owns the service.
-   */
-  ASIO_DECL service(asio::io_service& owner);
-
-  /// Destructor.
-  ASIO_DECL virtual ~service();
-};
-
-namespace detail {
-
-// Special service base class to keep classes header-file only.
-template <typename Type>
-class service_base
-  : public asio::io_service::service
-{
-public:
-  static asio::detail::service_id<Type> id;
-
-  // Constructor.
-  service_base(asio::io_service& io_service)
-    : asio::io_service::service(io_service)
-  {
-  }
-};
-
-template <typename Type>
-asio::detail::service_id<Type> service_base<Type>::id;
-
-} // namespace detail
 } // namespace asio
 
 #include "asio/detail/pop_options.hpp"
 
-#include "asio/impl/io_service.hpp"
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/impl/io_service.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-// If both io_service.hpp and strand.hpp have been included, automatically
-// include the header file needed for the io_service::strand class.
-#if defined(ASIO_STRAND_HPP)
-# include "asio/io_service_strand.hpp"
-#endif // defined(ASIO_STRAND_HPP)
-
 #endif // ASIO_IO_SERVICE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/io_service_strand.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/io_service_strand.hpp
index 3123a5e..49f6f3b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/io_service_strand.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/io_service_strand.hpp
@@ -2,7 +2,7 @@
 // io_service_strand.hpp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -15,354 +15,6 @@
 # pragma once
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
-#include "asio/detail/config.hpp"
-#include "asio/async_result.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/strand_service.hpp"
-#include "asio/detail/wrapped_handler.hpp"
-#include "asio/io_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Provides serialised handler execution.
-/**
- * The io_service::strand class provides the ability to post and dispatch
- * handlers with the guarantee that none of those handlers will execute
- * concurrently.
- *
- * @par Order of handler invocation
- * Given:
- *
- * @li a strand object @c s
- *
- * @li an object @c a meeting completion handler requirements
- *
- * @li an object @c a1 which is an arbitrary copy of @c a made by the
- * implementation
- *
- * @li an object @c b meeting completion handler requirements
- *
- * @li an object @c b1 which is an arbitrary copy of @c b made by the
- * implementation
- *
- * if any of the following conditions are true:
- *
- * @li @c s.post(a) happens-before @c s.post(b)
- * 
- * @li @c s.post(a) happens-before @c s.dispatch(b), where the latter is
- * performed outside the strand
- * 
- * @li @c s.dispatch(a) happens-before @c s.post(b), where the former is
- * performed outside the strand
- * 
- * @li @c s.dispatch(a) happens-before @c s.dispatch(b), where both are
- * performed outside the strand
- *   
- * then @c asio_handler_invoke(a1, &a1) happens-before
- * @c asio_handler_invoke(b1, &b1).
- * 
- * Note that in the following case:
- * @code async_op_1(..., s.wrap(a));
- * async_op_2(..., s.wrap(b)); @endcode
- * the completion of the first async operation will perform @c s.dispatch(a),
- * and the second will perform @c s.dispatch(b), but the order in which those
- * are performed is unspecified. That is, you cannot state whether one
- * happens-before the other. Therefore none of the above conditions are met and
- * no ordering guarantee is made.
- *
- * @note The implementation makes no guarantee that handlers posted or
- * dispatched through different @c strand objects will be invoked concurrently.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Safe.
- *
- * @par Concepts:
- * Dispatcher.
- */
-class io_service::strand
-{
-public:
-  /// Constructor.
-  /**
-   * Constructs the strand.
-   *
-   * @param io_service The io_service object that the strand will use to
-   * dispatch handlers that are ready to be run.
-   */
-  explicit strand(asio::io_service& io_service)
-    : service_(asio::use_service<
-        asio::detail::strand_service>(io_service))
-  {
-    service_.construct(impl_);
-  }
-
-  /// Destructor.
-  /**
-   * Destroys a strand.
-   *
-   * Handlers posted through the strand that have not yet been invoked will
-   * still be dispatched in a way that meets the guarantee of non-concurrency.
-   */
-  ~strand()
-  {
-  }
-
-#if !defined(ASIO_NO_DEPRECATED)
-  /// (Deprecated: Use context().) Get the io_service associated with the
-  /// strand.
-  /**
-   * This function may be used to obtain the io_service object that the strand
-   * uses to dispatch handlers for asynchronous operations.
-   *
-   * @return A reference to the io_service object that the strand will use to
-   * dispatch handlers. Ownership is not transferred to the caller.
-   */
-  asio::io_service& get_io_service()
-  {
-    return service_.get_io_service();
-  }
-#endif // !defined(ASIO_NO_DEPRECATED)
-
-  /// Obtain the underlying execution context.
-  asio::io_service& context() ASIO_NOEXCEPT
-  {
-    return service_.get_io_service();
-  }
-
-  /// Inform the strand that it has some outstanding work to do.
-  /**
-   * The strand delegates this call to its underlying io_service.
-   */
-  void on_work_started() ASIO_NOEXCEPT
-  {
-    context().get_executor().on_work_started();
-  }
-
-  /// Inform the strand that some work is no longer outstanding.
-  /**
-   * The strand delegates this call to its underlying io_service.
-   */
-  void on_work_finished() ASIO_NOEXCEPT
-  {
-    context().get_executor().on_work_finished();
-  }
-
-  /// Request the strand to invoke the given function object.
-  /**
-   * This function is used to ask the strand to execute the given function
-   * object on its underlying io_service. The function object will be executed
-   * inside this function if the strand is not otherwise busy and if the
-   * underlying io_service's executor's @c dispatch() function is also able to
-   * execute the function before returning.
-   *
-   * @param f The function object to be called. The executor will make
-   * a copy of the handler object as required. The function signature of the
-   * function object must be: @code void function(); @endcode
-   *
-   * @param a An allocator that may be used by the executor to allocate the
-   * internal storage needed for function invocation.
-   */
-  template <typename Function, typename Allocator>
-  void dispatch(ASIO_MOVE_ARG(Function) f, const Allocator& a)
-  {
-    typename decay<Function>::type tmp(ASIO_MOVE_CAST(Function)(f));
-    service_.dispatch(impl_, tmp);
-    (void)a;
-  }
-
-#if !defined(ASIO_NO_DEPRECATED)
-  /// (Deprecated: Use asio::dispatch().) Request the strand to invoke
-  /// the given handler.
-  /**
-   * This function is used to ask the strand to execute the given handler.
-   *
-   * The strand object guarantees that handlers posted or dispatched through
-   * the strand will not be executed concurrently. The handler may be executed
-   * inside this function if the guarantee can be met. If this function is
-   * called from within a handler that was posted or dispatched through the same
-   * strand, then the new handler will be executed immediately.
-   *
-   * The strand's guarantee is in addition to the guarantee provided by the
-   * underlying io_service. The io_service guarantees that the handler will only
-   * be called in a thread in which the io_service's run member function is
-   * currently being invoked.
-   *
-   * @param handler The handler to be called. The strand will make a copy of the
-   * handler object as required. The function signature of the handler must be:
-   * @code void handler(); @endcode
-   */
-  template <typename CompletionHandler>
-  ASIO_INITFN_RESULT_TYPE(CompletionHandler, void ())
-  dispatch(ASIO_MOVE_ARG(CompletionHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a CompletionHandler.
-    ASIO_COMPLETION_HANDLER_CHECK(CompletionHandler, handler) type_check;
-
-    async_completion<CompletionHandler, void ()> init(handler);
-
-    service_.dispatch(impl_, init.handler);
-
-    return init.result.get();
-  }
-#endif // !defined(ASIO_NO_DEPRECATED)
-
-  /// Request the strand to invoke the given function object.
-  /**
-   * This function is used to ask the executor to execute the given function
-   * object. The function object will never be executed inside this function.
-   * Instead, it will be scheduled to run by the underlying io_service.
-   *
-   * @param f The function object to be called. The executor will make
-   * a copy of the handler object as required. The function signature of the
-   * function object must be: @code void function(); @endcode
-   *
-   * @param a An allocator that may be used by the executor to allocate the
-   * internal storage needed for function invocation.
-   */
-  template <typename Function, typename Allocator>
-  void post(ASIO_MOVE_ARG(Function) f, const Allocator& a)
-  {
-    typename decay<Function>::type tmp(ASIO_MOVE_CAST(Function)(f));
-    service_.post(impl_, tmp);
-    (void)a;
-  }
-
-#if !defined(ASIO_NO_DEPRECATED)
-  /// (Deprecated: Use asio::post().) Request the strand to invoke the
-  /// given handler and return immediately.
-  /**
-   * This function is used to ask the strand to execute the given handler, but
-   * without allowing the strand to call the handler from inside this function.
-   *
-   * The strand object guarantees that handlers posted or dispatched through
-   * the strand will not be executed concurrently. The strand's guarantee is in
-   * addition to the guarantee provided by the underlying io_service. The
-   * io_service guarantees that the handler will only be called in a thread in
-   * which the io_service's run member function is currently being invoked.
-   *
-   * @param handler The handler to be called. The strand will make a copy of the
-   * handler object as required. The function signature of the handler must be:
-   * @code void handler(); @endcode
-   */
-  template <typename CompletionHandler>
-  ASIO_INITFN_RESULT_TYPE(CompletionHandler, void ())
-  post(ASIO_MOVE_ARG(CompletionHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a CompletionHandler.
-    ASIO_COMPLETION_HANDLER_CHECK(CompletionHandler, handler) type_check;
-
-    async_completion<CompletionHandler, void ()> init(handler);
-
-    service_.post(impl_, init.handler);
-
-    return init.result.get();
-  }
-#endif // !defined(ASIO_NO_DEPRECATED)
-
-  /// Request the strand to invoke the given function object.
-  /**
-   * This function is used to ask the executor to execute the given function
-   * object. The function object will never be executed inside this function.
-   * Instead, it will be scheduled to run by the underlying io_service.
-   *
-   * @param f The function object to be called. The executor will make
-   * a copy of the handler object as required. The function signature of the
-   * function object must be: @code void function(); @endcode
-   *
-   * @param a An allocator that may be used by the executor to allocate the
-   * internal storage needed for function invocation.
-   */
-  template <typename Function, typename Allocator>
-  void defer(ASIO_MOVE_ARG(Function) f, const Allocator& a)
-  {
-    typename decay<Function>::type tmp(ASIO_MOVE_CAST(Function)(f));
-    service_.post(impl_, tmp);
-    (void)a;
-  }
-
-#if !defined(ASIO_NO_DEPRECATED)
-  /// (Deprecated: Use asio::wrap().) Create a new handler that
-  /// automatically dispatches the wrapped handler on the strand.
-  /**
-   * This function is used to create a new handler function object that, when
-   * invoked, will automatically pass the wrapped handler to the strand's
-   * dispatch function.
-   *
-   * @param handler The handler to be wrapped. The strand will make a copy of
-   * the handler object as required. The function signature of the handler must
-   * be: @code void handler(A1 a1, ... An an); @endcode
-   *
-   * @return A function object that, when invoked, passes the wrapped handler to
-   * the strand's dispatch function. Given a function object with the signature:
-   * @code R f(A1 a1, ... An an); @endcode
-   * If this function object is passed to the wrap function like so:
-   * @code strand.wrap(f); @endcode
-   * then the return value is a function object with the signature
-   * @code void g(A1 a1, ... An an); @endcode
-   * that, when invoked, executes code equivalent to:
-   * @code strand.dispatch(boost::bind(f, a1, ... an)); @endcode
-   */
-  template <typename Handler>
-#if defined(GENERATING_DOCUMENTATION)
-  unspecified
-#else
-  detail::wrapped_handler<strand, Handler, detail::is_continuation_if_running>
-#endif
-  wrap(Handler handler)
-  {
-    return detail::wrapped_handler<io_service::strand, Handler,
-        detail::is_continuation_if_running>(*this, handler);
-  }
-#endif // !defined(ASIO_NO_DEPRECATED)
-
-  /// Determine whether the strand is running in the current thread.
-  /**
-   * @return @c true if the current thread is executing a handler that was
-   * submitted to the strand using post(), dispatch() or wrap(). Otherwise
-   * returns @c false.
-   */
-  bool running_in_this_thread() const ASIO_NOEXCEPT
-  {
-    return service_.running_in_this_thread(impl_);
-  }
-
-  /// Compare two strands for equality.
-  /**
-   * Two strands are equal if they refer to the same ordered, non-concurrent
-   * state.
-   */
-  friend bool operator==(const strand& a, const strand& b) ASIO_NOEXCEPT
-  {
-    return a.impl_ == b.impl_;
-  }
-
-  /// Compare two strands for inequality.
-  /**
-   * Two strands are equal if they refer to the same ordered, non-concurrent
-   * state.
-   */
-  friend bool operator!=(const strand& a, const strand& b) ASIO_NOEXCEPT
-  {
-    return a.impl_ != b.impl_;
-  }
-
-private:
-  asio::detail::strand_service& service_;
-  asio::detail::strand_service::implementation_type impl_;
-};
-
-#if !defined(GENERATING_DOCUMENTATION)
-template <>
-struct is_executor<io_service::strand> : true_type {};
-#endif // !defined(GENERATING_DOCUMENTATION)
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
+#include "asio/io_context_strand.hpp"
 
 #endif // ASIO_IO_SERVICE_STRAND_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address.hpp
index 7cddee2..351a815 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address.hpp
@@ -2,7 +2,7 @@
 // ip/address.hpp
 // ~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,6 +17,8 @@
 
 #include "asio/detail/config.hpp"
 #include <string>
+#include "asio/detail/throw_exception.hpp"
+#include "asio/detail/string_view.hpp"
 #include "asio/detail/type_traits.hpp"
 #include "asio/error_code.hpp"
 #include "asio/ip/address_v4.hpp"
@@ -89,21 +91,19 @@ public:
     return type_ == ipv6;
   }
 
-#if !defined(ASIO_NO_DEPRECATED)
   /// Get the address as an IP version 4 address.
   ASIO_DECL asio::ip::address_v4 to_v4() const;
 
   /// Get the address as an IP version 6 address.
   ASIO_DECL asio::ip::address_v6 to_v6() const;
-#endif // !defined(ASIO_NO_DEPRECATED)
 
-  /// Get the address as a string in dotted decimal format.
+  /// Get the address as a string.
   ASIO_DECL std::string to_string() const;
 
-  /// Get the address as a string in dotted decimal format.
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use other overload.) Get the address as a string.
   ASIO_DECL std::string to_string(asio::error_code& ec) const;
 
-#if !defined(ASIO_NO_DEPRECATED)
   /// (Deprecated: Use make_address().) Create an address from an IPv4 address
   /// string in dotted decimal form, or from an IPv6 address in hexadecimal
   /// notation.
@@ -166,20 +166,8 @@ public:
   }
 
 private:
-  // Helper function to get the underlying IPv4 address.
-  friend asio::ip::address_v4 get_v4_helper(const address& a)
-  {
-    return a.ipv4_address_;
-  }
-
-  // Helper function to get the underlying IPv4 address.
-  friend asio::ip::address_v6 get_v6_helper(const address& a)
-  {
-    return a.ipv6_address_;
-  }
-
   // The type of the address.
-  enum { none, ipv4, ipv6 } type_;
+  enum { ipv4, ipv6 } type_;
 
   // The underlying IPv4 address.
   asio::ip::address_v4 ipv4_address_;
@@ -218,92 +206,26 @@ ASIO_DECL address make_address(const std::string& str);
 ASIO_DECL address make_address(
     const std::string& str, asio::error_code& ec);
 
-/** @defgroup address_cast asio::ip::address_cast
- *
- * @brief The asio::ip::address_cast function is used to convert between
- * address types.
- */
-/*@{*/
+#if defined(ASIO_HAS_STD_STRING_VIEW) \
+  || defined(GENERATING_DOCUMENTATION)
 
-/// Cast a version-independent address to itself.
-template <typename T>
-inline T address_cast(const address& addr,
-    typename enable_if<is_same<T, address>::value>::type* = 0)
-{
-  return addr;
-}
-
-/// Cast a version-independent address to an IPv4 address.
+/// Create an address from an IPv4 address string in dotted decimal form,
+/// or from an IPv6 address in hexadecimal notation.
 /**
- * @throws bad_address_cast if @c a does not represent an IPv4 address.
+ * @relates address
  */
-template <typename T>
-inline T address_cast(const address& addr,
-    typename enable_if<is_same<T, address_v4>::value>::type* = 0)
-{
-  if (!addr.is_v4())
-    throw bad_address_cast();
-  return get_v4_helper(addr);
-}
+ASIO_DECL address make_address(string_view str);
 
-/// Cast a version-independent address to an IPv6 address.
+/// Create an address from an IPv4 address string in dotted decimal form,
+/// or from an IPv6 address in hexadecimal notation.
 /**
- * @throws bad_address_cast if @c a does not represent an IPv6 address.
+ * @relates address
  */
-template <typename T>
-inline T address_cast(const address& addr,
-    typename enable_if<is_same<T, address_v6>::value>::type* = 0)
-{
-  if (!addr.is_v6())
-    throw bad_address_cast();
-  return get_v6_helper(addr);
-}
-
-/// Cast an IPv4 address to a version-independent address.
-template <typename T>
-inline T address_cast(const address_v4& addr,
-    typename enable_if<is_same<T, address>::value>::type* = 0)
-{
-  return address(addr);
-}
-
-/// Cast an IPv4 address to itself.
-template <typename T>
-inline T address_cast(const address_v4& addr,
-    typename enable_if<is_same<T, address_v4>::value>::type* = 0)
-{
-  return addr;
-}
-
-/// Cast from IPv4 to IPV6 address is not permitted.
-template <typename T>
-bad_address_cast address_cast(const address_v4&,
-    typename enable_if<is_same<T, address_v6>::value>::type* = 0)
-  ASIO_DELETED;
-
-/// Cast an IPv6 address to a version-independent address.
-template <typename T>
-inline T address_cast(const address_v6& addr,
-    typename enable_if<is_same<T, address>::value>::type* = 0)
-{
-  return address(addr);
-}
-
-/// Cast an IPv6 address to itself.
-template <typename T>
-inline T address_cast(const address_v6& addr,
-    typename enable_if<is_same<T, address_v6>::value>::type* = 0)
-{
-  return addr;
-}
-
-/// Cast from IPv6 to IPv4 address is not permitted.
-template <typename T>
-bad_address_cast address_cast(const address_v6&,
-    typename enable_if<is_same<T, address_v4>::value>::type* = 0)
-  ASIO_DELETED;
+ASIO_DECL address make_address(
+    string_view str, asio::error_code& ec);
 
-/*@}*/
+#endif // defined(ASIO_HAS_STD_STRING_VIEW)
+       //  || defined(GENERATING_DOCUMENTATION)
 
 #if !defined(ASIO_NO_IOSTREAM)
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_iterator_v4.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_iterator_v4.hpp
deleted file mode 100644
index 8ae7869..0000000
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_iterator_v4.hpp
+++ /dev/null
@@ -1,156 +0,0 @@
-//
-// ip/address_iterator_v4.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_ADDRESS_ITERATOR_V4_HPP
-#define ASIO_IP_ADDRESS_ITERATOR_V4_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/ip/address_v4.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-/// An input iterator that can be used for traversing IPv4 addresses.
-/**
- * In addition to satisfying the input iterator requirements, this iterator
- * also supports decrement.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-class address_iterator_v4
-{
-public:
-  /// The type of the elements pointed to by the iterator.
-  typedef address_v4 value_type;
-
-  /// Distance between two iterators.
-  typedef std::ptrdiff_t difference_type;
-
-  /// The type of a pointer to an element pointed to by the iterator.
-  typedef const address_v4* pointer;
-
-  /// The type of a reference to an element pointed to by the iterator.
-  typedef const address_v4& reference;
-
-  /// Denotes that the iterator satisfies the input iterator requirements.
-  typedef std::input_iterator_tag iterator_category;
-
-  /// Construct an iterator that points to the specified address.
-  address_iterator_v4(const address_v4& addr) ASIO_NOEXCEPT
-    : address_(addr)
-  {
-  }
-
-  /// Copy constructor.
-  address_iterator_v4(const address_iterator_v4& other) ASIO_NOEXCEPT
-    : address_(other.address_)
-  {
-  }
-
-#if defined(ASIO_HAS_MOVE)
-  /// Move constructor.
-  address_iterator_v4(address_iterator_v4&& other) ASIO_NOEXCEPT
-    : address_(ASIO_MOVE_CAST(address_v4)(other.address_))
-  {
-  }
-#endif // defined(ASIO_HAS_MOVE)
-
-  /// Assignment operator.
-  address_iterator_v4& operator=(
-      const address_iterator_v4& other) ASIO_NOEXCEPT
-  {
-    address_ = other.address_;
-    return *this;
-  }
-
-#if defined(ASIO_HAS_MOVE)
-  /// Move assignment operator.
-  address_iterator_v4& operator=(
-      address_iterator_v4&& other) ASIO_NOEXCEPT
-  {
-    address_ = ASIO_MOVE_CAST(address_v4)(other.address_);
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE)
-
-  /// Dereference the iterator.
-  const address_v4& operator*() const ASIO_NOEXCEPT
-  {
-    return address_;
-  }
-
-  /// Dereference the iterator.
-  const address_v4* operator->() const ASIO_NOEXCEPT
-  {
-    return &address_;
-  }
-
-  /// Pre-increment operator.
-  address_iterator_v4& operator++() ASIO_NOEXCEPT
-  {
-    address_ = address_v4((address_.to_ulong() + 1) & 0xFFFFFFFF);
-    return *this;
-  }
-
-  /// Post-increment operator.
-  address_iterator_v4 operator++(int) ASIO_NOEXCEPT
-  {
-    address_iterator_v4 tmp(*this);
-    ++*this;
-    return tmp;
-  }
-
-  /// Pre-decrement operator.
-  address_iterator_v4& operator--() ASIO_NOEXCEPT
-  {
-    address_ = address_v4((address_.to_ulong() - 1) & 0xFFFFFFFF);
-    return *this;
-  }
-
-  /// Post-decrement operator.
-  address_iterator_v4 operator--(int)
-  {
-    address_iterator_v4 tmp(*this);
-    --*this;
-    return tmp;
-  }
-
-  /// Compare two addresses for equality.
-  friend bool operator==(const address_iterator_v4& a,
-      const address_iterator_v4& b)
-  {
-    return a.address_ == b.address_;
-  }
-
-  /// Compare two addresses for inequality.
-  friend bool operator!=(const address_iterator_v4& a,
-      const address_iterator_v4& b)
-  {
-    return a.address_ != b.address_;
-  }
-
-private:
-  address_v4 address_;
-};
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_ADDRESS_ITERATOR_V4_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_iterator_v6.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_iterator_v6.hpp
deleted file mode 100644
index 4cd9cc0..0000000
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_iterator_v6.hpp
+++ /dev/null
@@ -1,177 +0,0 @@
-//
-// ip/address_iterator_v6.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//                         Oliver Kowalke (oliver dot kowalke at gmail dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_ADDRESS_ITERATOR_V6_HPP
-#define ASIO_IP_ADDRESS_ITERATOR_V6_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/ip/address_v6.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-/// An input iterator that can be used for traversing IPv6 addresses.
-/**
- * In addition to satisfying the input iterator requirements, this iterator
- * also supports decrement.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-class address_iterator_v6
-{
-public:
-  /// The type of the elements pointed to by the iterator.
-  typedef address_v6 value_type;
-
-  /// Distance between two iterators.
-  typedef std::ptrdiff_t difference_type;
-
-  /// The type of a pointer to an element pointed to by the iterator.
-  typedef const address_v6* pointer;
-
-  /// The type of a reference to an element pointed to by the iterator.
-  typedef const address_v6& reference;
-
-  /// Denotes that the iterator satisfies the input iterator requirements.
-  typedef std::input_iterator_tag iterator_category;
-
-  /// Construct an iterator that points to the specified address.
-  address_iterator_v6(const address_v6& addr) ASIO_NOEXCEPT
-    : address_(addr)
-  {
-  }
-
-  /// Copy constructor.
-  address_iterator_v6(const address_iterator_v6& other) ASIO_NOEXCEPT
-    : address_(other.address_)
-  {
-  }
-
-#if defined(ASIO_HAS_MOVE)
-  /// Move constructor.
-  address_iterator_v6(address_iterator_v6&& other) ASIO_NOEXCEPT
-    : address_(ASIO_MOVE_CAST(address_v6)(other.address_))
-  {
-  }
-#endif // defined(ASIO_HAS_MOVE)
-
-  /// Assignment operator.
-  address_iterator_v6& operator=(
-      const address_iterator_v6& other) ASIO_NOEXCEPT
-  {
-    address_ = other.address_;
-    return *this;
-  }
-
-#if defined(ASIO_HAS_MOVE)
-  /// Move assignment operator.
-  address_iterator_v6& operator=(
-      address_iterator_v6&& other) ASIO_NOEXCEPT
-  {
-    address_ = ASIO_MOVE_CAST(address_v6)(other.address_);
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE)
-
-  /// Dereference the iterator.
-  const address_v6& operator*() const ASIO_NOEXCEPT
-  {
-    return address_;
-  }
-
-  /// Dereference the iterator.
-  const address_v6* operator->() const ASIO_NOEXCEPT
-  {
-    return &address_;
-  }
-
-  /// Pre-increment operator.
-  address_iterator_v6& operator++() ASIO_NOEXCEPT
-  {
-    for (int i = 15; i >= 0; --i)
-    {
-      if (address_.addr_.s6_addr[i] < 0xFF)
-      {
-        ++address_.addr_.s6_addr[i];
-        break;
-      }
-
-      address_.addr_.s6_addr[i] = 0;
-    }
-
-    return *this;
-  }
-
-  /// Post-increment operator.
-  address_iterator_v6 operator++(int) ASIO_NOEXCEPT
-  {
-    address_iterator_v6 tmp(*this);
-    ++*this;
-    return tmp;
-  }
-
-  /// Pre-decrement operator.
-  address_iterator_v6& operator--() ASIO_NOEXCEPT
-  {
-    for (int i = 15; i >= 0; --i)
-    {
-      if (address_.addr_.s6_addr[i] > 0)
-      {
-        --address_.addr_.s6_addr[i];
-        break;
-      }
-
-      address_.addr_.s6_addr[i] = 0xFF;
-    }
-
-    return *this;
-  }
-
-  /// Post-decrement operator.
-  address_iterator_v6 operator--(int)
-  {
-    address_iterator_v6 tmp(*this);
-    --*this;
-    return tmp;
-  }
-
-  /// Compare two addresses for equality.
-  friend bool operator==(const address_iterator_v6& a,
-      const address_iterator_v6& b)
-  {
-    return a.address_ == b.address_;
-  }
-
-  /// Compare two addresses for inequality.
-  friend bool operator!=(const address_iterator_v6& a,
-      const address_iterator_v6& b)
-  {
-    return a.address_ != b.address_;
-  }
-
-private:
-  address_v6 address_;
-};
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_ADDRESS_ITERATOR_V6_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_range_v4.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_range_v4.hpp
deleted file mode 100644
index 3b07b45..0000000
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_range_v4.hpp
+++ /dev/null
@@ -1,129 +0,0 @@
-//
-// ip/address_range_v4.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_ADDRESS_RANGE_V4_HPP
-#define ASIO_IP_ADDRESS_RANGE_V4_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/ip/address_iterator_v4.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-/// Represents a range of IPv4 addresses.
-/**
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-class address_range_v4
-{
-public:
-  /// The type of an iterator that points into the range.
-  typedef address_iterator_v4 iterator;
-
-  /// Construct an empty range.
-  address_range_v4() ASIO_NOEXCEPT
-    : begin_(address_v4()),
-      end_(address_v4())
-  {
-  }
-
-  /// Construct an range that represents the given range of addresses.
-  explicit address_range_v4(const address_iterator_v4& first,
-      const address_iterator_v4& last) ASIO_NOEXCEPT
-    : begin_(first),
-      end_(last)
-  {
-  }
-
-  /// Copy constructor.
-  address_range_v4(const address_range_v4& other) ASIO_NOEXCEPT
-    : begin_(other.begin_),
-      end_(other.end_)
-  {
-  }
-
-#if defined(ASIO_HAS_MOVE)
-  /// Move constructor.
-  address_range_v4(address_range_v4&& other) ASIO_NOEXCEPT
-    : begin_(ASIO_MOVE_CAST(address_iterator_v4)(other.begin_)),
-      end_(ASIO_MOVE_CAST(address_iterator_v4)(other.end_))
-  {
-  }
-#endif // defined(ASIO_HAS_MOVE)
-
-  /// Assignment operator.
-  address_range_v4& operator=(
-      const address_range_v4& other) ASIO_NOEXCEPT
-  {
-    begin_ = other.begin_;
-    end_ = other.end_;
-    return *this;
-  }
-
-#if defined(ASIO_HAS_MOVE)
-  /// Move assignment operator.
-  address_range_v4& operator=(
-      address_range_v4&& other) ASIO_NOEXCEPT
-  {
-    begin_ = ASIO_MOVE_CAST(address_iterator_v4)(other.begin_);
-    end_ = ASIO_MOVE_CAST(address_iterator_v4)(other.end_);
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE)
-
-  /// Obtain an iterator that points to the start of the range.
-  iterator begin() const ASIO_NOEXCEPT
-  {
-    return begin_;
-  }
-
-  /// Obtain an iterator that points to the end of the range.
-  iterator end() const ASIO_NOEXCEPT
-  {
-    return end_;
-  }
-
-  /// Determine whether the range is empty.
-  bool empty() const ASIO_NOEXCEPT
-  {
-    return size() == 0;
-  }
-
-  /// Return the size of the range.
-  std::size_t size() const ASIO_NOEXCEPT
-  {
-    return end_->to_ulong() - begin_->to_ulong();
-  }
-
-  /// Find an address in the range.
-  iterator find(const address_v4& addr) const ASIO_NOEXCEPT
-  {
-    return addr >= *begin_ && addr < *end_ ? iterator(addr) : end_;
-  }
-
-private:
-  address_iterator_v4 begin_;
-  address_iterator_v4 end_;
-};
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_ADDRESS_RANGE_V4_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_range_v6.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_range_v6.hpp
deleted file mode 100644
index e8620db..0000000
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_range_v6.hpp
+++ /dev/null
@@ -1,124 +0,0 @@
-//
-// ip/address_range_v6.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//                         Oliver Kowalke (oliver dot kowalke at gmail dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_ADDRESS_RANGE_v6_HPP
-#define ASIO_IP_ADDRESS_RANGE_v6_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/ip/address_iterator_v6.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-/// Represents a range of IPv6 addresses.
-/**
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-class address_range_v6
-{
-public:
-  /// The type of an iterator that points into the range.
-  typedef address_iterator_v6 iterator;
-
-  /// Construct an empty range.
-  address_range_v6() ASIO_NOEXCEPT
-    : begin_(address_v6()),
-      end_(address_v6())
-  {
-  }
-
-  /// Construct an range that represents the given range of addresses.
-  explicit address_range_v6(const address_iterator_v6& first,
-      const address_iterator_v6& last) ASIO_NOEXCEPT
-    : begin_(first),
-      end_(last)
-  {
-  }
-
-  /// Copy constructor.
-  address_range_v6(const address_range_v6& other) ASIO_NOEXCEPT
-    : begin_(other.begin_),
-      end_(other.end_)
-  {
-  }
-
-#if defined(ASIO_HAS_MOVE)
-  /// Move constructor.
-  address_range_v6(address_range_v6&& other) ASIO_NOEXCEPT
-    : begin_(ASIO_MOVE_CAST(address_iterator_v6)(other.begin_)),
-      end_(ASIO_MOVE_CAST(address_iterator_v6)(other.end_))
-  {
-  }
-#endif // defined(ASIO_HAS_MOVE)
-
-  /// Assignment operator.
-  address_range_v6& operator=(
-      const address_range_v6& other) ASIO_NOEXCEPT
-  {
-    begin_ = other.begin_;
-    end_ = other.end_;
-    return *this;
-  }
-
-#if defined(ASIO_HAS_MOVE)
-  /// Move assignment operator.
-  address_range_v6& operator=(
-      address_range_v6&& other) ASIO_NOEXCEPT
-  {
-    begin_ = ASIO_MOVE_CAST(address_iterator_v6)(other.begin_);
-    end_ = ASIO_MOVE_CAST(address_iterator_v6)(other.end_);
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE)
-
-  /// Obtain an iterator that points to the start of the range.
-  iterator begin() const ASIO_NOEXCEPT
-  {
-    return begin_;
-  }
-
-  /// Obtain an iterator that points to the end of the range.
-  iterator end() const ASIO_NOEXCEPT
-  {
-    return end_;
-  }
-
-  /// Determine whether the range is empty.
-  bool empty() const ASIO_NOEXCEPT
-  {
-    return begin_ == end_;
-  }
-
-  /// Find an address in the range.
-  iterator find(const address_v6& addr) const ASIO_NOEXCEPT
-  {
-    return addr >= *begin_ && addr < *end_ ? iterator(addr) : end_;
-  }
-
-private:
-  address_iterator_v6 begin_;
-  address_iterator_v6 end_;
-};
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_ADDRESS_RANGE_V6_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_v4.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_v4.hpp
index 120210a..6e16313 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_v4.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_v4.hpp
@@ -2,7 +2,7 @@
 // ip/address_v4.hpp
 // ~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -18,7 +18,9 @@
 #include "asio/detail/config.hpp"
 #include <string>
 #include "asio/detail/array.hpp"
+#include "asio/detail/cstdint.hpp"
 #include "asio/detail/socket_types.hpp"
+#include "asio/detail/string_view.hpp"
 #include "asio/detail/winsock_init.hpp"
 #include "asio/error_code.hpp"
 
@@ -43,6 +45,9 @@ namespace ip {
 class address_v4
 {
 public:
+  /// The type used to represent an address as an unsigned integer.
+  typedef uint_least32_t uint_type;
+
   /// The type used to represent an address as an array of bytes.
   /**
    * @note This type is defined in terms of the C++0x template @c std::array
@@ -63,8 +68,8 @@ public:
   /// Construct an address from raw bytes.
   ASIO_DECL explicit address_v4(const bytes_type& bytes);
 
-  /// Construct an address from an unsigned long in host byte order.
-  ASIO_DECL explicit address_v4(unsigned long addr);
+  /// Construct an address from an unsigned integer in host byte order.
+  ASIO_DECL explicit address_v4(uint_type addr);
 
   /// Copy constructor.
   address_v4(const address_v4& other)
@@ -99,16 +104,22 @@ public:
   /// Get the address in bytes, in network byte order.
   ASIO_DECL bytes_type to_bytes() const;
 
+  /// Get the address as an unsigned integer in host byte order
+  ASIO_DECL uint_type to_uint() const;
+
+#if !defined(ASIO_NO_DEPRECATED)
   /// Get the address as an unsigned long in host byte order
   ASIO_DECL unsigned long to_ulong() const;
+#endif // !defined(ASIO_NO_DEPRECATED)
 
   /// Get the address as a string in dotted decimal format.
   ASIO_DECL std::string to_string() const;
 
-  /// Get the address as a string in dotted decimal format.
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use other overload.) Get the address as a string in dotted
+  /// decimal format.
   ASIO_DECL std::string to_string(asio::error_code& ec) const;
 
-#if !defined(ASIO_NO_DEPRECATED)
   /// (Deprecated: Use make_address_v4().) Create an address from an IP address
   /// string in dotted decimal form.
   static address_v4 from_string(const char* str);
@@ -134,14 +145,19 @@ public:
   /// Determine whether the address is unspecified.
   ASIO_DECL bool is_unspecified() const;
 
-  /// Determine whether the address is a class A address.
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use network_v4 class.) Determine whether the address is a
+  /// class A address.
   ASIO_DECL bool is_class_a() const;
 
-  /// Determine whether the address is a class B address.
+  /// (Deprecated: Use network_v4 class.) Determine whether the address is a
+  /// class B address.
   ASIO_DECL bool is_class_b() const;
 
-  /// Determine whether the address is a class C address.
+  /// (Deprecated: Use network_v4 class.) Determine whether the address is a
+  /// class C address.
   ASIO_DECL bool is_class_c() const;
+#endif // !defined(ASIO_NO_DEPRECATED)
 
   /// Determine whether the address is a multicast address.
   ASIO_DECL bool is_multicast() const;
@@ -161,25 +177,25 @@ public:
   /// Compare addresses for ordering.
   friend bool operator<(const address_v4& a1, const address_v4& a2)
   {
-    return a1.to_ulong() < a2.to_ulong();
+    return a1.to_uint() < a2.to_uint();
   }
 
   /// Compare addresses for ordering.
   friend bool operator>(const address_v4& a1, const address_v4& a2)
   {
-    return a1.to_ulong() > a2.to_ulong();
+    return a1.to_uint() > a2.to_uint();
   }
 
   /// Compare addresses for ordering.
   friend bool operator<=(const address_v4& a1, const address_v4& a2)
   {
-    return a1.to_ulong() <= a2.to_ulong();
+    return a1.to_uint() <= a2.to_uint();
   }
 
   /// Compare addresses for ordering.
   friend bool operator>=(const address_v4& a1, const address_v4& a2)
   {
-    return a1.to_ulong() >= a2.to_ulong();
+    return a1.to_uint() >= a2.to_uint();
   }
 
   /// Obtain an address object that represents any address.
@@ -200,14 +216,17 @@ public:
     return address_v4(0xFFFFFFFF);
   }
 
-  /// Obtain an address object that represents the broadcast address that
-  /// corresponds to the specified address and netmask.
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use network_v4 class.) Obtain an address object that
+  /// represents the broadcast address that corresponds to the specified
+  /// address and netmask.
   ASIO_DECL static address_v4 broadcast(
       const address_v4& addr, const address_v4& mask);
 
-  /// Obtain the netmask that corresponds to the address, based on its address
-  /// class.
+  /// (Deprecated: Use network_v4 class.) Obtain the netmask that corresponds
+  /// to the address, based on its address class.
   ASIO_DECL static address_v4 netmask(const address_v4& addr);
+#endif // !defined(ASIO_NO_DEPRECATED)
 
 private:
   // The underlying IPv4 address.
@@ -223,11 +242,11 @@ inline address_v4 make_address_v4(const address_v4::bytes_type& bytes)
   return address_v4(bytes);
 }
 
-/// Create an IPv4 address from an unsigned long in host byte order.
+/// Create an IPv4 address from an unsigned integer in host byte order.
 /**
  * @relates address_v4
  */
-inline address_v4 make_address_v4(unsigned long addr)
+inline address_v4 make_address_v4(address_v4::uint_type addr)
 {
   return address_v4(addr);
 }
@@ -258,6 +277,25 @@ ASIO_DECL address_v4 make_address_v4(const std::string& str);
 ASIO_DECL address_v4 make_address_v4(
     const std::string& str, asio::error_code& ec);
 
+#if defined(ASIO_HAS_STD_STRING_VIEW) \
+  || defined(GENERATING_DOCUMENTATION)
+
+/// Create an IPv4 address from an IP address string in dotted decimal form.
+/**
+ * @relates address_v4
+ */
+ASIO_DECL address_v4 make_address_v4(string_view str);
+
+/// Create an IPv4 address from an IP address string in dotted decimal form.
+/**
+ * @relates address_v4
+ */
+ASIO_DECL address_v4 make_address_v4(
+    string_view str, asio::error_code& ec);
+
+#endif // defined(ASIO_HAS_STD_STRING_VIEW)
+       //  || defined(GENERATING_DOCUMENTATION)
+
 #if !defined(ASIO_NO_IOSTREAM)
 
 /// Output an address as a string.
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_v4_iterator.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_v4_iterator.hpp
new file mode 100644
index 0000000..ad0889c
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_v4_iterator.hpp
@@ -0,0 +1,162 @@
+//
+// ip/address_v4_iterator.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_IP_ADDRESS_V4_ITERATOR_HPP
+#define ASIO_IP_ADDRESS_V4_ITERATOR_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+#include "asio/ip/address_v4.hpp"
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+namespace ip {
+
+template <typename> class basic_address_iterator;
+
+/// An input iterator that can be used for traversing IPv4 addresses.
+/**
+ * In addition to satisfying the input iterator requirements, this iterator
+ * also supports decrement.
+ *
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Unsafe.
+ */
+template <> class basic_address_iterator<address_v4>
+{
+public:
+  /// The type of the elements pointed to by the iterator.
+  typedef address_v4 value_type;
+
+  /// Distance between two iterators.
+  typedef std::ptrdiff_t difference_type;
+
+  /// The type of a pointer to an element pointed to by the iterator.
+  typedef const address_v4* pointer;
+
+  /// The type of a reference to an element pointed to by the iterator.
+  typedef const address_v4& reference;
+
+  /// Denotes that the iterator satisfies the input iterator requirements.
+  typedef std::input_iterator_tag iterator_category;
+
+  /// Construct an iterator that points to the specified address.
+  basic_address_iterator(const address_v4& addr) ASIO_NOEXCEPT
+    : address_(addr)
+  {
+  }
+
+  /// Copy constructor.
+  basic_address_iterator(
+      const basic_address_iterator& other) ASIO_NOEXCEPT
+    : address_(other.address_)
+  {
+  }
+
+#if defined(ASIO_HAS_MOVE)
+  /// Move constructor.
+  basic_address_iterator(basic_address_iterator&& other) ASIO_NOEXCEPT
+    : address_(ASIO_MOVE_CAST(address_v4)(other.address_))
+  {
+  }
+#endif // defined(ASIO_HAS_MOVE)
+
+  /// Assignment operator.
+  basic_address_iterator& operator=(
+      const basic_address_iterator& other) ASIO_NOEXCEPT
+  {
+    address_ = other.address_;
+    return *this;
+  }
+
+#if defined(ASIO_HAS_MOVE)
+  /// Move assignment operator.
+  basic_address_iterator& operator=(
+      basic_address_iterator&& other) ASIO_NOEXCEPT
+  {
+    address_ = ASIO_MOVE_CAST(address_v4)(other.address_);
+    return *this;
+  }
+#endif // defined(ASIO_HAS_MOVE)
+
+  /// Dereference the iterator.
+  const address_v4& operator*() const ASIO_NOEXCEPT
+  {
+    return address_;
+  }
+
+  /// Dereference the iterator.
+  const address_v4* operator->() const ASIO_NOEXCEPT
+  {
+    return &address_;
+  }
+
+  /// Pre-increment operator.
+  basic_address_iterator& operator++() ASIO_NOEXCEPT
+  {
+    address_ = address_v4((address_.to_uint() + 1) & 0xFFFFFFFF);
+    return *this;
+  }
+
+  /// Post-increment operator.
+  basic_address_iterator operator++(int) ASIO_NOEXCEPT
+  {
+    basic_address_iterator tmp(*this);
+    ++*this;
+    return tmp;
+  }
+
+  /// Pre-decrement operator.
+  basic_address_iterator& operator--() ASIO_NOEXCEPT
+  {
+    address_ = address_v4((address_.to_uint() - 1) & 0xFFFFFFFF);
+    return *this;
+  }
+
+  /// Post-decrement operator.
+  basic_address_iterator operator--(int)
+  {
+    basic_address_iterator tmp(*this);
+    --*this;
+    return tmp;
+  }
+
+  /// Compare two addresses for equality.
+  friend bool operator==(const basic_address_iterator& a,
+      const basic_address_iterator& b)
+  {
+    return a.address_ == b.address_;
+  }
+
+  /// Compare two addresses for inequality.
+  friend bool operator!=(const basic_address_iterator& a,
+      const basic_address_iterator& b)
+  {
+    return a.address_ != b.address_;
+  }
+
+private:
+  address_v4 address_;
+};
+
+/// An input iterator that can be used for traversing IPv4 addresses.
+typedef basic_address_iterator<address_v4> address_v4_iterator;
+
+} // namespace ip
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // ASIO_IP_ADDRESS_V4_ITERATOR_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_v4_range.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_v4_range.hpp
new file mode 100644
index 0000000..06f3bd1
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_v4_range.hpp
@@ -0,0 +1,134 @@
+//
+// ip/address_v4_range.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_IP_ADDRESS_V4_RANGE_HPP
+#define ASIO_IP_ADDRESS_V4_RANGE_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+#include "asio/ip/address_v4_iterator.hpp"
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+namespace ip {
+
+template <typename> class basic_address_range;
+
+/// Represents a range of IPv4 addresses.
+/**
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Unsafe.
+ */
+template <> class basic_address_range<address_v4>
+{
+public:
+  /// The type of an iterator that points into the range.
+  typedef basic_address_iterator<address_v4> iterator;
+
+  /// Construct an empty range.
+  basic_address_range() ASIO_NOEXCEPT
+    : begin_(address_v4()),
+      end_(address_v4())
+  {
+  }
+
+  /// Construct an range that represents the given range of addresses.
+  explicit basic_address_range(const iterator& first,
+      const iterator& last) ASIO_NOEXCEPT
+    : begin_(first),
+      end_(last)
+  {
+  }
+
+  /// Copy constructor.
+  basic_address_range(const basic_address_range& other) ASIO_NOEXCEPT
+    : begin_(other.begin_),
+      end_(other.end_)
+  {
+  }
+
+#if defined(ASIO_HAS_MOVE)
+  /// Move constructor.
+  basic_address_range(basic_address_range&& other) ASIO_NOEXCEPT
+    : begin_(ASIO_MOVE_CAST(iterator)(other.begin_)),
+      end_(ASIO_MOVE_CAST(iterator)(other.end_))
+  {
+  }
+#endif // defined(ASIO_HAS_MOVE)
+
+  /// Assignment operator.
+  basic_address_range& operator=(
+      const basic_address_range& other) ASIO_NOEXCEPT
+  {
+    begin_ = other.begin_;
+    end_ = other.end_;
+    return *this;
+  }
+
+#if defined(ASIO_HAS_MOVE)
+  /// Move assignment operator.
+  basic_address_range& operator=(
+      basic_address_range&& other) ASIO_NOEXCEPT
+  {
+    begin_ = ASIO_MOVE_CAST(iterator)(other.begin_);
+    end_ = ASIO_MOVE_CAST(iterator)(other.end_);
+    return *this;
+  }
+#endif // defined(ASIO_HAS_MOVE)
+
+  /// Obtain an iterator that points to the start of the range.
+  iterator begin() const ASIO_NOEXCEPT
+  {
+    return begin_;
+  }
+
+  /// Obtain an iterator that points to the end of the range.
+  iterator end() const ASIO_NOEXCEPT
+  {
+    return end_;
+  }
+
+  /// Determine whether the range is empty.
+  bool empty() const ASIO_NOEXCEPT
+  {
+    return size() == 0;
+  }
+
+  /// Return the size of the range.
+  std::size_t size() const ASIO_NOEXCEPT
+  {
+    return end_->to_uint() - begin_->to_uint();
+  }
+
+  /// Find an address in the range.
+  iterator find(const address_v4& addr) const ASIO_NOEXCEPT
+  {
+    return addr >= *begin_ && addr < *end_ ? iterator(addr) : end_;
+  }
+
+private:
+  iterator begin_;
+  iterator end_;
+};
+
+/// Represents a range of IPv4 addresses.
+typedef basic_address_range<address_v4> address_v4_range;
+
+} // namespace ip
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // ASIO_IP_ADDRESS_V4_RANGE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_v6.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_v6.hpp
index 9930f1e..663601d 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_v6.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_v6.hpp
@@ -2,7 +2,7 @@
 // ip/address_v6.hpp
 // ~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -19,6 +19,7 @@
 #include <string>
 #include "asio/detail/array.hpp"
 #include "asio/detail/socket_types.hpp"
+#include "asio/detail/string_view.hpp"
 #include "asio/detail/winsock_init.hpp"
 #include "asio/error_code.hpp"
 #include "asio/ip/address_v4.hpp"
@@ -32,6 +33,8 @@
 namespace asio {
 namespace ip {
 
+template <typename> class basic_address_iterator;
+
 /// Implements IP version 6 style addresses.
 /**
  * The asio::ip::address_v6 class provides the ability to use and
@@ -102,10 +105,10 @@ public:
   /// Get the address as a string.
   ASIO_DECL std::string to_string() const;
 
-  /// Get the address as a string.
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use other overload.) Get the address as a string.
   ASIO_DECL std::string to_string(asio::error_code& ec) const;
 
-#if !defined(ASIO_NO_DEPRECATED)
   /// (Deprecated: Use make_address_v6().) Create an IPv6 address from an IP
   /// address string.
   static address_v6 from_string(const char* str);
@@ -218,7 +221,7 @@ public:
 #endif // !defined(ASIO_NO_DEPRECATED)
 
 private:
-  friend class address_iterator_v6;
+  friend class basic_address_iterator<address_v6>;
 
   // The underlying IPv6 address.
   asio::detail::in6_addr_type addr_;
@@ -263,6 +266,25 @@ ASIO_DECL address_v6 make_address_v6(const std::string& str);
 ASIO_DECL address_v6 make_address_v6(
     const std::string& str, asio::error_code& ec);
 
+#if defined(ASIO_HAS_STD_STRING_VIEW) \
+  || defined(GENERATING_DOCUMENTATION)
+
+/// Create an IPv6 address from an IP address string.
+/**
+ * @relates address_v6
+ */
+ASIO_DECL address_v6 make_address_v6(string_view str);
+
+/// Create an IPv6 address from an IP address string.
+/**
+ * @relates address_v6
+ */
+ASIO_DECL address_v6 make_address_v6(
+    string_view str, asio::error_code& ec);
+
+#endif // defined(ASIO_HAS_STD_STRING_VIEW)
+       //  || defined(GENERATING_DOCUMENTATION)
+
 /// Tag type used for distinguishing overloads that deal in IPv4-mapped IPv6
 /// addresses.
 enum v4_mapped_t { v4_mapped };
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_v6_iterator.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_v6_iterator.hpp
new file mode 100644
index 0000000..947af07
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_v6_iterator.hpp
@@ -0,0 +1,183 @@
+//
+// ip/address_v6_iterator.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//                         Oliver Kowalke (oliver dot kowalke at gmail dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_IP_ADDRESS_V6_ITERATOR_HPP
+#define ASIO_IP_ADDRESS_V6_ITERATOR_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+#include "asio/ip/address_v6.hpp"
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+namespace ip {
+
+template <typename> class basic_address_iterator;
+
+/// An input iterator that can be used for traversing IPv6 addresses.
+/**
+ * In addition to satisfying the input iterator requirements, this iterator
+ * also supports decrement.
+ *
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Unsafe.
+ */
+template <> class basic_address_iterator<address_v6>
+{
+public:
+  /// The type of the elements pointed to by the iterator.
+  typedef address_v6 value_type;
+
+  /// Distance between two iterators.
+  typedef std::ptrdiff_t difference_type;
+
+  /// The type of a pointer to an element pointed to by the iterator.
+  typedef const address_v6* pointer;
+
+  /// The type of a reference to an element pointed to by the iterator.
+  typedef const address_v6& reference;
+
+  /// Denotes that the iterator satisfies the input iterator requirements.
+  typedef std::input_iterator_tag iterator_category;
+
+  /// Construct an iterator that points to the specified address.
+  basic_address_iterator(const address_v6& addr) ASIO_NOEXCEPT
+    : address_(addr)
+  {
+  }
+
+  /// Copy constructor.
+  basic_address_iterator(
+      const basic_address_iterator& other) ASIO_NOEXCEPT
+    : address_(other.address_)
+  {
+  }
+
+#if defined(ASIO_HAS_MOVE)
+  /// Move constructor.
+  basic_address_iterator(basic_address_iterator&& other) ASIO_NOEXCEPT
+    : address_(ASIO_MOVE_CAST(address_v6)(other.address_))
+  {
+  }
+#endif // defined(ASIO_HAS_MOVE)
+
+  /// Assignment operator.
+  basic_address_iterator& operator=(
+      const basic_address_iterator& other) ASIO_NOEXCEPT
+  {
+    address_ = other.address_;
+    return *this;
+  }
+
+#if defined(ASIO_HAS_MOVE)
+  /// Move assignment operator.
+  basic_address_iterator& operator=(
+      basic_address_iterator&& other) ASIO_NOEXCEPT
+  {
+    address_ = ASIO_MOVE_CAST(address_v6)(other.address_);
+    return *this;
+  }
+#endif // defined(ASIO_HAS_MOVE)
+
+  /// Dereference the iterator.
+  const address_v6& operator*() const ASIO_NOEXCEPT
+  {
+    return address_;
+  }
+
+  /// Dereference the iterator.
+  const address_v6* operator->() const ASIO_NOEXCEPT
+  {
+    return &address_;
+  }
+
+  /// Pre-increment operator.
+  basic_address_iterator& operator++() ASIO_NOEXCEPT
+  {
+    for (int i = 15; i >= 0; --i)
+    {
+      if (address_.addr_.s6_addr[i] < 0xFF)
+      {
+        ++address_.addr_.s6_addr[i];
+        break;
+      }
+
+      address_.addr_.s6_addr[i] = 0;
+    }
+
+    return *this;
+  }
+
+  /// Post-increment operator.
+  basic_address_iterator operator++(int) ASIO_NOEXCEPT
+  {
+    basic_address_iterator tmp(*this);
+    ++*this;
+    return tmp;
+  }
+
+  /// Pre-decrement operator.
+  basic_address_iterator& operator--() ASIO_NOEXCEPT
+  {
+    for (int i = 15; i >= 0; --i)
+    {
+      if (address_.addr_.s6_addr[i] > 0)
+      {
+        --address_.addr_.s6_addr[i];
+        break;
+      }
+
+      address_.addr_.s6_addr[i] = 0xFF;
+    }
+
+    return *this;
+  }
+
+  /// Post-decrement operator.
+  basic_address_iterator operator--(int)
+  {
+    basic_address_iterator tmp(*this);
+    --*this;
+    return tmp;
+  }
+
+  /// Compare two addresses for equality.
+  friend bool operator==(const basic_address_iterator& a,
+      const basic_address_iterator& b)
+  {
+    return a.address_ == b.address_;
+  }
+
+  /// Compare two addresses for inequality.
+  friend bool operator!=(const basic_address_iterator& a,
+      const basic_address_iterator& b)
+  {
+    return a.address_ != b.address_;
+  }
+
+private:
+  address_v6 address_;
+};
+
+/// An input iterator that can be used for traversing IPv6 addresses.
+typedef basic_address_iterator<address_v6> address_v6_iterator;
+
+} // namespace ip
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // ASIO_IP_ADDRESS_V6_ITERATOR_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_v6_range.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_v6_range.hpp
new file mode 100644
index 0000000..4dc7a30
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/address_v6_range.hpp
@@ -0,0 +1,129 @@
+//
+// ip/address_v6_range.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//                         Oliver Kowalke (oliver dot kowalke at gmail dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_IP_ADDRESS_V6_RANGE_HPP
+#define ASIO_IP_ADDRESS_V6_RANGE_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+#include "asio/ip/address_v6_iterator.hpp"
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+namespace ip {
+
+template <typename> class basic_address_range;
+
+/// Represents a range of IPv6 addresses.
+/**
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Unsafe.
+ */
+template <> class basic_address_range<address_v6>
+{
+public:
+  /// The type of an iterator that points into the range.
+  typedef basic_address_iterator<address_v6> iterator;
+
+  /// Construct an empty range.
+  basic_address_range() ASIO_NOEXCEPT
+    : begin_(address_v6()),
+      end_(address_v6())
+  {
+  }
+
+  /// Construct an range that represents the given range of addresses.
+  explicit basic_address_range(const iterator& first,
+      const iterator& last) ASIO_NOEXCEPT
+    : begin_(first),
+      end_(last)
+  {
+  }
+
+  /// Copy constructor.
+  basic_address_range(const basic_address_range& other) ASIO_NOEXCEPT
+    : begin_(other.begin_),
+      end_(other.end_)
+  {
+  }
+
+#if defined(ASIO_HAS_MOVE)
+  /// Move constructor.
+  basic_address_range(basic_address_range&& other) ASIO_NOEXCEPT
+    : begin_(ASIO_MOVE_CAST(iterator)(other.begin_)),
+      end_(ASIO_MOVE_CAST(iterator)(other.end_))
+  {
+  }
+#endif // defined(ASIO_HAS_MOVE)
+
+  /// Assignment operator.
+  basic_address_range& operator=(
+      const basic_address_range& other) ASIO_NOEXCEPT
+  {
+    begin_ = other.begin_;
+    end_ = other.end_;
+    return *this;
+  }
+
+#if defined(ASIO_HAS_MOVE)
+  /// Move assignment operator.
+  basic_address_range& operator=(
+      basic_address_range&& other) ASIO_NOEXCEPT
+  {
+    begin_ = ASIO_MOVE_CAST(iterator)(other.begin_);
+    end_ = ASIO_MOVE_CAST(iterator)(other.end_);
+    return *this;
+  }
+#endif // defined(ASIO_HAS_MOVE)
+
+  /// Obtain an iterator that points to the start of the range.
+  iterator begin() const ASIO_NOEXCEPT
+  {
+    return begin_;
+  }
+
+  /// Obtain an iterator that points to the end of the range.
+  iterator end() const ASIO_NOEXCEPT
+  {
+    return end_;
+  }
+
+  /// Determine whether the range is empty.
+  bool empty() const ASIO_NOEXCEPT
+  {
+    return begin_ == end_;
+  }
+
+  /// Find an address in the range.
+  iterator find(const address_v6& addr) const ASIO_NOEXCEPT
+  {
+    return addr >= *begin_ && addr < *end_ ? iterator(addr) : end_;
+  }
+
+private:
+  iterator begin_;
+  iterator end_;
+};
+
+/// Represents a range of IPv6 addresses.
+typedef basic_address_range<address_v6> address_v6_range;
+
+} // namespace ip
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // ASIO_IP_ADDRESS_V6_RANGE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/bad_address_cast.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/bad_address_cast.hpp
index f32a143..6c47914 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/bad_address_cast.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/bad_address_cast.hpp
@@ -2,7 +2,7 @@
 // ip/bad_address_cast.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_endpoint.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_endpoint.hpp
index f4c9bdc..d48f644 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_endpoint.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_endpoint.hpp
@@ -2,7 +2,7 @@
 // ip/basic_endpoint.hpp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -97,13 +97,13 @@ public:
   {
   }
 
-#if defined(ASIO_HAS_MOVE)
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
   /// Move constructor.
   basic_endpoint(basic_endpoint&& other)
     : impl_(other.impl_)
   {
   }
-#endif // defined(ASIO_HAS_MOVE)
+#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
 
   /// Assign from another endpoint.
   basic_endpoint& operator=(const basic_endpoint& other)
@@ -112,21 +112,21 @@ public:
     return *this;
   }
 
-#if defined(ASIO_HAS_MOVE)
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
   /// Move-assign from another endpoint.
   basic_endpoint& operator=(basic_endpoint&& other)
   {
     impl_ = other.impl_;
     return *this;
   }
-#endif // defined(ASIO_HAS_MOVE)
+#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
 
   /// The protocol associated with the endpoint.
   protocol_type protocol() const
   {
-    if (impl_.is_v6())
-      return InternetProtocol::v6();
-    return InternetProtocol::v4();
+    if (impl_.is_v4())
+      return InternetProtocol::v4();
+    return InternetProtocol::v6();
   }
 
   /// Get the underlying endpoint in the native type.
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_resolver.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_resolver.hpp
index 3fd1a39..3aa61fb 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_resolver.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_resolver.hpp
@@ -2,7 +2,7 @@
 // ip/basic_resolver.hpp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,13 +16,36 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
+#include <string>
+#include "asio/async_result.hpp"
 #include "asio/basic_io_object.hpp"
 #include "asio/detail/handler_type_requirements.hpp"
+#include "asio/detail/string_view.hpp"
 #include "asio/detail/throw_error.hpp"
 #include "asio/error.hpp"
+#include "asio/io_context.hpp"
 #include "asio/ip/basic_resolver_iterator.hpp"
 #include "asio/ip/basic_resolver_query.hpp"
-#include "asio/ip/resolver_service.hpp"
+#include "asio/ip/basic_resolver_results.hpp"
+#include "asio/ip/resolver_base.hpp"
+
+#if defined(ASIO_HAS_MOVE)
+# include <utility>
+#endif // defined(ASIO_HAS_MOVE)
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+# include "asio/ip/resolver_service.hpp"
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+# if defined(ASIO_WINDOWS_RUNTIME)
+#  include "asio/detail/winrt_resolver_service.hpp"
+#  define ASIO_SVC_T \
+    asio::detail::winrt_resolver_service<InternetProtocol>
+# else
+#  include "asio/detail/resolver_service.hpp"
+#  define ASIO_SVC_T \
+    asio::detail::resolver_service<InternetProtocol>
+# endif
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
 
 #include "asio/detail/push_options.hpp"
 
@@ -38,35 +61,130 @@ namespace ip {
  * @e Distinct @e objects: Safe.@n
  * @e Shared @e objects: Unsafe.
  */
-template <typename InternetProtocol,
-    typename ResolverService = resolver_service<InternetProtocol> >
+template <typename InternetProtocol
+    ASIO_SVC_TPARAM_DEF1(= resolver_service<InternetProtocol>)>
 class basic_resolver
-  : public basic_io_object<ResolverService>
+  : ASIO_SVC_ACCESS basic_io_object<ASIO_SVC_T>,
+    public resolver_base
 {
 public:
+  /// The type of the executor associated with the object.
+  typedef io_context::executor_type executor_type;
+
   /// The protocol type.
   typedef InternetProtocol protocol_type;
 
   /// The endpoint type.
   typedef typename InternetProtocol::endpoint endpoint_type;
 
-  /// The query type.
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated.) The query type.
   typedef basic_resolver_query<InternetProtocol> query;
 
-  /// The iterator type.
+  /// (Deprecated.) The iterator type.
   typedef basic_resolver_iterator<InternetProtocol> iterator;
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// The results type.
+  typedef basic_resolver_results<InternetProtocol> results_type;
 
   /// Constructor.
   /**
    * This constructor creates a basic_resolver.
    *
-   * @param io_service The io_service object that the resolver will use to
-   * dispatch handlers for any asynchronous operations performed on the timer.
+   * @param io_context The io_context object that the resolver will use to
+   * dispatch handlers for any asynchronous operations performed on the
+   * resolver.
+   */
+  explicit basic_resolver(asio::io_context& io_context)
+    : basic_io_object<ASIO_SVC_T>(io_context)
+  {
+  }
+
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+  /// Move-construct a basic_resolver from another.
+  /**
+   * This constructor moves a resolver from one object to another.
+   *
+   * @param other The other basic_resolver object from which the move will
+   * occur.
+   *
+   * @note Following the move, the moved-from object is in the same state as if
+   * constructed using the @c basic_resolver(io_context&) constructor.
+   */
+  basic_resolver(basic_resolver&& other)
+    : basic_io_object<ASIO_SVC_T>(std::move(other))
+  {
+  }
+
+  /// Move-assign a basic_resolver from another.
+  /**
+   * This assignment operator moves a resolver from one object to another.
+   * Cancels any outstanding asynchronous operations associated with the target
+   * object.
+   *
+   * @param other The other basic_resolver object from which the move will
+   * occur.
+   *
+   * @note Following the move, the moved-from object is in the same state as if
+   * constructed using the @c basic_resolver(io_context&) constructor.
    */
-  explicit basic_resolver(asio::io_service& io_service)
-    : basic_io_object<ResolverService>(io_service)
+  basic_resolver& operator=(basic_resolver&& other)
   {
+    basic_io_object<ASIO_SVC_T>::operator=(std::move(other));
+    return *this;
   }
+#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+
+  /// Destroys the resolver.
+  /**
+   * This function destroys the resolver, cancelling any outstanding
+   * asynchronous wait operations associated with the resolver as if by calling
+   * @c cancel.
+   */
+  ~basic_resolver()
+  {
+  }
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+  // These functions are provided by basic_io_object<>.
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_context()
+  {
+    return basic_io_object<ASIO_SVC_T>::get_io_context();
+  }
+
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_service()
+  {
+    return basic_io_object<ASIO_SVC_T>::get_io_service();
+  }
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// Get the executor associated with the object.
+  executor_type get_executor() ASIO_NOEXCEPT
+  {
+    return basic_io_object<ASIO_SVC_T>::get_executor();
+  }
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
 
   /// Cancel any asynchronous operations that are waiting on the resolver.
   /**
@@ -79,53 +197,411 @@ public:
     return this->get_service().cancel(this->get_implementation());
   }
 
-  /// Perform forward resolution of a query to a list of entries.
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated.) Perform forward resolution of a query to a list of entries.
   /**
    * This function is used to resolve a query into a list of endpoint entries.
    *
    * @param q A query object that determines what endpoints will be returned.
    *
-   * @returns A forward-only iterator that can be used to traverse the list
-   * of endpoint entries.
+   * @returns A range object representing the list of endpoint entries. A
+   * successful call to this function is guaranteed to return a non-empty
+   * range.
    *
    * @throws asio::system_error Thrown on failure.
+   */
+  results_type resolve(const query& q)
+  {
+    asio::error_code ec;
+    results_type r = this->get_service().resolve(
+        this->get_implementation(), q, ec);
+    asio::detail::throw_error(ec, "resolve");
+    return r;
+  }
+
+  /// (Deprecated.) Perform forward resolution of a query to a list of entries.
+  /**
+   * This function is used to resolve a query into a list of endpoint entries.
+   *
+   * @param q A query object that determines what endpoints will be returned.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @returns A range object representing the list of endpoint entries. An
+   * empty range is returned if an error occurs. A successful call to this
+   * function is guaranteed to return a non-empty range.
+   */
+  results_type resolve(const query& q, asio::error_code& ec)
+  {
+    return this->get_service().resolve(this->get_implementation(), q, ec);
+  }
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// Perform forward resolution of a query to a list of entries.
+  /**
+   * This function is used to resolve host and service names into a list of
+   * endpoint entries.
+   *
+   * @param host A string identifying a location. May be a descriptive name or
+   * a numeric address string. If an empty string and the passive flag has been
+   * specified, the resolved endpoints are suitable for local service binding.
+   * If an empty string and passive is not specified, the resolved endpoints
+   * will use the loopback address.
+   *
+   * @param service A string identifying the requested service. This may be a
+   * descriptive name or a numeric string corresponding to a port number. May
+   * be an empty string, in which case all resolved endpoints will have a port
+   * number of 0.
+   *
+   * @returns A range object representing the list of endpoint entries. A
+   * successful call to this function is guaranteed to return a non-empty
+   * range.
    *
-   * @note A default constructed iterator represents the end of the list.
+   * @throws asio::system_error Thrown on failure.
+   *
+   * @note On POSIX systems, host names may be locally defined in the file
+   * <tt>/etc/hosts</tt>. On Windows, host names may be defined in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\hosts</tt>. Remote host name
+   * resolution is performed using DNS. Operating systems may use additional
+   * locations when resolving host names (such as NETBIOS names on Windows).
    *
-   * A successful call to this function is guaranteed to return at least one
-   * entry.
+   * On POSIX systems, service names are typically defined in the file
+   * <tt>/etc/services</tt>. On Windows, service names may be found in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\services</tt>. Operating systems
+   * may use additional locations when resolving service names.
    */
-  iterator resolve(const query& q)
+  results_type resolve(ASIO_STRING_VIEW_PARAM host,
+      ASIO_STRING_VIEW_PARAM service)
+  {
+    return resolve(host, service, resolver_base::flags());
+  }
+
+  /// Perform forward resolution of a query to a list of entries.
+  /**
+   * This function is used to resolve host and service names into a list of
+   * endpoint entries.
+   *
+   * @param host A string identifying a location. May be a descriptive name or
+   * a numeric address string. If an empty string and the passive flag has been
+   * specified, the resolved endpoints are suitable for local service binding.
+   * If an empty string and passive is not specified, the resolved endpoints
+   * will use the loopback address.
+   *
+   * @param service A string identifying the requested service. This may be a
+   * descriptive name or a numeric string corresponding to a port number. May
+   * be an empty string, in which case all resolved endpoints will have a port
+   * number of 0.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @returns A range object representing the list of endpoint entries. An
+   * empty range is returned if an error occurs. A successful call to this
+   * function is guaranteed to return a non-empty range.
+   *
+   * @note On POSIX systems, host names may be locally defined in the file
+   * <tt>/etc/hosts</tt>. On Windows, host names may be defined in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\hosts</tt>. Remote host name
+   * resolution is performed using DNS. Operating systems may use additional
+   * locations when resolving host names (such as NETBIOS names on Windows).
+   *
+   * On POSIX systems, service names are typically defined in the file
+   * <tt>/etc/services</tt>. On Windows, service names may be found in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\services</tt>. Operating systems
+   * may use additional locations when resolving service names.
+   */
+  results_type resolve(ASIO_STRING_VIEW_PARAM host,
+      ASIO_STRING_VIEW_PARAM service, asio::error_code& ec)
+  {
+    return resolve(host, service, resolver_base::flags(), ec);
+  }
+
+  /// Perform forward resolution of a query to a list of entries.
+  /**
+   * This function is used to resolve host and service names into a list of
+   * endpoint entries.
+   *
+   * @param host A string identifying a location. May be a descriptive name or
+   * a numeric address string. If an empty string and the passive flag has been
+   * specified, the resolved endpoints are suitable for local service binding.
+   * If an empty string and passive is not specified, the resolved endpoints
+   * will use the loopback address.
+   *
+   * @param service A string identifying the requested service. This may be a
+   * descriptive name or a numeric string corresponding to a port number. May
+   * be an empty string, in which case all resolved endpoints will have a port
+   * number of 0.
+   *
+   * @param resolve_flags A set of flags that determine how name resolution
+   * should be performed. The default flags are suitable for communication with
+   * remote hosts.
+   *
+   * @returns A range object representing the list of endpoint entries. A
+   * successful call to this function is guaranteed to return a non-empty
+   * range.
+   *
+   * @throws asio::system_error Thrown on failure.
+   *
+   * @note On POSIX systems, host names may be locally defined in the file
+   * <tt>/etc/hosts</tt>. On Windows, host names may be defined in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\hosts</tt>. Remote host name
+   * resolution is performed using DNS. Operating systems may use additional
+   * locations when resolving host names (such as NETBIOS names on Windows).
+   *
+   * On POSIX systems, service names are typically defined in the file
+   * <tt>/etc/services</tt>. On Windows, service names may be found in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\services</tt>. Operating systems
+   * may use additional locations when resolving service names.
+   */
+  results_type resolve(ASIO_STRING_VIEW_PARAM host,
+      ASIO_STRING_VIEW_PARAM service, resolver_base::flags resolve_flags)
   {
     asio::error_code ec;
-    iterator i = this->get_service().resolve(this->get_implementation(), q, ec);
+    basic_resolver_query<protocol_type> q(static_cast<std::string>(host),
+        static_cast<std::string>(service), resolve_flags);
+    results_type r = this->get_service().resolve(
+        this->get_implementation(), q, ec);
     asio::detail::throw_error(ec, "resolve");
-    return i;
+    return r;
   }
 
   /// Perform forward resolution of a query to a list of entries.
   /**
-   * This function is used to resolve a query into a list of endpoint entries.
+   * This function is used to resolve host and service names into a list of
+   * endpoint entries.
    *
-   * @param q A query object that determines what endpoints will be returned.
+   * @param host A string identifying a location. May be a descriptive name or
+   * a numeric address string. If an empty string and the passive flag has been
+   * specified, the resolved endpoints are suitable for local service binding.
+   * If an empty string and passive is not specified, the resolved endpoints
+   * will use the loopback address.
+   *
+   * @param service A string identifying the requested service. This may be a
+   * descriptive name or a numeric string corresponding to a port number. May
+   * be an empty string, in which case all resolved endpoints will have a port
+   * number of 0.
+   *
+   * @param resolve_flags A set of flags that determine how name resolution
+   * should be performed. The default flags are suitable for communication with
+   * remote hosts.
    *
    * @param ec Set to indicate what error occurred, if any.
    *
-   * @returns A forward-only iterator that can be used to traverse the list
-   * of endpoint entries. Returns a default constructed iterator if an error
-   * occurs.
+   * @returns A range object representing the list of endpoint entries. An
+   * empty range is returned if an error occurs. A successful call to this
+   * function is guaranteed to return a non-empty range.
    *
-   * @note A default constructed iterator represents the end of the list.
+   * @note On POSIX systems, host names may be locally defined in the file
+   * <tt>/etc/hosts</tt>. On Windows, host names may be defined in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\hosts</tt>. Remote host name
+   * resolution is performed using DNS. Operating systems may use additional
+   * locations when resolving host names (such as NETBIOS names on Windows).
    *
-   * A successful call to this function is guaranteed to return at least one
-   * entry.
+   * On POSIX systems, service names are typically defined in the file
+   * <tt>/etc/services</tt>. On Windows, service names may be found in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\services</tt>. Operating systems
+   * may use additional locations when resolving service names.
    */
-  iterator resolve(const query& q, asio::error_code& ec)
+  results_type resolve(ASIO_STRING_VIEW_PARAM host,
+      ASIO_STRING_VIEW_PARAM service, resolver_base::flags resolve_flags,
+      asio::error_code& ec)
   {
+    basic_resolver_query<protocol_type> q(static_cast<std::string>(host),
+        static_cast<std::string>(service), resolve_flags);
     return this->get_service().resolve(this->get_implementation(), q, ec);
   }
 
-  /// Asynchronously perform forward resolution of a query to a list of entries.
+  /// Perform forward resolution of a query to a list of entries.
+  /**
+   * This function is used to resolve host and service names into a list of
+   * endpoint entries.
+   *
+   * @param protocol A protocol object, normally representing either the IPv4 or
+   * IPv6 version of an internet protocol.
+   *
+   * @param host A string identifying a location. May be a descriptive name or
+   * a numeric address string. If an empty string and the passive flag has been
+   * specified, the resolved endpoints are suitable for local service binding.
+   * If an empty string and passive is not specified, the resolved endpoints
+   * will use the loopback address.
+   *
+   * @param service A string identifying the requested service. This may be a
+   * descriptive name or a numeric string corresponding to a port number. May
+   * be an empty string, in which case all resolved endpoints will have a port
+   * number of 0.
+   *
+   * @returns A range object representing the list of endpoint entries. A
+   * successful call to this function is guaranteed to return a non-empty
+   * range.
+   *
+   * @throws asio::system_error Thrown on failure.
+   *
+   * @note On POSIX systems, host names may be locally defined in the file
+   * <tt>/etc/hosts</tt>. On Windows, host names may be defined in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\hosts</tt>. Remote host name
+   * resolution is performed using DNS. Operating systems may use additional
+   * locations when resolving host names (such as NETBIOS names on Windows).
+   *
+   * On POSIX systems, service names are typically defined in the file
+   * <tt>/etc/services</tt>. On Windows, service names may be found in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\services</tt>. Operating systems
+   * may use additional locations when resolving service names.
+   */
+  results_type resolve(const protocol_type& protocol,
+      ASIO_STRING_VIEW_PARAM host, ASIO_STRING_VIEW_PARAM service)
+  {
+    return resolve(protocol, host, service, resolver_base::flags());
+  }
+
+  /// Perform forward resolution of a query to a list of entries.
+  /**
+   * This function is used to resolve host and service names into a list of
+   * endpoint entries.
+   *
+   * @param protocol A protocol object, normally representing either the IPv4 or
+   * IPv6 version of an internet protocol.
+   *
+   * @param host A string identifying a location. May be a descriptive name or
+   * a numeric address string. If an empty string and the passive flag has been
+   * specified, the resolved endpoints are suitable for local service binding.
+   * If an empty string and passive is not specified, the resolved endpoints
+   * will use the loopback address.
+   *
+   * @param service A string identifying the requested service. This may be a
+   * descriptive name or a numeric string corresponding to a port number. May
+   * be an empty string, in which case all resolved endpoints will have a port
+   * number of 0.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @returns A range object representing the list of endpoint entries. An
+   * empty range is returned if an error occurs. A successful call to this
+   * function is guaranteed to return a non-empty range.
+   *
+   * @note On POSIX systems, host names may be locally defined in the file
+   * <tt>/etc/hosts</tt>. On Windows, host names may be defined in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\hosts</tt>. Remote host name
+   * resolution is performed using DNS. Operating systems may use additional
+   * locations when resolving host names (such as NETBIOS names on Windows).
+   *
+   * On POSIX systems, service names are typically defined in the file
+   * <tt>/etc/services</tt>. On Windows, service names may be found in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\services</tt>. Operating systems
+   * may use additional locations when resolving service names.
+   */
+  results_type resolve(const protocol_type& protocol,
+      ASIO_STRING_VIEW_PARAM host, ASIO_STRING_VIEW_PARAM service,
+      asio::error_code& ec)
+  {
+    return resolve(protocol, host, service, resolver_base::flags(), ec);
+  }
+
+  /// Perform forward resolution of a query to a list of entries.
+  /**
+   * This function is used to resolve host and service names into a list of
+   * endpoint entries.
+   *
+   * @param protocol A protocol object, normally representing either the IPv4 or
+   * IPv6 version of an internet protocol.
+   *
+   * @param host A string identifying a location. May be a descriptive name or
+   * a numeric address string. If an empty string and the passive flag has been
+   * specified, the resolved endpoints are suitable for local service binding.
+   * If an empty string and passive is not specified, the resolved endpoints
+   * will use the loopback address.
+   *
+   * @param service A string identifying the requested service. This may be a
+   * descriptive name or a numeric string corresponding to a port number. May
+   * be an empty string, in which case all resolved endpoints will have a port
+   * number of 0.
+   *
+   * @param resolve_flags A set of flags that determine how name resolution
+   * should be performed. The default flags are suitable for communication with
+   * remote hosts.
+   *
+   * @returns A range object representing the list of endpoint entries. A
+   * successful call to this function is guaranteed to return a non-empty
+   * range.
+   *
+   * @throws asio::system_error Thrown on failure.
+   *
+   * @note On POSIX systems, host names may be locally defined in the file
+   * <tt>/etc/hosts</tt>. On Windows, host names may be defined in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\hosts</tt>. Remote host name
+   * resolution is performed using DNS. Operating systems may use additional
+   * locations when resolving host names (such as NETBIOS names on Windows).
+   *
+   * On POSIX systems, service names are typically defined in the file
+   * <tt>/etc/services</tt>. On Windows, service names may be found in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\services</tt>. Operating systems
+   * may use additional locations when resolving service names.
+   */
+  results_type resolve(const protocol_type& protocol,
+      ASIO_STRING_VIEW_PARAM host, ASIO_STRING_VIEW_PARAM service,
+      resolver_base::flags resolve_flags)
+  {
+    asio::error_code ec;
+    basic_resolver_query<protocol_type> q(
+        protocol, static_cast<std::string>(host),
+        static_cast<std::string>(service), resolve_flags);
+    results_type r = this->get_service().resolve(
+        this->get_implementation(), q, ec);
+    asio::detail::throw_error(ec, "resolve");
+    return r;
+  }
+
+  /// Perform forward resolution of a query to a list of entries.
+  /**
+   * This function is used to resolve host and service names into a list of
+   * endpoint entries.
+   *
+   * @param protocol A protocol object, normally representing either the IPv4 or
+   * IPv6 version of an internet protocol.
+   *
+   * @param host A string identifying a location. May be a descriptive name or
+   * a numeric address string. If an empty string and the passive flag has been
+   * specified, the resolved endpoints are suitable for local service binding.
+   * If an empty string and passive is not specified, the resolved endpoints
+   * will use the loopback address.
+   *
+   * @param service A string identifying the requested service. This may be a
+   * descriptive name or a numeric string corresponding to a port number. May
+   * be an empty string, in which case all resolved endpoints will have a port
+   * number of 0.
+   *
+   * @param resolve_flags A set of flags that determine how name resolution
+   * should be performed. The default flags are suitable for communication with
+   * remote hosts.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @returns A range object representing the list of endpoint entries. An
+   * empty range is returned if an error occurs. A successful call to this
+   * function is guaranteed to return a non-empty range.
+   *
+   * @note On POSIX systems, host names may be locally defined in the file
+   * <tt>/etc/hosts</tt>. On Windows, host names may be defined in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\hosts</tt>. Remote host name
+   * resolution is performed using DNS. Operating systems may use additional
+   * locations when resolving host names (such as NETBIOS names on Windows).
+   *
+   * On POSIX systems, service names are typically defined in the file
+   * <tt>/etc/services</tt>. On Windows, service names may be found in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\services</tt>. Operating systems
+   * may use additional locations when resolving service names.
+   */
+  results_type resolve(const protocol_type& protocol,
+      ASIO_STRING_VIEW_PARAM host, ASIO_STRING_VIEW_PARAM service,
+      resolver_base::flags resolve_flags, asio::error_code& ec)
+  {
+    basic_resolver_query<protocol_type> q(
+        protocol, static_cast<std::string>(host),
+        static_cast<std::string>(service), resolve_flags);
+    return this->get_service().resolve(this->get_implementation(), q, ec);
+  }
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated.) Asynchronously perform forward resolution of a query to a
+  /// list of entries.
   /**
    * This function is used to asynchronously resolve a query into a list of
    * endpoint entries.
@@ -137,33 +613,305 @@ public:
    * signature of the handler must be:
    * @code void handler(
    *   const asio::error_code& error, // Result of operation.
-   *   resolver::iterator iterator             // Forward-only iterator that can
-   *                                           // be used to traverse the list
-   *                                           // of endpoint entries.
+   *   resolver::results_type results // Resolved endpoints as a range.
    * ); @endcode
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
-   * @note A default constructed iterator represents the end of the list.
-   *
-   * A successful resolve operation is guaranteed to pass at least one entry to
+   * A successful resolve operation is guaranteed to pass a non-empty range to
    * the handler.
    */
   template <typename ResolveHandler>
   ASIO_INITFN_RESULT_TYPE(ResolveHandler,
-      void (asio::error_code, iterator))
+      void (asio::error_code, results_type))
   async_resolve(const query& q,
       ASIO_MOVE_ARG(ResolveHandler) handler)
   {
     // If you get an error on the following line it means that your handler does
     // not meet the documented type requirements for a ResolveHandler.
     ASIO_RESOLVE_HANDLER_CHECK(
-        ResolveHandler, handler, iterator) type_check;
+        ResolveHandler, handler, results_type) type_check;
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+    return this->get_service().async_resolve(this->get_implementation(), q,
+        ASIO_MOVE_CAST(ResolveHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    asio::async_completion<ResolveHandler,
+      void (asio::error_code, results_type)> init(handler);
+
+    this->get_service().async_resolve(
+        this->get_implementation(), q, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+  }
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// Asynchronously perform forward resolution of a query to a list of entries.
+  /**
+   * This function is used to resolve host and service names into a list of
+   * endpoint entries.
+   *
+   * @param host A string identifying a location. May be a descriptive name or
+   * a numeric address string. If an empty string and the passive flag has been
+   * specified, the resolved endpoints are suitable for local service binding.
+   * If an empty string and passive is not specified, the resolved endpoints
+   * will use the loopback address.
+   *
+   * @param service A string identifying the requested service. This may be a
+   * descriptive name or a numeric string corresponding to a port number. May
+   * be an empty string, in which case all resolved endpoints will have a port
+   * number of 0.
+   *
+   * @param handler The handler to be called when the resolve operation
+   * completes. Copies will be made of the handler as required. The function
+   * signature of the handler must be:
+   * @code void handler(
+   *   const asio::error_code& error, // Result of operation.
+   *   resolver::results_type results // Resolved endpoints as a range.
+   * ); @endcode
+   * Regardless of whether the asynchronous operation completes immediately or
+   * not, the handler will not be invoked from within this function. Invocation
+   * of the handler will be performed in a manner equivalent to using
+   * asio::io_context::post().
+   *
+   * A successful resolve operation is guaranteed to pass a non-empty range to
+   * the handler.
+   *
+   * @note On POSIX systems, host names may be locally defined in the file
+   * <tt>/etc/hosts</tt>. On Windows, host names may be defined in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\hosts</tt>. Remote host name
+   * resolution is performed using DNS. Operating systems may use additional
+   * locations when resolving host names (such as NETBIOS names on Windows).
+   *
+   * On POSIX systems, service names are typically defined in the file
+   * <tt>/etc/services</tt>. On Windows, service names may be found in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\services</tt>. Operating systems
+   * may use additional locations when resolving service names.
+   */
+  template <typename ResolveHandler>
+  ASIO_INITFN_RESULT_TYPE(ResolveHandler,
+      void (asio::error_code, results_type))
+  async_resolve(ASIO_STRING_VIEW_PARAM host,
+      ASIO_STRING_VIEW_PARAM service,
+      ASIO_MOVE_ARG(ResolveHandler) handler)
+  {
+    return async_resolve(host, service, resolver_base::flags(),
+        ASIO_MOVE_CAST(ResolveHandler)(handler));
+  }
+
+  /// Asynchronously perform forward resolution of a query to a list of entries.
+  /**
+   * This function is used to resolve host and service names into a list of
+   * endpoint entries.
+   *
+   * @param host A string identifying a location. May be a descriptive name or
+   * a numeric address string. If an empty string and the passive flag has been
+   * specified, the resolved endpoints are suitable for local service binding.
+   * If an empty string and passive is not specified, the resolved endpoints
+   * will use the loopback address.
+   *
+   * @param service A string identifying the requested service. This may be a
+   * descriptive name or a numeric string corresponding to a port number. May
+   * be an empty string, in which case all resolved endpoints will have a port
+   * number of 0.
+   *
+   * @param resolve_flags A set of flags that determine how name resolution
+   * should be performed. The default flags are suitable for communication with
+   * remote hosts.
+   *
+   * @param handler The handler to be called when the resolve operation
+   * completes. Copies will be made of the handler as required. The function
+   * signature of the handler must be:
+   * @code void handler(
+   *   const asio::error_code& error, // Result of operation.
+   *   resolver::results_type results // Resolved endpoints as a range.
+   * ); @endcode
+   * Regardless of whether the asynchronous operation completes immediately or
+   * not, the handler will not be invoked from within this function. Invocation
+   * of the handler will be performed in a manner equivalent to using
+   * asio::io_context::post().
+   *
+   * A successful resolve operation is guaranteed to pass a non-empty range to
+   * the handler.
+   *
+   * @note On POSIX systems, host names may be locally defined in the file
+   * <tt>/etc/hosts</tt>. On Windows, host names may be defined in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\hosts</tt>. Remote host name
+   * resolution is performed using DNS. Operating systems may use additional
+   * locations when resolving host names (such as NETBIOS names on Windows).
+   *
+   * On POSIX systems, service names are typically defined in the file
+   * <tt>/etc/services</tt>. On Windows, service names may be found in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\services</tt>. Operating systems
+   * may use additional locations when resolving service names.
+   */
+  template <typename ResolveHandler>
+  ASIO_INITFN_RESULT_TYPE(ResolveHandler,
+      void (asio::error_code, results_type))
+  async_resolve(ASIO_STRING_VIEW_PARAM host,
+      ASIO_STRING_VIEW_PARAM service,
+      resolver_base::flags resolve_flags,
+      ASIO_MOVE_ARG(ResolveHandler) handler)
+  {
+    // If you get an error on the following line it means that your handler does
+    // not meet the documented type requirements for a ResolveHandler.
+    ASIO_RESOLVE_HANDLER_CHECK(
+        ResolveHandler, handler, results_type) type_check;
 
+    basic_resolver_query<protocol_type> q(static_cast<std::string>(host),
+        static_cast<std::string>(service), resolve_flags);
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+    return this->get_service().async_resolve(this->get_implementation(), q,
+        ASIO_MOVE_CAST(ResolveHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    asio::async_completion<ResolveHandler,
+      void (asio::error_code, results_type)> init(handler);
+
+    this->get_service().async_resolve(
+        this->get_implementation(), q, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+  }
+
+  /// Asynchronously perform forward resolution of a query to a list of entries.
+  /**
+   * This function is used to resolve host and service names into a list of
+   * endpoint entries.
+   *
+   * @param protocol A protocol object, normally representing either the IPv4 or
+   * IPv6 version of an internet protocol.
+   *
+   * @param host A string identifying a location. May be a descriptive name or
+   * a numeric address string. If an empty string and the passive flag has been
+   * specified, the resolved endpoints are suitable for local service binding.
+   * If an empty string and passive is not specified, the resolved endpoints
+   * will use the loopback address.
+   *
+   * @param service A string identifying the requested service. This may be a
+   * descriptive name or a numeric string corresponding to a port number. May
+   * be an empty string, in which case all resolved endpoints will have a port
+   * number of 0.
+   *
+   * @param handler The handler to be called when the resolve operation
+   * completes. Copies will be made of the handler as required. The function
+   * signature of the handler must be:
+   * @code void handler(
+   *   const asio::error_code& error, // Result of operation.
+   *   resolver::results_type results // Resolved endpoints as a range.
+   * ); @endcode
+   * Regardless of whether the asynchronous operation completes immediately or
+   * not, the handler will not be invoked from within this function. Invocation
+   * of the handler will be performed in a manner equivalent to using
+   * asio::io_context::post().
+   *
+   * A successful resolve operation is guaranteed to pass a non-empty range to
+   * the handler.
+   *
+   * @note On POSIX systems, host names may be locally defined in the file
+   * <tt>/etc/hosts</tt>. On Windows, host names may be defined in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\hosts</tt>. Remote host name
+   * resolution is performed using DNS. Operating systems may use additional
+   * locations when resolving host names (such as NETBIOS names on Windows).
+   *
+   * On POSIX systems, service names are typically defined in the file
+   * <tt>/etc/services</tt>. On Windows, service names may be found in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\services</tt>. Operating systems
+   * may use additional locations when resolving service names.
+   */
+  template <typename ResolveHandler>
+  ASIO_INITFN_RESULT_TYPE(ResolveHandler,
+      void (asio::error_code, results_type))
+  async_resolve(const protocol_type& protocol,
+      ASIO_STRING_VIEW_PARAM host, ASIO_STRING_VIEW_PARAM service,
+      ASIO_MOVE_ARG(ResolveHandler) handler)
+  {
+    return async_resolve(protocol, host, service, resolver_base::flags(),
+        ASIO_MOVE_CAST(ResolveHandler)(handler));
+  }
+
+  /// Asynchronously perform forward resolution of a query to a list of entries.
+  /**
+   * This function is used to resolve host and service names into a list of
+   * endpoint entries.
+   *
+   * @param protocol A protocol object, normally representing either the IPv4 or
+   * IPv6 version of an internet protocol.
+   *
+   * @param host A string identifying a location. May be a descriptive name or
+   * a numeric address string. If an empty string and the passive flag has been
+   * specified, the resolved endpoints are suitable for local service binding.
+   * If an empty string and passive is not specified, the resolved endpoints
+   * will use the loopback address.
+   *
+   * @param service A string identifying the requested service. This may be a
+   * descriptive name or a numeric string corresponding to a port number. May
+   * be an empty string, in which case all resolved endpoints will have a port
+   * number of 0.
+   *
+   * @param resolve_flags A set of flags that determine how name resolution
+   * should be performed. The default flags are suitable for communication with
+   * remote hosts.
+   *
+   * @param handler The handler to be called when the resolve operation
+   * completes. Copies will be made of the handler as required. The function
+   * signature of the handler must be:
+   * @code void handler(
+   *   const asio::error_code& error, // Result of operation.
+   *   resolver::results_type results // Resolved endpoints as a range.
+   * ); @endcode
+   * Regardless of whether the asynchronous operation completes immediately or
+   * not, the handler will not be invoked from within this function. Invocation
+   * of the handler will be performed in a manner equivalent to using
+   * asio::io_context::post().
+   *
+   * A successful resolve operation is guaranteed to pass a non-empty range to
+   * the handler.
+   *
+   * @note On POSIX systems, host names may be locally defined in the file
+   * <tt>/etc/hosts</tt>. On Windows, host names may be defined in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\hosts</tt>. Remote host name
+   * resolution is performed using DNS. Operating systems may use additional
+   * locations when resolving host names (such as NETBIOS names on Windows).
+   *
+   * On POSIX systems, service names are typically defined in the file
+   * <tt>/etc/services</tt>. On Windows, service names may be found in the file
+   * <tt>c:\\windows\\system32\\drivers\\etc\\services</tt>. Operating systems
+   * may use additional locations when resolving service names.
+   */
+  template <typename ResolveHandler>
+  ASIO_INITFN_RESULT_TYPE(ResolveHandler,
+      void (asio::error_code, results_type))
+  async_resolve(const protocol_type& protocol,
+      ASIO_STRING_VIEW_PARAM host, ASIO_STRING_VIEW_PARAM service,
+      resolver_base::flags resolve_flags,
+      ASIO_MOVE_ARG(ResolveHandler) handler)
+  {
+    // If you get an error on the following line it means that your handler does
+    // not meet the documented type requirements for a ResolveHandler.
+    ASIO_RESOLVE_HANDLER_CHECK(
+        ResolveHandler, handler, results_type) type_check;
+
+    basic_resolver_query<protocol_type> q(
+        protocol, static_cast<std::string>(host),
+        static_cast<std::string>(service), resolve_flags);
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_resolve(this->get_implementation(), q,
         ASIO_MOVE_CAST(ResolveHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    asio::async_completion<ResolveHandler,
+      void (asio::error_code, results_type)> init(handler);
+
+    this->get_service().async_resolve(
+        this->get_implementation(), q, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 
   /// Perform reverse resolution of an endpoint to a list of entries.
@@ -174,20 +922,17 @@ public:
    * @param e An endpoint object that determines what endpoints will be
    * returned.
    *
-   * @returns A forward-only iterator that can be used to traverse the list
-   * of endpoint entries.
+   * @returns A range object representing the list of endpoint entries. A
+   * successful call to this function is guaranteed to return a non-empty
+   * range.
    *
    * @throws asio::system_error Thrown on failure.
-   *
-   * @note A default constructed iterator represents the end of the list.
-   *
-   * A successful call to this function is guaranteed to return at least one
-   * entry.
    */
-  iterator resolve(const endpoint_type& e)
+  results_type resolve(const endpoint_type& e)
   {
     asio::error_code ec;
-    iterator i = this->get_service().resolve(this->get_implementation(), e, ec);
+    results_type i = this->get_service().resolve(
+        this->get_implementation(), e, ec);
     asio::detail::throw_error(ec, "resolve");
     return i;
   }
@@ -202,16 +947,11 @@ public:
    *
    * @param ec Set to indicate what error occurred, if any.
    *
-   * @returns A forward-only iterator that can be used to traverse the list
-   * of endpoint entries. Returns a default constructed iterator if an error
-   * occurs.
-   *
-   * @note A default constructed iterator represents the end of the list.
-   *
-   * A successful call to this function is guaranteed to return at least one
-   * entry.
+   * @returns A range object representing the list of endpoint entries. An
+   * empty range is returned if an error occurs. A successful call to this
+   * function is guaranteed to return a non-empty range.
    */
-  iterator resolve(const endpoint_type& e, asio::error_code& ec)
+  results_type resolve(const endpoint_type& e, asio::error_code& ec)
   {
     return this->get_service().resolve(this->get_implementation(), e, ec);
   }
@@ -230,33 +970,39 @@ public:
    * signature of the handler must be:
    * @code void handler(
    *   const asio::error_code& error, // Result of operation.
-   *   resolver::iterator iterator             // Forward-only iterator that can
-   *                                           // be used to traverse the list
-   *                                           // of endpoint entries.
+   *   resolver::results_type results // Resolved endpoints as a range.
    * ); @endcode
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
-   * @note A default constructed iterator represents the end of the list.
-   *
-   * A successful resolve operation is guaranteed to pass at least one entry to
+   * A successful resolve operation is guaranteed to pass a non-empty range to
    * the handler.
    */
   template <typename ResolveHandler>
   ASIO_INITFN_RESULT_TYPE(ResolveHandler,
-      void (asio::error_code, iterator))
+      void (asio::error_code, results_type))
   async_resolve(const endpoint_type& e,
       ASIO_MOVE_ARG(ResolveHandler) handler)
   {
     // If you get an error on the following line it means that your handler does
     // not meet the documented type requirements for a ResolveHandler.
     ASIO_RESOLVE_HANDLER_CHECK(
-        ResolveHandler, handler, iterator) type_check;
+        ResolveHandler, handler, results_type) type_check;
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
     return this->get_service().async_resolve(this->get_implementation(), e,
         ASIO_MOVE_CAST(ResolveHandler)(handler));
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+    asio::async_completion<ResolveHandler,
+      void (asio::error_code, results_type)> init(handler);
+
+    this->get_service().async_resolve(
+        this->get_implementation(), e, init.completion_handler);
+
+    return init.result.get();
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
   }
 };
 
@@ -265,4 +1011,8 @@ public:
 
 #include "asio/detail/pop_options.hpp"
 
+#if !defined(ASIO_ENABLE_OLD_SERVICES)
+# undef ASIO_SVC_T
+#endif // !defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_IP_BASIC_RESOLVER_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_resolver_entry.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_resolver_entry.hpp
index 8ad45a8..ce689aa 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_resolver_entry.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_resolver_entry.hpp
@@ -2,7 +2,7 @@
 // ip/basic_resolver_entry.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,6 +17,7 @@
 
 #include "asio/detail/config.hpp"
 #include <string>
+#include "asio/detail/string_view.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -49,10 +50,10 @@ public:
 
   /// Construct with specified endpoint, host name and service name.
   basic_resolver_entry(const endpoint_type& ep,
-      const std::string& host, const std::string& service)
+      ASIO_STRING_VIEW_PARAM host, ASIO_STRING_VIEW_PARAM service)
     : endpoint_(ep),
-      host_name_(host),
-      service_name_(service)
+      host_name_(static_cast<std::string>(host)),
+      service_name_(static_cast<std::string>(service))
   {
   }
 
@@ -74,12 +75,30 @@ public:
     return host_name_;
   }
 
+  /// Get the host name associated with the entry.
+  template <class Allocator>
+  std::basic_string<char, std::char_traits<char>, Allocator> host_name(
+      const Allocator& alloc = Allocator()) const
+  {
+    return std::basic_string<char, std::char_traits<char>, Allocator>(
+        host_name_.c_str(), alloc);
+  }
+
   /// Get the service name associated with the entry.
   std::string service_name() const
   {
     return service_name_;
   }
 
+  /// Get the service name associated with the entry.
+  template <class Allocator>
+  std::basic_string<char, std::char_traits<char>, Allocator> service_name(
+      const Allocator& alloc = Allocator()) const
+  {
+    return std::basic_string<char, std::char_traits<char>, Allocator>(
+        service_name_.c_str(), alloc);
+  }
+
 private:
   endpoint_type endpoint_;
   std::string host_name_;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_resolver_iterator.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_resolver_iterator.hpp
index 3ce63c0..8cab75d 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_resolver_iterator.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_resolver_iterator.hpp
@@ -2,7 +2,7 @@
 // ip/basic_resolver_iterator.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -72,114 +72,45 @@ public:
   {
   }
 
-  /// Create an iterator from an addrinfo list returned by getaddrinfo.
-  static basic_resolver_iterator create(
-      asio::detail::addrinfo_type* address_info,
-      const std::string& host_name, const std::string& service_name)
+  /// Copy constructor.
+  basic_resolver_iterator(const basic_resolver_iterator& other)
+    : values_(other.values_),
+      index_(other.index_)
   {
-    basic_resolver_iterator iter;
-    if (!address_info)
-      return iter;
-
-    std::string actual_host_name = host_name;
-    if (address_info->ai_canonname)
-      actual_host_name = address_info->ai_canonname;
-
-    iter.values_.reset(new values_type);
-
-    while (address_info)
-    {
-      if (address_info->ai_family == ASIO_OS_DEF(AF_INET)
-          || address_info->ai_family == ASIO_OS_DEF(AF_INET6))
-      {
-        using namespace std; // For memcpy.
-        typename InternetProtocol::endpoint endpoint;
-        endpoint.resize(static_cast<std::size_t>(address_info->ai_addrlen));
-        memcpy(endpoint.data(), address_info->ai_addr,
-            address_info->ai_addrlen);
-        iter.values_->push_back(
-            basic_resolver_entry<InternetProtocol>(endpoint,
-              actual_host_name, service_name));
-      }
-      address_info = address_info->ai_next;
-    }
-
-    return iter;
   }
 
-  /// Create an iterator from an endpoint, host name and service name.
-  static basic_resolver_iterator create(
-      const typename InternetProtocol::endpoint& endpoint,
-      const std::string& host_name, const std::string& service_name)
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+  /// Move constructor.
+  basic_resolver_iterator(basic_resolver_iterator&& other)
+    : values_(ASIO_MOVE_CAST(values_ptr_type)(other.values_)),
+      index_(other.index_)
   {
-    basic_resolver_iterator iter;
-    iter.values_.reset(new values_type);
-    iter.values_->push_back(
-        basic_resolver_entry<InternetProtocol>(
-          endpoint, host_name, service_name));
-    return iter;
+    other.index_ = 0;
   }
+#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
 
-  /// Create an iterator from a sequence of endpoints, host and service name.
-  template <typename EndpointIterator>
-  static basic_resolver_iterator create(
-      EndpointIterator begin, EndpointIterator end,
-      const std::string& host_name, const std::string& service_name)
+  /// Assignment operator.
+  basic_resolver_iterator& operator=(const basic_resolver_iterator& other)
   {
-    basic_resolver_iterator iter;
-    if (begin != end)
-    {
-      iter.values_.reset(new values_type);
-      for (EndpointIterator ep_iter = begin; ep_iter != end; ++ep_iter)
-      {
-        iter.values_->push_back(
-            basic_resolver_entry<InternetProtocol>(
-              *ep_iter, host_name, service_name));
-      }
-    }
-    return iter;
+    values_ = other.values_;
+    index_ = other.index_;
+    return *this;
   }
 
-#if defined(ASIO_WINDOWS_RUNTIME)
-  /// Create an iterator from a Windows Runtime list of EndpointPair objects.
-  static basic_resolver_iterator create(
-      Windows::Foundation::Collections::IVectorView<
-        Windows::Networking::EndpointPair^>^ endpoints,
-      const asio::detail::addrinfo_type& hints,
-      const std::string& host_name, const std::string& service_name)
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+  /// Move-assignment operator.
+  basic_resolver_iterator& operator=(basic_resolver_iterator&& other)
   {
-    basic_resolver_iterator iter;
-    if (endpoints->Size)
+    if (this != &other)
     {
-      iter.values_.reset(new values_type);
-      for (unsigned int i = 0; i < endpoints->Size; ++i)
-      {
-        auto pair = endpoints->GetAt(i);
-
-        if (hints.ai_family == ASIO_OS_DEF(AF_INET)
-            && pair->RemoteHostName->Type
-              != Windows::Networking::HostNameType::Ipv4)
-          continue;
-
-        if (hints.ai_family == ASIO_OS_DEF(AF_INET6)
-            && pair->RemoteHostName->Type
-              != Windows::Networking::HostNameType::Ipv6)
-          continue;
-
-        iter.values_->push_back(
-            basic_resolver_entry<InternetProtocol>(
-              typename InternetProtocol::endpoint(
-                ip::address::from_string(
-                  asio::detail::winrt_utils::string(
-                    pair->RemoteHostName->CanonicalName)),
-                asio::detail::winrt_utils::integer(
-                  pair->RemoteServiceName)),
-              host_name, service_name));
-      }
+      values_ = ASIO_MOVE_CAST(values_ptr_type)(other.values_);
+      index_ = other.index_;
+      other.index_ = 0;
     }
-    return iter;
+
+    return *this;
   }
-#endif // defined(ASIO_WINDOWS_RUNTIME)
+#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
 
   /// Dereference an iterator.
   const basic_resolver_entry<InternetProtocol>& operator*() const
@@ -222,7 +153,7 @@ public:
     return !a.equal(b);
   }
 
-private:
+protected:
   void increment()
   {
     if (++index_ == values_->size())
@@ -248,7 +179,8 @@ private:
   }
 
   typedef std::vector<basic_resolver_entry<InternetProtocol> > values_type;
-  asio::detail::shared_ptr<values_type> values_;
+  typedef asio::detail::shared_ptr<values_type> values_ptr_type;
+  values_ptr_type values_;
   std::size_t index_;
 };
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_resolver_query.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_resolver_query.hpp
index ced5724..9bde9fe 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_resolver_query.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_resolver_query.hpp
@@ -2,7 +2,7 @@
 // ip/basic_resolver_query.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_resolver_results.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_resolver_results.hpp
new file mode 100644
index 0000000..dec2c7e
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/basic_resolver_results.hpp
@@ -0,0 +1,311 @@
+//
+// ip/basic_resolver_results.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_IP_BASIC_RESOLVER_RESULTS_HPP
+#define ASIO_IP_BASIC_RESOLVER_RESULTS_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+#include <cstddef>
+#include <cstring>
+#include "asio/detail/socket_ops.hpp"
+#include "asio/detail/socket_types.hpp"
+#include "asio/ip/basic_resolver_iterator.hpp"
+
+#if defined(ASIO_WINDOWS_RUNTIME)
+# include "asio/detail/winrt_utils.hpp"
+#endif // defined(ASIO_WINDOWS_RUNTIME)
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+namespace ip {
+
+/// A range of entries produced by a resolver.
+/**
+ * The asio::ip::basic_resolver_results class template is used to define
+ * a range over the results returned by a resolver.
+ *
+ * The iterator's value_type, obtained when a results iterator is dereferenced,
+ * is: @code const basic_resolver_entry<InternetProtocol> @endcode
+ *
+ * @note For backward compatibility, basic_resolver_results is derived from
+ * basic_resolver_iterator. This derivation is deprecated.
+ *
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Unsafe.
+ */
+template <typename InternetProtocol>
+class basic_resolver_results
+#if !defined(ASIO_NO_DEPRECATED)
+  : public basic_resolver_iterator<InternetProtocol>
+#else // !defined(ASIO_NO_DEPRECATED)
+  : private basic_resolver_iterator<InternetProtocol>
+#endif // !defined(ASIO_NO_DEPRECATED)
+{
+public:
+  /// The protocol type associated with the results.
+  typedef InternetProtocol protocol_type;
+
+  /// The endpoint type associated with the results.
+  typedef typename protocol_type::endpoint endpoint_type;
+
+  /// The type of a value in the results range.
+  typedef basic_resolver_entry<endpoint_type> value_type;
+
+  /// The type of a const reference to a value in the range.
+  typedef const value_type& const_reference;
+
+  /// The type of a non-const reference to a value in the range.
+  typedef value_type& reference;
+
+  /// The type of an iterator into the range.
+  typedef basic_resolver_iterator<protocol_type> const_iterator;
+
+  /// The type of an iterator into the range.
+  typedef const_iterator iterator;
+
+  /// Type used to represent the distance between two iterators in the range.
+  typedef std::ptrdiff_t difference_type;
+
+  /// Type used to represent a count of the elements in the range.
+  typedef std::size_t size_type;
+
+  /// Default constructor creates an empty range.
+  basic_resolver_results()
+  {
+  }
+
+  /// Copy constructor.
+  basic_resolver_results(const basic_resolver_results& other)
+    : basic_resolver_iterator<InternetProtocol>(other)
+  {
+  }
+
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+  /// Move constructor.
+  basic_resolver_results(basic_resolver_results&& other)
+    : basic_resolver_iterator<InternetProtocol>(
+        ASIO_MOVE_CAST(basic_resolver_results)(other))
+  {
+  }
+#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+
+  /// Assignment operator.
+  basic_resolver_results& operator=(const basic_resolver_results& other)
+  {
+    basic_resolver_iterator<InternetProtocol>::operator=(other);
+    return *this;
+  }
+
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+  /// Move-assignment operator.
+  basic_resolver_results& operator=(basic_resolver_results&& other)
+  {
+    basic_resolver_iterator<InternetProtocol>::operator=(
+        ASIO_MOVE_CAST(basic_resolver_results)(other));
+    return *this;
+  }
+#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+
+#if !defined(GENERATING_DOCUMENTATION)
+  // Create results from an addrinfo list returned by getaddrinfo.
+  static basic_resolver_results create(
+      asio::detail::addrinfo_type* address_info,
+      const std::string& host_name, const std::string& service_name)
+  {
+    basic_resolver_results results;
+    if (!address_info)
+      return results;
+
+    std::string actual_host_name = host_name;
+    if (address_info->ai_canonname)
+      actual_host_name = address_info->ai_canonname;
+
+    results.values_.reset(new values_type);
+
+    while (address_info)
+    {
+      if (address_info->ai_family == ASIO_OS_DEF(AF_INET)
+          || address_info->ai_family == ASIO_OS_DEF(AF_INET6))
+      {
+        using namespace std; // For memcpy.
+        typename InternetProtocol::endpoint endpoint;
+        endpoint.resize(static_cast<std::size_t>(address_info->ai_addrlen));
+        memcpy(endpoint.data(), address_info->ai_addr,
+            address_info->ai_addrlen);
+        results.values_->push_back(
+            basic_resolver_entry<InternetProtocol>(endpoint,
+              actual_host_name, service_name));
+      }
+      address_info = address_info->ai_next;
+    }
+
+    return results;
+  }
+
+  // Create results from an endpoint, host name and service name.
+  static basic_resolver_results create(const endpoint_type& endpoint,
+      const std::string& host_name, const std::string& service_name)
+  {
+    basic_resolver_results results;
+    results.values_.reset(new values_type);
+    results.values_->push_back(
+        basic_resolver_entry<InternetProtocol>(
+          endpoint, host_name, service_name));
+    return results;
+  }
+
+  // Create results from a sequence of endpoints, host and service name.
+  template <typename EndpointIterator>
+  static basic_resolver_results create(
+      EndpointIterator begin, EndpointIterator end,
+      const std::string& host_name, const std::string& service_name)
+  {
+    basic_resolver_results results;
+    if (begin != end)
+    {
+      results.values_.reset(new values_type);
+      for (EndpointIterator ep_iter = begin; ep_iter != end; ++ep_iter)
+      {
+        results.values_->push_back(
+            basic_resolver_entry<InternetProtocol>(
+              *ep_iter, host_name, service_name));
+      }
+    }
+    return results;
+  }
+
+# if defined(ASIO_WINDOWS_RUNTIME)
+  // Create results from a Windows Runtime list of EndpointPair objects.
+  static basic_resolver_results create(
+      Windows::Foundation::Collections::IVectorView<
+        Windows::Networking::EndpointPair^>^ endpoints,
+      const asio::detail::addrinfo_type& hints,
+      const std::string& host_name, const std::string& service_name)
+  {
+    basic_resolver_results results;
+    if (endpoints->Size)
+    {
+      results.values_.reset(new values_type);
+      for (unsigned int i = 0; i < endpoints->Size; ++i)
+      {
+        auto pair = endpoints->GetAt(i);
+
+        if (hints.ai_family == ASIO_OS_DEF(AF_INET)
+            && pair->RemoteHostName->Type
+              != Windows::Networking::HostNameType::Ipv4)
+          continue;
+
+        if (hints.ai_family == ASIO_OS_DEF(AF_INET6)
+            && pair->RemoteHostName->Type
+              != Windows::Networking::HostNameType::Ipv6)
+          continue;
+
+        results.values_->push_back(
+            basic_resolver_entry<InternetProtocol>(
+              typename InternetProtocol::endpoint(
+                ip::make_address(
+                  asio::detail::winrt_utils::string(
+                    pair->RemoteHostName->CanonicalName)),
+                asio::detail::winrt_utils::integer(
+                  pair->RemoteServiceName)),
+              host_name, service_name));
+      }
+    }
+    return results;
+  }
+# endif // defined(ASIO_WINDOWS_RUNTIME)
+#endif // !defined(GENERATING_DOCUMENTATION)
+
+  /// Get the number of entries in the results range.
+  size_type size() const ASIO_NOEXCEPT
+  {
+    return this->values_->size();
+  }
+
+  /// Get the maximum number of entries permitted in a results range.
+  size_type max_size() const ASIO_NOEXCEPT
+  {
+    return this->values_->max_size();
+  }
+
+  /// Determine whether the results range is empty.
+  bool empty() const ASIO_NOEXCEPT
+  {
+    return this->values_->empty();
+  }
+
+  /// Obtain a begin iterator for the results range.
+  const_iterator begin() const
+  {
+    basic_resolver_results tmp(*this);
+    tmp.index_ = 0;
+    return tmp;
+  }
+
+  /// Obtain an end iterator for the results range.
+  const_iterator end() const
+  {
+    return const_iterator();
+  }
+
+  /// Obtain a begin iterator for the results range.
+  const_iterator cbegin() const
+  {
+    return begin();
+  }
+
+  /// Obtain an end iterator for the results range.
+  const_iterator cend() const
+  {
+    return end();
+  }
+
+  /// Swap the results range with another.
+  void swap(basic_resolver_results& that) ASIO_NOEXCEPT
+  {
+    if (this != &that)
+    {
+      this->values_.swap(that.values_);
+      std::size_t index = this->index_;
+      this->index_ = that.index_;
+      that.index_ = index;
+    }
+  }
+
+  /// Test two iterators for equality.
+  friend bool operator==(const basic_resolver_results& a,
+      const basic_resolver_results& b)
+  {
+    return a.equal(b);
+  }
+
+  /// Test two iterators for inequality.
+  friend bool operator!=(const basic_resolver_results& a,
+      const basic_resolver_results& b)
+  {
+    return !a.equal(b);
+  }
+
+private:
+  typedef std::vector<basic_resolver_entry<InternetProtocol> > values_type;
+};
+
+} // namespace ip
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // ASIO_IP_BASIC_RESOLVER_RESULTS_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/detail/endpoint.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/detail/endpoint.hpp
index 42b8f89..82875a4 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/detail/endpoint.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/detail/endpoint.hpp
@@ -2,7 +2,7 @@
 // ip/detail/endpoint.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -111,15 +111,9 @@ public:
     return data_.base.sa_family == ASIO_OS_DEF(AF_INET);
   }
 
-  // Determine whether the endpoint is IPv6.
-  bool is_v6() const
-  {
-    return data_.base.sa_family == ASIO_OS_DEF(AF_INET6);
-  }
-
 #if !defined(ASIO_NO_IOSTREAM)
   // Convert to a string.
-  ASIO_DECL std::string to_string(asio::error_code& ec) const;
+  ASIO_DECL std::string to_string() const;
 #endif // !defined(ASIO_NO_IOSTREAM)
 
 private:
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/detail/impl/endpoint.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/detail/impl/endpoint.ipp
index b2ca0d6..2f76137 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/detail/impl/endpoint.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/detail/impl/endpoint.ipp
@@ -2,7 +2,7 @@
 // ip/detail/impl/endpoint.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -50,7 +50,7 @@ endpoint::endpoint(int family, unsigned short port_num)
       asio::detail::socket_ops::host_to_network_short(port_num);
     data_.v4.sin_addr.s_addr = ASIO_OS_DEF(INADDR_ANY);
   }
-  else if (family == ASIO_OS_DEF(AF_INET6))
+  else
   {
     data_.v6.sin6_family = ASIO_OS_DEF(AF_INET6);
     data_.v6.sin6_port =
@@ -66,13 +66,6 @@ endpoint::endpoint(int family, unsigned short port_num)
     data_.v6.sin6_addr.s6_addr[14] = 0, data_.v6.sin6_addr.s6_addr[15] = 0;
     data_.v6.sin6_scope_id = 0;
   }
-  else
-  {
-    data_.v4.sin_family = ASIO_OS_DEF(AF_UNSPEC);
-    data_.v4.sin_port =
-      asio::detail::socket_ops::host_to_network_short(port_num);
-    data_.v4.sin_addr.s_addr = ASIO_OS_DEF(INADDR_ANY);
-  }
 }
 
 endpoint::endpoint(const asio::ip::address& addr,
@@ -87,34 +80,26 @@ endpoint::endpoint(const asio::ip::address& addr,
       asio::detail::socket_ops::host_to_network_short(port_num);
     data_.v4.sin_addr.s_addr =
       asio::detail::socket_ops::host_to_network_long(
-          static_cast<asio::detail::u_long_type>(
-            address_cast<address_v4>(addr).to_ulong()));
+        addr.to_v4().to_uint());
   }
-  else if (addr.is_v6())
+  else
   {
     data_.v6.sin6_family = ASIO_OS_DEF(AF_INET6);
     data_.v6.sin6_port =
       asio::detail::socket_ops::host_to_network_short(port_num);
     data_.v6.sin6_flowinfo = 0;
-    asio::ip::address_v6 v6_addr = address_cast<address_v6>(addr);
+    asio::ip::address_v6 v6_addr = addr.to_v6();
     asio::ip::address_v6::bytes_type bytes = v6_addr.to_bytes();
     memcpy(data_.v6.sin6_addr.s6_addr, bytes.data(), 16);
     data_.v6.sin6_scope_id =
       static_cast<asio::detail::u_long_type>(
         v6_addr.scope_id());
   }
-  else
-  {
-    data_.v4.sin_family = ASIO_OS_DEF(AF_UNSPEC);
-    data_.v4.sin_port =
-      asio::detail::socket_ops::host_to_network_short(port_num);
-    data_.v4.sin_addr.s_addr = ASIO_OS_DEF(INADDR_ANY);
-  }
 }
 
 void endpoint::resize(std::size_t new_size)
 {
-  if (new_size > sizeof(data_))
+  if (new_size > sizeof(asio::detail::sockaddr_storage_type))
   {
     asio::error_code ec(asio::error::invalid_argument);
     asio::detail::throw_error(ec);
@@ -123,28 +108,28 @@ void endpoint::resize(std::size_t new_size)
 
 unsigned short endpoint::port() const
 {
-  if (is_v6())
+  if (is_v4())
   {
     return asio::detail::socket_ops::network_to_host_short(
-        data_.v6.sin6_port);
+        data_.v4.sin_port);
   }
   else
   {
     return asio::detail::socket_ops::network_to_host_short(
-        data_.v4.sin_port);
+        data_.v6.sin6_port);
   }
 }
 
 void endpoint::port(unsigned short port_num)
 {
-  if (is_v6())
+  if (is_v4())
   {
-    data_.v6.sin6_port
+    data_.v4.sin_port
       = asio::detail::socket_ops::host_to_network_short(port_num);
   }
   else
   {
-    data_.v4.sin_port
+    data_.v6.sin6_port
       = asio::detail::socket_ops::host_to_network_short(port_num);
   }
 }
@@ -158,7 +143,7 @@ asio::ip::address endpoint::address() const
         asio::detail::socket_ops::network_to_host_long(
           data_.v4.sin_addr.s_addr));
   }
-  else if (is_v6())
+  else
   {
     asio::ip::address_v6::bytes_type bytes;
 #if defined(ASIO_HAS_STD_ARRAY)
@@ -168,10 +153,6 @@ asio::ip::address endpoint::address() const
 #endif // defined(ASIO_HAS_STD_ARRAY)
     return asio::ip::address_v6(bytes, data_.v6.sin6_scope_id);
   }
-  else
-  {
-    return asio::ip::address();
-  }
 }
 
 void endpoint::address(const asio::ip::address& addr)
@@ -195,18 +176,14 @@ bool operator<(const endpoint& e1, const endpoint& e2)
 }
 
 #if !defined(ASIO_NO_IOSTREAM)
-std::string endpoint::to_string(asio::error_code& ec) const
+std::string endpoint::to_string() const
 {
-  std::string a = address().to_string(ec);
-  if (ec)
-    return std::string();
-
   std::ostringstream tmp_os;
   tmp_os.imbue(std::locale::classic());
   if (is_v4())
-    tmp_os << a;
+    tmp_os << address();
   else
-    tmp_os << '[' << a << ']';
+    tmp_os << '[' << address() << ']';
   tmp_os << ':' << port();
 
   return tmp_os.str();
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/detail/socket_option.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/detail/socket_option.hpp
index a44e610..d555a40 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/detail/socket_option.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/detail/socket_option.hpp
@@ -2,7 +2,7 @@
 // detail/socket_option.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -398,7 +398,7 @@ public:
     if (multicast_address.is_v6())
     {
       using namespace std; // For memcpy.
-      address_v6 ipv6_address = address_cast<address_v6>(multicast_address);
+      address_v6 ipv6_address = multicast_address.to_v6();
       address_v6::bytes_type bytes = ipv6_address.to_bytes();
       memcpy(ipv6_value_.ipv6mr_multiaddr.s6_addr, bytes.data(), 16);
       ipv6_value_.ipv6mr_interface = ipv6_address.scope_id();
@@ -407,10 +407,10 @@ public:
     {
       ipv4_value_.imr_multiaddr.s_addr =
         asio::detail::socket_ops::host_to_network_long(
-            address_cast<address_v4>(multicast_address).to_ulong());
+            multicast_address.to_v4().to_uint());
       ipv4_value_.imr_interface.s_addr =
         asio::detail::socket_ops::host_to_network_long(
-            address_v4::any().to_ulong());
+            address_v4::any().to_uint());
     }
   }
 
@@ -421,10 +421,10 @@ public:
   {
     ipv4_value_.imr_multiaddr.s_addr =
       asio::detail::socket_ops::host_to_network_long(
-          multicast_address.to_ulong());
+          multicast_address.to_uint());
     ipv4_value_.imr_interface.s_addr =
       asio::detail::socket_ops::host_to_network_long(
-          network_interface.to_ulong());
+          network_interface.to_uint());
   }
 
   // Construct with multicast address and IPv6 network interface index.
@@ -493,7 +493,7 @@ public:
   {
     ipv4_value_.s_addr =
       asio::detail::socket_ops::host_to_network_long(
-          address_v4::any().to_ulong());
+          address_v4::any().to_uint());
     ipv6_value_ = 0;
   }
 
@@ -502,7 +502,7 @@ public:
   {
     ipv4_value_.s_addr =
       asio::detail::socket_ops::host_to_network_long(
-          ipv4_interface.to_ulong());
+          ipv4_interface.to_uint());
     ipv6_value_ = 0;
   }
 
@@ -511,7 +511,7 @@ public:
   {
     ipv4_value_.s_addr =
       asio::detail::socket_ops::host_to_network_long(
-          address_v4::any().to_ulong());
+          address_v4::any().to_uint());
     ipv6_value_ = ipv6_interface;
   }
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/host_name.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/host_name.hpp
index a5d6e59..6e556c6 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/host_name.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/host_name.hpp
@@ -2,7 +2,7 @@
 // ip/host_name.hpp
 // ~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/icmp.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/icmp.hpp
index 26766e6..752a82c 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/icmp.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/icmp.hpp
@@ -2,7 +2,7 @@
 // ip/icmp.hpp
 // ~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address.hpp
index 5f2267c..c64fb02 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address.hpp
@@ -2,7 +2,7 @@
 // ip/impl/address.hpp
 // ~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -54,19 +54,7 @@ template <typename Elem, typename Traits>
 std::basic_ostream<Elem, Traits>& operator<<(
     std::basic_ostream<Elem, Traits>& os, const address& addr)
 {
-  asio::error_code ec;
-  std::string s = addr.to_string(ec);
-  if (ec)
-  {
-    if (os.exceptions() & std::basic_ostream<Elem, Traits>::failbit)
-      asio::detail::throw_error(ec);
-    else
-      os.setstate(std::basic_ostream<Elem, Traits>::failbit);
-  }
-  else
-    for (std::string::iterator i = s.begin(); i != s.end(); ++i)
-      os << os.widen(*i);
-  return os;
+  return os << addr.to_string().c_str();
 }
 
 } // namespace ip
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address.ipp
index e7745b4..c558d9a 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address.ipp
@@ -2,7 +2,7 @@
 // ip/impl/address.ipp
 // ~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -30,7 +30,7 @@ namespace asio {
 namespace ip {
 
 address::address()
-  : type_(none),
+  : type_(ipv4),
     ipv4_address_(),
     ipv6_address_()
 {
@@ -134,7 +134,21 @@ address make_address(const std::string& str,
   return make_address(str.c_str(), ec);
 }
 
-#if !defined(ASIO_NO_DEPRECATED)
+#if defined(ASIO_HAS_STD_STRING_VIEW)
+
+address make_address(string_view str)
+{
+  return make_address(static_cast<std::string>(str));
+}
+
+address make_address(string_view str,
+    asio::error_code& ec)
+{
+  return make_address(static_cast<std::string>(str), ec);
+}
+
+#endif // defined(ASIO_HAS_STD_STRING_VIEW)
+
 asio::ip::address_v4 address::to_v4() const
 {
   if (type_ != ipv4)
@@ -154,85 +168,51 @@ asio::ip::address_v6 address::to_v6() const
   }
   return ipv6_address_;
 }
-#endif // !defined(ASIO_NO_DEPRECATED)
 
 std::string address::to_string() const
 {
-  switch (type_)
-  {
-  case ipv4:
-    return ipv4_address_.to_string();
-  case ipv6:
+  if (type_ == ipv6)
     return ipv6_address_.to_string();
-  default:
-    bad_address_cast ex;
-    asio::detail::throw_exception(ex);
-    return std::string();
-  }
+  return ipv4_address_.to_string();
 }
 
+#if !defined(ASIO_NO_DEPRECATED)
 std::string address::to_string(asio::error_code& ec) const
 {
-  switch (type_)
-  {
-  case ipv4:
-    return ipv4_address_.to_string(ec);
-  case ipv6:
+  if (type_ == ipv6)
     return ipv6_address_.to_string(ec);
-  default:
-    ec = asio::error::invalid_argument;
-    return std::string();
-  }
+  return ipv4_address_.to_string(ec);
 }
+#endif // !defined(ASIO_NO_DEPRECATED)
 
 bool address::is_loopback() const
 {
-  switch (type_)
-  {
-  case ipv4:
-    return ipv4_address_.is_loopback();
-  case ipv6:
-    return ipv6_address_.is_loopback();
-  default:
-    return false;
-  }
+  return (type_ == ipv4)
+    ? ipv4_address_.is_loopback()
+    : ipv6_address_.is_loopback();
 }
 
 bool address::is_unspecified() const
 {
-  switch (type_)
-  {
-  case ipv4:
-    return ipv4_address_.is_unspecified();
-  case ipv6:
-    return ipv6_address_.is_unspecified();
-  default:
-    return false;
-  }
+  return (type_ == ipv4)
+    ? ipv4_address_.is_unspecified()
+    : ipv6_address_.is_unspecified();
 }
 
 bool address::is_multicast() const
 {
-  switch (type_)
-  {
-  case ipv4:
-    return ipv4_address_.is_multicast();
-  case ipv6:
-    return ipv6_address_.is_multicast();
-  default:
-    return false;
-  }
+  return (type_ == ipv4)
+    ? ipv4_address_.is_multicast()
+    : ipv6_address_.is_multicast();
 }
 
 bool operator==(const address& a1, const address& a2)
 {
   if (a1.type_ != a2.type_)
     return false;
-  if (a1.type_ == address::ipv4)
-    return a1.ipv4_address_ == a2.ipv4_address_;
   if (a1.type_ == address::ipv6)
     return a1.ipv6_address_ == a2.ipv6_address_;
-  return true;
+  return a1.ipv4_address_ == a2.ipv4_address_;
 }
 
 bool operator<(const address& a1, const address& a2)
@@ -241,11 +221,9 @@ bool operator<(const address& a1, const address& a2)
     return true;
   if (a1.type_ > a2.type_)
     return false;
-  if (a1.type_ == address::ipv4)
-    return a1.ipv4_address_ < a2.ipv4_address_;
   if (a1.type_ == address::ipv6)
     return a1.ipv6_address_ < a2.ipv6_address_;
-  return false;
+  return a1.ipv4_address_ < a2.ipv4_address_;
 }
 
 } // namespace ip
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address_v4.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address_v4.hpp
index 4b848fb..1897fd2 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address_v4.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address_v4.hpp
@@ -2,7 +2,7 @@
 // ip/impl/address_v4.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -54,19 +54,7 @@ template <typename Elem, typename Traits>
 std::basic_ostream<Elem, Traits>& operator<<(
     std::basic_ostream<Elem, Traits>& os, const address_v4& addr)
 {
-  asio::error_code ec;
-  std::string s = addr.to_string(ec);
-  if (ec)
-  {
-    if (os.exceptions() & std::basic_ostream<Elem, Traits>::failbit)
-      asio::detail::throw_error(ec);
-    else
-      os.setstate(std::basic_ostream<Elem, Traits>::failbit);
-  }
-  else
-    for (std::string::iterator i = s.begin(); i != s.end(); ++i)
-      os << os.widen(*i);
-  return os;
+  return os << addr.to_string().c_str();
 }
 
 } // namespace ip
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address_v4.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address_v4.ipp
index c3caf3b..09439eb 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address_v4.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address_v4.ipp
@@ -2,7 +2,7 @@
 // ip/impl/address_v4.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,6 +17,7 @@
 
 #include "asio/detail/config.hpp"
 #include <climits>
+#include <limits>
 #include <stdexcept>
 #include "asio/error.hpp"
 #include "asio/detail/socket_ops.hpp"
@@ -44,15 +45,13 @@ address_v4::address_v4(const address_v4::bytes_type& bytes)
   memcpy(&addr_.s_addr, bytes.data(), 4);
 }
 
-address_v4::address_v4(unsigned long addr)
+address_v4::address_v4(address_v4::uint_type addr)
 {
-#if ULONG_MAX > 0xFFFFFFFF
-  if (addr > 0xFFFFFFFF)
+  if ((std::numeric_limits<uint_type>::max)() > 0xFFFFFFFF)
   {
-    std::out_of_range ex("address_v4 from unsigned long");
+    std::out_of_range ex("address_v4 from unsigned integer");
     asio::detail::throw_exception(ex);
   }
-#endif // ULONG_MAX > 0xFFFFFFFF
 
   addr_.s_addr = asio::detail::socket_ops::host_to_network_long(
       static_cast<asio::detail::u_long_type>(addr));
@@ -70,19 +69,32 @@ address_v4::bytes_type address_v4::to_bytes() const
   return bytes;
 }
 
+address_v4::uint_type address_v4::to_uint() const
+{
+  return asio::detail::socket_ops::network_to_host_long(addr_.s_addr);
+}
+
+#if !defined(ASIO_NO_DEPRECATED)
 unsigned long address_v4::to_ulong() const
 {
   return asio::detail::socket_ops::network_to_host_long(addr_.s_addr);
 }
+#endif // !defined(ASIO_NO_DEPRECATED)
 
 std::string address_v4::to_string() const
 {
   asio::error_code ec;
-  std::string addr = to_string(ec);
-  asio::detail::throw_error(ec);
+  char addr_str[asio::detail::max_addr_v4_str_len];
+  const char* addr =
+    asio::detail::socket_ops::inet_ntop(
+        ASIO_OS_DEF(AF_INET), &addr_, addr_str,
+        asio::detail::max_addr_v4_str_len, 0, ec);
+  if (addr == 0)
+    asio::detail::throw_error(ec);
   return addr;
 }
 
+#if !defined(ASIO_NO_DEPRECATED)
 std::string address_v4::to_string(asio::error_code& ec) const
 {
   char addr_str[asio::detail::max_addr_v4_str_len];
@@ -94,40 +106,44 @@ std::string address_v4::to_string(asio::error_code& ec) const
     return std::string();
   return addr;
 }
+#endif // !defined(ASIO_NO_DEPRECATED)
 
 bool address_v4::is_loopback() const
 {
-  return (to_ulong() & 0xFF000000) == 0x7F000000;
+  return (to_uint() & 0xFF000000) == 0x7F000000;
 }
 
 bool address_v4::is_unspecified() const
 {
-  return to_ulong() == 0;
+  return to_uint() == 0;
 }
 
+#if !defined(ASIO_NO_DEPRECATED)
 bool address_v4::is_class_a() const
 {
-  return (to_ulong() & 0x80000000) == 0;
+  return (to_uint() & 0x80000000) == 0;
 }
 
 bool address_v4::is_class_b() const
 {
-  return (to_ulong() & 0xC0000000) == 0x80000000;
+  return (to_uint() & 0xC0000000) == 0x80000000;
 }
 
 bool address_v4::is_class_c() const
 {
-  return (to_ulong() & 0xE0000000) == 0xC0000000;
+  return (to_uint() & 0xE0000000) == 0xC0000000;
 }
+#endif // !defined(ASIO_NO_DEPRECATED)
 
 bool address_v4::is_multicast() const
 {
-  return (to_ulong() & 0xF0000000) == 0xE0000000;
+  return (to_uint() & 0xF0000000) == 0xE0000000;
 }
 
+#if !defined(ASIO_NO_DEPRECATED)
 address_v4 address_v4::broadcast(const address_v4& addr, const address_v4& mask)
 {
-  return address_v4(addr.to_ulong() | (mask.to_ulong() ^ 0xFFFFFFFF));
+  return address_v4(addr.to_uint() | (mask.to_uint() ^ 0xFFFFFFFF));
 }
 
 address_v4 address_v4::netmask(const address_v4& addr)
@@ -140,6 +156,7 @@ address_v4 address_v4::netmask(const address_v4& addr)
     return address_v4(0xFFFFFF00);
   return address_v4(0xFFFFFFFF);
 }
+#endif // !defined(ASIO_NO_DEPRECATED)
 
 address_v4 make_address_v4(const char* str)
 {
@@ -170,6 +187,21 @@ address_v4 make_address_v4(
   return make_address_v4(str.c_str(), ec);
 }
 
+#if defined(ASIO_HAS_STD_STRING_VIEW)
+
+address_v4 make_address_v4(string_view str)
+{
+  return make_address_v4(static_cast<std::string>(str));
+}
+
+address_v4 make_address_v4(string_view str,
+    asio::error_code& ec)
+{
+  return make_address_v4(static_cast<std::string>(str), ec);
+}
+
+#endif // defined(ASIO_HAS_STD_STRING_VIEW)
+
 } // namespace ip
 } // namespace asio
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address_v6.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address_v6.hpp
index 0aa3b8c..407d9c1 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address_v6.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address_v6.hpp
@@ -2,7 +2,7 @@
 // ip/impl/address_v6.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -54,19 +54,7 @@ template <typename Elem, typename Traits>
 std::basic_ostream<Elem, Traits>& operator<<(
     std::basic_ostream<Elem, Traits>& os, const address_v6& addr)
 {
-  asio::error_code ec;
-  std::string s = addr.to_string(ec);
-  if (ec)
-  {
-    if (os.exceptions() & std::basic_ostream<Elem, Traits>::failbit)
-      asio::detail::throw_error(ec);
-    else
-      os.setstate(std::basic_ostream<Elem, Traits>::failbit);
-  }
-  else
-    for (std::string::iterator i = s.begin(); i != s.end(); ++i)
-      os << os.widen(*i);
-  return os;
+  return os << addr.to_string().c_str();
 }
 
 } // namespace ip
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address_v6.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address_v6.ipp
index 42e02b1..79025ae 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address_v6.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/address_v6.ipp
@@ -2,7 +2,7 @@
 // ip/impl/address_v6.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -101,11 +101,17 @@ address_v6::bytes_type address_v6::to_bytes() const
 std::string address_v6::to_string() const
 {
   asio::error_code ec;
-  std::string addr = to_string(ec);
-  asio::detail::throw_error(ec);
+  char addr_str[asio::detail::max_addr_v6_str_len];
+  const char* addr =
+    asio::detail::socket_ops::inet_ntop(
+        ASIO_OS_DEF(AF_INET6), &addr_, addr_str,
+        asio::detail::max_addr_v6_str_len, scope_id_, ec);
+  if (addr == 0)
+    asio::detail::throw_error(ec);
   return addr;
 }
 
+#if !defined(ASIO_NO_DEPRECATED)
 std::string address_v6::to_string(asio::error_code& ec) const
 {
   char addr_str[asio::detail::max_addr_v6_str_len];
@@ -118,7 +124,6 @@ std::string address_v6::to_string(asio::error_code& ec) const
   return addr;
 }
 
-#if !defined(ASIO_NO_DEPRECATED)
 address_v4 address_v6::to_v4() const
 {
   if (!is_v4_mapped() && !is_v4_compatible())
@@ -298,6 +303,21 @@ address_v6 make_address_v6(
   return make_address_v6(str.c_str(), ec);
 }
 
+#if defined(ASIO_HAS_STD_STRING_VIEW)
+
+address_v6 make_address_v6(string_view str)
+{
+  return make_address_v6(static_cast<std::string>(str));
+}
+
+address_v6 make_address_v6(string_view str,
+    asio::error_code& ec)
+{
+  return make_address_v6(static_cast<std::string>(str), ec);
+}
+
+#endif // defined(ASIO_HAS_STD_STRING_VIEW)
+
 address_v4 make_address_v4(
     v4_mapped_t, const address_v6& v6_addr)
 {
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/basic_endpoint.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/basic_endpoint.hpp
index 2f15c4f..c1a29a8 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/basic_endpoint.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/basic_endpoint.hpp
@@ -2,7 +2,7 @@
 // ip/impl/basic_endpoint.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -30,19 +30,7 @@ std::basic_ostream<Elem, Traits>& operator<<(
     const basic_endpoint<InternetProtocol>& endpoint)
 {
   asio::ip::detail::endpoint tmp_ep(endpoint.address(), endpoint.port());
-  asio::error_code ec;
-  std::string s = tmp_ep.to_string(ec);
-  if (ec)
-  {
-    if (os.exceptions() & std::basic_ostream<Elem, Traits>::failbit)
-      asio::detail::throw_error(ec);
-    else
-      os.setstate(std::basic_ostream<Elem, Traits>::failbit);
-  }
-  else
-    for (std::string::iterator i = s.begin(); i != s.end(); ++i)
-      os << os.widen(*i);
-  return os;
+  return os << tmp_ep.to_string().c_str();
 }
 
 } // namespace ip
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/host_name.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/host_name.ipp
index b1dc38e..a1f8a0d 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/host_name.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/host_name.ipp
@@ -2,7 +2,7 @@
 // ip/impl/host_name.ipp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/network_v4.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/network_v4.hpp
index e48baeb..34c03fd 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/network_v4.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/network_v4.hpp
@@ -2,7 +2,7 @@
 // ip/impl/network_v4.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2014 Oliver Kowalke (oliver dot kowalke at gmail dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/network_v4.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/network_v4.ipp
index fb645ab..ec39aae 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/network_v4.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/network_v4.ipp
@@ -2,7 +2,7 @@
 // ip/impl/network_v4.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2014 Oliver Kowalke (oliver dot kowalke at gmail dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -101,11 +101,11 @@ address_v4 network_v4::netmask() const ASIO_NOEXCEPT
   return address_v4(nmbits);
 }
 
-address_range_v4 network_v4::hosts() const ASIO_NOEXCEPT
+address_v4_range network_v4::hosts() const ASIO_NOEXCEPT
 {
   return is_host()
-    ? address_range_v4(address_, address_v4(address_.to_ulong() + 1))
-    : address_range_v4(address_v4(network().to_ulong() + 1), broadcast());
+    ? address_v4_range(address_, address_v4(address_.to_uint() + 1))
+    : address_v4_range(address_v4(network().to_uint() + 1), broadcast());
 }
 
 bool network_v4::is_subnet_of(const network_v4& other) const
@@ -182,6 +182,21 @@ network_v4 make_network_v4(const std::string& str,
       std::atoi(str.substr(pos + 1).c_str()));
 }
 
+#if defined(ASIO_HAS_STD_STRING_VIEW)
+
+network_v4 make_network_v4(string_view str)
+{
+  return make_network_v4(static_cast<std::string>(str));
+}
+
+network_v4 make_network_v4(string_view str,
+    asio::error_code& ec)
+{
+  return make_network_v4(static_cast<std::string>(str), ec);
+}
+
+#endif // defined(ASIO_HAS_STD_STRING_VIEW)
+
 } // namespace ip
 } // namespace asio
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/network_v6.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/network_v6.hpp
index 88c8462..03b9ed8 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/network_v6.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/network_v6.hpp
@@ -2,7 +2,7 @@
 // ip/impl/network_v6.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/network_v6.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/network_v6.ipp
index b75e6a5..c2418e3 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/network_v6.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/impl/network_v6.ipp
@@ -2,7 +2,7 @@
 // ip/impl/network_v6.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2014 Oliver Kowalke (oliver dot kowalke at gmail dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -55,7 +55,7 @@ ASIO_DECL address_v6 network_v6::network() const ASIO_NOEXCEPT
   return address_v6(bytes, address_.scope_id());
 }
 
-address_range_v6 network_v6::hosts() const ASIO_NOEXCEPT
+address_v6_range network_v6::hosts() const ASIO_NOEXCEPT
 {
   address_v6::bytes_type begin_bytes(address_.to_bytes());
   address_v6::bytes_type end_bytes(address_.to_bytes());
@@ -72,9 +72,9 @@ address_range_v6 network_v6::hosts() const ASIO_NOEXCEPT
       end_bytes[i] |= 0xFF >> (prefix_length_ % 8);
     }
   }
-  return address_range_v6(
-      address_iterator_v6(address_v6(begin_bytes, address_.scope_id())),
-      ++address_iterator_v6(address_v6(end_bytes, address_.scope_id())));
+  return address_v6_range(
+      address_v6_iterator(address_v6(begin_bytes, address_.scope_id())),
+      ++address_v6_iterator(address_v6(end_bytes, address_.scope_id())));
 }
 
 bool network_v6::is_subnet_of(const network_v6& other) const
@@ -151,6 +151,21 @@ network_v6 make_network_v6(const std::string& str,
       std::atoi(str.substr(pos + 1).c_str()));
 }
 
+#if defined(ASIO_HAS_STD_STRING_VIEW)
+
+network_v6 make_network_v6(string_view str)
+{
+  return make_network_v6(static_cast<std::string>(str));
+}
+
+network_v6 make_network_v6(string_view str,
+    asio::error_code& ec)
+{
+  return make_network_v6(static_cast<std::string>(str), ec);
+}
+
+#endif // defined(ASIO_HAS_STD_STRING_VIEW)
+
 } // namespace ip
 } // namespace asio
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/multicast.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/multicast.hpp
index 4af2c3a..16fbf4c 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/multicast.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/multicast.hpp
@@ -2,7 +2,7 @@
 // ip/multicast.hpp
 // ~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -32,7 +32,7 @@ namespace multicast {
  * @par Examples
  * Setting the option to join a multicast group:
  * @code
- * asio::ip::udp::socket socket(io_service); 
+ * asio::ip::udp::socket socket(io_context); 
  * ...
  * asio::ip::address multicast_address =
  *   asio::ip::address::from_string("225.0.0.1");
@@ -60,7 +60,7 @@ typedef asio::ip::detail::socket_option::multicast_request<
  * @par Examples
  * Setting the option to leave a multicast group:
  * @code
- * asio::ip::udp::socket socket(io_service); 
+ * asio::ip::udp::socket socket(io_context); 
  * ...
  * asio::ip::address multicast_address =
  *   asio::ip::address::from_string("225.0.0.1");
@@ -88,7 +88,7 @@ typedef asio::ip::detail::socket_option::multicast_request<
  * @par Examples
  * Setting the option:
  * @code
- * asio::ip::udp::socket socket(io_service); 
+ * asio::ip::udp::socket socket(io_context); 
  * ...
  * asio::ip::address_v4 local_interface =
  *   asio::ip::address_v4::from_string("1.2.3.4");
@@ -116,7 +116,7 @@ typedef asio::ip::detail::socket_option::network_interface<
  * @par Examples
  * Setting the option:
  * @code
- * asio::ip::udp::socket socket(io_service); 
+ * asio::ip::udp::socket socket(io_context); 
  * ...
  * asio::ip::multicast::hops option(4);
  * socket.set_option(option);
@@ -125,7 +125,7 @@ typedef asio::ip::detail::socket_option::network_interface<
  * @par
  * Getting the current option value:
  * @code
- * asio::ip::udp::socket socket(io_service); 
+ * asio::ip::udp::socket socket(io_context); 
  * ...
  * asio::ip::multicast::hops option;
  * socket.get_option(option);
@@ -153,7 +153,7 @@ typedef asio::ip::detail::socket_option::multicast_hops<
  * @par Examples
  * Setting the option:
  * @code
- * asio::ip::udp::socket socket(io_service); 
+ * asio::ip::udp::socket socket(io_context); 
  * ...
  * asio::ip::multicast::enable_loopback option(true);
  * socket.set_option(option);
@@ -162,7 +162,7 @@ typedef asio::ip::detail::socket_option::multicast_hops<
  * @par
  * Getting the current option value:
  * @code
- * asio::ip::udp::socket socket(io_service); 
+ * asio::ip::udp::socket socket(io_context); 
  * ...
  * asio::ip::multicast::enable_loopback option;
  * socket.get_option(option);
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/network_v4.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/network_v4.hpp
index 7deba5c..5980b8e 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/network_v4.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/network_v4.hpp
@@ -2,7 +2,7 @@
 // ip/network_v4.hpp
 // ~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2014 Oliver Kowalke (oliver dot kowalke at gmail dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -18,8 +18,9 @@
 
 #include "asio/detail/config.hpp"
 #include <string>
+#include "asio/detail/string_view.hpp"
 #include "asio/error_code.hpp"
-#include "asio/ip/address_range_v4.hpp"
+#include "asio/ip/address_v4_range.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -106,17 +107,17 @@ public:
   /// Obtain an address object that represents the network address.
   address_v4 network() const ASIO_NOEXCEPT
   {
-    return address_v4(address_.to_ulong() & netmask().to_ulong());
+    return address_v4(address_.to_uint() & netmask().to_uint());
   }
 
   /// Obtain an address object that represents the network's broadcast address.
   address_v4 broadcast() const ASIO_NOEXCEPT
   {
-    return address_v4::broadcast(network(), netmask());
+    return address_v4(network().to_uint() | (netmask().to_uint() ^ 0xFFFFFFFF));
   }
 
   /// Obtain an address range corresponding to the hosts in the network.
-  ASIO_DECL address_range_v4 hosts() const ASIO_NOEXCEPT;
+  ASIO_DECL address_v4_range hosts() const ASIO_NOEXCEPT;
 
   /// Obtain the true network address, omitting any host bits.
   network_v4 canonical() const ASIO_NOEXCEPT
@@ -183,26 +184,50 @@ inline network_v4 make_network_v4(
  */
 ASIO_DECL network_v4 make_network_v4(const char* str);
 
-/// Create an IPv4 address from an IP address string in dotted decimal form.
+/// Create an IPv4 network from a string containing IP address and prefix
+/// length.
 /**
  * @relates network_v4
  */
 ASIO_DECL network_v4 make_network_v4(
     const char* str, asio::error_code& ec);
 
-/// Create an IPv4 address from an IP address string in dotted decimal form.
+/// Create an IPv4 network from a string containing IP address and prefix
+/// length.
 /**
  * @relates network_v4
  */
 ASIO_DECL network_v4 make_network_v4(const std::string& str);
 
-/// Create an IPv4 address from an IP address string in dotted decimal form.
+/// Create an IPv4 network from a string containing IP address and prefix
+/// length.
 /**
  * @relates network_v4
  */
 ASIO_DECL network_v4 make_network_v4(
     const std::string& str, asio::error_code& ec);
 
+#if defined(ASIO_HAS_STD_STRING_VIEW) \
+  || defined(GENERATING_DOCUMENTATION)
+
+/// Create an IPv4 network from a string containing IP address and prefix
+/// length.
+/**
+ * @relates network_v4
+ */
+ASIO_DECL network_v4 make_network_v4(string_view str);
+
+/// Create an IPv4 network from a string containing IP address and prefix
+/// length.
+/**
+ * @relates network_v4
+ */
+ASIO_DECL network_v4 make_network_v4(
+    string_view str, asio::error_code& ec);
+
+#endif // defined(ASIO_HAS_STD_STRING_VIEW)
+       //  || defined(GENERATING_DOCUMENTATION)
+
 #if !defined(ASIO_NO_IOSTREAM)
 
 /// Output a network as a string.
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/network_v6.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/network_v6.hpp
index d6c5481..4e07dbb 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/network_v6.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/network_v6.hpp
@@ -2,7 +2,7 @@
 // ip/network_v6.hpp
 // ~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2014 Oliver Kowalke (oliver dot kowalke at gmail dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -18,8 +18,9 @@
 
 #include "asio/detail/config.hpp"
 #include <string>
+#include "asio/detail/string_view.hpp"
 #include "asio/error_code.hpp"
-#include "asio/ip/address_range_v6.hpp"
+#include "asio/ip/address_v6_range.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -100,7 +101,7 @@ public:
   ASIO_DECL address_v6 network() const ASIO_NOEXCEPT;
 
   /// Obtain an address range corresponding to the hosts in the network.
-  ASIO_DECL address_range_v6 hosts() const ASIO_NOEXCEPT;
+  ASIO_DECL address_v6_range hosts() const ASIO_NOEXCEPT;
 
   /// Obtain the true network address, omitting any host bits.
   network_v6 canonical() const ASIO_NOEXCEPT
@@ -157,26 +158,50 @@ inline network_v6 make_network_v6(
  */
 ASIO_DECL network_v6 make_network_v6(const char* str);
 
-/// Create an IPv6 address from an IP address string in dotted decimal form.
+/// Create an IPv6 network from a string containing IP address and prefix
+/// length.
 /**
  * @relates network_v6
  */
 ASIO_DECL network_v6 make_network_v6(
     const char* str, asio::error_code& ec);
 
-/// Create an IPv6 address from an IP address string in dotted decimal form.
+/// Create an IPv6 network from a string containing IP address and prefix
+/// length.
 /**
  * @relates network_v6
  */
 ASIO_DECL network_v6 make_network_v6(const std::string& str);
 
-/// Create an IPv6 address from an IP address string in dotted decimal form.
+/// Create an IPv6 network from a string containing IP address and prefix
+/// length.
 /**
  * @relates network_v6
  */
 ASIO_DECL network_v6 make_network_v6(
     const std::string& str, asio::error_code& ec);
 
+#if defined(ASIO_HAS_STD_STRING_VIEW) \
+  || defined(GENERATING_DOCUMENTATION)
+
+/// Create an IPv6 network from a string containing IP address and prefix
+/// length.
+/**
+ * @relates network_v6
+ */
+ASIO_DECL network_v6 make_network_v6(string_view str);
+
+/// Create an IPv6 network from a string containing IP address and prefix
+/// length.
+/**
+ * @relates network_v6
+ */
+ASIO_DECL network_v6 make_network_v6(
+    string_view str, asio::error_code& ec);
+
+#endif // defined(ASIO_HAS_STD_STRING_VIEW)
+       //  || defined(GENERATING_DOCUMENTATION)
+
 #if !defined(ASIO_NO_IOSTREAM)
 
 /// Output a network as a string.
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/resolver_base.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/resolver_base.hpp
new file mode 100644
index 0000000..a8a94d5
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/resolver_base.hpp
@@ -0,0 +1,129 @@
+//
+// ip/resolver_base.hpp
+// ~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_IP_RESOLVER_BASE_HPP
+#define ASIO_IP_RESOLVER_BASE_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+#include "asio/detail/socket_types.hpp"
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+namespace ip {
+
+/// The resolver_base class is used as a base for the basic_resolver class
+/// templates to provide a common place to define the flag constants.
+class resolver_base
+{
+public:
+#if defined(GENERATING_DOCUMENTATION)
+  /// A bitmask type (C++ Std [lib.bitmask.types]).
+  typedef unspecified flags;
+
+  /// Determine the canonical name of the host specified in the query.
+  static const flags canonical_name = implementation_defined;
+
+  /// Indicate that returned endpoint is intended for use as a locally bound
+  /// socket endpoint.
+  static const flags passive = implementation_defined;
+
+  /// Host name should be treated as a numeric string defining an IPv4 or IPv6
+  /// address and no name resolution should be attempted.
+  static const flags numeric_host = implementation_defined;
+
+  /// Service name should be treated as a numeric string defining a port number
+  /// and no name resolution should be attempted.
+  static const flags numeric_service = implementation_defined;
+
+  /// If the query protocol family is specified as IPv6, return IPv4-mapped
+  /// IPv6 addresses on finding no IPv6 addresses.
+  static const flags v4_mapped = implementation_defined;
+
+  /// If used with v4_mapped, return all matching IPv6 and IPv4 addresses.
+  static const flags all_matching = implementation_defined;
+
+  /// Only return IPv4 addresses if a non-loopback IPv4 address is configured
+  /// for the system. Only return IPv6 addresses if a non-loopback IPv6 address
+  /// is configured for the system.
+  static const flags address_configured = implementation_defined;
+#else
+  enum flags
+  {
+    canonical_name = ASIO_OS_DEF(AI_CANONNAME),
+    passive = ASIO_OS_DEF(AI_PASSIVE),
+    numeric_host = ASIO_OS_DEF(AI_NUMERICHOST),
+    numeric_service = ASIO_OS_DEF(AI_NUMERICSERV),
+    v4_mapped = ASIO_OS_DEF(AI_V4MAPPED),
+    all_matching = ASIO_OS_DEF(AI_ALL),
+    address_configured = ASIO_OS_DEF(AI_ADDRCONFIG)
+  };
+
+  // Implement bitmask operations as shown in C++ Std [lib.bitmask.types].
+
+  friend flags operator&(flags x, flags y)
+  {
+    return static_cast<flags>(
+        static_cast<unsigned int>(x) & static_cast<unsigned int>(y));
+  }
+
+  friend flags operator|(flags x, flags y)
+  {
+    return static_cast<flags>(
+        static_cast<unsigned int>(x) | static_cast<unsigned int>(y));
+  }
+
+  friend flags operator^(flags x, flags y)
+  {
+    return static_cast<flags>(
+        static_cast<unsigned int>(x) ^ static_cast<unsigned int>(y));
+  }
+
+  friend flags operator~(flags x)
+  {
+    return static_cast<flags>(~static_cast<unsigned int>(x));
+  }
+
+  friend flags& operator&=(flags& x, flags y)
+  {
+    x = x & y;
+    return x;
+  }
+
+  friend flags& operator|=(flags& x, flags y)
+  {
+    x = x | y;
+    return x;
+  }
+
+  friend flags& operator^=(flags& x, flags y)
+  {
+    x = x ^ y;
+    return x;
+  }
+#endif
+
+protected:
+  /// Protected destructor to prevent deletion through this type.
+  ~resolver_base()
+  {
+  }
+};
+
+} // namespace ip
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // ASIO_IP_RESOLVER_BASE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/resolver_query_base.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/resolver_query_base.hpp
index bd1bde5..297c9c9 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/resolver_query_base.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/resolver_query_base.hpp
@@ -2,7 +2,7 @@
 // ip/resolver_query_base.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,7 +16,7 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
-#include "asio/detail/socket_types.hpp"
+#include "asio/ip/resolver_base.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -26,95 +26,8 @@ namespace ip {
 /// The resolver_query_base class is used as a base for the
 /// basic_resolver_query class templates to provide a common place to define
 /// the flag constants.
-class resolver_query_base
+class resolver_query_base : public resolver_base
 {
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// A bitmask type (C++ Std [lib.bitmask.types]).
-  typedef unspecified flags;
-
-  /// Determine the canonical name of the host specified in the query.
-  static const flags canonical_name = implementation_defined;
-
-  /// Indicate that returned endpoint is intended for use as a locally bound
-  /// socket endpoint.
-  static const flags passive = implementation_defined;
-
-  /// Host name should be treated as a numeric string defining an IPv4 or IPv6
-  /// address and no name resolution should be attempted.
-  static const flags numeric_host = implementation_defined;
-
-  /// Service name should be treated as a numeric string defining a port number
-  /// and no name resolution should be attempted.
-  static const flags numeric_service = implementation_defined;
-
-  /// If the query protocol family is specified as IPv6, return IPv4-mapped
-  /// IPv6 addresses on finding no IPv6 addresses.
-  static const flags v4_mapped = implementation_defined;
-
-  /// If used with v4_mapped, return all matching IPv6 and IPv4 addresses.
-  static const flags all_matching = implementation_defined;
-
-  /// Only return IPv4 addresses if a non-loopback IPv4 address is configured
-  /// for the system. Only return IPv6 addresses if a non-loopback IPv6 address
-  /// is configured for the system.
-  static const flags address_configured = implementation_defined;
-#else
-  enum flags
-  {
-    canonical_name = ASIO_OS_DEF(AI_CANONNAME),
-    passive = ASIO_OS_DEF(AI_PASSIVE),
-    numeric_host = ASIO_OS_DEF(AI_NUMERICHOST),
-    numeric_service = ASIO_OS_DEF(AI_NUMERICSERV),
-    v4_mapped = ASIO_OS_DEF(AI_V4MAPPED),
-    all_matching = ASIO_OS_DEF(AI_ALL),
-    address_configured = ASIO_OS_DEF(AI_ADDRCONFIG)
-  };
-
-  // Implement bitmask operations as shown in C++ Std [lib.bitmask.types].
-
-  friend flags operator&(flags x, flags y)
-  {
-    return static_cast<flags>(
-        static_cast<unsigned int>(x) & static_cast<unsigned int>(y));
-  }
-
-  friend flags operator|(flags x, flags y)
-  {
-    return static_cast<flags>(
-        static_cast<unsigned int>(x) | static_cast<unsigned int>(y));
-  }
-
-  friend flags operator^(flags x, flags y)
-  {
-    return static_cast<flags>(
-        static_cast<unsigned int>(x) ^ static_cast<unsigned int>(y));
-  }
-
-  friend flags operator~(flags x)
-  {
-    return static_cast<flags>(~static_cast<unsigned int>(x));
-  }
-
-  friend flags& operator&=(flags& x, flags y)
-  {
-    x = x & y;
-    return x;
-  }
-
-  friend flags& operator|=(flags& x, flags y)
-  {
-    x = x | y;
-    return x;
-  }
-
-  friend flags& operator^=(flags& x, flags y)
-  {
-    x = x ^ y;
-    return x;
-  }
-#endif
-
 protected:
   /// Protected destructor to prevent deletion through this type.
   ~resolver_query_base()
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/resolver_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/resolver_service.hpp
index 3255497..18e2dc1 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/resolver_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/resolver_service.hpp
@@ -2,7 +2,7 @@
 // ip/resolver_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,11 +16,15 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #include "asio/async_result.hpp"
 #include "asio/error_code.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/ip/basic_resolver_iterator.hpp"
 #include "asio/ip/basic_resolver_query.hpp"
+#include "asio/ip/basic_resolver_results.hpp"
 
 #if defined(ASIO_WINDOWS_RUNTIME)
 # include "asio/detail/winrt_resolver_service.hpp"
@@ -37,7 +41,7 @@ namespace ip {
 template <typename InternetProtocol>
 class resolver_service
 #if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
+  : public asio::io_context::service
 #else
   : public asio::detail::service_base<
       resolver_service<InternetProtocol> >
@@ -46,7 +50,7 @@ class resolver_service
 public:
 #if defined(GENERATING_DOCUMENTATION)
   /// The unique service identifier.
-  static asio::io_service::id id;
+  static asio::io_context::id id;
 #endif
 
   /// The protocol type.
@@ -61,6 +65,9 @@ public:
   /// The iterator type.
   typedef basic_resolver_iterator<InternetProtocol> iterator_type;
 
+  /// The results type.
+  typedef basic_resolver_results<InternetProtocol> results_type;
+
 private:
   // The type of the platform-specific implementation.
 #if defined(ASIO_WINDOWS_RUNTIME)
@@ -79,11 +86,11 @@ public:
   typedef typename service_impl_type::implementation_type implementation_type;
 #endif
 
-  /// Construct a new resolver service for the specified io_service.
-  explicit resolver_service(asio::io_service& io_service)
+  /// Construct a new resolver service for the specified io_context.
+  explicit resolver_service(asio::io_context& io_context)
     : asio::detail::service_base<
-        resolver_service<InternetProtocol> >(io_service),
-      service_impl_(io_service)
+        resolver_service<InternetProtocol> >(io_context),
+      service_impl_(io_context)
   {
   }
 
@@ -93,6 +100,23 @@ public:
     service_impl_.construct(impl);
   }
 
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+  /// Move-construct a new resolver implementation.
+  void move_construct(implementation_type& impl,
+      implementation_type& other_impl)
+  {
+    service_impl_.move_construct(impl, other_impl);
+  }
+
+  /// Move-assign from another resolver implementation.
+  void move_assign(implementation_type& impl,
+      resolver_service& other_service,
+      implementation_type& other_impl)
+  {
+    service_impl_.move_assign(impl, other_service.service_impl_, other_impl);
+  }
+#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+
   /// Destroy a resolver implementation.
   void destroy(implementation_type& impl)
   {
@@ -106,7 +130,7 @@ public:
   }
 
   /// Resolve a query to a list of entries.
-  iterator_type resolve(implementation_type& impl, const query_type& query,
+  results_type resolve(implementation_type& impl, const query_type& query,
       asio::error_code& ec)
   {
     return service_impl_.resolve(impl, query, ec);
@@ -115,20 +139,20 @@ public:
   /// Asynchronously resolve a query to a list of entries.
   template <typename ResolveHandler>
   ASIO_INITFN_RESULT_TYPE(ResolveHandler,
-      void (asio::error_code, iterator_type))
+      void (asio::error_code, results_type))
   async_resolve(implementation_type& impl, const query_type& query,
       ASIO_MOVE_ARG(ResolveHandler) handler)
   {
     asio::async_completion<ResolveHandler,
-      void (asio::error_code, iterator_type)> init(handler);
+      void (asio::error_code, results_type)> init(handler);
 
-    service_impl_.async_resolve(impl, query, init.handler);
+    service_impl_.async_resolve(impl, query, init.completion_handler);
 
     return init.result.get();
   }
 
   /// Resolve an endpoint to a list of entries.
-  iterator_type resolve(implementation_type& impl,
+  results_type resolve(implementation_type& impl,
       const endpoint_type& endpoint, asio::error_code& ec)
   {
     return service_impl_.resolve(impl, endpoint, ec);
@@ -137,29 +161,29 @@ public:
   /// Asynchronously resolve an endpoint to a list of entries.
   template <typename ResolveHandler>
   ASIO_INITFN_RESULT_TYPE(ResolveHandler,
-      void (asio::error_code, iterator_type))
+      void (asio::error_code, results_type))
   async_resolve(implementation_type& impl, const endpoint_type& endpoint,
       ASIO_MOVE_ARG(ResolveHandler) handler)
   {
     asio::async_completion<ResolveHandler,
-      void (asio::error_code, iterator_type)> init(handler);
+      void (asio::error_code, results_type)> init(handler);
 
-    service_impl_.async_resolve(impl, endpoint, init.handler);
+    service_impl_.async_resolve(impl, endpoint, init.completion_handler);
 
     return init.result.get();
   }
 
 private:
   // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
+  void shutdown()
   {
-    service_impl_.shutdown_service();
+    service_impl_.shutdown();
   }
 
   // Perform any fork-related housekeeping.
-  void fork_service(asio::io_service::fork_event event)
+  void notify_fork(asio::io_context::fork_event event)
   {
-    service_impl_.fork_service(event);
+    service_impl_.notify_fork(event);
   }
 
   // The platform-specific implementation.
@@ -171,4 +195,6 @@ private:
 
 #include "asio/detail/pop_options.hpp"
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_IP_RESOLVER_SERVICE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/tcp.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/tcp.hpp
index 90009f4..40e5470 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/tcp.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/tcp.hpp
@@ -2,7 +2,7 @@
 // ip/tcp.hpp
 // ~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -99,7 +99,7 @@ public:
    * @par Examples
    * Setting the option:
    * @code
-   * asio::ip::tcp::socket socket(io_service); 
+   * asio::ip::tcp::socket socket(io_context); 
    * ...
    * asio::ip::tcp::no_delay option(true);
    * socket.set_option(option);
@@ -108,7 +108,7 @@ public:
    * @par
    * Getting the current option value:
    * @code
-   * asio::ip::tcp::socket socket(io_service); 
+   * asio::ip::tcp::socket socket(io_context); 
    * ...
    * asio::ip::tcp::no_delay option;
    * socket.get_option(option);
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/udp.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/udp.hpp
index 35c3f95..a011acc 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/udp.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/udp.hpp
@@ -2,7 +2,7 @@
 // ip/udp.hpp
 // ~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/unicast.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/unicast.hpp
index b07d10b..8b768c2 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/unicast.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/unicast.hpp
@@ -2,7 +2,7 @@
 // ip/unicast.hpp
 // ~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -32,7 +32,7 @@ namespace unicast {
  * @par Examples
  * Setting the option:
  * @code
- * asio::ip::udp::socket socket(io_service); 
+ * asio::ip::udp::socket socket(io_context); 
  * ...
  * asio::ip::unicast::hops option(4);
  * socket.set_option(option);
@@ -41,7 +41,7 @@ namespace unicast {
  * @par
  * Getting the current option value:
  * @code
- * asio::ip::udp::socket socket(io_service); 
+ * asio::ip::udp::socket socket(io_context); 
  * ...
  * asio::ip::unicast::hops option;
  * socket.get_option(option);
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/v6_only.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/v6_only.hpp
index 9b51097..9106b25 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/v6_only.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ip/v6_only.hpp
@@ -2,7 +2,7 @@
 // ip/v6_only.hpp
 // ~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -31,7 +31,7 @@ namespace ip {
  * @par Examples
  * Setting the option:
  * @code
- * asio::ip::tcp::socket socket(io_service); 
+ * asio::ip::tcp::socket socket(io_context); 
  * ...
  * asio::ip::v6_only option(true);
  * socket.set_option(option);
@@ -40,7 +40,7 @@ namespace ip {
  * @par
  * Getting the current option value:
  * @code
- * asio::ip::tcp::socket socket(io_service); 
+ * asio::ip::tcp::socket socket(io_context); 
  * ...
  * asio::ip::v6_only option;
  * socket.get_option(option);
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/is_executor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/is_executor.hpp
index 59981ad..d5abf7b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/is_executor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/is_executor.hpp
@@ -2,7 +2,7 @@
 // is_executor.hpp
 // ~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,7 +16,7 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
-#include "asio/detail/type_traits.hpp"
+#include "asio/detail/is_executor.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -25,13 +25,19 @@ namespace asio {
 /// The is_executor trait detects whether a type T meets the Executor type
 /// requirements.
 /**
- * Meets the UnaryTypeTrait requirements. The asio library implementation
- * provides a definition that is derived from false_type. A program may
- * specialise this template to derive from true_type for a user-defined type T
- * that meets the Executor requirements.
+ * Class template @c is_executor is a UnaryTypeTrait that is derived from @c
+ * true_type if the type @c T meets the syntactic requirements for Executor,
+ * otherwise @c false_type.
  */
 template <typename T>
-struct is_executor : false_type {};
+struct is_executor
+#if defined(GENERATING_DOCUMENTATION)
+  : integral_constant<bool, automatically_determined>
+#else // defined(GENERATING_DOCUMENTATION)
+  : asio::detail::is_executor<T>
+#endif // defined(GENERATING_DOCUMENTATION)
+{
+};
 
 } // namespace asio
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/is_read_buffered.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/is_read_buffered.hpp
index 5fcfa94..10483b1 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/is_read_buffered.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/is_read_buffered.hpp
@@ -2,7 +2,7 @@
 // is_read_buffered.hpp
 // ~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/is_write_buffered.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/is_write_buffered.hpp
index 2f71b1d..b0efbbb 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/is_write_buffered.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/is_write_buffered.hpp
@@ -2,7 +2,7 @@
 // is_write_buffered.hpp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/local/basic_endpoint.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/local/basic_endpoint.hpp
index 9a19ab0..ae30100 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/local/basic_endpoint.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/local/basic_endpoint.hpp
@@ -2,7 +2,7 @@
 // local/basic_endpoint.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Derived from a public domain implementation written by Daniel Casimiro.
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/local/connect_pair.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/local/connect_pair.hpp
index 2d785d5..3542d9b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/local/connect_pair.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/local/connect_pair.hpp
@@ -2,7 +2,7 @@
 // local/connect_pair.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -32,32 +32,32 @@ namespace asio {
 namespace local {
 
 /// Create a pair of connected sockets.
-template <typename Protocol, typename SocketService1, typename SocketService2>
+template <typename Protocol ASIO_SVC_TPARAM ASIO_SVC_TPARAM1>
 void connect_pair(
-    basic_socket<Protocol, SocketService1>& socket1,
-    basic_socket<Protocol, SocketService2>& socket2);
+    basic_socket<Protocol ASIO_SVC_TARG>& socket1,
+    basic_socket<Protocol ASIO_SVC_TARG1>& socket2);
 
 /// Create a pair of connected sockets.
-template <typename Protocol, typename SocketService1, typename SocketService2>
-asio::error_code connect_pair(
-    basic_socket<Protocol, SocketService1>& socket1,
-    basic_socket<Protocol, SocketService2>& socket2,
+template <typename Protocol ASIO_SVC_TPARAM ASIO_SVC_TPARAM1>
+ASIO_SYNC_OP_VOID connect_pair(
+    basic_socket<Protocol ASIO_SVC_TARG>& socket1,
+    basic_socket<Protocol ASIO_SVC_TARG1>& socket2,
     asio::error_code& ec);
 
-template <typename Protocol, typename SocketService1, typename SocketService2>
+template <typename Protocol ASIO_SVC_TPARAM ASIO_SVC_TPARAM1>
 inline void connect_pair(
-    basic_socket<Protocol, SocketService1>& socket1,
-    basic_socket<Protocol, SocketService2>& socket2)
+    basic_socket<Protocol ASIO_SVC_TARG>& socket1,
+    basic_socket<Protocol ASIO_SVC_TARG1>& socket2)
 {
   asio::error_code ec;
   connect_pair(socket1, socket2, ec);
   asio::detail::throw_error(ec, "connect_pair");
 }
 
-template <typename Protocol, typename SocketService1, typename SocketService2>
-inline asio::error_code connect_pair(
-    basic_socket<Protocol, SocketService1>& socket1,
-    basic_socket<Protocol, SocketService2>& socket2,
+template <typename Protocol ASIO_SVC_TPARAM ASIO_SVC_TPARAM1>
+inline ASIO_SYNC_OP_VOID connect_pair(
+    basic_socket<Protocol ASIO_SVC_TARG>& socket1,
+    basic_socket<Protocol ASIO_SVC_TARG1>& socket2,
     asio::error_code& ec)
 {
   // Check that this function is only being used with a UNIX domain socket.
@@ -70,27 +70,29 @@ inline asio::error_code connect_pair(
   if (asio::detail::socket_ops::socketpair(protocol.family(),
         protocol.type(), protocol.protocol(), sv, ec)
       == asio::detail::socket_error_retval)
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
 
-  if (socket1.assign(protocol, sv[0], ec))
+  socket1.assign(protocol, sv[0], ec);
+  if (ec)
   {
     asio::error_code temp_ec;
     asio::detail::socket_ops::state_type state[2] = { 0, 0 };
     asio::detail::socket_ops::close(sv[0], state[0], true, temp_ec);
     asio::detail::socket_ops::close(sv[1], state[1], true, temp_ec);
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
-  if (socket2.assign(protocol, sv[1], ec))
+  socket2.assign(protocol, sv[1], ec);
+  if (ec)
   {
     asio::error_code temp_ec;
     socket1.close(temp_ec);
     asio::detail::socket_ops::state_type state = 0;
     asio::detail::socket_ops::close(sv[1], state, true, temp_ec);
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 } // namespace local
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/local/datagram_protocol.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/local/datagram_protocol.hpp
index 3fa062c..17773d7 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/local/datagram_protocol.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/local/datagram_protocol.hpp
@@ -2,7 +2,7 @@
 // local/datagram_protocol.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/local/detail/endpoint.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/local/detail/endpoint.hpp
index 43c6673..6125e97 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/local/detail/endpoint.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/local/detail/endpoint.hpp
@@ -2,7 +2,7 @@
 // local/detail/endpoint.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Derived from a public domain implementation written by Daniel Casimiro.
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/local/detail/impl/endpoint.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/local/detail/impl/endpoint.ipp
index aad7556..adda630 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/local/detail/impl/endpoint.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/local/detail/impl/endpoint.ipp
@@ -2,7 +2,7 @@
 // local/detail/impl/endpoint.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Derived from a public domain implementation written by Daniel Casimiro.
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/local/stream_protocol.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/local/stream_protocol.hpp
index 7fe9772..e8094cc 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/local/stream_protocol.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/local/stream_protocol.hpp
@@ -2,7 +2,7 @@
 // local/stream_protocol.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/package.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/package.hpp
deleted file mode 100644
index b8158b4..0000000
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/package.hpp
+++ /dev/null
@@ -1,294 +0,0 @@
-//
-// package.hpp
-// ~~~~~~~~~~~
-//
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_USE_PACKAGE_HPP
-#define ASIO_USE_PACKAGE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <future>
-#include <memory>
-#include "asio/async_result.hpp"
-#include "asio/detail/type_traits.hpp"
-#include "asio/detail/variadic_templates.hpp"
-#include "asio/handler_type.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Class to enable lazy construction of a packaged_task from a completion
-/// token.
-/**
- * The packaged_token class is used to adapt a function object as a packaged
- * task. When this adapter is passed as a completion token to an asynchronous
- * operation, the result of the function object is retuned via a std::future.
- *
- * Use the @ref package function rather than using this class directly.
- */
-template <typename Function, typename Allocator = std::allocator<void> >
-class packaged_token
-{
-public:
-  /// The allocator type. The allocator is used when constructing the
-  /// @c std::promise object for a given asynchronous operation.
-  typedef Allocator allocator_type;
-
-  /// Construct using specified allocator.
-  explicit packaged_token(Function f)
-    : func_(std::move(f))
-  {
-  }
-
-  /// Construct using specified allocator.
-  packaged_token(Function f, const Allocator& allocator)
-    : func_(std::move(f)),
-      allocator_(allocator)
-  {
-  }
-
-  /// Obtain allocator.
-  allocator_type get_allocator() const ASIO_NOEXCEPT
-  {
-    return allocator_;
-  }
-
-private:
-  template <class, class> friend class packaged_handler;
-  Function func_;
-  Allocator allocator_;
-};
-
-/// A packaged_task with an associated allocator.
-template <typename Signature, typename Allocator>
-class packaged_handler : public std::packaged_task<Signature>
-{
-public:
-  /// The allocator type. The allocator is used when constructing the
-  /// @c std::promise object for a given asynchronous operation.
-  typedef Allocator allocator_type;
-
-  /// Construct from a packaged token.
-  template <typename Function>
-  packaged_handler(
-      packaged_token<Function, Allocator>&& token)
-#if defined(_MSC_VER)
-    : std::packaged_task<Signature>(std::move(token.func_)),
-#elif defined(ASIO_HAS_CLANG_LIBCXX)
-    : std::packaged_task<Signature>(std::allocator_arg,
-        typename std::allocator_traits<
-          Allocator>::template rebind_alloc<char>(token.allocator_),
-        std::move(token.func_)),
-#else
-    : std::packaged_task<Signature>(std::allocator_arg,
-        token.allocator_, std::move(token.func_)),
-#endif
-      allocator_(token.allocator_)
-  {
-  }
-
-  /// Move construct from another packaged handler.
-  packaged_handler(packaged_handler&& other)
-    : std::packaged_task<Signature>(
-        static_cast<std::packaged_task<Signature>&&>(other)),
-      allocator_(other.allocator_)
-  {
-  }
-
-  /// Obtain allocator.
-  allocator_type get_allocator() const ASIO_NOEXCEPT
-  {
-    return allocator_;
-  }
-
-private:
-  Allocator allocator_;
-};
-
-/// Wrap a function object in a packaged task.
-/**
- * The @c package function is used to adapt a function object as a packaged
- * task. When this adapter is passed as a completion token to an asynchronous
- * operation, the result of the function object is retuned via a std::future.
- *
- * @par Example
- *
- * @code std::future<std::size_t> fut =
- *   my_socket.async_read_some(buffer,
- *     package([](asio::error_code ec, std::size_t n)
- *       {
- *         return ec ? 0 : n;
- *       }));
- * ...
- * std::size_t n = fut.get(); @endcode
- */
-template <typename Function>
-inline packaged_token<typename decay<Function>::type, std::allocator<void> >
-package(ASIO_MOVE_ARG(Function) function)
-{
-  return packaged_token<typename decay<Function>::type, std::allocator<void> >(
-      ASIO_MOVE_CAST(Function)(function), std::allocator<void>());
-}
-
-/// Wrap a function object in a packaged task.
-/**
- * The @c package function is used to adapt a function object as a packaged
- * task. When this adapter is passed as a completion token to an asynchronous
- * operation, the result of the function object is retuned via a std::future.
- *
- * @par Example
- *
- * @code std::future<std::size_t> fut =
- *   my_socket.async_read_some(buffer,
- *     package([](asio::error_code ec, std::size_t n)
- *       {
- *         return ec ? 0 : n;
- *       }));
- * ...
- * std::size_t n = fut.get(); @endcode
- */
-template <typename Function, typename Allocator>
-inline packaged_token<typename decay<Function>::type, Allocator> package(
-    ASIO_MOVE_ARG(Function) function, const Allocator& a)
-{
-  return packaged_token<typename decay<Function>::type, Allocator>(
-      ASIO_MOVE_CAST(Function)(function), a);
-}
-
-#if !defined(GENERATING_DOCUMENTATION)
-
-#if defined(ASIO_HAS_VARIADIC_TEMPLATES)
-
-template <typename Function, typename Allocator, typename R, typename... Args>
-struct handler_type<packaged_token<Function, Allocator>, R(Args...)>
-{
-  typedef packaged_handler<
-    typename result_of<Function(Args...)>::type(Args...),
-      Allocator> type;
-};
-
-#else // defined(ASIO_HAS_VARIADIC_TEMPLATES)
-
-template <typename Function, typename Allocator, typename R>
-struct handler_type<packaged_token<Function, Allocator>, R()>
-{
-  typedef packaged_handler<
-    typename result_of<Function()>::type(),
-      Allocator> type;
-};
-
-#define ASIO_PRIVATE_HANDLER_TYPE_DEF(n) \
-  template <typename Function, typename Allocator, \
-    typename R, ASIO_VARIADIC_TPARAMS(n)> \
-  struct handler_type< \
-    packaged_token<Function, Allocator>, R(ASIO_VARIADIC_TARGS(n))> \
-  { \
-    typedef packaged_handler< \
-      typename result_of< \
-        Function(ASIO_VARIADIC_TARGS(n))>::type( \
-          ASIO_VARIADIC_TARGS(n)), \
-            Allocator> type; \
-  }; \
-  /**/
-  ASIO_VARIADIC_GENERATE(ASIO_PRIVATE_HANDLER_TYPE_DEF)
-#undef ASIO_PRIVATE_HANDLER_TYPE_DEF
-
-#endif // defined(ASIO_HAS_VARIADIC_TEMPLATES)
-
-#if defined(ASIO_HAS_VARIADIC_TEMPLATES)
-
-template <typename R, typename... Args>
-class async_result<std::packaged_task<R(Args...)> >
-{
-public:
-  typedef std::future<R> type;
-
-  explicit async_result(std::packaged_task<R(Args...)>& h)
-    : future_(h.get_future())
-  {
-  }
-
-  type get()
-  {
-    return std::move(future_);
-  }
-
-private:
-  type future_;
-};
-
-#else // defined(ASIO_HAS_VARIADIC_TEMPLATES)
-
-template <typename R>
-class async_result<std::packaged_task<R()> >
-{
-public:
-  typedef std::future<R> type;
-
-  explicit async_result(std::packaged_task<R()>& h)
-    : future_(h.get_future())
-  {
-  }
-
-  type get()
-  {
-    return std::move(future_);
-  }
-
-private:
-  type future_;
-};
-
-#define ASIO_PRIVATE_ASYNC_RESULT_DEF(n) \
-  template <typename R, ASIO_VARIADIC_TPARAMS(n)> \
-  class async_result<std::packaged_task<R(ASIO_VARIADIC_TARGS(n))> > \
-  { \
-  public: \
-    typedef std::future<R> type; \
-  \
-    explicit async_result( \
-        std::packaged_task<R(ASIO_VARIADIC_TARGS(n))>& h) \
-      : future_(h.get_future()) \
-    { \
-    } \
-  \
-    type get() \
-    { \
-      return std::move(future_); \
-    } \
-  \
-  private: \
-    type future_; \
-  }; \
-  /**/
-  ASIO_VARIADIC_GENERATE(ASIO_PRIVATE_ASYNC_RESULT_DEF)
-#undef ASIO_PRIVATE_ASYNC_RESULT_DEF
-
-#endif // defined(ASIO_HAS_VARIADIC_TEMPLATES)
-
-template <typename Signature, typename Allocator>
-class async_result<packaged_handler<Signature, Allocator>>
-  : public async_result<std::packaged_task<Signature>>
-{
-public:
-  explicit async_result(packaged_handler<Signature, Allocator>& h)
-    : async_result<std::packaged_task<Signature>>(h) {}
-};
-
-#endif // !defined(GENERATING_DOCUMENTATION)
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_USE_PACKAGE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/packaged_task.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/packaged_task.hpp
new file mode 100644
index 0000000..af8d689
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/packaged_task.hpp
@@ -0,0 +1,126 @@
+//
+// packaged_task.hpp
+// ~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_PACKAGED_TASK_HPP
+#define ASIO_PACKAGED_TASK_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+
+#if defined(ASIO_HAS_STD_FUTURE) \
+  || defined(GENERATING_DOCUMENTATION)
+
+#include <future>
+#include "asio/async_result.hpp"
+#include "asio/detail/type_traits.hpp"
+#include "asio/detail/variadic_templates.hpp"
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+
+#if defined(ASIO_HAS_VARIADIC_TEMPLATES) \
+  || defined(GENERATING_DOCUMENTATION)
+
+/// Partial specialisation of @c async_result for @c std::packaged_task.
+template <typename Result, typename... Args, typename Signature>
+class async_result<std::packaged_task<Result(Args...)>, Signature>
+{
+public:
+  /// The packaged task is the concrete completion handler type.
+  typedef std::packaged_task<Result(Args...)> completion_handler_type;
+
+  /// The return type of the initiating function is the future obtained from
+  /// the packaged task.
+  typedef std::future<Result> return_type;
+
+  /// The constructor extracts the future from the packaged task.
+  explicit async_result(completion_handler_type& h)
+    : future_(h.get_future())
+  {
+  }
+
+  /// Returns the packaged task's future.
+  return_type get()
+  {
+    return std::move(future_);
+  }
+
+private:
+  return_type future_;
+};
+
+#else // defined(ASIO_HAS_VARIADIC_TEMPLATES)
+      //   || defined(GENERATING_DOCUMENTATION)
+
+template <typename Result, typename Signature>
+struct async_result<std::packaged_task<Result()>, Signature>
+{
+  typedef std::packaged_task<Result()> completion_handler_type;
+  typedef std::future<Result> return_type;
+
+  explicit async_result(completion_handler_type& h)
+    : future_(h.get_future())
+  {
+  }
+
+  return_type get()
+  {
+    return std::move(future_);
+  }
+
+private:
+  return_type future_;
+};
+
+#define ASIO_PRIVATE_ASYNC_RESULT_DEF(n) \
+  template <typename Result, \
+    ASIO_VARIADIC_TPARAMS(n), typename Signature> \
+  class async_result< \
+    std::packaged_task<Result(ASIO_VARIADIC_TARGS(n))>, Signature> \
+  { \
+  public: \
+    typedef std::packaged_task< \
+      Result(ASIO_VARIADIC_TARGS(n))> \
+        completion_handler_type; \
+  \
+    typedef std::future<Result> return_type; \
+  \
+    explicit async_result(completion_handler_type& h) \
+      : future_(h.get_future()) \
+    { \
+    } \
+  \
+    return_type get() \
+    { \
+      return std::move(future_); \
+    } \
+  \
+  private: \
+    return_type future_; \
+  }; \
+  /**/
+  ASIO_VARIADIC_GENERATE(ASIO_PRIVATE_ASYNC_RESULT_DEF)
+#undef ASIO_PRIVATE_ASYNC_RESULT_DEF
+
+#endif // defined(ASIO_HAS_VARIADIC_TEMPLATES)
+       //   || defined(GENERATING_DOCUMENTATION)
+
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // defined(ASIO_HAS_STD_FUTURE)
+       //   || defined(GENERATING_DOCUMENTATION)
+
+#endif // ASIO_PACKAGED_TASK_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/placeholders.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/placeholders.hpp
index 011cf26..8e6e2e5 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/placeholders.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/placeholders.hpp
@@ -2,7 +2,7 @@
 // placeholders.hpp
 // ~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -40,10 +40,20 @@ unspecified bytes_transferred;
 
 /// An argument placeholder, for use with boost::bind(), that corresponds to
 /// the iterator argument of a handler for asynchronous functions such as
-/// asio::basic_resolver::async_resolve.
+/// asio::async_connect.
 unspecified iterator;
 
 /// An argument placeholder, for use with boost::bind(), that corresponds to
+/// the results argument of a handler for asynchronous functions such as
+/// asio::basic_resolver::async_resolve.
+unspecified results;
+
+/// An argument placeholder, for use with boost::bind(), that corresponds to
+/// the results argument of a handler for asynchronous functions such as
+/// asio::async_connect.
+unspecified endpoint;
+
+/// An argument placeholder, for use with boost::bind(), that corresponds to
 /// the signal_number argument of a handler for asynchronous functions such as
 /// asio::signal_set::async_wait.
 unspecified signal_number;
@@ -66,6 +76,16 @@ inline boost::arg<2> iterator()
   return boost::arg<2>();
 }
 
+inline boost::arg<2> results()
+{
+  return boost::arg<2>();
+}
+
+inline boost::arg<2> endpoint()
+{
+  return boost::arg<2>();
+}
+
 inline boost::arg<2> signal_number()
 {
   return boost::arg<2>();
@@ -94,6 +114,10 @@ static boost::arg<2>& bytes_transferred
   = asio::placeholders::detail::placeholder<2>::get();
 static boost::arg<2>& iterator
   = asio::placeholders::detail::placeholder<2>::get();
+static boost::arg<2>& results
+  = asio::placeholders::detail::placeholder<2>::get();
+static boost::arg<2>& endpoint
+  = asio::placeholders::detail::placeholder<2>::get();
 static boost::arg<2>& signal_number
   = asio::placeholders::detail::placeholder<2>::get();
 
@@ -107,6 +131,10 @@ namespace
     = asio::placeholders::detail::placeholder<2>::get();
   boost::arg<2>& iterator
     = asio::placeholders::detail::placeholder<2>::get();
+  boost::arg<2>& results
+    = asio::placeholders::detail::placeholder<2>::get();
+  boost::arg<2>& endpoint
+    = asio::placeholders::detail::placeholder<2>::get();
   boost::arg<2>& signal_number
     = asio::placeholders::detail::placeholder<2>::get();
 } // namespace
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/basic_descriptor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/basic_descriptor.hpp
index 9aa18f3..27db872 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/basic_descriptor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/basic_descriptor.hpp
@@ -2,7 +2,7 @@
 // posix/basic_descriptor.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,6 +17,8 @@
 
 #include "asio/detail/config.hpp"
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #if defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR) \
   || defined(GENERATING_DOCUMENTATION)
 
@@ -55,12 +57,12 @@ public:
   /**
    * This constructor creates a descriptor without opening it.
    *
-   * @param io_service The io_service object that the descriptor will use to
+   * @param io_context The io_context object that the descriptor will use to
    * dispatch handlers for any asynchronous operations performed on the
    * descriptor.
    */
-  explicit basic_descriptor(asio::io_service& io_service)
-    : basic_io_object<DescriptorService>(io_service)
+  explicit basic_descriptor(asio::io_context& io_context)
+    : basic_io_object<DescriptorService>(io_context)
   {
   }
 
@@ -69,7 +71,7 @@ public:
    * This constructor creates a descriptor object to hold an existing native
    * descriptor.
    *
-   * @param io_service The io_service object that the descriptor will use to
+   * @param io_context The io_context object that the descriptor will use to
    * dispatch handlers for any asynchronous operations performed on the
    * descriptor.
    *
@@ -77,9 +79,9 @@ public:
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_descriptor(asio::io_service& io_service,
+  basic_descriptor(asio::io_context& io_context,
       const native_handle_type& native_descriptor)
-    : basic_io_object<DescriptorService>(io_service)
+    : basic_io_object<DescriptorService>(io_context)
   {
     asio::error_code ec;
     this->get_service().assign(this->get_implementation(),
@@ -96,7 +98,7 @@ public:
    * occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_descriptor(io_service&) constructor.
+   * constructed using the @c basic_descriptor(io_context&) constructor.
    */
   basic_descriptor(basic_descriptor&& other)
     : basic_io_object<DescriptorService>(
@@ -112,7 +114,7 @@ public:
    * occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_descriptor(io_service&) constructor.
+   * constructed using the @c basic_descriptor(io_context&) constructor.
    */
   basic_descriptor& operator=(basic_descriptor&& other)
   {
@@ -174,11 +176,12 @@ public:
    *
    * @param ec Set to indicate what error occurred, if any.
    */
-  asio::error_code assign(const native_handle_type& native_descriptor,
+  ASIO_SYNC_OP_VOID assign(const native_handle_type& native_descriptor,
       asio::error_code& ec)
   {
-    return this->get_service().assign(
+    this->get_service().assign(
         this->get_implementation(), native_descriptor, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Determine whether the descriptor is open.
@@ -212,9 +215,10 @@ public:
    * @param ec Set to indicate what error occurred, if any. Note that, even if
    * the function indicates an error, the underlying descriptor is closed.
    */
-  asio::error_code close(asio::error_code& ec)
+  ASIO_SYNC_OP_VOID close(asio::error_code& ec)
   {
-    return this->get_service().close(this->get_implementation(), ec);
+    this->get_service().close(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the native descriptor representation.
@@ -266,9 +270,10 @@ public:
    *
    * @param ec Set to indicate what error occurred, if any.
    */
-  asio::error_code cancel(asio::error_code& ec)
+  ASIO_SYNC_OP_VOID cancel(asio::error_code& ec)
   {
-    return this->get_service().cancel(this->get_implementation(), ec);
+    this->get_service().cancel(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Perform an IO control command on the descriptor.
@@ -286,7 +291,7 @@ public:
    * @par Example
    * Getting the number of bytes ready to read:
    * @code
-   * asio::posix::stream_descriptor descriptor(io_service);
+   * asio::posix::stream_descriptor descriptor(io_context);
    * ...
    * asio::posix::stream_descriptor::bytes_readable command;
    * descriptor.io_control(command);
@@ -316,7 +321,7 @@ public:
    * @par Example
    * Getting the number of bytes ready to read:
    * @code
-   * asio::posix::stream_descriptor descriptor(io_service);
+   * asio::posix::stream_descriptor descriptor(io_context);
    * ...
    * asio::posix::stream_descriptor::bytes_readable command;
    * asio::error_code ec;
@@ -329,11 +334,11 @@ public:
    * @endcode
    */
   template <typename IoControlCommand>
-  asio::error_code io_control(IoControlCommand& command,
+  ASIO_SYNC_OP_VOID io_control(IoControlCommand& command,
       asio::error_code& ec)
   {
-    return this->get_service().io_control(
-        this->get_implementation(), command, ec);
+    this->get_service().io_control(this->get_implementation(), command, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Gets the non-blocking mode of the descriptor.
@@ -385,11 +390,11 @@ public:
    * operations. Asynchronous operations will never fail with the error
    * asio::error::would_block.
    */
-  asio::error_code non_blocking(
+  ASIO_SYNC_OP_VOID non_blocking(
       bool mode, asio::error_code& ec)
   {
-    return this->get_service().non_blocking(
-        this->get_implementation(), mode, ec);
+    this->get_service().non_blocking(this->get_implementation(), mode, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Gets the non-blocking mode of the native descriptor implementation.
@@ -450,11 +455,12 @@ public:
    * function fails with asio::error::invalid_argument, as the
    * combination does not make sense.
    */
-  asio::error_code native_non_blocking(
+  ASIO_SYNC_OP_VOID native_non_blocking(
       bool mode, asio::error_code& ec)
   {
-    return this->get_service().native_non_blocking(
+    this->get_service().native_non_blocking(
         this->get_implementation(), mode, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Wait for the descriptor to become ready to read, ready to write, or to
@@ -468,7 +474,7 @@ public:
    * @par Example
    * Waiting for a descriptor to become readable.
    * @code
-   * asio::posix::stream_descriptor descriptor(io_service);
+   * asio::posix::stream_descriptor descriptor(io_context);
    * ...
    * descriptor.wait(asio::posix::stream_descriptor::wait_read);
    * @endcode
@@ -493,15 +499,16 @@ public:
    * @par Example
    * Waiting for a descriptor to become readable.
    * @code
-   * asio::posix::stream_descriptor descriptor(io_service);
+   * asio::posix::stream_descriptor descriptor(io_context);
    * ...
    * asio::error_code ec;
    * descriptor.wait(asio::posix::stream_descriptor::wait_read, ec);
    * @endcode
    */
-  asio::error_code wait(wait_type w, asio::error_code& ec)
+  ASIO_SYNC_OP_VOID wait(wait_type w, asio::error_code& ec)
   {
-    return this->get_service().wait(this->get_implementation(), w, ec);
+    this->get_service().wait(this->get_implementation(), w, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Asynchronously wait for the descriptor to become ready to read, ready to
@@ -521,7 +528,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @par Example
    * @code
@@ -535,7 +542,7 @@ public:
    *
    * ...
    *
-   * asio::posix::stream_descriptor descriptor(io_service);
+   * asio::posix::stream_descriptor descriptor(io_context);
    * ...
    * descriptor.async_wait(
    *     asio::posix::stream_descriptor::wait_read,
@@ -570,4 +577,6 @@ protected:
 #endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
        //   || defined(GENERATING_DOCUMENTATION)
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_POSIX_BASIC_DESCRIPTOR_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/basic_stream_descriptor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/basic_stream_descriptor.hpp
index f185c30..eb7bc8b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/basic_stream_descriptor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/basic_stream_descriptor.hpp
@@ -2,7 +2,7 @@
 // posix/basic_stream_descriptor.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,6 +17,8 @@
 
 #include "asio/detail/config.hpp"
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #if defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR) \
   || defined(GENERATING_DOCUMENTATION)
 
@@ -59,12 +61,12 @@ public:
    * descriptor needs to be opened and then connected or accepted before data
    * can be sent or received on it.
    *
-   * @param io_service The io_service object that the stream descriptor will
+   * @param io_context The io_context object that the stream descriptor will
    * use to dispatch handlers for any asynchronous operations performed on the
    * descriptor.
    */
-  explicit basic_stream_descriptor(asio::io_service& io_service)
-    : basic_descriptor<StreamDescriptorService>(io_service)
+  explicit basic_stream_descriptor(asio::io_context& io_context)
+    : basic_descriptor<StreamDescriptorService>(io_context)
   {
   }
 
@@ -73,7 +75,7 @@ public:
    * This constructor creates a stream descriptor object to hold an existing
    * native descriptor.
    *
-   * @param io_service The io_service object that the stream descriptor will
+   * @param io_context The io_context object that the stream descriptor will
    * use to dispatch handlers for any asynchronous operations performed on the
    * descriptor.
    *
@@ -81,9 +83,9 @@ public:
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_stream_descriptor(asio::io_service& io_service,
+  basic_stream_descriptor(asio::io_context& io_context,
       const native_handle_type& native_descriptor)
-    : basic_descriptor<StreamDescriptorService>(io_service, native_descriptor)
+    : basic_descriptor<StreamDescriptorService>(io_context, native_descriptor)
   {
   }
 
@@ -96,7 +98,7 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_stream_descriptor(io_service&) constructor.
+   * constructed using the @c basic_stream_descriptor(io_context&) constructor.
    */
   basic_stream_descriptor(basic_stream_descriptor&& other)
     : basic_descriptor<StreamDescriptorService>(
@@ -113,7 +115,7 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_stream_descriptor(io_service&) constructor.
+   * constructed using the @c basic_stream_descriptor(io_context&) constructor.
    */
   basic_stream_descriptor& operator=(basic_stream_descriptor&& other)
   {
@@ -204,7 +206,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The write operation may not transmit all of the data to the peer.
    * Consider using the @ref async_write function if you need to ensure that all
@@ -316,7 +318,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The read operation may not read all of the requested number of bytes.
    * Consider using the @ref async_read function if you need to ensure that the
@@ -355,4 +357,6 @@ public:
 #endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
        //   || defined(GENERATING_DOCUMENTATION)
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_POSIX_BASIC_STREAM_DESCRIPTOR_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/descriptor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/descriptor.hpp
new file mode 100644
index 0000000..9ab46a5
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/descriptor.hpp
@@ -0,0 +1,644 @@
+//
+// posix/descriptor.hpp
+// ~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_POSIX_DESCRIPTOR_HPP
+#define ASIO_POSIX_DESCRIPTOR_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+
+#if !defined(ASIO_ENABLE_OLD_SERVICES)
+
+#if defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR) \
+  || defined(GENERATING_DOCUMENTATION)
+
+#include "asio/async_result.hpp"
+#include "asio/basic_io_object.hpp"
+#include "asio/detail/handler_type_requirements.hpp"
+#include "asio/detail/reactive_descriptor_service.hpp"
+#include "asio/detail/throw_error.hpp"
+#include "asio/error.hpp"
+#include "asio/io_context.hpp"
+#include "asio/posix/descriptor_base.hpp"
+
+#if defined(ASIO_HAS_MOVE)
+# include <utility>
+#endif // defined(ASIO_HAS_MOVE)
+
+#define ASIO_SVC_T asio::detail::reactive_descriptor_service
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+namespace posix {
+
+/// Provides POSIX descriptor functionality.
+/**
+ * The posix::descriptor class template provides the ability to wrap a
+ * POSIX descriptor.
+ *
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Unsafe.
+ */
+class descriptor
+  : ASIO_SVC_ACCESS basic_io_object<ASIO_SVC_T>,
+    public descriptor_base
+{
+public:
+  /// The type of the executor associated with the object.
+  typedef io_context::executor_type executor_type;
+
+  /// The native representation of a descriptor.
+#if defined(GENERATING_DOCUMENTATION)
+  typedef implementation_defined native_handle_type;
+#else
+  typedef ASIO_SVC_T::native_handle_type native_handle_type;
+#endif
+
+  /// A descriptor is always the lowest layer.
+  typedef descriptor lowest_layer_type;
+
+  /// Construct a descriptor without opening it.
+  /**
+   * This constructor creates a descriptor without opening it.
+   *
+   * @param io_context The io_context object that the descriptor will use to
+   * dispatch handlers for any asynchronous operations performed on the
+   * descriptor.
+   */
+  explicit descriptor(asio::io_context& io_context)
+    : basic_io_object<ASIO_SVC_T>(io_context)
+  {
+  }
+
+  /// Construct a descriptor on an existing native descriptor.
+  /**
+   * This constructor creates a descriptor object to hold an existing native
+   * descriptor.
+   *
+   * @param io_context The io_context object that the descriptor will use to
+   * dispatch handlers for any asynchronous operations performed on the
+   * descriptor.
+   *
+   * @param native_descriptor A native descriptor.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  descriptor(asio::io_context& io_context,
+      const native_handle_type& native_descriptor)
+    : basic_io_object<ASIO_SVC_T>(io_context)
+  {
+    asio::error_code ec;
+    this->get_service().assign(this->get_implementation(),
+        native_descriptor, ec);
+    asio::detail::throw_error(ec, "assign");
+  }
+
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+  /// Move-construct a descriptor from another.
+  /**
+   * This constructor moves a descriptor from one object to another.
+   *
+   * @param other The other descriptor object from which the move will
+   * occur.
+   *
+   * @note Following the move, the moved-from object is in the same state as if
+   * constructed using the @c descriptor(io_context&) constructor.
+   */
+  descriptor(descriptor&& other)
+    : basic_io_object<ASIO_SVC_T>(std::move(other))
+  {
+  }
+
+  /// Move-assign a descriptor from another.
+  /**
+   * This assignment operator moves a descriptor from one object to another.
+   *
+   * @param other The other descriptor object from which the move will
+   * occur.
+   *
+   * @note Following the move, the moved-from object is in the same state as if
+   * constructed using the @c descriptor(io_context&) constructor.
+   */
+  descriptor& operator=(descriptor&& other)
+  {
+    basic_io_object<ASIO_SVC_T>::operator=(std::move(other));
+    return *this;
+  }
+#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_context()
+  {
+    return basic_io_object<ASIO_SVC_T>::get_io_context();
+  }
+
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_service()
+  {
+    return basic_io_object<ASIO_SVC_T>::get_io_service();
+  }
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// Get the executor associated with the object.
+  executor_type get_executor() ASIO_NOEXCEPT
+  {
+    return basic_io_object<ASIO_SVC_T>::get_executor();
+  }
+
+  /// Get a reference to the lowest layer.
+  /**
+   * This function returns a reference to the lowest layer in a stack of
+   * layers. Since a descriptor cannot contain any further layers, it
+   * simply returns a reference to itself.
+   *
+   * @return A reference to the lowest layer in the stack of layers. Ownership
+   * is not transferred to the caller.
+   */
+  lowest_layer_type& lowest_layer()
+  {
+    return *this;
+  }
+
+  /// Get a const reference to the lowest layer.
+  /**
+   * This function returns a const reference to the lowest layer in a stack of
+   * layers. Since a descriptor cannot contain any further layers, it
+   * simply returns a reference to itself.
+   *
+   * @return A const reference to the lowest layer in the stack of layers.
+   * Ownership is not transferred to the caller.
+   */
+  const lowest_layer_type& lowest_layer() const
+  {
+    return *this;
+  }
+
+  /// Assign an existing native descriptor to the descriptor.
+  /*
+   * This function opens the descriptor to hold an existing native descriptor.
+   *
+   * @param native_descriptor A native descriptor.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  void assign(const native_handle_type& native_descriptor)
+  {
+    asio::error_code ec;
+    this->get_service().assign(this->get_implementation(),
+        native_descriptor, ec);
+    asio::detail::throw_error(ec, "assign");
+  }
+
+  /// Assign an existing native descriptor to the descriptor.
+  /*
+   * This function opens the descriptor to hold an existing native descriptor.
+   *
+   * @param native_descriptor A native descriptor.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   */
+  ASIO_SYNC_OP_VOID assign(const native_handle_type& native_descriptor,
+      asio::error_code& ec)
+  {
+    this->get_service().assign(
+        this->get_implementation(), native_descriptor, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Determine whether the descriptor is open.
+  bool is_open() const
+  {
+    return this->get_service().is_open(this->get_implementation());
+  }
+
+  /// Close the descriptor.
+  /**
+   * This function is used to close the descriptor. Any asynchronous read or
+   * write operations will be cancelled immediately, and will complete with the
+   * asio::error::operation_aborted error.
+   *
+   * @throws asio::system_error Thrown on failure. Note that, even if
+   * the function indicates an error, the underlying descriptor is closed.
+   */
+  void close()
+  {
+    asio::error_code ec;
+    this->get_service().close(this->get_implementation(), ec);
+    asio::detail::throw_error(ec, "close");
+  }
+
+  /// Close the descriptor.
+  /**
+   * This function is used to close the descriptor. Any asynchronous read or
+   * write operations will be cancelled immediately, and will complete with the
+   * asio::error::operation_aborted error.
+   *
+   * @param ec Set to indicate what error occurred, if any. Note that, even if
+   * the function indicates an error, the underlying descriptor is closed.
+   */
+  ASIO_SYNC_OP_VOID close(asio::error_code& ec)
+  {
+    this->get_service().close(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Get the native descriptor representation.
+  /**
+   * This function may be used to obtain the underlying representation of the
+   * descriptor. This is intended to allow access to native descriptor
+   * functionality that is not otherwise provided.
+   */
+  native_handle_type native_handle()
+  {
+    return this->get_service().native_handle(this->get_implementation());
+  }
+
+  /// Release ownership of the native descriptor implementation.
+  /**
+   * This function may be used to obtain the underlying representation of the
+   * descriptor. After calling this function, @c is_open() returns false. The
+   * caller is responsible for closing the descriptor.
+   *
+   * All outstanding asynchronous read or write operations will finish
+   * immediately, and the handlers for cancelled operations will be passed the
+   * asio::error::operation_aborted error.
+   */
+  native_handle_type release()
+  {
+    return this->get_service().release(this->get_implementation());
+  }
+
+  /// Cancel all asynchronous operations associated with the descriptor.
+  /**
+   * This function causes all outstanding asynchronous read or write operations
+   * to finish immediately, and the handlers for cancelled operations will be
+   * passed the asio::error::operation_aborted error.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  void cancel()
+  {
+    asio::error_code ec;
+    this->get_service().cancel(this->get_implementation(), ec);
+    asio::detail::throw_error(ec, "cancel");
+  }
+
+  /// Cancel all asynchronous operations associated with the descriptor.
+  /**
+   * This function causes all outstanding asynchronous read or write operations
+   * to finish immediately, and the handlers for cancelled operations will be
+   * passed the asio::error::operation_aborted error.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   */
+  ASIO_SYNC_OP_VOID cancel(asio::error_code& ec)
+  {
+    this->get_service().cancel(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Perform an IO control command on the descriptor.
+  /**
+   * This function is used to execute an IO control command on the descriptor.
+   *
+   * @param command The IO control command to be performed on the descriptor.
+   *
+   * @throws asio::system_error Thrown on failure.
+   *
+   * @sa IoControlCommand @n
+   * asio::posix::descriptor_base::bytes_readable @n
+   * asio::posix::descriptor_base::non_blocking_io
+   *
+   * @par Example
+   * Getting the number of bytes ready to read:
+   * @code
+   * asio::posix::stream_descriptor descriptor(io_context);
+   * ...
+   * asio::posix::stream_descriptor::bytes_readable command;
+   * descriptor.io_control(command);
+   * std::size_t bytes_readable = command.get();
+   * @endcode
+   */
+  template <typename IoControlCommand>
+  void io_control(IoControlCommand& command)
+  {
+    asio::error_code ec;
+    this->get_service().io_control(this->get_implementation(), command, ec);
+    asio::detail::throw_error(ec, "io_control");
+  }
+
+  /// Perform an IO control command on the descriptor.
+  /**
+   * This function is used to execute an IO control command on the descriptor.
+   *
+   * @param command The IO control command to be performed on the descriptor.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @sa IoControlCommand @n
+   * asio::posix::descriptor_base::bytes_readable @n
+   * asio::posix::descriptor_base::non_blocking_io
+   *
+   * @par Example
+   * Getting the number of bytes ready to read:
+   * @code
+   * asio::posix::stream_descriptor descriptor(io_context);
+   * ...
+   * asio::posix::stream_descriptor::bytes_readable command;
+   * asio::error_code ec;
+   * descriptor.io_control(command, ec);
+   * if (ec)
+   * {
+   *   // An error occurred.
+   * }
+   * std::size_t bytes_readable = command.get();
+   * @endcode
+   */
+  template <typename IoControlCommand>
+  ASIO_SYNC_OP_VOID io_control(IoControlCommand& command,
+      asio::error_code& ec)
+  {
+    this->get_service().io_control(this->get_implementation(), command, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Gets the non-blocking mode of the descriptor.
+  /**
+   * @returns @c true if the descriptor's synchronous operations will fail with
+   * asio::error::would_block if they are unable to perform the requested
+   * operation immediately. If @c false, synchronous operations will block
+   * until complete.
+   *
+   * @note The non-blocking mode has no effect on the behaviour of asynchronous
+   * operations. Asynchronous operations will never fail with the error
+   * asio::error::would_block.
+   */
+  bool non_blocking() const
+  {
+    return this->get_service().non_blocking(this->get_implementation());
+  }
+
+  /// Sets the non-blocking mode of the descriptor.
+  /**
+   * @param mode If @c true, the descriptor's synchronous operations will fail
+   * with asio::error::would_block if they are unable to perform the
+   * requested operation immediately. If @c false, synchronous operations will
+   * block until complete.
+   *
+   * @throws asio::system_error Thrown on failure.
+   *
+   * @note The non-blocking mode has no effect on the behaviour of asynchronous
+   * operations. Asynchronous operations will never fail with the error
+   * asio::error::would_block.
+   */
+  void non_blocking(bool mode)
+  {
+    asio::error_code ec;
+    this->get_service().non_blocking(this->get_implementation(), mode, ec);
+    asio::detail::throw_error(ec, "non_blocking");
+  }
+
+  /// Sets the non-blocking mode of the descriptor.
+  /**
+   * @param mode If @c true, the descriptor's synchronous operations will fail
+   * with asio::error::would_block if they are unable to perform the
+   * requested operation immediately. If @c false, synchronous operations will
+   * block until complete.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @note The non-blocking mode has no effect on the behaviour of asynchronous
+   * operations. Asynchronous operations will never fail with the error
+   * asio::error::would_block.
+   */
+  ASIO_SYNC_OP_VOID non_blocking(
+      bool mode, asio::error_code& ec)
+  {
+    this->get_service().non_blocking(this->get_implementation(), mode, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Gets the non-blocking mode of the native descriptor implementation.
+  /**
+   * This function is used to retrieve the non-blocking mode of the underlying
+   * native descriptor. This mode has no effect on the behaviour of the
+   * descriptor object's synchronous operations.
+   *
+   * @returns @c true if the underlying descriptor is in non-blocking mode and
+   * direct system calls may fail with asio::error::would_block (or the
+   * equivalent system error).
+   *
+   * @note The current non-blocking mode is cached by the descriptor object.
+   * Consequently, the return value may be incorrect if the non-blocking mode
+   * was set directly on the native descriptor.
+   */
+  bool native_non_blocking() const
+  {
+    return this->get_service().native_non_blocking(
+        this->get_implementation());
+  }
+
+  /// Sets the non-blocking mode of the native descriptor implementation.
+  /**
+   * This function is used to modify the non-blocking mode of the underlying
+   * native descriptor. It has no effect on the behaviour of the descriptor
+   * object's synchronous operations.
+   *
+   * @param mode If @c true, the underlying descriptor is put into non-blocking
+   * mode and direct system calls may fail with asio::error::would_block
+   * (or the equivalent system error).
+   *
+   * @throws asio::system_error Thrown on failure. If the @c mode is
+   * @c false, but the current value of @c non_blocking() is @c true, this
+   * function fails with asio::error::invalid_argument, as the
+   * combination does not make sense.
+   */
+  void native_non_blocking(bool mode)
+  {
+    asio::error_code ec;
+    this->get_service().native_non_blocking(
+        this->get_implementation(), mode, ec);
+    asio::detail::throw_error(ec, "native_non_blocking");
+  }
+
+  /// Sets the non-blocking mode of the native descriptor implementation.
+  /**
+   * This function is used to modify the non-blocking mode of the underlying
+   * native descriptor. It has no effect on the behaviour of the descriptor
+   * object's synchronous operations.
+   *
+   * @param mode If @c true, the underlying descriptor is put into non-blocking
+   * mode and direct system calls may fail with asio::error::would_block
+   * (or the equivalent system error).
+   *
+   * @param ec Set to indicate what error occurred, if any. If the @c mode is
+   * @c false, but the current value of @c non_blocking() is @c true, this
+   * function fails with asio::error::invalid_argument, as the
+   * combination does not make sense.
+   */
+  ASIO_SYNC_OP_VOID native_non_blocking(
+      bool mode, asio::error_code& ec)
+  {
+    this->get_service().native_non_blocking(
+        this->get_implementation(), mode, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Wait for the descriptor to become ready to read, ready to write, or to
+  /// have pending error conditions.
+  /**
+   * This function is used to perform a blocking wait for a descriptor to enter
+   * a ready to read, write or error condition state.
+   *
+   * @param w Specifies the desired descriptor state.
+   *
+   * @par Example
+   * Waiting for a descriptor to become readable.
+   * @code
+   * asio::posix::stream_descriptor descriptor(io_context);
+   * ...
+   * descriptor.wait(asio::posix::stream_descriptor::wait_read);
+   * @endcode
+   */
+  void wait(wait_type w)
+  {
+    asio::error_code ec;
+    this->get_service().wait(this->get_implementation(), w, ec);
+    asio::detail::throw_error(ec, "wait");
+  }
+
+  /// Wait for the descriptor to become ready to read, ready to write, or to
+  /// have pending error conditions.
+  /**
+   * This function is used to perform a blocking wait for a descriptor to enter
+   * a ready to read, write or error condition state.
+   *
+   * @param w Specifies the desired descriptor state.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @par Example
+   * Waiting for a descriptor to become readable.
+   * @code
+   * asio::posix::stream_descriptor descriptor(io_context);
+   * ...
+   * asio::error_code ec;
+   * descriptor.wait(asio::posix::stream_descriptor::wait_read, ec);
+   * @endcode
+   */
+  ASIO_SYNC_OP_VOID wait(wait_type w, asio::error_code& ec)
+  {
+    this->get_service().wait(this->get_implementation(), w, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Asynchronously wait for the descriptor to become ready to read, ready to
+  /// write, or to have pending error conditions.
+  /**
+   * This function is used to perform an asynchronous wait for a descriptor to
+   * enter a ready to read, write or error condition state.
+   *
+   * @param w Specifies the desired descriptor state.
+   *
+   * @param handler The handler to be called when the wait operation completes.
+   * Copies will be made of the handler as required. The function signature of
+   * the handler must be:
+   * @code void handler(
+   *   const asio::error_code& error // Result of operation
+   * ); @endcode
+   * Regardless of whether the asynchronous operation completes immediately or
+   * not, the handler will not be invoked from within this function. Invocation
+   * of the handler will be performed in a manner equivalent to using
+   * asio::io_context::post().
+   *
+   * @par Example
+   * @code
+   * void wait_handler(const asio::error_code& error)
+   * {
+   *   if (!error)
+   *   {
+   *     // Wait succeeded.
+   *   }
+   * }
+   *
+   * ...
+   *
+   * asio::posix::stream_descriptor descriptor(io_context);
+   * ...
+   * descriptor.async_wait(
+   *     asio::posix::stream_descriptor::wait_read,
+   *     wait_handler);
+   * @endcode
+   */
+  template <typename WaitHandler>
+  ASIO_INITFN_RESULT_TYPE(WaitHandler,
+      void (asio::error_code))
+  async_wait(wait_type w, ASIO_MOVE_ARG(WaitHandler) handler)
+  {
+    // If you get an error on the following line it means that your handler does
+    // not meet the documented type requirements for a WaitHandler.
+    ASIO_WAIT_HANDLER_CHECK(WaitHandler, handler) type_check;
+
+    async_completion<WaitHandler,
+      void (asio::error_code)> init(handler);
+
+    this->get_service().async_wait(
+        this->get_implementation(), w, init.completion_handler);
+
+    return init.result.get();
+  }
+
+protected:
+  /// Protected destructor to prevent deletion through this type.
+  /**
+   * This function destroys the descriptor, cancelling any outstanding
+   * asynchronous wait operations associated with the descriptor as if by
+   * calling @c cancel.
+   */
+  ~descriptor()
+  {
+  }
+};
+
+} // namespace posix
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#undef ASIO_SVC_T
+
+#endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
+       //   || defined(GENERATING_DOCUMENTATION)
+
+#endif // !defined(ASIO_ENABLE_OLD_SERVICES)
+
+#endif // ASIO_POSIX_DESCRIPTOR_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/descriptor_base.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/descriptor_base.hpp
index e8d9784..b77d49d 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/descriptor_base.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/descriptor_base.hpp
@@ -2,7 +2,7 @@
 // posix/descriptor_base.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -28,15 +28,14 @@
 namespace asio {
 namespace posix {
 
-/// The descriptor_base class is used as a base for the basic_stream_descriptor
-/// class template so that we have a common place to define the associated
-/// IO control commands.
+/// The descriptor_base class is used as a base for the descriptor class as a
+/// place to define the associated IO control commands.
 class descriptor_base
 {
 public:
   /// Wait types.
   /**
-   * For use with basic_descriptor::wait() and basic_descriptor::async_wait().
+   * For use with descriptor::wait() and descriptor::async_wait().
    */
   enum wait_type
   {
@@ -57,7 +56,7 @@ public:
    *
    * @par Example
    * @code
-   * asio::posix::stream_descriptor descriptor(io_service); 
+   * asio::posix::stream_descriptor descriptor(io_context); 
    * ...
    * asio::descriptor_base::bytes_readable command(true);
    * descriptor.io_control(command);
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/stream_descriptor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/stream_descriptor.hpp
index 25c62e8..29e1572 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/stream_descriptor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/stream_descriptor.hpp
@@ -2,7 +2,7 @@
 // posix/stream_descriptor.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,17 +16,340 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
+#include "asio/posix/descriptor.hpp"
 
 #if defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR) \
   || defined(GENERATING_DOCUMENTATION)
 
-#include "asio/posix/basic_stream_descriptor.hpp"
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+# include "asio/posix/basic_stream_descriptor.hpp"
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
 
 namespace asio {
 namespace posix {
 
-/// Typedef for the typical usage of a stream-oriented descriptor.
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+// Typedef for the typical usage of a stream-oriented descriptor.
 typedef basic_stream_descriptor<> stream_descriptor;
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+/// Provides stream-oriented descriptor functionality.
+/**
+ * The posix::stream_descriptor class template provides asynchronous and
+ * blocking stream-oriented descriptor functionality.
+ *
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Unsafe.
+ *
+ * @par Concepts:
+ * AsyncReadStream, AsyncWriteStream, Stream, SyncReadStream, SyncWriteStream.
+ */
+class stream_descriptor
+  : public descriptor
+{
+public:
+  /// Construct a stream_descriptor without opening it.
+  /**
+   * This constructor creates a stream descriptor without opening it. The
+   * descriptor needs to be opened and then connected or accepted before data
+   * can be sent or received on it.
+   *
+   * @param io_context The io_context object that the stream descriptor will
+   * use to dispatch handlers for any asynchronous operations performed on the
+   * descriptor.
+   */
+  explicit stream_descriptor(asio::io_context& io_context)
+    : descriptor(io_context)
+  {
+  }
+
+  /// Construct a stream_descriptor on an existing native descriptor.
+  /**
+   * This constructor creates a stream descriptor object to hold an existing
+   * native descriptor.
+   *
+   * @param io_context The io_context object that the stream descriptor will
+   * use to dispatch handlers for any asynchronous operations performed on the
+   * descriptor.
+   *
+   * @param native_descriptor The new underlying descriptor implementation.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  stream_descriptor(asio::io_context& io_context,
+      const native_handle_type& native_descriptor)
+    : descriptor(io_context, native_descriptor)
+  {
+  }
+
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+  /// Move-construct a stream_descriptor from another.
+  /**
+   * This constructor moves a stream descriptor from one object to another.
+   *
+   * @param other The other stream_descriptor object from which the move
+   * will occur.
+   *
+   * @note Following the move, the moved-from object is in the same state as if
+   * constructed using the @c stream_descriptor(io_context&) constructor.
+   */
+  stream_descriptor(stream_descriptor&& other)
+    : descriptor(std::move(other))
+  {
+  }
+
+  /// Move-assign a stream_descriptor from another.
+  /**
+   * This assignment operator moves a stream descriptor from one object to
+   * another.
+   *
+   * @param other The other stream_descriptor object from which the move
+   * will occur.
+   *
+   * @note Following the move, the moved-from object is in the same state as if
+   * constructed using the @c stream_descriptor(io_context&) constructor.
+   */
+  stream_descriptor& operator=(stream_descriptor&& other)
+  {
+    descriptor::operator=(std::move(other));
+    return *this;
+  }
+#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+
+  /// Write some data to the descriptor.
+  /**
+   * This function is used to write data to the stream descriptor. The function
+   * call will block until one or more bytes of the data has been written
+   * successfully, or until an error occurs.
+   *
+   * @param buffers One or more data buffers to be written to the descriptor.
+   *
+   * @returns The number of bytes written.
+   *
+   * @throws asio::system_error Thrown on failure. An error code of
+   * asio::error::eof indicates that the connection was closed by the
+   * peer.
+   *
+   * @note The write_some operation may not transmit all of the data to the
+   * peer. Consider using the @ref write function if you need to ensure that
+   * all data is written before the blocking operation completes.
+   *
+   * @par Example
+   * To write a single data buffer use the @ref buffer function as follows:
+   * @code
+   * descriptor.write_some(asio::buffer(data, size));
+   * @endcode
+   * See the @ref buffer documentation for information on writing multiple
+   * buffers in one go, and how to use it with arrays, boost::array or
+   * std::vector.
+   */
+  template <typename ConstBufferSequence>
+  std::size_t write_some(const ConstBufferSequence& buffers)
+  {
+    asio::error_code ec;
+    std::size_t s = this->get_service().write_some(
+        this->get_implementation(), buffers, ec);
+    asio::detail::throw_error(ec, "write_some");
+    return s;
+  }
+
+  /// Write some data to the descriptor.
+  /**
+   * This function is used to write data to the stream descriptor. The function
+   * call will block until one or more bytes of the data has been written
+   * successfully, or until an error occurs.
+   *
+   * @param buffers One or more data buffers to be written to the descriptor.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @returns The number of bytes written. Returns 0 if an error occurred.
+   *
+   * @note The write_some operation may not transmit all of the data to the
+   * peer. Consider using the @ref write function if you need to ensure that
+   * all data is written before the blocking operation completes.
+   */
+  template <typename ConstBufferSequence>
+  std::size_t write_some(const ConstBufferSequence& buffers,
+      asio::error_code& ec)
+  {
+    return this->get_service().write_some(
+        this->get_implementation(), buffers, ec);
+  }
+
+  /// Start an asynchronous write.
+  /**
+   * This function is used to asynchronously write data to the stream
+   * descriptor. The function call always returns immediately.
+   *
+   * @param buffers One or more data buffers to be written to the descriptor.
+   * Although the buffers object may be copied as necessary, ownership of the
+   * underlying memory blocks is retained by the caller, which must guarantee
+   * that they remain valid until the handler is called.
+   *
+   * @param handler The handler to be called when the write operation completes.
+   * Copies will be made of the handler as required. The function signature of
+   * the handler must be:
+   * @code void handler(
+   *   const asio::error_code& error, // Result of operation.
+   *   std::size_t bytes_transferred           // Number of bytes written.
+   * ); @endcode
+   * Regardless of whether the asynchronous operation completes immediately or
+   * not, the handler will not be invoked from within this function. Invocation
+   * of the handler will be performed in a manner equivalent to using
+   * asio::io_context::post().
+   *
+   * @note The write operation may not transmit all of the data to the peer.
+   * Consider using the @ref async_write function if you need to ensure that all
+   * data is written before the asynchronous operation completes.
+   *
+   * @par Example
+   * To write a single data buffer use the @ref buffer function as follows:
+   * @code
+   * descriptor.async_write_some(asio::buffer(data, size), handler);
+   * @endcode
+   * See the @ref buffer documentation for information on writing multiple
+   * buffers in one go, and how to use it with arrays, boost::array or
+   * std::vector.
+   */
+  template <typename ConstBufferSequence, typename WriteHandler>
+  ASIO_INITFN_RESULT_TYPE(WriteHandler,
+      void (asio::error_code, std::size_t))
+  async_write_some(const ConstBufferSequence& buffers,
+      ASIO_MOVE_ARG(WriteHandler) handler)
+  {
+    // If you get an error on the following line it means that your handler does
+    // not meet the documented type requirements for a WriteHandler.
+    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
+
+    asio::async_completion<WriteHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_write_some(
+        this->get_implementation(), buffers, init.completion_handler);
+
+    return init.result.get();
+  }
+
+  /// Read some data from the descriptor.
+  /**
+   * This function is used to read data from the stream descriptor. The function
+   * call will block until one or more bytes of data has been read successfully,
+   * or until an error occurs.
+   *
+   * @param buffers One or more buffers into which the data will be read.
+   *
+   * @returns The number of bytes read.
+   *
+   * @throws asio::system_error Thrown on failure. An error code of
+   * asio::error::eof indicates that the connection was closed by the
+   * peer.
+   *
+   * @note The read_some operation may not read all of the requested number of
+   * bytes. Consider using the @ref read function if you need to ensure that
+   * the requested amount of data is read before the blocking operation
+   * completes.
+   *
+   * @par Example
+   * To read into a single data buffer use the @ref buffer function as follows:
+   * @code
+   * descriptor.read_some(asio::buffer(data, size));
+   * @endcode
+   * See the @ref buffer documentation for information on reading into multiple
+   * buffers in one go, and how to use it with arrays, boost::array or
+   * std::vector.
+   */
+  template <typename MutableBufferSequence>
+  std::size_t read_some(const MutableBufferSequence& buffers)
+  {
+    asio::error_code ec;
+    std::size_t s = this->get_service().read_some(
+        this->get_implementation(), buffers, ec);
+    asio::detail::throw_error(ec, "read_some");
+    return s;
+  }
+
+  /// Read some data from the descriptor.
+  /**
+   * This function is used to read data from the stream descriptor. The function
+   * call will block until one or more bytes of data has been read successfully,
+   * or until an error occurs.
+   *
+   * @param buffers One or more buffers into which the data will be read.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @returns The number of bytes read. Returns 0 if an error occurred.
+   *
+   * @note The read_some operation may not read all of the requested number of
+   * bytes. Consider using the @ref read function if you need to ensure that
+   * the requested amount of data is read before the blocking operation
+   * completes.
+   */
+  template <typename MutableBufferSequence>
+  std::size_t read_some(const MutableBufferSequence& buffers,
+      asio::error_code& ec)
+  {
+    return this->get_service().read_some(
+        this->get_implementation(), buffers, ec);
+  }
+
+  /// Start an asynchronous read.
+  /**
+   * This function is used to asynchronously read data from the stream
+   * descriptor. The function call always returns immediately.
+   *
+   * @param buffers One or more buffers into which the data will be read.
+   * Although the buffers object may be copied as necessary, ownership of the
+   * underlying memory blocks is retained by the caller, which must guarantee
+   * that they remain valid until the handler is called.
+   *
+   * @param handler The handler to be called when the read operation completes.
+   * Copies will be made of the handler as required. The function signature of
+   * the handler must be:
+   * @code void handler(
+   *   const asio::error_code& error, // Result of operation.
+   *   std::size_t bytes_transferred           // Number of bytes read.
+   * ); @endcode
+   * Regardless of whether the asynchronous operation completes immediately or
+   * not, the handler will not be invoked from within this function. Invocation
+   * of the handler will be performed in a manner equivalent to using
+   * asio::io_context::post().
+   *
+   * @note The read operation may not read all of the requested number of bytes.
+   * Consider using the @ref async_read function if you need to ensure that the
+   * requested amount of data is read before the asynchronous operation
+   * completes.
+   *
+   * @par Example
+   * To read into a single data buffer use the @ref buffer function as follows:
+   * @code
+   * descriptor.async_read_some(asio::buffer(data, size), handler);
+   * @endcode
+   * See the @ref buffer documentation for information on reading into multiple
+   * buffers in one go, and how to use it with arrays, boost::array or
+   * std::vector.
+   */
+  template <typename MutableBufferSequence, typename ReadHandler>
+  ASIO_INITFN_RESULT_TYPE(ReadHandler,
+      void (asio::error_code, std::size_t))
+  async_read_some(const MutableBufferSequence& buffers,
+      ASIO_MOVE_ARG(ReadHandler) handler)
+  {
+    // If you get an error on the following line it means that your handler does
+    // not meet the documented type requirements for a ReadHandler.
+    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
+
+    asio::async_completion<ReadHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_read_some(
+        this->get_implementation(), buffers, init.completion_handler);
+
+    return init.result.get();
+  }
+};
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
 
 } // namespace posix
 } // namespace asio
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/stream_descriptor_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/stream_descriptor_service.hpp
index 9e216b2..e7a1b32 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/stream_descriptor_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/posix/stream_descriptor_service.hpp
@@ -2,7 +2,7 @@
 // posix/stream_descriptor_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,13 +17,15 @@
 
 #include "asio/detail/config.hpp"
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #if defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR) \
   || defined(GENERATING_DOCUMENTATION)
 
 #include <cstddef>
 #include "asio/async_result.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/detail/reactive_descriptor_service.hpp"
 
 #include "asio/detail/push_options.hpp"
@@ -34,7 +36,7 @@ namespace posix {
 /// Default service implementation for a stream descriptor.
 class stream_descriptor_service
 #if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
+  : public asio::io_context::service
 #else
   : public asio::detail::service_base<stream_descriptor_service>
 #endif
@@ -42,7 +44,7 @@ class stream_descriptor_service
 public:
 #if defined(GENERATING_DOCUMENTATION)
   /// The unique service identifier.
-  static asio::io_service::id id;
+  static asio::io_context::id id;
 #endif
 
 private:
@@ -64,10 +66,10 @@ public:
   typedef service_impl_type::native_handle_type native_handle_type;
 #endif
 
-  /// Construct a new stream descriptor service for the specified io_service.
-  explicit stream_descriptor_service(asio::io_service& io_service)
-    : asio::detail::service_base<stream_descriptor_service>(io_service),
-      service_impl_(io_service)
+  /// Construct a new stream descriptor service for the specified io_context.
+  explicit stream_descriptor_service(asio::io_context& io_context)
+    : asio::detail::service_base<stream_descriptor_service>(io_context),
+      service_impl_(io_context)
   {
   }
 
@@ -101,11 +103,12 @@ public:
   }
 
   /// Assign an existing native descriptor to a stream descriptor.
-  asio::error_code assign(implementation_type& impl,
+  ASIO_SYNC_OP_VOID assign(implementation_type& impl,
       const native_handle_type& native_descriptor,
       asio::error_code& ec)
   {
-    return service_impl_.assign(impl, native_descriptor, ec);
+    service_impl_.assign(impl, native_descriptor, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Determine whether the descriptor is open.
@@ -115,10 +118,11 @@ public:
   }
 
   /// Close a stream descriptor implementation.
-  asio::error_code close(implementation_type& impl,
+  ASIO_SYNC_OP_VOID close(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.close(impl, ec);
+    service_impl_.close(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the native descriptor implementation.
@@ -134,18 +138,20 @@ public:
   }
 
   /// Cancel all asynchronous operations associated with the descriptor.
-  asio::error_code cancel(implementation_type& impl,
+  ASIO_SYNC_OP_VOID cancel(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.cancel(impl, ec);
+    service_impl_.cancel(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Perform an IO control command on the descriptor.
   template <typename IoControlCommand>
-  asio::error_code io_control(implementation_type& impl,
+  ASIO_SYNC_OP_VOID io_control(implementation_type& impl,
       IoControlCommand& command, asio::error_code& ec)
   {
-    return service_impl_.io_control(impl, command, ec);
+    service_impl_.io_control(impl, command, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Gets the non-blocking mode of the descriptor.
@@ -155,10 +161,11 @@ public:
   }
 
   /// Sets the non-blocking mode of the descriptor.
-  asio::error_code non_blocking(implementation_type& impl,
+  ASIO_SYNC_OP_VOID non_blocking(implementation_type& impl,
       bool mode, asio::error_code& ec)
   {
-    return service_impl_.non_blocking(impl, mode, ec);
+    service_impl_.non_blocking(impl, mode, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Gets the non-blocking mode of the native descriptor implementation.
@@ -168,18 +175,20 @@ public:
   }
 
   /// Sets the non-blocking mode of the native descriptor implementation.
-  asio::error_code native_non_blocking(implementation_type& impl,
+  ASIO_SYNC_OP_VOID native_non_blocking(implementation_type& impl,
       bool mode, asio::error_code& ec)
   {
-    return service_impl_.native_non_blocking(impl, mode, ec);
+    service_impl_.native_non_blocking(impl, mode, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Wait for the descriptor to become ready to read, ready to write, or to
   /// have pending error conditions.
-  asio::error_code wait(implementation_type& impl,
+  ASIO_SYNC_OP_VOID wait(implementation_type& impl,
       descriptor_base::wait_type w, asio::error_code& ec)
   {
-    return service_impl_.wait(impl, w, ec);
+    service_impl_.wait(impl, w, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Asynchronously wait for the descriptor to become ready to read, ready to
@@ -193,7 +202,7 @@ public:
     async_completion<WaitHandler,
       void (asio::error_code)> init(handler);
 
-    service_impl_.async_wait(impl, w, init.handler);
+    service_impl_.async_wait(impl, w, init.completion_handler);
 
     return init.result.get();
   }
@@ -217,7 +226,7 @@ public:
     asio::async_completion<WriteHandler,
       void (asio::error_code, std::size_t)> init(handler);
 
-    service_impl_.async_write_some(impl, buffers, init.handler);
+    service_impl_.async_write_some(impl, buffers, init.completion_handler);
 
     return init.result.get();
   }
@@ -241,16 +250,16 @@ public:
     asio::async_completion<ReadHandler,
       void (asio::error_code, std::size_t)> init(handler);
 
-    service_impl_.async_read_some(impl, buffers, init.handler);
+    service_impl_.async_read_some(impl, buffers, init.completion_handler);
 
     return init.result.get();
   }
 
 private:
   // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
+  void shutdown()
   {
-    service_impl_.shutdown_service();
+    service_impl_.shutdown();
   }
 
   // The platform-specific implementation.
@@ -265,4 +274,6 @@ private:
 #endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
        //   || defined(GENERATING_DOCUMENTATION)
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_POSIX_STREAM_DESCRIPTOR_SERVICE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/post.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/post.hpp
index bce879e..17625cb 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/post.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/post.hpp
@@ -2,7 +2,7 @@
 // post.hpp
 // ~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/raw_socket_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/raw_socket_service.hpp
index fbf4538..f8b183d 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/raw_socket_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/raw_socket_service.hpp
@@ -2,7 +2,7 @@
 // raw_socket_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,11 +16,14 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #include <cstddef>
 #include "asio/async_result.hpp"
 #include "asio/detail/type_traits.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 
 #if defined(ASIO_WINDOWS_RUNTIME)
 # include "asio/detail/null_socket_service.hpp"
@@ -38,7 +41,7 @@ namespace asio {
 template <typename Protocol>
 class raw_socket_service
 #if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
+  : public asio::io_context::service
 #else
   : public asio::detail::service_base<raw_socket_service<Protocol> >
 #endif
@@ -46,7 +49,7 @@ class raw_socket_service
 public:
 #if defined(GENERATING_DOCUMENTATION)
   /// The unique service identifier.
-  static asio::io_service::id id;
+  static asio::io_context::id id;
 #endif
 
   /// The protocol type.
@@ -80,11 +83,11 @@ public:
   typedef typename service_impl_type::native_handle_type native_handle_type;
 #endif
 
-  /// Construct a new raw socket service for the specified io_service.
-  explicit raw_socket_service(asio::io_service& io_service)
+  /// Construct a new raw socket service for the specified io_context.
+  explicit raw_socket_service(asio::io_context& io_context)
     : asio::detail::service_base<
-        raw_socket_service<Protocol> >(io_service),
-      service_impl_(io_service)
+        raw_socket_service<Protocol> >(io_context),
+      service_impl_(io_context)
   {
   }
 
@@ -131,22 +134,23 @@ public:
   }
 
   // Open a new raw socket implementation.
-  asio::error_code open(implementation_type& impl,
+  ASIO_SYNC_OP_VOID open(implementation_type& impl,
       const protocol_type& protocol, asio::error_code& ec)
   {
     if (protocol.type() == ASIO_OS_DEF(SOCK_RAW))
       service_impl_.open(impl, protocol, ec);
     else
       ec = asio::error::invalid_argument;
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Assign an existing native socket to a raw socket.
-  asio::error_code assign(implementation_type& impl,
+  ASIO_SYNC_OP_VOID assign(implementation_type& impl,
       const protocol_type& protocol, const native_handle_type& native_socket,
       asio::error_code& ec)
   {
-    return service_impl_.assign(impl, protocol, native_socket, ec);
+    service_impl_.assign(impl, protocol, native_socket, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Determine whether the socket is open.
@@ -156,10 +160,11 @@ public:
   }
 
   /// Close a raw socket implementation.
-  asio::error_code close(implementation_type& impl,
+  ASIO_SYNC_OP_VOID close(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.close(impl, ec);
+    service_impl_.close(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the native socket implementation.
@@ -169,10 +174,11 @@ public:
   }
 
   /// Cancel all asynchronous operations associated with the socket.
-  asio::error_code cancel(implementation_type& impl,
+  ASIO_SYNC_OP_VOID cancel(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.cancel(impl, ec);
+    service_impl_.cancel(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Determine whether the socket is at the out-of-band data mark.
@@ -190,17 +196,19 @@ public:
   }
 
   // Bind the raw socket to the specified local endpoint.
-  asio::error_code bind(implementation_type& impl,
+  ASIO_SYNC_OP_VOID bind(implementation_type& impl,
       const endpoint_type& endpoint, asio::error_code& ec)
   {
-    return service_impl_.bind(impl, endpoint, ec);
+    service_impl_.bind(impl, endpoint, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Connect the raw socket to the specified endpoint.
-  asio::error_code connect(implementation_type& impl,
+  ASIO_SYNC_OP_VOID connect(implementation_type& impl,
       const endpoint_type& peer_endpoint, asio::error_code& ec)
   {
-    return service_impl_.connect(impl, peer_endpoint, ec);
+    service_impl_.connect(impl, peer_endpoint, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Start an asynchronous connect.
@@ -214,33 +222,36 @@ public:
     async_completion<ConnectHandler,
       void (asio::error_code)> init(handler);
 
-    service_impl_.async_connect(impl, peer_endpoint, init.handler);
+    service_impl_.async_connect(impl, peer_endpoint, init.completion_handler);
 
     return init.result.get();
   }
 
   /// Set a socket option.
   template <typename SettableSocketOption>
-  asio::error_code set_option(implementation_type& impl,
+  ASIO_SYNC_OP_VOID set_option(implementation_type& impl,
       const SettableSocketOption& option, asio::error_code& ec)
   {
-    return service_impl_.set_option(impl, option, ec);
+    service_impl_.set_option(impl, option, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get a socket option.
   template <typename GettableSocketOption>
-  asio::error_code get_option(const implementation_type& impl,
+  ASIO_SYNC_OP_VOID get_option(const implementation_type& impl,
       GettableSocketOption& option, asio::error_code& ec) const
   {
-    return service_impl_.get_option(impl, option, ec);
+    service_impl_.get_option(impl, option, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Perform an IO control command on the socket.
   template <typename IoControlCommand>
-  asio::error_code io_control(implementation_type& impl,
+  ASIO_SYNC_OP_VOID io_control(implementation_type& impl,
       IoControlCommand& command, asio::error_code& ec)
   {
-    return service_impl_.io_control(impl, command, ec);
+    service_impl_.io_control(impl, command, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Gets the non-blocking mode of the socket.
@@ -250,10 +261,11 @@ public:
   }
 
   /// Sets the non-blocking mode of the socket.
-  asio::error_code non_blocking(implementation_type& impl,
+  ASIO_SYNC_OP_VOID non_blocking(implementation_type& impl,
       bool mode, asio::error_code& ec)
   {
-    return service_impl_.non_blocking(impl, mode, ec);
+    service_impl_.non_blocking(impl, mode, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Gets the non-blocking mode of the native socket implementation.
@@ -263,10 +275,11 @@ public:
   }
 
   /// Sets the non-blocking mode of the native socket implementation.
-  asio::error_code native_non_blocking(implementation_type& impl,
+  ASIO_SYNC_OP_VOID native_non_blocking(implementation_type& impl,
       bool mode, asio::error_code& ec)
   {
-    return service_impl_.native_non_blocking(impl, mode, ec);
+    service_impl_.native_non_blocking(impl, mode, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the local endpoint.
@@ -284,18 +297,20 @@ public:
   }
 
   /// Disable sends or receives on the socket.
-  asio::error_code shutdown(implementation_type& impl,
+  ASIO_SYNC_OP_VOID shutdown(implementation_type& impl,
       socket_base::shutdown_type what, asio::error_code& ec)
   {
-    return service_impl_.shutdown(impl, what, ec);
+    service_impl_.shutdown(impl, what, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Wait for the socket to become ready to read, ready to write, or to have
   /// pending error conditions.
-  asio::error_code wait(implementation_type& impl,
+  ASIO_SYNC_OP_VOID wait(implementation_type& impl,
       socket_base::wait_type w, asio::error_code& ec)
   {
-    return service_impl_.wait(impl, w, ec);
+    service_impl_.wait(impl, w, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Asynchronously wait for the socket to become ready to read, ready to
@@ -309,7 +324,7 @@ public:
     async_completion<WaitHandler,
       void (asio::error_code)> init(handler);
 
-    service_impl_.async_wait(impl, w, init.handler);
+    service_impl_.async_wait(impl, w, init.completion_handler);
 
     return init.result.get();
   }
@@ -334,7 +349,7 @@ public:
     async_completion<WriteHandler,
       void (asio::error_code, std::size_t)> init(handler);
 
-    service_impl_.async_send(impl, buffers, flags, init.handler);
+    service_impl_.async_send(impl, buffers, flags, init.completion_handler);
 
     return init.result.get();
   }
@@ -361,7 +376,7 @@ public:
       void (asio::error_code, std::size_t)> init(handler);
 
     service_impl_.async_send_to(impl, buffers,
-        destination, flags, init.handler);
+        destination, flags, init.completion_handler);
 
     return init.result.get();
   }
@@ -387,7 +402,7 @@ public:
     async_completion<ReadHandler,
       void (asio::error_code, std::size_t)> init(handler);
 
-    service_impl_.async_receive(impl, buffers, flags, init.handler);
+    service_impl_.async_receive(impl, buffers, flags, init.completion_handler);
 
     return init.result.get();
   }
@@ -415,16 +430,16 @@ public:
       void (asio::error_code, std::size_t)> init(handler);
 
     service_impl_.async_receive_from(impl, buffers,
-        sender_endpoint, flags, init.handler);
+        sender_endpoint, flags, init.completion_handler);
 
     return init.result.get();
   }
 
 private:
   // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
+  void shutdown()
   {
-    service_impl_.shutdown_service();
+    service_impl_.shutdown();
   }
 
   // The platform-specific implementation.
@@ -435,4 +450,6 @@ private:
 
 #include "asio/detail/pop_options.hpp"
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_RAW_SOCKET_SERVICE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/read.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/read.hpp
index ff5913e..4839934 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/read.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/read.hpp
@@ -2,7 +2,7 @@
 // read.hpp
 // ~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -18,10 +18,13 @@
 #include "asio/detail/config.hpp"
 #include <cstddef>
 #include "asio/async_result.hpp"
-#include "asio/basic_streambuf_fwd.hpp"
 #include "asio/buffer.hpp"
 #include "asio/error.hpp"
 
+#if !defined(ASIO_NO_EXTENSIONS)
+# include "asio/basic_streambuf_fwd.hpp"
+#endif // !defined(ASIO_NO_EXTENSIONS)
+
 #include "asio/detail/push_options.hpp"
 
 namespace asio {
@@ -247,11 +250,11 @@ std::size_t read(SyncReadStream& s, const MutableBufferSequence& buffers,
  *     s, buffers,
  *     asio::transfer_all()); @endcode
  */
-template <typename SyncReadStream, typename DynamicBufferSequence>
+template <typename SyncReadStream, typename DynamicBuffer>
 std::size_t read(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type* = 0);
 
 /// Attempt to read a certain amount of data from a stream before returning.
@@ -280,12 +283,12 @@ std::size_t read(SyncReadStream& s,
  *     s, buffers,
  *     asio::transfer_all(), ec); @endcode
  */
-template <typename SyncReadStream, typename DynamicBufferSequence>
+template <typename SyncReadStream, typename DynamicBuffer>
 std::size_t read(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     asio::error_code& ec,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type* = 0);
 
 /// Attempt to read a certain amount of data from a stream before returning.
@@ -324,13 +327,13 @@ std::size_t read(SyncReadStream& s,
  *
  * @throws asio::system_error Thrown on failure.
  */
-template <typename SyncReadStream, typename DynamicBufferSequence,
+template <typename SyncReadStream, typename DynamicBuffer,
     typename CompletionCondition>
 std::size_t read(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     CompletionCondition completion_condition,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type* = 0);
 
 /// Attempt to read a certain amount of data from a stream before returning.
@@ -370,15 +373,16 @@ std::size_t read(SyncReadStream& s,
  * @returns The number of bytes read. If an error occurs, returns the total
  * number of bytes successfully transferred prior to the error.
  */
-template <typename SyncReadStream, typename DynamicBufferSequence,
+template <typename SyncReadStream, typename DynamicBuffer,
     typename CompletionCondition>
 std::size_t read(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     CompletionCondition completion_condition, asio::error_code& ec,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type* = 0);
 
+#if !defined(ASIO_NO_EXTENSIONS)
 #if !defined(ASIO_NO_IOSTREAM)
 
 /// Attempt to read a certain amount of data from a stream before returning.
@@ -522,6 +526,7 @@ std::size_t read(SyncReadStream& s, basic_streambuf<Allocator>& b,
     CompletionCondition completion_condition, asio::error_code& ec);
 
 #endif // !defined(ASIO_NO_IOSTREAM)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 /*@}*/
 /**
@@ -575,7 +580,7 @@ std::size_t read(SyncReadStream& s, basic_streambuf<Allocator>& b,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @par Example
  * To read into a single data buffer use the @ref buffer function as follows:
@@ -653,7 +658,7 @@ async_read(AsyncReadStream& s, const MutableBufferSequence& buffers,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @par Example
  * To read into a single data buffer use the @ref buffer function as follows:
@@ -718,7 +723,7 @@ async_read(AsyncReadStream& s, const MutableBufferSequence& buffers,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @note This overload is equivalent to calling:
  * @code asio::async_read(
@@ -727,14 +732,14 @@ async_read(AsyncReadStream& s, const MutableBufferSequence& buffers,
  *     handler); @endcode
  */
 template <typename AsyncReadStream,
-    typename DynamicBufferSequence, typename ReadHandler>
+    typename DynamicBuffer, typename ReadHandler>
 ASIO_INITFN_RESULT_TYPE(ReadHandler,
     void (asio::error_code, std::size_t))
 async_read(AsyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     ASIO_MOVE_ARG(ReadHandler) handler,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type* = 0);
 
 /// Start an asynchronous operation to read a certain amount of data from a
@@ -793,20 +798,21 @@ async_read(AsyncReadStream& s,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  */
-template <typename AsyncReadStream, typename DynamicBufferSequence,
+template <typename AsyncReadStream, typename DynamicBuffer,
     typename CompletionCondition, typename ReadHandler>
 ASIO_INITFN_RESULT_TYPE(ReadHandler,
     void (asio::error_code, std::size_t))
 async_read(AsyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     CompletionCondition completion_condition,
     ASIO_MOVE_ARG(ReadHandler) handler,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type* = 0);
 
+#if !defined(ASIO_NO_EXTENSIONS)
 #if !defined(ASIO_NO_IOSTREAM)
 
 /// Start an asynchronous operation to read a certain amount of data from a
@@ -849,7 +855,7 @@ async_read(AsyncReadStream& s,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @note This overload is equivalent to calling:
  * @code asio::async_read(
@@ -917,7 +923,7 @@ async_read(AsyncReadStream& s, basic_streambuf<Allocator>& b,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  */
 template <typename AsyncReadStream, typename Allocator,
     typename CompletionCondition, typename ReadHandler>
@@ -928,6 +934,7 @@ async_read(AsyncReadStream& s, basic_streambuf<Allocator>& b,
     ASIO_MOVE_ARG(ReadHandler) handler);
 
 #endif // !defined(ASIO_NO_IOSTREAM)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 /*@}*/
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/read_at.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/read_at.hpp
index 15291fc..16e6af1 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/read_at.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/read_at.hpp
@@ -2,7 +2,7 @@
 // read_at.hpp
 // ~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -18,10 +18,13 @@
 #include "asio/detail/config.hpp"
 #include <cstddef>
 #include "asio/async_result.hpp"
-#include "asio/basic_streambuf_fwd.hpp"
 #include "asio/detail/cstdint.hpp"
 #include "asio/error.hpp"
 
+#if !defined(ASIO_NO_EXTENSIONS)
+# include "asio/basic_streambuf_fwd.hpp"
+#endif // !defined(ASIO_NO_EXTENSIONS)
+
 #include "asio/detail/push_options.hpp"
 
 namespace asio {
@@ -229,6 +232,7 @@ std::size_t read_at(SyncRandomAccessReadDevice& d,
     uint64_t offset, const MutableBufferSequence& buffers,
     CompletionCondition completion_condition, asio::error_code& ec);
 
+#if !defined(ASIO_NO_EXTENSIONS)
 #if !defined(ASIO_NO_IOSTREAM)
 
 /// Attempt to read a certain amount of data at the specified offset before
@@ -384,6 +388,7 @@ std::size_t read_at(SyncRandomAccessReadDevice& d,
     CompletionCondition completion_condition, asio::error_code& ec);
 
 #endif // !defined(ASIO_NO_IOSTREAM)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 /*@}*/
 /**
@@ -436,7 +441,7 @@ std::size_t read_at(SyncRandomAccessReadDevice& d,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @par Example
  * To read into a single data buffer use the @ref buffer function as follows:
@@ -514,7 +519,7 @@ async_read_at(AsyncRandomAccessReadDevice& d, uint64_t offset,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @par Example
  * To read into a single data buffer use the @ref buffer function as follows:
@@ -535,6 +540,7 @@ async_read_at(AsyncRandomAccessReadDevice& d,
     CompletionCondition completion_condition,
     ASIO_MOVE_ARG(ReadHandler) handler);
 
+#if !defined(ASIO_NO_EXTENSIONS)
 #if !defined(ASIO_NO_IOSTREAM)
 
 /// Start an asynchronous operation to read a certain amount of data at the
@@ -574,7 +580,7 @@ async_read_at(AsyncRandomAccessReadDevice& d,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @note This overload is equivalent to calling:
  * @code asio::async_read_at(
@@ -640,7 +646,7 @@ async_read_at(AsyncRandomAccessReadDevice& d, uint64_t offset,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  */
 template <typename AsyncRandomAccessReadDevice, typename Allocator,
     typename CompletionCondition, typename ReadHandler>
@@ -652,6 +658,7 @@ async_read_at(AsyncRandomAccessReadDevice& d,
     ASIO_MOVE_ARG(ReadHandler) handler);
 
 #endif // !defined(ASIO_NO_IOSTREAM)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 /*@}*/
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/read_until.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/read_until.hpp
index a33e92c..93bf96b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/read_until.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/read_until.hpp
@@ -2,7 +2,7 @@
 // read_until.hpp
 // ~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,15 +16,18 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
-
 #include <cstddef>
 #include <string>
 #include "asio/async_result.hpp"
-#include "asio/basic_streambuf_fwd.hpp"
 #include "asio/detail/regex_fwd.hpp"
+#include "asio/detail/string_view.hpp"
 #include "asio/detail/type_traits.hpp"
 #include "asio/error.hpp"
 
+#if !defined(ASIO_NO_EXTENSIONS)
+# include "asio/basic_streambuf_fwd.hpp"
+#endif // !defined(ASIO_NO_EXTENSIONS)
+
 #include "asio/detail/push_options.hpp"
 
 namespace asio {
@@ -123,9 +126,9 @@ struct is_match_condition
  * This data may be the start of a new line, to be extracted by a subsequent
  * @c read_until operation.
  */
-template <typename SyncReadStream, typename DynamicBufferSequence>
+template <typename SyncReadStream, typename DynamicBuffer>
 std::size_t read_until(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers, char delim);
+    ASIO_MOVE_ARG(DynamicBuffer) buffers, char delim);
 
 /// Read data into a dynamic buffer sequence until it contains a specified
 /// delimiter.
@@ -161,9 +164,9 @@ std::size_t read_until(SyncReadStream& s,
  * typically leave that data in the dynamic buffer sequence for a subsequent
  * read_until operation to examine.
  */
-template <typename SyncReadStream, typename DynamicBufferSequence>
+template <typename SyncReadStream, typename DynamicBuffer>
 std::size_t read_until(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     char delim, asio::error_code& ec);
 
 /// Read data into a dynamic buffer sequence until it contains a specified
@@ -217,11 +220,10 @@ std::size_t read_until(SyncReadStream& s,
  * This data may be the start of a new line, to be extracted by a subsequent
  * @c read_until operation.
  */
-template <typename SyncReadStream,
-    typename DynamicBufferSequence, typename Allocator>
+template <typename SyncReadStream, typename DynamicBuffer>
 std::size_t read_until(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
-    const std::basic_string<char, std::char_traits<char>, Allocator>& delim);
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
+    ASIO_STRING_VIEW_PARAM delim);
 
 /// Read data into a dynamic buffer sequence until it contains a specified
 /// delimiter.
@@ -257,13 +259,13 @@ std::size_t read_until(SyncReadStream& s,
  * typically leave that data in the dynamic buffer sequence for a subsequent
  * read_until operation to examine.
  */
-template <typename SyncReadStream,
-    typename DynamicBufferSequence, typename Allocator>
+template <typename SyncReadStream, typename DynamicBuffer>
 std::size_t read_until(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
-    const std::basic_string<char, std::char_traits<char>, Allocator>& delim,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
+    ASIO_STRING_VIEW_PARAM delim,
     asio::error_code& ec);
 
+#if !defined(ASIO_NO_EXTENSIONS)
 #if defined(ASIO_HAS_BOOST_REGEX) \
   || defined(GENERATING_DOCUMENTATION)
 
@@ -321,9 +323,9 @@ std::size_t read_until(SyncReadStream& s,
  * This data may be the start of a new line, to be extracted by a subsequent
  * @c read_until operation.
  */
-template <typename SyncReadStream, typename DynamicBufferSequence>
+template <typename SyncReadStream, typename DynamicBuffer>
 std::size_t read_until(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     const boost::regex& expr);
 
 /// Read data into a dynamic buffer sequence until some part of the data it
@@ -362,9 +364,9 @@ std::size_t read_until(SyncReadStream& s,
  * expression. An application will typically leave that data in the dynamic
  * buffer sequence for a subsequent read_until operation to examine.
  */
-template <typename SyncReadStream, typename DynamicBufferSequence>
+template <typename SyncReadStream, typename DynamicBuffer>
 std::size_t read_until(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     const boost::regex& expr, asio::error_code& ec);
 
 #endif // defined(ASIO_HAS_BOOST_REGEX)
@@ -398,7 +400,7 @@ std::size_t read_until(SyncReadStream& s,
  * @code pair<iterator, bool> match_condition(iterator begin, iterator end);
  * @endcode
  * where @c iterator represents the type:
- * @code buffers_iterator<typename DynamicBufferSequence::const_buffers_type>
+ * @code buffers_iterator<typename DynamicBuffer::const_buffers_type>
  * @endcode
  * The iterator parameters @c begin and @c end define the range of bytes to be
  * scanned to determine whether there is a match. The @c first member of the
@@ -408,7 +410,7 @@ std::size_t read_until(SyncReadStream& s,
  * @c second member of the return value is true if a match has been found, false
  * otherwise.
  *
- * @returns The number of bytes in the dynamic_buffer_sequence's get area that
+ * @returns The number of bytes in the dynamic_buffer's get area that
  * have been fully consumed by the match function.
  *
  * @throws asio::system_error Thrown on failure.
@@ -473,9 +475,9 @@ std::size_t read_until(SyncReadStream& s,
  * @endcode
  */
 template <typename SyncReadStream,
-    typename DynamicBufferSequence, typename MatchCondition>
+    typename DynamicBuffer, typename MatchCondition>
 std::size_t read_until(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     MatchCondition match_condition,
     typename enable_if<is_match_condition<MatchCondition>::value>::type* = 0);
 
@@ -506,7 +508,7 @@ std::size_t read_until(SyncReadStream& s,
  * @code pair<iterator, bool> match_condition(iterator begin, iterator end);
  * @endcode
  * where @c iterator represents the type:
- * @code buffers_iterator<DynamicBufferSequence::const_buffers_type>
+ * @code buffers_iterator<DynamicBuffer::const_buffers_type>
  * @endcode
  * The iterator parameters @c begin and @c end define the range of bytes to be
  * scanned to determine whether there is a match. The @c first member of the
@@ -533,9 +535,9 @@ std::size_t read_until(SyncReadStream& s,
  * function objects.
  */
 template <typename SyncReadStream,
-    typename DynamicBufferSequence, typename MatchCondition>
+    typename DynamicBuffer, typename MatchCondition>
 std::size_t read_until(SyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     MatchCondition match_condition, asio::error_code& ec,
     typename enable_if<is_match_condition<MatchCondition>::value>::type* = 0);
 
@@ -678,7 +680,8 @@ std::size_t read_until(SyncReadStream& s,
  */
 template <typename SyncReadStream, typename Allocator>
 std::size_t read_until(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, const std::string& delim);
+    asio::basic_streambuf<Allocator>& b,
+    ASIO_STRING_VIEW_PARAM delim);
 
 /// Read data into a streambuf until it contains a specified delimiter.
 /**
@@ -712,8 +715,8 @@ std::size_t read_until(SyncReadStream& s,
  */
 template <typename SyncReadStream, typename Allocator>
 std::size_t read_until(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, const std::string& delim,
-    asio::error_code& ec);
+    asio::basic_streambuf<Allocator>& b,
+    ASIO_STRING_VIEW_PARAM delim, asio::error_code& ec);
 
 #if defined(ASIO_HAS_BOOST_REGEX) \
   || defined(GENERATING_DOCUMENTATION)
@@ -976,6 +979,7 @@ std::size_t read_until(SyncReadStream& s,
     typename enable_if<is_match_condition<MatchCondition>::value>::type* = 0);
 
 #endif // !defined(ASIO_NO_IOSTREAM)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 /*@}*/
 /**
@@ -1034,7 +1038,7 @@ std::size_t read_until(SyncReadStream& s,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @note After a successful async_read_until operation, the dynamic buffer
  * sequence may contain additional data beyond the delimiter. An application
@@ -1070,11 +1074,11 @@ std::size_t read_until(SyncReadStream& s,
  * @c async_read_until operation.
  */
 template <typename AsyncReadStream,
-    typename DynamicBufferSequence, typename ReadHandler>
+    typename DynamicBuffer, typename ReadHandler>
 ASIO_INITFN_RESULT_TYPE(ReadHandler,
     void (asio::error_code, std::size_t))
 async_read_until(AsyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     char delim, ASIO_MOVE_ARG(ReadHandler) handler);
 
 /// Start an asynchronous operation to read data into a dynamic buffer sequence
@@ -1124,7 +1128,7 @@ async_read_until(AsyncReadStream& s,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @note After a successful async_read_until operation, the dynamic buffer
  * sequence may contain additional data beyond the delimiter. An application
@@ -1160,14 +1164,15 @@ async_read_until(AsyncReadStream& s,
  * @c async_read_until operation.
  */
 template <typename AsyncReadStream,
-    typename DynamicBufferSequence, typename ReadHandler>
+    typename DynamicBuffer, typename ReadHandler>
 ASIO_INITFN_RESULT_TYPE(ReadHandler,
     void (asio::error_code, std::size_t))
 async_read_until(AsyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
-    const std::string& delim,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
+    ASIO_STRING_VIEW_PARAM delim,
     ASIO_MOVE_ARG(ReadHandler) handler);
 
+#if !defined(ASIO_NO_EXTENSIONS)
 #if defined(ASIO_HAS_BOOST_REGEX) \
   || defined(GENERATING_DOCUMENTATION)
 
@@ -1220,7 +1225,7 @@ async_read_until(AsyncReadStream& s,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @note After a successful async_read_until operation, the dynamic buffer
  * sequence may contain additional data beyond that which matched the regular
@@ -1257,11 +1262,11 @@ async_read_until(AsyncReadStream& s,
  * @c async_read_until operation.
  */
 template <typename AsyncReadStream,
-    typename DynamicBufferSequence, typename ReadHandler>
+    typename DynamicBuffer, typename ReadHandler>
 ASIO_INITFN_RESULT_TYPE(ReadHandler,
     void (asio::error_code, std::size_t))
 async_read_until(AsyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     const boost::regex& expr,
     ASIO_MOVE_ARG(ReadHandler) handler);
 
@@ -1304,7 +1309,7 @@ async_read_until(AsyncReadStream& s,
  * @code pair<iterator, bool> match_condition(iterator begin, iterator end);
  * @endcode
  * where @c iterator represents the type:
- * @code buffers_iterator<typename DynamicBufferSequence::const_buffers_type>
+ * @code buffers_iterator<typename DynamicBuffer::const_buffers_type>
  * @endcode
  * The iterator parameters @c begin and @c end define the range of bytes to be
  * scanned to determine whether there is a match. The @c first member of the
@@ -1329,7 +1334,7 @@ async_read_until(AsyncReadStream& s,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @note After a successful async_read_until operation, the dynamic buffer
  * sequence may contain additional data beyond that which matched the function
@@ -1396,12 +1401,12 @@ async_read_until(AsyncReadStream& s,
  * asio::async_read_until(s, data, match_char('a'), handler);
  * @endcode
  */
-template <typename AsyncReadStream, typename DynamicBufferSequence,
+template <typename AsyncReadStream, typename DynamicBuffer,
     typename MatchCondition, typename ReadHandler>
 ASIO_INITFN_RESULT_TYPE(ReadHandler,
     void (asio::error_code, std::size_t))
 async_read_until(AsyncReadStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     MatchCondition match_condition, ASIO_MOVE_ARG(ReadHandler) handler,
     typename enable_if<is_match_condition<MatchCondition>::value>::type* = 0);
 
@@ -1451,7 +1456,7 @@ async_read_until(AsyncReadStream& s,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @note After a successful async_read_until operation, the streambuf may
  * contain additional data beyond the delimiter. An application will typically
@@ -1536,7 +1541,7 @@ async_read_until(AsyncReadStream& s,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @note After a successful async_read_until operation, the streambuf may
  * contain additional data beyond the delimiter. An application will typically
@@ -1574,7 +1579,8 @@ template <typename AsyncReadStream, typename Allocator, typename ReadHandler>
 ASIO_INITFN_RESULT_TYPE(ReadHandler,
     void (asio::error_code, std::size_t))
 async_read_until(AsyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, const std::string& delim,
+    asio::basic_streambuf<Allocator>& b,
+    ASIO_STRING_VIEW_PARAM delim,
     ASIO_MOVE_ARG(ReadHandler) handler);
 
 #if defined(ASIO_HAS_BOOST_REGEX) \
@@ -1627,7 +1633,7 @@ async_read_until(AsyncReadStream& s,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @note After a successful async_read_until operation, the streambuf may
  * contain additional data beyond that which matched the regular expression. An
@@ -1729,7 +1735,7 @@ async_read_until(AsyncReadStream& s,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @note After a successful async_read_until operation, the streambuf may
  * contain additional data beyond that which matched the function object. An
@@ -1805,6 +1811,7 @@ async_read_until(AsyncReadStream& s,
     typename enable_if<is_match_condition<MatchCondition>::value>::type* = 0);
 
 #endif // !defined(ASIO_NO_IOSTREAM)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 /*@}*/
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/seq_packet_socket_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/seq_packet_socket_service.hpp
index f47154f..d517eeb 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/seq_packet_socket_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/seq_packet_socket_service.hpp
@@ -2,7 +2,7 @@
 // seq_packet_socket_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,11 +16,14 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #include <cstddef>
 #include "asio/async_result.hpp"
 #include "asio/detail/type_traits.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 
 #if defined(ASIO_WINDOWS_RUNTIME)
 # include "asio/detail/null_socket_service.hpp"
@@ -38,7 +41,7 @@ namespace asio {
 template <typename Protocol>
 class seq_packet_socket_service
 #if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
+  : public asio::io_context::service
 #else
   : public asio::detail::service_base<
       seq_packet_socket_service<Protocol> >
@@ -47,7 +50,7 @@ class seq_packet_socket_service
 public:
 #if defined(GENERATING_DOCUMENTATION)
   /// The unique service identifier.
-  static asio::io_service::id id;
+  static asio::io_context::id id;
 #endif
 
   /// The protocol type.
@@ -82,11 +85,11 @@ public:
 #endif
 
   /// Construct a new sequenced packet socket service for the specified
-  /// io_service.
-  explicit seq_packet_socket_service(asio::io_service& io_service)
+  /// io_context.
+  explicit seq_packet_socket_service(asio::io_context& io_context)
     : asio::detail::service_base<
-        seq_packet_socket_service<Protocol> >(io_service),
-      service_impl_(io_service)
+        seq_packet_socket_service<Protocol> >(io_context),
+      service_impl_(io_context)
   {
   }
 
@@ -133,22 +136,23 @@ public:
   }
 
   /// Open a sequenced packet socket.
-  asio::error_code open(implementation_type& impl,
+  ASIO_SYNC_OP_VOID open(implementation_type& impl,
       const protocol_type& protocol, asio::error_code& ec)
   {
     if (protocol.type() == ASIO_OS_DEF(SOCK_SEQPACKET))
       service_impl_.open(impl, protocol, ec);
     else
       ec = asio::error::invalid_argument;
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Assign an existing native socket to a sequenced packet socket.
-  asio::error_code assign(implementation_type& impl,
+  ASIO_SYNC_OP_VOID assign(implementation_type& impl,
       const protocol_type& protocol, const native_handle_type& native_socket,
       asio::error_code& ec)
   {
-    return service_impl_.assign(impl, protocol, native_socket, ec);
+    service_impl_.assign(impl, protocol, native_socket, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Determine whether the socket is open.
@@ -158,10 +162,11 @@ public:
   }
 
   /// Close a sequenced packet socket implementation.
-  asio::error_code close(implementation_type& impl,
+  ASIO_SYNC_OP_VOID close(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.close(impl, ec);
+    service_impl_.close(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the native socket implementation.
@@ -171,10 +176,11 @@ public:
   }
 
   /// Cancel all asynchronous operations associated with the socket.
-  asio::error_code cancel(implementation_type& impl,
+  ASIO_SYNC_OP_VOID cancel(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.cancel(impl, ec);
+    service_impl_.cancel(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Determine whether the socket is at the out-of-band data mark.
@@ -192,17 +198,19 @@ public:
   }
 
   /// Bind the sequenced packet socket to the specified local endpoint.
-  asio::error_code bind(implementation_type& impl,
+  ASIO_SYNC_OP_VOID bind(implementation_type& impl,
       const endpoint_type& endpoint, asio::error_code& ec)
   {
-    return service_impl_.bind(impl, endpoint, ec);
+    service_impl_.bind(impl, endpoint, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Connect the sequenced packet socket to the specified endpoint.
-  asio::error_code connect(implementation_type& impl,
+  ASIO_SYNC_OP_VOID connect(implementation_type& impl,
       const endpoint_type& peer_endpoint, asio::error_code& ec)
   {
-    return service_impl_.connect(impl, peer_endpoint, ec);
+    service_impl_.connect(impl, peer_endpoint, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Start an asynchronous connect.
@@ -216,33 +224,36 @@ public:
     async_completion<ConnectHandler,
       void (asio::error_code)> init(handler);
 
-    service_impl_.async_connect(impl, peer_endpoint, init.handler);
+    service_impl_.async_connect(impl, peer_endpoint, init.completion_handler);
 
     return init.result.get();
   }
 
   /// Set a socket option.
   template <typename SettableSocketOption>
-  asio::error_code set_option(implementation_type& impl,
+  ASIO_SYNC_OP_VOID set_option(implementation_type& impl,
       const SettableSocketOption& option, asio::error_code& ec)
   {
-    return service_impl_.set_option(impl, option, ec);
+    service_impl_.set_option(impl, option, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get a socket option.
   template <typename GettableSocketOption>
-  asio::error_code get_option(const implementation_type& impl,
+  ASIO_SYNC_OP_VOID get_option(const implementation_type& impl,
       GettableSocketOption& option, asio::error_code& ec) const
   {
-    return service_impl_.get_option(impl, option, ec);
+    service_impl_.get_option(impl, option, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Perform an IO control command on the socket.
   template <typename IoControlCommand>
-  asio::error_code io_control(implementation_type& impl,
+  ASIO_SYNC_OP_VOID io_control(implementation_type& impl,
       IoControlCommand& command, asio::error_code& ec)
   {
-    return service_impl_.io_control(impl, command, ec);
+    service_impl_.io_control(impl, command, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Gets the non-blocking mode of the socket.
@@ -252,10 +263,11 @@ public:
   }
 
   /// Sets the non-blocking mode of the socket.
-  asio::error_code non_blocking(implementation_type& impl,
+  ASIO_SYNC_OP_VOID non_blocking(implementation_type& impl,
       bool mode, asio::error_code& ec)
   {
-    return service_impl_.non_blocking(impl, mode, ec);
+    service_impl_.non_blocking(impl, mode, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Gets the non-blocking mode of the native socket implementation.
@@ -265,10 +277,11 @@ public:
   }
 
   /// Sets the non-blocking mode of the native socket implementation.
-  asio::error_code native_non_blocking(implementation_type& impl,
+  ASIO_SYNC_OP_VOID native_non_blocking(implementation_type& impl,
       bool mode, asio::error_code& ec)
   {
-    return service_impl_.native_non_blocking(impl, mode, ec);
+    service_impl_.native_non_blocking(impl, mode, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the local endpoint.
@@ -286,18 +299,20 @@ public:
   }
 
   /// Disable sends or receives on the socket.
-  asio::error_code shutdown(implementation_type& impl,
+  ASIO_SYNC_OP_VOID shutdown(implementation_type& impl,
       socket_base::shutdown_type what, asio::error_code& ec)
   {
-    return service_impl_.shutdown(impl, what, ec);
+    service_impl_.shutdown(impl, what, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Wait for the socket to become ready to read, ready to write, or to have
   /// pending error conditions.
-  asio::error_code wait(implementation_type& impl,
+  ASIO_SYNC_OP_VOID wait(implementation_type& impl,
       socket_base::wait_type w, asio::error_code& ec)
   {
-    return service_impl_.wait(impl, w, ec);
+    service_impl_.wait(impl, w, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Asynchronously wait for the socket to become ready to read, ready to
@@ -311,7 +326,7 @@ public:
     async_completion<WaitHandler,
       void (asio::error_code)> init(handler);
 
-    service_impl_.async_wait(impl, w, init.handler);
+    service_impl_.async_wait(impl, w, init.completion_handler);
 
     return init.result.get();
   }
@@ -337,7 +352,7 @@ public:
     async_completion<WriteHandler,
       void (asio::error_code, std::size_t)> init(handler);
 
-    service_impl_.async_send(impl, buffers, flags, init.handler);
+    service_impl_.async_send(impl, buffers, flags, init.completion_handler);
 
     return init.result.get();
   }
@@ -365,16 +380,16 @@ public:
       void (asio::error_code, std::size_t)> init(handler);
 
     service_impl_.async_receive_with_flags(impl,
-        buffers, in_flags, out_flags, init.handler);
+        buffers, in_flags, out_flags, init.completion_handler);
 
     return init.result.get();
   }
 
 private:
   // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
+  void shutdown()
   {
-    service_impl_.shutdown_service();
+    service_impl_.shutdown();
   }
 
   // The platform-specific implementation.
@@ -385,4 +400,6 @@ private:
 
 #include "asio/detail/pop_options.hpp"
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_SEQ_PACKET_SOCKET_SERVICE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/serial_port.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/serial_port.hpp
index f5ac715..4455a0a 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/serial_port.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/serial_port.hpp
@@ -2,7 +2,7 @@
 // serial_port.hpp
 // ~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -21,15 +21,748 @@
 #if defined(ASIO_HAS_SERIAL_PORT) \
   || defined(GENERATING_DOCUMENTATION)
 
-#include "asio/basic_serial_port.hpp"
+#include <string>
+#include "asio/async_result.hpp"
+#include "asio/basic_io_object.hpp"
+#include "asio/detail/handler_type_requirements.hpp"
+#include "asio/detail/throw_error.hpp"
+#include "asio/error.hpp"
+#include "asio/io_context.hpp"
+#include "asio/serial_port_base.hpp"
+
+#if defined(ASIO_HAS_MOVE)
+# include <utility>
+#endif // defined(ASIO_HAS_MOVE)
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+# include "asio/basic_serial_port.hpp"
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+# if defined(ASIO_HAS_IOCP)
+#  include "asio/detail/win_iocp_serial_port_service.hpp"
+#  define ASIO_SVC_T detail::win_iocp_serial_port_service
+# else
+#  include "asio/detail/reactive_serial_port_service.hpp"
+#  define ASIO_SVC_T detail::reactive_serial_port_service
+# endif
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
+#include "asio/detail/push_options.hpp"
 
 namespace asio {
 
-/// Typedef for the typical usage of a serial port.
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+// Typedef for the typical usage of a serial port.
 typedef basic_serial_port<> serial_port;
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+/// Provides serial port functionality.
+/**
+ * The serial_port class provides a wrapper over serial port functionality.
+ *
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Unsafe.
+ */
+class serial_port
+  : ASIO_SVC_ACCESS basic_io_object<ASIO_SVC_T>,
+    public serial_port_base
+{
+public:
+  /// The type of the executor associated with the object.
+  typedef io_context::executor_type executor_type;
+
+  /// The native representation of a serial port.
+#if defined(GENERATING_DOCUMENTATION)
+  typedef implementation_defined native_handle_type;
+#else
+  typedef ASIO_SVC_T::native_handle_type native_handle_type;
+#endif
+
+  /// A basic_serial_port is always the lowest layer.
+  typedef serial_port lowest_layer_type;
+
+  /// Construct a serial_port without opening it.
+  /**
+   * This constructor creates a serial port without opening it.
+   *
+   * @param io_context The io_context object that the serial port will use to
+   * dispatch handlers for any asynchronous operations performed on the port.
+   */
+  explicit serial_port(asio::io_context& io_context)
+    : basic_io_object<ASIO_SVC_T>(io_context)
+  {
+  }
+
+  /// Construct and open a serial_port.
+  /**
+   * This constructor creates and opens a serial port for the specified device
+   * name.
+   *
+   * @param io_context The io_context object that the serial port will use to
+   * dispatch handlers for any asynchronous operations performed on the port.
+   *
+   * @param device The platform-specific device name for this serial
+   * port.
+   */
+  explicit serial_port(asio::io_context& io_context,
+      const char* device)
+    : basic_io_object<ASIO_SVC_T>(io_context)
+  {
+    asio::error_code ec;
+    this->get_service().open(this->get_implementation(), device, ec);
+    asio::detail::throw_error(ec, "open");
+  }
+
+  /// Construct and open a serial_port.
+  /**
+   * This constructor creates and opens a serial port for the specified device
+   * name.
+   *
+   * @param io_context The io_context object that the serial port will use to
+   * dispatch handlers for any asynchronous operations performed on the port.
+   *
+   * @param device The platform-specific device name for this serial
+   * port.
+   */
+  explicit serial_port(asio::io_context& io_context,
+      const std::string& device)
+    : basic_io_object<ASIO_SVC_T>(io_context)
+  {
+    asio::error_code ec;
+    this->get_service().open(this->get_implementation(), device, ec);
+    asio::detail::throw_error(ec, "open");
+  }
+
+  /// Construct a serial_port on an existing native serial port.
+  /**
+   * This constructor creates a serial port object to hold an existing native
+   * serial port.
+   *
+   * @param io_context The io_context object that the serial port will use to
+   * dispatch handlers for any asynchronous operations performed on the port.
+   *
+   * @param native_serial_port A native serial port.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  serial_port(asio::io_context& io_context,
+      const native_handle_type& native_serial_port)
+    : basic_io_object<ASIO_SVC_T>(io_context)
+  {
+    asio::error_code ec;
+    this->get_service().assign(this->get_implementation(),
+        native_serial_port, ec);
+    asio::detail::throw_error(ec, "assign");
+  }
+
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+  /// Move-construct a serial_port from another.
+  /**
+   * This constructor moves a serial port from one object to another.
+   *
+   * @param other The other serial_port object from which the move will
+   * occur.
+   *
+   * @note Following the move, the moved-from object is in the same state as if
+   * constructed using the @c serial_port(io_context&) constructor.
+   */
+  serial_port(serial_port&& other)
+    : basic_io_object<ASIO_SVC_T>(std::move(other))
+  {
+  }
+
+  /// Move-assign a serial_port from another.
+  /**
+   * This assignment operator moves a serial port from one object to another.
+   *
+   * @param other The other serial_port object from which the move will
+   * occur.
+   *
+   * @note Following the move, the moved-from object is in the same state as if
+   * constructed using the @c serial_port(io_context&) constructor.
+   */
+  serial_port& operator=(serial_port&& other)
+  {
+    basic_io_object<ASIO_SVC_T>::operator=(std::move(other));
+    return *this;
+  }
+#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+
+  /// Destroys the serial port.
+  /**
+   * This function destroys the serial port, cancelling any outstanding
+   * asynchronous wait operations associated with the serial port as if by
+   * calling @c cancel.
+   */
+  ~serial_port()
+  {
+  }
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_context()
+  {
+    return basic_io_object<ASIO_SVC_T>::get_io_context();
+  }
+
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_service()
+  {
+    return basic_io_object<ASIO_SVC_T>::get_io_service();
+  }
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// Get the executor associated with the object.
+  executor_type get_executor() ASIO_NOEXCEPT
+  {
+    return basic_io_object<ASIO_SVC_T>::get_executor();
+  }
+
+  /// Get a reference to the lowest layer.
+  /**
+   * This function returns a reference to the lowest layer in a stack of
+   * layers. Since a serial_port cannot contain any further layers, it simply
+   * returns a reference to itself.
+   *
+   * @return A reference to the lowest layer in the stack of layers. Ownership
+   * is not transferred to the caller.
+   */
+  lowest_layer_type& lowest_layer()
+  {
+    return *this;
+  }
+
+  /// Get a const reference to the lowest layer.
+  /**
+   * This function returns a const reference to the lowest layer in a stack of
+   * layers. Since a serial_port cannot contain any further layers, it simply
+   * returns a reference to itself.
+   *
+   * @return A const reference to the lowest layer in the stack of layers.
+   * Ownership is not transferred to the caller.
+   */
+  const lowest_layer_type& lowest_layer() const
+  {
+    return *this;
+  }
+
+  /// Open the serial port using the specified device name.
+  /**
+   * This function opens the serial port for the specified device name.
+   *
+   * @param device The platform-specific device name.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  void open(const std::string& device)
+  {
+    asio::error_code ec;
+    this->get_service().open(this->get_implementation(), device, ec);
+    asio::detail::throw_error(ec, "open");
+  }
+
+  /// Open the serial port using the specified device name.
+  /**
+   * This function opens the serial port using the given platform-specific
+   * device name.
+   *
+   * @param device The platform-specific device name.
+   *
+   * @param ec Set the indicate what error occurred, if any.
+   */
+  ASIO_SYNC_OP_VOID open(const std::string& device,
+      asio::error_code& ec)
+  {
+    this->get_service().open(this->get_implementation(), device, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Assign an existing native serial port to the serial port.
+  /*
+   * This function opens the serial port to hold an existing native serial port.
+   *
+   * @param native_serial_port A native serial port.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  void assign(const native_handle_type& native_serial_port)
+  {
+    asio::error_code ec;
+    this->get_service().assign(this->get_implementation(),
+        native_serial_port, ec);
+    asio::detail::throw_error(ec, "assign");
+  }
+
+  /// Assign an existing native serial port to the serial port.
+  /*
+   * This function opens the serial port to hold an existing native serial port.
+   *
+   * @param native_serial_port A native serial port.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   */
+  ASIO_SYNC_OP_VOID assign(const native_handle_type& native_serial_port,
+      asio::error_code& ec)
+  {
+    this->get_service().assign(this->get_implementation(),
+        native_serial_port, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Determine whether the serial port is open.
+  bool is_open() const
+  {
+    return this->get_service().is_open(this->get_implementation());
+  }
+
+  /// Close the serial port.
+  /**
+   * This function is used to close the serial port. Any asynchronous read or
+   * write operations will be cancelled immediately, and will complete with the
+   * asio::error::operation_aborted error.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  void close()
+  {
+    asio::error_code ec;
+    this->get_service().close(this->get_implementation(), ec);
+    asio::detail::throw_error(ec, "close");
+  }
+
+  /// Close the serial port.
+  /**
+   * This function is used to close the serial port. Any asynchronous read or
+   * write operations will be cancelled immediately, and will complete with the
+   * asio::error::operation_aborted error.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   */
+  ASIO_SYNC_OP_VOID close(asio::error_code& ec)
+  {
+    this->get_service().close(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Get the native serial port representation.
+  /**
+   * This function may be used to obtain the underlying representation of the
+   * serial port. This is intended to allow access to native serial port
+   * functionality that is not otherwise provided.
+   */
+  native_handle_type native_handle()
+  {
+    return this->get_service().native_handle(this->get_implementation());
+  }
+
+  /// Cancel all asynchronous operations associated with the serial port.
+  /**
+   * This function causes all outstanding asynchronous read or write operations
+   * to finish immediately, and the handlers for cancelled operations will be
+   * passed the asio::error::operation_aborted error.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  void cancel()
+  {
+    asio::error_code ec;
+    this->get_service().cancel(this->get_implementation(), ec);
+    asio::detail::throw_error(ec, "cancel");
+  }
+
+  /// Cancel all asynchronous operations associated with the serial port.
+  /**
+   * This function causes all outstanding asynchronous read or write operations
+   * to finish immediately, and the handlers for cancelled operations will be
+   * passed the asio::error::operation_aborted error.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   */
+  ASIO_SYNC_OP_VOID cancel(asio::error_code& ec)
+  {
+    this->get_service().cancel(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Send a break sequence to the serial port.
+  /**
+   * This function causes a break sequence of platform-specific duration to be
+   * sent out the serial port.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  void send_break()
+  {
+    asio::error_code ec;
+    this->get_service().send_break(this->get_implementation(), ec);
+    asio::detail::throw_error(ec, "send_break");
+  }
+
+  /// Send a break sequence to the serial port.
+  /**
+   * This function causes a break sequence of platform-specific duration to be
+   * sent out the serial port.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   */
+  ASIO_SYNC_OP_VOID send_break(asio::error_code& ec)
+  {
+    this->get_service().send_break(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Set an option on the serial port.
+  /**
+   * This function is used to set an option on the serial port.
+   *
+   * @param option The option value to be set on the serial port.
+   *
+   * @throws asio::system_error Thrown on failure.
+   *
+   * @sa SettableSerialPortOption @n
+   * asio::serial_port_base::baud_rate @n
+   * asio::serial_port_base::flow_control @n
+   * asio::serial_port_base::parity @n
+   * asio::serial_port_base::stop_bits @n
+   * asio::serial_port_base::character_size
+   */
+  template <typename SettableSerialPortOption>
+  void set_option(const SettableSerialPortOption& option)
+  {
+    asio::error_code ec;
+    this->get_service().set_option(this->get_implementation(), option, ec);
+    asio::detail::throw_error(ec, "set_option");
+  }
+
+  /// Set an option on the serial port.
+  /**
+   * This function is used to set an option on the serial port.
+   *
+   * @param option The option value to be set on the serial port.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @sa SettableSerialPortOption @n
+   * asio::serial_port_base::baud_rate @n
+   * asio::serial_port_base::flow_control @n
+   * asio::serial_port_base::parity @n
+   * asio::serial_port_base::stop_bits @n
+   * asio::serial_port_base::character_size
+   */
+  template <typename SettableSerialPortOption>
+  ASIO_SYNC_OP_VOID set_option(const SettableSerialPortOption& option,
+      asio::error_code& ec)
+  {
+    this->get_service().set_option(this->get_implementation(), option, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Get an option from the serial port.
+  /**
+   * This function is used to get the current value of an option on the serial
+   * port.
+   *
+   * @param option The option value to be obtained from the serial port.
+   *
+   * @throws asio::system_error Thrown on failure.
+   *
+   * @sa GettableSerialPortOption @n
+   * asio::serial_port_base::baud_rate @n
+   * asio::serial_port_base::flow_control @n
+   * asio::serial_port_base::parity @n
+   * asio::serial_port_base::stop_bits @n
+   * asio::serial_port_base::character_size
+   */
+  template <typename GettableSerialPortOption>
+  void get_option(GettableSerialPortOption& option)
+  {
+    asio::error_code ec;
+    this->get_service().get_option(this->get_implementation(), option, ec);
+    asio::detail::throw_error(ec, "get_option");
+  }
+
+  /// Get an option from the serial port.
+  /**
+   * This function is used to get the current value of an option on the serial
+   * port.
+   *
+   * @param option The option value to be obtained from the serial port.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @sa GettableSerialPortOption @n
+   * asio::serial_port_base::baud_rate @n
+   * asio::serial_port_base::flow_control @n
+   * asio::serial_port_base::parity @n
+   * asio::serial_port_base::stop_bits @n
+   * asio::serial_port_base::character_size
+   */
+  template <typename GettableSerialPortOption>
+  ASIO_SYNC_OP_VOID get_option(GettableSerialPortOption& option,
+      asio::error_code& ec)
+  {
+    this->get_service().get_option(this->get_implementation(), option, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Write some data to the serial port.
+  /**
+   * This function is used to write data to the serial port. The function call
+   * will block until one or more bytes of the data has been written
+   * successfully, or until an error occurs.
+   *
+   * @param buffers One or more data buffers to be written to the serial port.
+   *
+   * @returns The number of bytes written.
+   *
+   * @throws asio::system_error Thrown on failure. An error code of
+   * asio::error::eof indicates that the connection was closed by the
+   * peer.
+   *
+   * @note The write_some operation may not transmit all of the data to the
+   * peer. Consider using the @ref write function if you need to ensure that
+   * all data is written before the blocking operation completes.
+   *
+   * @par Example
+   * To write a single data buffer use the @ref buffer function as follows:
+   * @code
+   * serial_port.write_some(asio::buffer(data, size));
+   * @endcode
+   * See the @ref buffer documentation for information on writing multiple
+   * buffers in one go, and how to use it with arrays, boost::array or
+   * std::vector.
+   */
+  template <typename ConstBufferSequence>
+  std::size_t write_some(const ConstBufferSequence& buffers)
+  {
+    asio::error_code ec;
+    std::size_t s = this->get_service().write_some(
+        this->get_implementation(), buffers, ec);
+    asio::detail::throw_error(ec, "write_some");
+    return s;
+  }
+
+  /// Write some data to the serial port.
+  /**
+   * This function is used to write data to the serial port. The function call
+   * will block until one or more bytes of the data has been written
+   * successfully, or until an error occurs.
+   *
+   * @param buffers One or more data buffers to be written to the serial port.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @returns The number of bytes written. Returns 0 if an error occurred.
+   *
+   * @note The write_some operation may not transmit all of the data to the
+   * peer. Consider using the @ref write function if you need to ensure that
+   * all data is written before the blocking operation completes.
+   */
+  template <typename ConstBufferSequence>
+  std::size_t write_some(const ConstBufferSequence& buffers,
+      asio::error_code& ec)
+  {
+    return this->get_service().write_some(
+        this->get_implementation(), buffers, ec);
+  }
+
+  /// Start an asynchronous write.
+  /**
+   * This function is used to asynchronously write data to the serial port.
+   * The function call always returns immediately.
+   *
+   * @param buffers One or more data buffers to be written to the serial port.
+   * Although the buffers object may be copied as necessary, ownership of the
+   * underlying memory blocks is retained by the caller, which must guarantee
+   * that they remain valid until the handler is called.
+   *
+   * @param handler The handler to be called when the write operation completes.
+   * Copies will be made of the handler as required. The function signature of
+   * the handler must be:
+   * @code void handler(
+   *   const asio::error_code& error, // Result of operation.
+   *   std::size_t bytes_transferred           // Number of bytes written.
+   * ); @endcode
+   * Regardless of whether the asynchronous operation completes immediately or
+   * not, the handler will not be invoked from within this function. Invocation
+   * of the handler will be performed in a manner equivalent to using
+   * asio::io_context::post().
+   *
+   * @note The write operation may not transmit all of the data to the peer.
+   * Consider using the @ref async_write function if you need to ensure that all
+   * data is written before the asynchronous operation completes.
+   *
+   * @par Example
+   * To write a single data buffer use the @ref buffer function as follows:
+   * @code
+   * serial_port.async_write_some(asio::buffer(data, size), handler);
+   * @endcode
+   * See the @ref buffer documentation for information on writing multiple
+   * buffers in one go, and how to use it with arrays, boost::array or
+   * std::vector.
+   */
+  template <typename ConstBufferSequence, typename WriteHandler>
+  ASIO_INITFN_RESULT_TYPE(WriteHandler,
+      void (asio::error_code, std::size_t))
+  async_write_some(const ConstBufferSequence& buffers,
+      ASIO_MOVE_ARG(WriteHandler) handler)
+  {
+    // If you get an error on the following line it means that your handler does
+    // not meet the documented type requirements for a WriteHandler.
+    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
+
+    async_completion<WriteHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_write_some(
+        this->get_implementation(), buffers, init.completion_handler);
+
+    return init.result.get();
+  }
+
+  /// Read some data from the serial port.
+  /**
+   * This function is used to read data from the serial port. The function
+   * call will block until one or more bytes of data has been read successfully,
+   * or until an error occurs.
+   *
+   * @param buffers One or more buffers into which the data will be read.
+   *
+   * @returns The number of bytes read.
+   *
+   * @throws asio::system_error Thrown on failure. An error code of
+   * asio::error::eof indicates that the connection was closed by the
+   * peer.
+   *
+   * @note The read_some operation may not read all of the requested number of
+   * bytes. Consider using the @ref read function if you need to ensure that
+   * the requested amount of data is read before the blocking operation
+   * completes.
+   *
+   * @par Example
+   * To read into a single data buffer use the @ref buffer function as follows:
+   * @code
+   * serial_port.read_some(asio::buffer(data, size));
+   * @endcode
+   * See the @ref buffer documentation for information on reading into multiple
+   * buffers in one go, and how to use it with arrays, boost::array or
+   * std::vector.
+   */
+  template <typename MutableBufferSequence>
+  std::size_t read_some(const MutableBufferSequence& buffers)
+  {
+    asio::error_code ec;
+    std::size_t s = this->get_service().read_some(
+        this->get_implementation(), buffers, ec);
+    asio::detail::throw_error(ec, "read_some");
+    return s;
+  }
+
+  /// Read some data from the serial port.
+  /**
+   * This function is used to read data from the serial port. The function
+   * call will block until one or more bytes of data has been read successfully,
+   * or until an error occurs.
+   *
+   * @param buffers One or more buffers into which the data will be read.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @returns The number of bytes read. Returns 0 if an error occurred.
+   *
+   * @note The read_some operation may not read all of the requested number of
+   * bytes. Consider using the @ref read function if you need to ensure that
+   * the requested amount of data is read before the blocking operation
+   * completes.
+   */
+  template <typename MutableBufferSequence>
+  std::size_t read_some(const MutableBufferSequence& buffers,
+      asio::error_code& ec)
+  {
+    return this->get_service().read_some(
+        this->get_implementation(), buffers, ec);
+  }
+
+  /// Start an asynchronous read.
+  /**
+   * This function is used to asynchronously read data from the serial port.
+   * The function call always returns immediately.
+   *
+   * @param buffers One or more buffers into which the data will be read.
+   * Although the buffers object may be copied as necessary, ownership of the
+   * underlying memory blocks is retained by the caller, which must guarantee
+   * that they remain valid until the handler is called.
+   *
+   * @param handler The handler to be called when the read operation completes.
+   * Copies will be made of the handler as required. The function signature of
+   * the handler must be:
+   * @code void handler(
+   *   const asio::error_code& error, // Result of operation.
+   *   std::size_t bytes_transferred           // Number of bytes read.
+   * ); @endcode
+   * Regardless of whether the asynchronous operation completes immediately or
+   * not, the handler will not be invoked from within this function. Invocation
+   * of the handler will be performed in a manner equivalent to using
+   * asio::io_context::post().
+   *
+   * @note The read operation may not read all of the requested number of bytes.
+   * Consider using the @ref async_read function if you need to ensure that the
+   * requested amount of data is read before the asynchronous operation
+   * completes.
+   *
+   * @par Example
+   * To read into a single data buffer use the @ref buffer function as follows:
+   * @code
+   * serial_port.async_read_some(asio::buffer(data, size), handler);
+   * @endcode
+   * See the @ref buffer documentation for information on reading into multiple
+   * buffers in one go, and how to use it with arrays, boost::array or
+   * std::vector.
+   */
+  template <typename MutableBufferSequence, typename ReadHandler>
+  ASIO_INITFN_RESULT_TYPE(ReadHandler,
+      void (asio::error_code, std::size_t))
+  async_read_some(const MutableBufferSequence& buffers,
+      ASIO_MOVE_ARG(ReadHandler) handler)
+  {
+    // If you get an error on the following line it means that your handler does
+    // not meet the documented type requirements for a ReadHandler.
+    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
+
+    async_completion<ReadHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_read_some(
+        this->get_implementation(), buffers, init.completion_handler);
+
+    return init.result.get();
+  }
+};
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
 
 } // namespace asio
 
+#include "asio/detail/pop_options.hpp"
+
+#if !defined(ASIO_ENABLE_OLD_SERVICES)
+# undef ASIO_SVC_T
+#endif // !defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // defined(ASIO_HAS_SERIAL_PORT)
        //   || defined(GENERATING_DOCUMENTATION)
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/serial_port_base.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/serial_port_base.hpp
index a6d8652..b4ab4f3 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/serial_port_base.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/serial_port_base.hpp
@@ -2,7 +2,7 @@
 // serial_port_base.hpp
 // ~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -54,10 +54,10 @@ public:
   public:
     explicit baud_rate(unsigned int rate = 0);
     unsigned int value() const;
-    ASIO_DECL asio::error_code store(
+    ASIO_DECL ASIO_SYNC_OP_VOID store(
         ASIO_OPTION_STORAGE& storage,
         asio::error_code& ec) const;
-    ASIO_DECL asio::error_code load(
+    ASIO_DECL ASIO_SYNC_OP_VOID load(
         const ASIO_OPTION_STORAGE& storage,
         asio::error_code& ec);
   private:
@@ -74,10 +74,10 @@ public:
     enum type { none, software, hardware };
     ASIO_DECL explicit flow_control(type t = none);
     type value() const;
-    ASIO_DECL asio::error_code store(
+    ASIO_DECL ASIO_SYNC_OP_VOID store(
         ASIO_OPTION_STORAGE& storage,
         asio::error_code& ec) const;
-    ASIO_DECL asio::error_code load(
+    ASIO_DECL ASIO_SYNC_OP_VOID load(
         const ASIO_OPTION_STORAGE& storage,
         asio::error_code& ec);
   private:
@@ -94,10 +94,10 @@ public:
     enum type { none, odd, even };
     ASIO_DECL explicit parity(type t = none);
     type value() const;
-    ASIO_DECL asio::error_code store(
+    ASIO_DECL ASIO_SYNC_OP_VOID store(
         ASIO_OPTION_STORAGE& storage,
         asio::error_code& ec) const;
-    ASIO_DECL asio::error_code load(
+    ASIO_DECL ASIO_SYNC_OP_VOID load(
         const ASIO_OPTION_STORAGE& storage,
         asio::error_code& ec);
   private:
@@ -114,10 +114,10 @@ public:
     enum type { one, onepointfive, two };
     ASIO_DECL explicit stop_bits(type t = one);
     type value() const;
-    ASIO_DECL asio::error_code store(
+    ASIO_DECL ASIO_SYNC_OP_VOID store(
         ASIO_OPTION_STORAGE& storage,
         asio::error_code& ec) const;
-    ASIO_DECL asio::error_code load(
+    ASIO_DECL ASIO_SYNC_OP_VOID load(
         const ASIO_OPTION_STORAGE& storage,
         asio::error_code& ec);
   private:
@@ -133,10 +133,10 @@ public:
   public:
     ASIO_DECL explicit character_size(unsigned int t = 8);
     unsigned int value() const;
-    ASIO_DECL asio::error_code store(
+    ASIO_DECL ASIO_SYNC_OP_VOID store(
         ASIO_OPTION_STORAGE& storage,
         asio::error_code& ec) const;
-    ASIO_DECL asio::error_code load(
+    ASIO_DECL ASIO_SYNC_OP_VOID load(
         const ASIO_OPTION_STORAGE& storage,
         asio::error_code& ec);
   private:
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/serial_port_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/serial_port_service.hpp
index 6b930c3..4f47e57 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/serial_port_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/serial_port_service.hpp
@@ -2,7 +2,7 @@
 // serial_port_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,6 +17,8 @@
 
 #include "asio/detail/config.hpp"
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #if defined(ASIO_HAS_SERIAL_PORT) \
   || defined(GENERATING_DOCUMENTATION)
 
@@ -26,7 +28,7 @@
 #include "asio/detail/reactive_serial_port_service.hpp"
 #include "asio/detail/win_iocp_serial_port_service.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/serial_port_base.hpp"
 
 #include "asio/detail/push_options.hpp"
@@ -36,7 +38,7 @@ namespace asio {
 /// Default service implementation for a serial port.
 class serial_port_service
 #if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
+  : public asio::io_context::service
 #else
   : public asio::detail::service_base<serial_port_service>
 #endif
@@ -44,7 +46,7 @@ class serial_port_service
 public:
 #if defined(GENERATING_DOCUMENTATION)
   /// The unique service identifier.
-  static asio::io_service::id id;
+  static asio::io_context::id id;
 #endif
 
 private:
@@ -70,10 +72,10 @@ public:
   typedef service_impl_type::native_handle_type native_handle_type;
 #endif
 
-  /// Construct a new serial port service for the specified io_service.
-  explicit serial_port_service(asio::io_service& io_service)
-    : asio::detail::service_base<serial_port_service>(io_service),
-      service_impl_(io_service)
+  /// Construct a new serial port service for the specified io_context.
+  explicit serial_port_service(asio::io_context& io_context)
+    : asio::detail::service_base<serial_port_service>(io_context),
+      service_impl_(io_context)
   {
   }
 
@@ -107,17 +109,19 @@ public:
   }
 
   /// Open a serial port.
-  asio::error_code open(implementation_type& impl,
+  ASIO_SYNC_OP_VOID open(implementation_type& impl,
       const std::string& device, asio::error_code& ec)
   {
-    return service_impl_.open(impl, device, ec);
+    service_impl_.open(impl, device, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Assign an existing native handle to a serial port.
-  asio::error_code assign(implementation_type& impl,
+  ASIO_SYNC_OP_VOID assign(implementation_type& impl,
       const native_handle_type& handle, asio::error_code& ec)
   {
-    return service_impl_.assign(impl, handle, ec);
+    service_impl_.assign(impl, handle, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Determine whether the handle is open.
@@ -127,10 +131,11 @@ public:
   }
 
   /// Close a serial port implementation.
-  asio::error_code close(implementation_type& impl,
+  ASIO_SYNC_OP_VOID close(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.close(impl, ec);
+    service_impl_.close(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the native handle implementation.
@@ -140,33 +145,37 @@ public:
   }
 
   /// Cancel all asynchronous operations associated with the handle.
-  asio::error_code cancel(implementation_type& impl,
+  ASIO_SYNC_OP_VOID cancel(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.cancel(impl, ec);
+    service_impl_.cancel(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Set a serial port option.
   template <typename SettableSerialPortOption>
-  asio::error_code set_option(implementation_type& impl,
+  ASIO_SYNC_OP_VOID set_option(implementation_type& impl,
       const SettableSerialPortOption& option, asio::error_code& ec)
   {
-    return service_impl_.set_option(impl, option, ec);
+    service_impl_.set_option(impl, option, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get a serial port option.
   template <typename GettableSerialPortOption>
-  asio::error_code get_option(const implementation_type& impl,
+  ASIO_SYNC_OP_VOID get_option(const implementation_type& impl,
       GettableSerialPortOption& option, asio::error_code& ec) const
   {
-    return service_impl_.get_option(impl, option, ec);
+    service_impl_.get_option(impl, option, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Send a break sequence to the serial port.
-  asio::error_code send_break(implementation_type& impl,
+  ASIO_SYNC_OP_VOID send_break(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.send_break(impl, ec);
+    service_impl_.send_break(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Write the given data to the stream.
@@ -188,7 +197,7 @@ public:
     async_completion<WriteHandler,
       void (asio::error_code, std::size_t)> init(handler);
 
-    service_impl_.async_write_some(impl, buffers, init.handler);
+    service_impl_.async_write_some(impl, buffers, init.completion_handler);
 
     return init.result.get();
   }
@@ -212,16 +221,16 @@ public:
     async_completion<ReadHandler,
       void (asio::error_code, std::size_t)> init(handler);
 
-    service_impl_.async_read_some(impl, buffers, init.handler);
+    service_impl_.async_read_some(impl, buffers, init.completion_handler);
 
     return init.result.get();
   }
 
 private:
   // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
+  void shutdown()
   {
-    service_impl_.shutdown_service();
+    service_impl_.shutdown();
   }
 
   // The platform-specific implementation.
@@ -235,4 +244,6 @@ private:
 #endif // defined(ASIO_HAS_SERIAL_PORT)
        //   || defined(GENERATING_DOCUMENTATION)
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_SERIAL_PORT_SERVICE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/signal_set.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/signal_set.hpp
index 985b6fa..0850901 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/signal_set.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/signal_set.hpp
@@ -2,7 +2,7 @@
 // signal_set.hpp
 // ~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,12 +16,431 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
-#include "asio/basic_signal_set.hpp"
+
+#include "asio/async_result.hpp"
+#include "asio/basic_io_object.hpp"
+#include "asio/detail/handler_type_requirements.hpp"
+#include "asio/detail/throw_error.hpp"
+#include "asio/error.hpp"
+#include "asio/io_context.hpp"
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+# include "asio/basic_signal_set.hpp"
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+# include "asio/detail/signal_set_service.hpp"
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
 
 namespace asio {
 
-/// Typedef for the typical usage of a signal set.
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+// Typedef for the typical usage of a signal set.
 typedef basic_signal_set<> signal_set;
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+/// Provides signal functionality.
+/**
+ * The signal_set class provides the ability to perform an asynchronous wait
+ * for one or more signals to occur.
+ *
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Unsafe.
+ *
+ * @par Example
+ * Performing an asynchronous wait:
+ * @code
+ * void handler(
+ *     const asio::error_code& error,
+ *     int signal_number)
+ * {
+ *   if (!error)
+ *   {
+ *     // A signal occurred.
+ *   }
+ * }
+ *
+ * ...
+ *
+ * // Construct a signal set registered for process termination.
+ * asio::signal_set signals(io_context, SIGINT, SIGTERM);
+ *
+ * // Start an asynchronous wait for one of the signals to occur.
+ * signals.async_wait(handler);
+ * @endcode
+ *
+ * @par Queueing of signal notifications
+ *
+ * If a signal is registered with a signal_set, and the signal occurs when
+ * there are no waiting handlers, then the signal notification is queued. The
+ * next async_wait operation on that signal_set will dequeue the notification.
+ * If multiple notifications are queued, subsequent async_wait operations
+ * dequeue them one at a time. Signal notifications are dequeued in order of
+ * ascending signal number.
+ *
+ * If a signal number is removed from a signal_set (using the @c remove or @c
+ * erase member functions) then any queued notifications for that signal are
+ * discarded.
+ *
+ * @par Multiple registration of signals
+ *
+ * The same signal number may be registered with different signal_set objects.
+ * When the signal occurs, one handler is called for each signal_set object.
+ *
+ * Note that multiple registration only works for signals that are registered
+ * using Asio. The application must not also register a signal handler using
+ * functions such as @c signal() or @c sigaction().
+ *
+ * @par Signal masking on POSIX platforms
+ *
+ * POSIX allows signals to be blocked using functions such as @c sigprocmask()
+ * and @c pthread_sigmask(). For signals to be delivered, programs must ensure
+ * that any signals registered using signal_set objects are unblocked in at
+ * least one thread.
+ */
+class signal_set
+  : ASIO_SVC_ACCESS basic_io_object<detail::signal_set_service>
+{
+public:
+  /// The type of the executor associated with the object.
+  typedef io_context::executor_type executor_type;
+
+  /// Construct a signal set without adding any signals.
+  /**
+   * This constructor creates a signal set without registering for any signals.
+   *
+   * @param io_context The io_context object that the signal set will use to
+   * dispatch handlers for any asynchronous operations performed on the set.
+   */
+  explicit signal_set(asio::io_context& io_context)
+    : basic_io_object<detail::signal_set_service>(io_context)
+  {
+  }
+
+  /// Construct a signal set and add one signal.
+  /**
+   * This constructor creates a signal set and registers for one signal.
+   *
+   * @param io_context The io_context object that the signal set will use to
+   * dispatch handlers for any asynchronous operations performed on the set.
+   *
+   * @param signal_number_1 The signal number to be added.
+   *
+   * @note This constructor is equivalent to performing:
+   * @code asio::signal_set signals(io_context);
+   * signals.add(signal_number_1); @endcode
+   */
+  signal_set(asio::io_context& io_context, int signal_number_1)
+    : basic_io_object<detail::signal_set_service>(io_context)
+  {
+    asio::error_code ec;
+    this->get_service().add(this->get_implementation(), signal_number_1, ec);
+    asio::detail::throw_error(ec, "add");
+  }
+
+  /// Construct a signal set and add two signals.
+  /**
+   * This constructor creates a signal set and registers for two signals.
+   *
+   * @param io_context The io_context object that the signal set will use to
+   * dispatch handlers for any asynchronous operations performed on the set.
+   *
+   * @param signal_number_1 The first signal number to be added.
+   *
+   * @param signal_number_2 The second signal number to be added.
+   *
+   * @note This constructor is equivalent to performing:
+   * @code asio::signal_set signals(io_context);
+   * signals.add(signal_number_1);
+   * signals.add(signal_number_2); @endcode
+   */
+  signal_set(asio::io_context& io_context, int signal_number_1,
+      int signal_number_2)
+    : basic_io_object<detail::signal_set_service>(io_context)
+  {
+    asio::error_code ec;
+    this->get_service().add(this->get_implementation(), signal_number_1, ec);
+    asio::detail::throw_error(ec, "add");
+    this->get_service().add(this->get_implementation(), signal_number_2, ec);
+    asio::detail::throw_error(ec, "add");
+  }
+
+  /// Construct a signal set and add three signals.
+  /**
+   * This constructor creates a signal set and registers for three signals.
+   *
+   * @param io_context The io_context object that the signal set will use to
+   * dispatch handlers for any asynchronous operations performed on the set.
+   *
+   * @param signal_number_1 The first signal number to be added.
+   *
+   * @param signal_number_2 The second signal number to be added.
+   *
+   * @param signal_number_3 The third signal number to be added.
+   *
+   * @note This constructor is equivalent to performing:
+   * @code asio::signal_set signals(io_context);
+   * signals.add(signal_number_1);
+   * signals.add(signal_number_2);
+   * signals.add(signal_number_3); @endcode
+   */
+  signal_set(asio::io_context& io_context, int signal_number_1,
+      int signal_number_2, int signal_number_3)
+    : basic_io_object<detail::signal_set_service>(io_context)
+  {
+    asio::error_code ec;
+    this->get_service().add(this->get_implementation(), signal_number_1, ec);
+    asio::detail::throw_error(ec, "add");
+    this->get_service().add(this->get_implementation(), signal_number_2, ec);
+    asio::detail::throw_error(ec, "add");
+    this->get_service().add(this->get_implementation(), signal_number_3, ec);
+    asio::detail::throw_error(ec, "add");
+  }
+
+  /// Destroys the signal set.
+  /**
+   * This function destroys the signal set, cancelling any outstanding
+   * asynchronous wait operations associated with the signal set as if by
+   * calling @c cancel.
+   */
+  ~signal_set()
+  {
+  }
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_context()
+  {
+    return basic_io_object<detail::signal_set_service>::get_io_context();
+  }
+
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_service()
+  {
+    return basic_io_object<detail::signal_set_service>::get_io_service();
+  }
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// Get the executor associated with the object.
+  executor_type get_executor() ASIO_NOEXCEPT
+  {
+    return basic_io_object<detail::signal_set_service>::get_executor();
+  }
+
+  /// Add a signal to a signal_set.
+  /**
+   * This function adds the specified signal to the set. It has no effect if the
+   * signal is already in the set.
+   *
+   * @param signal_number The signal to be added to the set.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  void add(int signal_number)
+  {
+    asio::error_code ec;
+    this->get_service().add(this->get_implementation(), signal_number, ec);
+    asio::detail::throw_error(ec, "add");
+  }
+
+  /// Add a signal to a signal_set.
+  /**
+   * This function adds the specified signal to the set. It has no effect if the
+   * signal is already in the set.
+   *
+   * @param signal_number The signal to be added to the set.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   */
+  ASIO_SYNC_OP_VOID add(int signal_number,
+      asio::error_code& ec)
+  {
+    this->get_service().add(this->get_implementation(), signal_number, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Remove a signal from a signal_set.
+  /**
+   * This function removes the specified signal from the set. It has no effect
+   * if the signal is not in the set.
+   *
+   * @param signal_number The signal to be removed from the set.
+   *
+   * @throws asio::system_error Thrown on failure.
+   *
+   * @note Removes any notifications that have been queued for the specified
+   * signal number.
+   */
+  void remove(int signal_number)
+  {
+    asio::error_code ec;
+    this->get_service().remove(this->get_implementation(), signal_number, ec);
+    asio::detail::throw_error(ec, "remove");
+  }
+
+  /// Remove a signal from a signal_set.
+  /**
+   * This function removes the specified signal from the set. It has no effect
+   * if the signal is not in the set.
+   *
+   * @param signal_number The signal to be removed from the set.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @note Removes any notifications that have been queued for the specified
+   * signal number.
+   */
+  ASIO_SYNC_OP_VOID remove(int signal_number,
+      asio::error_code& ec)
+  {
+    this->get_service().remove(this->get_implementation(), signal_number, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Remove all signals from a signal_set.
+  /**
+   * This function removes all signals from the set. It has no effect if the set
+   * is already empty.
+   *
+   * @throws asio::system_error Thrown on failure.
+   *
+   * @note Removes all queued notifications.
+   */
+  void clear()
+  {
+    asio::error_code ec;
+    this->get_service().clear(this->get_implementation(), ec);
+    asio::detail::throw_error(ec, "clear");
+  }
+
+  /// Remove all signals from a signal_set.
+  /**
+   * This function removes all signals from the set. It has no effect if the set
+   * is already empty.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @note Removes all queued notifications.
+   */
+  ASIO_SYNC_OP_VOID clear(asio::error_code& ec)
+  {
+    this->get_service().clear(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Cancel all operations associated with the signal set.
+  /**
+   * This function forces the completion of any pending asynchronous wait
+   * operations against the signal set. The handler for each cancelled
+   * operation will be invoked with the asio::error::operation_aborted
+   * error code.
+   *
+   * Cancellation does not alter the set of registered signals.
+   *
+   * @throws asio::system_error Thrown on failure.
+   *
+   * @note If a registered signal occurred before cancel() is called, then the
+   * handlers for asynchronous wait operations will:
+   *
+   * @li have already been invoked; or
+   *
+   * @li have been queued for invocation in the near future.
+   *
+   * These handlers can no longer be cancelled, and therefore are passed an
+   * error code that indicates the successful completion of the wait operation.
+   */
+  void cancel()
+  {
+    asio::error_code ec;
+    this->get_service().cancel(this->get_implementation(), ec);
+    asio::detail::throw_error(ec, "cancel");
+  }
+
+  /// Cancel all operations associated with the signal set.
+  /**
+   * This function forces the completion of any pending asynchronous wait
+   * operations against the signal set. The handler for each cancelled
+   * operation will be invoked with the asio::error::operation_aborted
+   * error code.
+   *
+   * Cancellation does not alter the set of registered signals.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @note If a registered signal occurred before cancel() is called, then the
+   * handlers for asynchronous wait operations will:
+   *
+   * @li have already been invoked; or
+   *
+   * @li have been queued for invocation in the near future.
+   *
+   * These handlers can no longer be cancelled, and therefore are passed an
+   * error code that indicates the successful completion of the wait operation.
+   */
+  ASIO_SYNC_OP_VOID cancel(asio::error_code& ec)
+  {
+    this->get_service().cancel(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Start an asynchronous operation to wait for a signal to be delivered.
+  /**
+   * This function may be used to initiate an asynchronous wait against the
+   * signal set. It always returns immediately.
+   *
+   * For each call to async_wait(), the supplied handler will be called exactly
+   * once. The handler will be called when:
+   *
+   * @li One of the registered signals in the signal set occurs; or
+   *
+   * @li The signal set was cancelled, in which case the handler is passed the
+   * error code asio::error::operation_aborted.
+   *
+   * @param handler The handler to be called when the signal occurs. Copies
+   * will be made of the handler as required. The function signature of the
+   * handler must be:
+   * @code void handler(
+   *   const asio::error_code& error, // Result of operation.
+   *   int signal_number // Indicates which signal occurred.
+   * ); @endcode
+   * Regardless of whether the asynchronous operation completes immediately or
+   * not, the handler will not be invoked from within this function. Invocation
+   * of the handler will be performed in a manner equivalent to using
+   * asio::io_context::post().
+   */
+  template <typename SignalHandler>
+  ASIO_INITFN_RESULT_TYPE(SignalHandler,
+      void (asio::error_code, int))
+  async_wait(ASIO_MOVE_ARG(SignalHandler) handler)
+  {
+    // If you get an error on the following line it means that your handler does
+    // not meet the documented type requirements for a SignalHandler.
+    ASIO_SIGNAL_HANDLER_CHECK(SignalHandler, handler) type_check;
+
+    async_completion<SignalHandler,
+      void (asio::error_code, int)> init(handler);
+
+    this->get_service().async_wait(this->get_implementation(),
+        init.completion_handler);
+
+    return init.result.get();
+  }
+};
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
 
 } // namespace asio
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/signal_set_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/signal_set_service.hpp
index a31f513..d4c54b8 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/signal_set_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/signal_set_service.hpp
@@ -2,7 +2,7 @@
 // signal_set_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,10 +16,13 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #include "asio/async_result.hpp"
 #include "asio/detail/signal_set_service.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -28,7 +31,7 @@ namespace asio {
 /// Default service implementation for a signal set.
 class signal_set_service
 #if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
+  : public asio::io_context::service
 #else
   : public asio::detail::service_base<signal_set_service>
 #endif
@@ -36,7 +39,7 @@ class signal_set_service
 public:
 #if defined(GENERATING_DOCUMENTATION)
   /// The unique service identifier.
-  static asio::io_service::id id;
+  static asio::io_context::id id;
 #endif
 
 public:
@@ -47,10 +50,10 @@ public:
   typedef detail::signal_set_service::implementation_type implementation_type;
 #endif
 
-  /// Construct a new signal set service for the specified io_service.
-  explicit signal_set_service(asio::io_service& io_service)
-    : asio::detail::service_base<signal_set_service>(io_service),
-      service_impl_(io_service)
+  /// Construct a new signal set service for the specified io_context.
+  explicit signal_set_service(asio::io_context& io_context)
+    : asio::detail::service_base<signal_set_service>(io_context),
+      service_impl_(io_context)
   {
   }
 
@@ -67,31 +70,35 @@ public:
   }
 
   /// Add a signal to a signal_set.
-  asio::error_code add(implementation_type& impl,
+  ASIO_SYNC_OP_VOID add(implementation_type& impl,
       int signal_number, asio::error_code& ec)
   {
-    return service_impl_.add(impl, signal_number, ec);
+    service_impl_.add(impl, signal_number, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Remove a signal to a signal_set.
-  asio::error_code remove(implementation_type& impl,
+  ASIO_SYNC_OP_VOID remove(implementation_type& impl,
       int signal_number, asio::error_code& ec)
   {
-    return service_impl_.remove(impl, signal_number, ec);
+    service_impl_.remove(impl, signal_number, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Remove all signals from a signal_set.
-  asio::error_code clear(implementation_type& impl,
+  ASIO_SYNC_OP_VOID clear(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.clear(impl, ec);
+    service_impl_.clear(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Cancel all operations associated with the signal set.
-  asio::error_code cancel(implementation_type& impl,
+  ASIO_SYNC_OP_VOID cancel(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.cancel(impl, ec);
+    service_impl_.cancel(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   // Start an asynchronous operation to wait for a signal to be delivered.
@@ -104,22 +111,22 @@ public:
     async_completion<SignalHandler,
       void (asio::error_code, int)> init(handler);
 
-    service_impl_.async_wait(impl, init.handler);
+    service_impl_.async_wait(impl, init.completion_handler);
 
     return init.result.get();
   }
 
 private:
   // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
+  void shutdown()
   {
-    service_impl_.shutdown_service();
+    service_impl_.shutdown();
   }
 
   // Perform any fork-related housekeeping.
-  void fork_service(asio::io_service::fork_event event)
+  void notify_fork(asio::io_context::fork_event event)
   {
-    service_impl_.fork_service(event);
+    service_impl_.notify_fork(event);
   }
 
   // The platform-specific implementation.
@@ -130,4 +137,6 @@ private:
 
 #include "asio/detail/pop_options.hpp"
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_SIGNAL_SET_SERVICE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/socket_acceptor_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/socket_acceptor_service.hpp
index 9844dc2..b9c33ff 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/socket_acceptor_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/socket_acceptor_service.hpp
@@ -2,7 +2,7 @@
 // socket_acceptor_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,10 +16,13 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #include "asio/basic_socket.hpp"
 #include "asio/detail/type_traits.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 
 #if defined(ASIO_WINDOWS_RUNTIME)
 # include "asio/detail/null_socket_service.hpp"
@@ -37,7 +40,7 @@ namespace asio {
 template <typename Protocol>
 class socket_acceptor_service
 #if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
+  : public asio::io_context::service
 #else
   : public asio::detail::service_base<socket_acceptor_service<Protocol> >
 #endif
@@ -45,7 +48,7 @@ class socket_acceptor_service
 public:
 #if defined(GENERATING_DOCUMENTATION)
   /// The unique service identifier.
-  static asio::io_service::id id;
+  static asio::io_context::id id;
 #endif
 
   /// The protocol type.
@@ -79,11 +82,11 @@ public:
   typedef typename service_impl_type::native_handle_type native_handle_type;
 #endif
 
-  /// Construct a new socket acceptor service for the specified io_service.
-  explicit socket_acceptor_service(asio::io_service& io_service)
+  /// Construct a new socket acceptor service for the specified io_context.
+  explicit socket_acceptor_service(asio::io_context& io_context)
     : asio::detail::service_base<
-        socket_acceptor_service<Protocol> >(io_service),
-      service_impl_(io_service)
+        socket_acceptor_service<Protocol> >(io_context),
+      service_impl_(io_context)
   {
   }
 
@@ -130,18 +133,20 @@ public:
   }
 
   /// Open a new socket acceptor implementation.
-  asio::error_code open(implementation_type& impl,
+  ASIO_SYNC_OP_VOID open(implementation_type& impl,
       const protocol_type& protocol, asio::error_code& ec)
   {
-    return service_impl_.open(impl, protocol, ec);
+    service_impl_.open(impl, protocol, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Assign an existing native acceptor to a socket acceptor.
-  asio::error_code assign(implementation_type& impl,
+  ASIO_SYNC_OP_VOID assign(implementation_type& impl,
       const protocol_type& protocol, const native_handle_type& native_acceptor,
       asio::error_code& ec)
   {
-    return service_impl_.assign(impl, protocol, native_acceptor, ec);
+    service_impl_.assign(impl, protocol, native_acceptor, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Determine whether the acceptor is open.
@@ -151,32 +156,36 @@ public:
   }
 
   /// Cancel all asynchronous operations associated with the acceptor.
-  asio::error_code cancel(implementation_type& impl,
+  ASIO_SYNC_OP_VOID cancel(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.cancel(impl, ec);
+    service_impl_.cancel(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Bind the socket acceptor to the specified local endpoint.
-  asio::error_code bind(implementation_type& impl,
+  ASIO_SYNC_OP_VOID bind(implementation_type& impl,
       const endpoint_type& endpoint, asio::error_code& ec)
   {
-    return service_impl_.bind(impl, endpoint, ec);
+    service_impl_.bind(impl, endpoint, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Place the socket acceptor into the state where it will listen for new
   /// connections.
-  asio::error_code listen(implementation_type& impl, int backlog,
+  ASIO_SYNC_OP_VOID listen(implementation_type& impl, int backlog,
       asio::error_code& ec)
   {
-    return service_impl_.listen(impl, backlog, ec);
+    service_impl_.listen(impl, backlog, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Close a socket acceptor implementation.
-  asio::error_code close(implementation_type& impl,
+  ASIO_SYNC_OP_VOID close(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.close(impl, ec);
+    service_impl_.close(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the native acceptor implementation.
@@ -187,26 +196,29 @@ public:
 
   /// Set a socket option.
   template <typename SettableSocketOption>
-  asio::error_code set_option(implementation_type& impl,
+  ASIO_SYNC_OP_VOID set_option(implementation_type& impl,
       const SettableSocketOption& option, asio::error_code& ec)
   {
-    return service_impl_.set_option(impl, option, ec);
+    service_impl_.set_option(impl, option, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get a socket option.
   template <typename GettableSocketOption>
-  asio::error_code get_option(const implementation_type& impl,
+  ASIO_SYNC_OP_VOID get_option(const implementation_type& impl,
       GettableSocketOption& option, asio::error_code& ec) const
   {
-    return service_impl_.get_option(impl, option, ec);
+    service_impl_.get_option(impl, option, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Perform an IO control command on the socket.
   template <typename IoControlCommand>
-  asio::error_code io_control(implementation_type& impl,
+  ASIO_SYNC_OP_VOID io_control(implementation_type& impl,
       IoControlCommand& command, asio::error_code& ec)
   {
-    return service_impl_.io_control(impl, command, ec);
+    service_impl_.io_control(impl, command, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Gets the non-blocking mode of the acceptor.
@@ -216,10 +228,11 @@ public:
   }
 
   /// Sets the non-blocking mode of the acceptor.
-  asio::error_code non_blocking(implementation_type& impl,
+  ASIO_SYNC_OP_VOID non_blocking(implementation_type& impl,
       bool mode, asio::error_code& ec)
   {
-    return service_impl_.non_blocking(impl, mode, ec);
+    service_impl_.non_blocking(impl, mode, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Gets the non-blocking mode of the native acceptor implementation.
@@ -229,10 +242,11 @@ public:
   }
 
   /// Sets the non-blocking mode of the native acceptor implementation.
-  asio::error_code native_non_blocking(implementation_type& impl,
+  ASIO_SYNC_OP_VOID native_non_blocking(implementation_type& impl,
       bool mode, asio::error_code& ec)
   {
-    return service_impl_.native_non_blocking(impl, mode, ec);
+    service_impl_.native_non_blocking(impl, mode, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the local endpoint.
@@ -244,10 +258,11 @@ public:
 
   /// Wait for the acceptor to become ready to read, ready to write, or to have
   /// pending error conditions.
-  asio::error_code wait(implementation_type& impl,
+  ASIO_SYNC_OP_VOID wait(implementation_type& impl,
       socket_base::wait_type w, asio::error_code& ec)
   {
-    return service_impl_.wait(impl, w, ec);
+    service_impl_.wait(impl, w, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Asynchronously wait for the acceptor to become ready to read, ready to
@@ -261,20 +276,31 @@ public:
     async_completion<WaitHandler,
       void (asio::error_code)> init(handler);
 
-    service_impl_.async_wait(impl, w, init.handler);
+    service_impl_.async_wait(impl, w, init.completion_handler);
 
     return init.result.get();
   }
 
   /// Accept a new connection.
   template <typename Protocol1, typename SocketService>
-  asio::error_code accept(implementation_type& impl,
+  ASIO_SYNC_OP_VOID accept(implementation_type& impl,
       basic_socket<Protocol1, SocketService>& peer,
       endpoint_type* peer_endpoint, asio::error_code& ec,
       typename enable_if<is_convertible<Protocol, Protocol1>::value>::type* = 0)
   {
-    return service_impl_.accept(impl, peer, peer_endpoint, ec);
+    service_impl_.accept(impl, peer, peer_endpoint, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+#if defined(ASIO_HAS_MOVE)
+  /// Accept a new connection.
+  typename Protocol::socket accept(implementation_type& impl,
+      io_context* peer_io_context, endpoint_type* peer_endpoint,
+      asio::error_code& ec)
+  {
+    return service_impl_.accept(impl, peer_io_context, peer_endpoint, ec);
   }
+#endif // defined(ASIO_HAS_MOVE)
 
   /// Start an asynchronous accept.
   template <typename Protocol1, typename SocketService, typename AcceptHandler>
@@ -289,16 +315,37 @@ public:
     async_completion<AcceptHandler,
       void (asio::error_code)> init(handler);
 
-    service_impl_.async_accept(impl, peer, peer_endpoint, init.handler);
+    service_impl_.async_accept(impl,
+        peer, peer_endpoint, init.completion_handler);
+
+    return init.result.get();
+  }
+
+#if defined(ASIO_HAS_MOVE)
+  /// Start an asynchronous accept.
+  template <typename MoveAcceptHandler>
+  ASIO_INITFN_RESULT_TYPE(MoveAcceptHandler,
+      void (asio::error_code, typename Protocol::socket))
+  async_accept(implementation_type& impl,
+      asio::io_context* peer_io_context, endpoint_type* peer_endpoint,
+      ASIO_MOVE_ARG(MoveAcceptHandler) handler)
+  {
+    async_completion<MoveAcceptHandler,
+      void (asio::error_code,
+        typename Protocol::socket)> init(handler);
+
+    service_impl_.async_accept(impl,
+        peer_io_context, peer_endpoint, init.completion_handler);
 
     return init.result.get();
   }
+#endif // defined(ASIO_HAS_MOVE)
 
 private:
   // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
+  void shutdown()
   {
-    service_impl_.shutdown_service();
+    service_impl_.shutdown();
   }
 
   // The platform-specific implementation.
@@ -309,4 +356,6 @@ private:
 
 #include "asio/detail/pop_options.hpp"
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_SOCKET_ACCEPTOR_SERVICE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/socket_base.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/socket_base.hpp
index b346f3a..99ef377 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/socket_base.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/socket_base.hpp
@@ -2,7 +2,7 @@
 // socket_base.hpp
 // ~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -98,7 +98,7 @@ public:
    * @par Examples
    * Setting the option:
    * @code
-   * asio::ip::udp::socket socket(io_service); 
+   * asio::ip::udp::socket socket(io_context); 
    * ...
    * asio::socket_base::broadcast option(true);
    * socket.set_option(option);
@@ -107,7 +107,7 @@ public:
    * @par
    * Getting the current option value:
    * @code
-   * asio::ip::udp::socket socket(io_service); 
+   * asio::ip::udp::socket socket(io_context); 
    * ...
    * asio::socket_base::broadcast option;
    * socket.get_option(option);
@@ -132,7 +132,7 @@ public:
    * @par Examples
    * Setting the option:
    * @code
-   * asio::ip::tcp::socket socket(io_service); 
+   * asio::ip::tcp::socket socket(io_context); 
    * ...
    * asio::socket_base::debug option(true);
    * socket.set_option(option);
@@ -141,7 +141,7 @@ public:
    * @par
    * Getting the current option value:
    * @code
-   * asio::ip::tcp::socket socket(io_service); 
+   * asio::ip::tcp::socket socket(io_context); 
    * ...
    * asio::socket_base::debug option;
    * socket.get_option(option);
@@ -165,7 +165,7 @@ public:
    * @par Examples
    * Setting the option:
    * @code
-   * asio::ip::udp::socket socket(io_service); 
+   * asio::ip::udp::socket socket(io_context); 
    * ...
    * asio::socket_base::do_not_route option(true);
    * socket.set_option(option);
@@ -174,7 +174,7 @@ public:
    * @par
    * Getting the current option value:
    * @code
-   * asio::ip::udp::socket socket(io_service); 
+   * asio::ip::udp::socket socket(io_context); 
    * ...
    * asio::socket_base::do_not_route option;
    * socket.get_option(option);
@@ -199,7 +199,7 @@ public:
    * @par Examples
    * Setting the option:
    * @code
-   * asio::ip::tcp::socket socket(io_service); 
+   * asio::ip::tcp::socket socket(io_context); 
    * ...
    * asio::socket_base::keep_alive option(true);
    * socket.set_option(option);
@@ -208,7 +208,7 @@ public:
    * @par
    * Getting the current option value:
    * @code
-   * asio::ip::tcp::socket socket(io_service); 
+   * asio::ip::tcp::socket socket(io_context); 
    * ...
    * asio::socket_base::keep_alive option;
    * socket.get_option(option);
@@ -232,7 +232,7 @@ public:
    * @par Examples
    * Setting the option:
    * @code
-   * asio::ip::tcp::socket socket(io_service); 
+   * asio::ip::tcp::socket socket(io_context); 
    * ...
    * asio::socket_base::send_buffer_size option(8192);
    * socket.set_option(option);
@@ -241,7 +241,7 @@ public:
    * @par
    * Getting the current option value:
    * @code
-   * asio::ip::tcp::socket socket(io_service); 
+   * asio::ip::tcp::socket socket(io_context); 
    * ...
    * asio::socket_base::send_buffer_size option;
    * socket.get_option(option);
@@ -266,7 +266,7 @@ public:
    * @par Examples
    * Setting the option:
    * @code
-   * asio::ip::tcp::socket socket(io_service); 
+   * asio::ip::tcp::socket socket(io_context); 
    * ...
    * asio::socket_base::send_low_watermark option(1024);
    * socket.set_option(option);
@@ -275,7 +275,7 @@ public:
    * @par
    * Getting the current option value:
    * @code
-   * asio::ip::tcp::socket socket(io_service); 
+   * asio::ip::tcp::socket socket(io_context); 
    * ...
    * asio::socket_base::send_low_watermark option;
    * socket.get_option(option);
@@ -300,7 +300,7 @@ public:
    * @par Examples
    * Setting the option:
    * @code
-   * asio::ip::tcp::socket socket(io_service); 
+   * asio::ip::tcp::socket socket(io_context); 
    * ...
    * asio::socket_base::receive_buffer_size option(8192);
    * socket.set_option(option);
@@ -309,7 +309,7 @@ public:
    * @par
    * Getting the current option value:
    * @code
-   * asio::ip::tcp::socket socket(io_service); 
+   * asio::ip::tcp::socket socket(io_context); 
    * ...
    * asio::socket_base::receive_buffer_size option;
    * socket.get_option(option);
@@ -334,7 +334,7 @@ public:
    * @par Examples
    * Setting the option:
    * @code
-   * asio::ip::tcp::socket socket(io_service); 
+   * asio::ip::tcp::socket socket(io_context); 
    * ...
    * asio::socket_base::receive_low_watermark option(1024);
    * socket.set_option(option);
@@ -343,7 +343,7 @@ public:
    * @par
    * Getting the current option value:
    * @code
-   * asio::ip::tcp::socket socket(io_service); 
+   * asio::ip::tcp::socket socket(io_context); 
    * ...
    * asio::socket_base::receive_low_watermark option;
    * socket.get_option(option);
@@ -369,7 +369,7 @@ public:
    * @par Examples
    * Setting the option:
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service); 
+   * asio::ip::tcp::acceptor acceptor(io_context); 
    * ...
    * asio::socket_base::reuse_address option(true);
    * acceptor.set_option(option);
@@ -378,7 +378,7 @@ public:
    * @par
    * Getting the current option value:
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service); 
+   * asio::ip::tcp::acceptor acceptor(io_context); 
    * ...
    * asio::socket_base::reuse_address option;
    * acceptor.get_option(option);
@@ -404,7 +404,7 @@ public:
    * @par Examples
    * Setting the option:
    * @code
-   * asio::ip::tcp::socket socket(io_service); 
+   * asio::ip::tcp::socket socket(io_context); 
    * ...
    * asio::socket_base::linger option(true, 30);
    * socket.set_option(option);
@@ -413,7 +413,7 @@ public:
    * @par
    * Getting the current option value:
    * @code
-   * asio::ip::tcp::socket socket(io_service); 
+   * asio::ip::tcp::socket socket(io_context); 
    * ...
    * asio::socket_base::linger option;
    * socket.get_option(option);
@@ -441,7 +441,7 @@ public:
    * @par Examples
    * Setting the option:
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service); 
+   * asio::ip::tcp::acceptor acceptor(io_context); 
    * ...
    * asio::socket_base::enable_connection_aborted option(true);
    * acceptor.set_option(option);
@@ -450,7 +450,7 @@ public:
    * @par
    * Getting the current option value:
    * @code
-   * asio::ip::tcp::acceptor acceptor(io_service); 
+   * asio::ip::tcp::acceptor acceptor(io_context); 
    * ...
    * asio::socket_base::enable_connection_aborted option;
    * acceptor.get_option(option);
@@ -476,7 +476,7 @@ public:
    *
    * @par Example
    * @code
-   * asio::ip::tcp::socket socket(io_service); 
+   * asio::ip::tcp::socket socket(io_context); 
    * ...
    * asio::socket_base::bytes_readable command(true);
    * socket.io_control(command);
@@ -494,11 +494,22 @@ public:
 
   /// The maximum length of the queue of pending incoming connections.
 #if defined(GENERATING_DOCUMENTATION)
+  static const int max_listen_connections = implementation_defined;
+#else
+  ASIO_STATIC_CONSTANT(int, max_listen_connections
+      = ASIO_OS_DEF(SOMAXCONN));
+#endif
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use max_listen_connections.) The maximum length of the queue
+  /// of pending incoming connections.
+#if defined(GENERATING_DOCUMENTATION)
   static const int max_connections = implementation_defined;
 #else
   ASIO_STATIC_CONSTANT(int, max_connections
       = ASIO_OS_DEF(SOMAXCONN));
 #endif
+#endif // !defined(ASIO_NO_DEPRECATED)
 
 protected:
   /// Protected destructor to prevent deletion through this type.
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/spawn.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/spawn.hpp
index c21658c..cffe431 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/spawn.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/spawn.hpp
@@ -2,7 +2,7 @@
 // spawn.hpp
 // ~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,14 +17,14 @@
 
 #include "asio/detail/config.hpp"
 #include <boost/coroutine/all.hpp>
+#include "asio/bind_executor.hpp"
 #include "asio/detail/memory.hpp"
 #include "asio/detail/type_traits.hpp"
 #include "asio/detail/wrapped_handler.hpp"
 #include "asio/executor.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/is_executor.hpp"
 #include "asio/strand.hpp"
-#include "asio/wrap.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -151,7 +151,7 @@ private:
 typedef basic_yield_context<unspecified> yield_context;
 #else // defined(GENERATING_DOCUMENTATION)
 typedef basic_yield_context<
-  executor_wrapper<void(*)(), executor> > yield_context;
+  executor_binder<void(*)(), executor> > yield_context;
 #endif // defined(GENERATING_DOCUMENTATION)
 
 /**
@@ -299,7 +299,7 @@ void spawn(const strand<Executor>& ex,
  * @param attributes Boost.Coroutine attributes used to customise the coroutine.
  */
 template <typename Function>
-void spawn(const asio::io_service::strand& s,
+void spawn(const asio::io_context::strand& s,
     ASIO_MOVE_ARG(Function) function,
     const boost::coroutines::attributes& attributes
       = boost::coroutines::attributes());
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl.hpp
index c3addfa..bc3dae0 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl.hpp
@@ -2,7 +2,7 @@
 // ssl.hpp
 // ~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/context.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/context.hpp
index d7a9e1c..6e3f2ad 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/context.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/context.hpp
@@ -2,7 +2,7 @@
 // ssl/context.hpp
 // ~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -19,7 +19,7 @@
 
 #include <string>
 #include "asio/buffer.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/ssl/context_base.hpp"
 #include "asio/ssl/detail/openssl_types.hpp"
 #include "asio/ssl/detail/openssl_init.hpp"
@@ -108,7 +108,7 @@ public:
    *
    * @note Calls @c SSL_CTX_clear_options.
    */
-  ASIO_DECL asio::error_code clear_options(options o,
+  ASIO_DECL ASIO_SYNC_OP_VOID clear_options(options o,
       asio::error_code& ec);
 
   /// Set options on the context.
@@ -137,7 +137,7 @@ public:
    *
    * @note Calls @c SSL_CTX_set_options.
    */
-  ASIO_DECL asio::error_code set_options(options o,
+  ASIO_DECL ASIO_SYNC_OP_VOID set_options(options o,
       asio::error_code& ec);
 
   /// Set the peer verification mode.
@@ -166,7 +166,7 @@ public:
    *
    * @note Calls @c SSL_CTX_set_verify.
    */
-  ASIO_DECL asio::error_code set_verify_mode(
+  ASIO_DECL ASIO_SYNC_OP_VOID set_verify_mode(
       verify_mode v, asio::error_code& ec);
 
   /// Set the peer verification depth.
@@ -195,7 +195,7 @@ public:
    *
    * @note Calls @c SSL_CTX_set_verify_depth.
    */
-  ASIO_DECL asio::error_code set_verify_depth(
+  ASIO_DECL ASIO_SYNC_OP_VOID set_verify_depth(
       int depth, asio::error_code& ec);
 
   /// Set the callback used to verify peer certificates.
@@ -238,7 +238,7 @@ public:
    * @note Calls @c SSL_CTX_set_verify.
    */
   template <typename VerifyCallback>
-  asio::error_code set_verify_callback(VerifyCallback callback,
+  ASIO_SYNC_OP_VOID set_verify_callback(VerifyCallback callback,
       asio::error_code& ec);
 
   /// Load a certification authority file for performing verification.
@@ -267,7 +267,7 @@ public:
    *
    * @note Calls @c SSL_CTX_load_verify_locations.
    */
-  ASIO_DECL asio::error_code load_verify_file(
+  ASIO_DECL ASIO_SYNC_OP_VOID load_verify_file(
       const std::string& filename, asio::error_code& ec);
 
   /// Add certification authority for performing verification.
@@ -296,7 +296,7 @@ public:
    *
    * @note Calls @c SSL_CTX_get_cert_store and @c X509_STORE_add_cert.
    */
-  ASIO_DECL asio::error_code add_certificate_authority(
+  ASIO_DECL ASIO_SYNC_OP_VOID add_certificate_authority(
       const const_buffer& ca, asio::error_code& ec);
 
   /// Configures the context to use the default directories for finding
@@ -323,7 +323,7 @@ public:
    *
    * @note Calls @c SSL_CTX_set_default_verify_paths.
    */
-  ASIO_DECL asio::error_code set_default_verify_paths(
+  ASIO_DECL ASIO_SYNC_OP_VOID set_default_verify_paths(
       asio::error_code& ec);
 
   /// Add a directory containing certificate authority files to be used for
@@ -356,7 +356,7 @@ public:
    *
    * @note Calls @c SSL_CTX_load_verify_locations.
    */
-  ASIO_DECL asio::error_code add_verify_path(
+  ASIO_DECL ASIO_SYNC_OP_VOID add_verify_path(
       const std::string& path, asio::error_code& ec);
 
   /// Use a certificate from a memory buffer.
@@ -386,7 +386,7 @@ public:
    *
    * @note Calls @c SSL_CTX_use_certificate or SSL_CTX_use_certificate_ASN1.
    */
-  ASIO_DECL asio::error_code use_certificate(
+  ASIO_DECL ASIO_SYNC_OP_VOID use_certificate(
       const const_buffer& certificate, file_format format,
       asio::error_code& ec);
 
@@ -417,7 +417,7 @@ public:
    *
    * @note Calls @c SSL_CTX_use_certificate_file.
    */
-  ASIO_DECL asio::error_code use_certificate_file(
+  ASIO_DECL ASIO_SYNC_OP_VOID use_certificate_file(
       const std::string& filename, file_format format,
       asio::error_code& ec);
 
@@ -447,7 +447,7 @@ public:
    *
    * @note Calls @c SSL_CTX_use_certificate and SSL_CTX_add_extra_chain_cert.
    */
-  ASIO_DECL asio::error_code use_certificate_chain(
+  ASIO_DECL ASIO_SYNC_OP_VOID use_certificate_chain(
       const const_buffer& chain, asio::error_code& ec);
 
   /// Use a certificate chain from a file.
@@ -476,7 +476,7 @@ public:
    *
    * @note Calls @c SSL_CTX_use_certificate_chain_file.
    */
-  ASIO_DECL asio::error_code use_certificate_chain_file(
+  ASIO_DECL ASIO_SYNC_OP_VOID use_certificate_chain_file(
       const std::string& filename, asio::error_code& ec);
 
   /// Use a private key from a memory buffer.
@@ -506,7 +506,7 @@ public:
    *
    * @note Calls @c SSL_CTX_use_PrivateKey or SSL_CTX_use_PrivateKey_ASN1.
    */
-  ASIO_DECL asio::error_code use_private_key(
+  ASIO_DECL ASIO_SYNC_OP_VOID use_private_key(
       const const_buffer& private_key, file_format format,
       asio::error_code& ec);
 
@@ -537,7 +537,7 @@ public:
    *
    * @note Calls @c SSL_CTX_use_PrivateKey_file.
    */
-  ASIO_DECL asio::error_code use_private_key_file(
+  ASIO_DECL ASIO_SYNC_OP_VOID use_private_key_file(
       const std::string& filename, file_format format,
       asio::error_code& ec);
 
@@ -570,7 +570,7 @@ public:
    *
    * @note Calls @c SSL_CTX_use_RSAPrivateKey or SSL_CTX_use_RSAPrivateKey_ASN1.
    */
-  ASIO_DECL asio::error_code use_rsa_private_key(
+  ASIO_DECL ASIO_SYNC_OP_VOID use_rsa_private_key(
       const const_buffer& private_key, file_format format,
       asio::error_code& ec);
 
@@ -603,7 +603,7 @@ public:
    *
    * @note Calls @c SSL_CTX_use_RSAPrivateKey_file.
    */
-  ASIO_DECL asio::error_code use_rsa_private_key_file(
+  ASIO_DECL ASIO_SYNC_OP_VOID use_rsa_private_key_file(
       const std::string& filename, file_format format,
       asio::error_code& ec);
 
@@ -635,7 +635,7 @@ public:
    *
    * @note Calls @c SSL_CTX_set_tmp_dh.
    */
-  ASIO_DECL asio::error_code use_tmp_dh(
+  ASIO_DECL ASIO_SYNC_OP_VOID use_tmp_dh(
       const const_buffer& dh, asio::error_code& ec);
 
   /// Use the specified file to obtain the temporary Diffie-Hellman parameters.
@@ -664,7 +664,7 @@ public:
    *
    * @note Calls @c SSL_CTX_set_tmp_dh.
    */
-  ASIO_DECL asio::error_code use_tmp_dh_file(
+  ASIO_DECL ASIO_SYNC_OP_VOID use_tmp_dh_file(
       const std::string& filename, asio::error_code& ec);
 
   /// Set the password callback.
@@ -705,7 +705,7 @@ public:
    * @note Calls @c SSL_CTX_set_default_passwd_cb.
    */
   template <typename PasswordCallback>
-  asio::error_code set_password_callback(PasswordCallback callback,
+  ASIO_SYNC_OP_VOID set_password_callback(PasswordCallback callback,
       asio::error_code& ec);
 
 private:
@@ -716,7 +716,7 @@ private:
   struct dh_cleanup;
 
   // Helper function used to set a peer certificate verification callback.
-  ASIO_DECL asio::error_code do_set_verify_callback(
+  ASIO_DECL ASIO_SYNC_OP_VOID do_set_verify_callback(
       detail::verify_callback_base* callback, asio::error_code& ec);
 
   // Callback used when the SSL implementation wants to verify a certificate.
@@ -724,7 +724,7 @@ private:
       int preverified, X509_STORE_CTX* ctx);
 
   // Helper function used to set a password callback.
-  ASIO_DECL asio::error_code do_set_password_callback(
+  ASIO_DECL ASIO_SYNC_OP_VOID do_set_password_callback(
       detail::password_callback_base* callback, asio::error_code& ec);
 
   // Callback used when the SSL implementation wants a password.
@@ -732,7 +732,7 @@ private:
       char* buf, int size, int purpose, void* data);
 
   // Helper function to set the temporary Diffie-Hellman parameters from a BIO.
-  ASIO_DECL asio::error_code do_use_tmp_dh(
+  ASIO_DECL ASIO_SYNC_OP_VOID do_use_tmp_dh(
       BIO* bio, asio::error_code& ec);
 
   // Helper function to make a BIO from a memory buffer.
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/context_base.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/context_base.hpp
index cfa2f42..b3af107 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/context_base.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/context_base.hpp
@@ -2,7 +2,7 @@
 // ssl/context_base.hpp
 // ~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/buffered_handshake_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/buffered_handshake_op.hpp
index 9e1d983..e661bde 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/buffered_handshake_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/buffered_handshake_op.hpp
@@ -2,7 +2,7 @@
 // ssl/detail/buffered_handshake_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -41,8 +41,27 @@ public:
       asio::error_code& ec,
       std::size_t& bytes_transferred) const
   {
-    typename ConstBufferSequence::const_iterator iter = buffers_.begin();
-    typename ConstBufferSequence::const_iterator end = buffers_.end();
+    return this->process(eng, ec, bytes_transferred,
+        asio::buffer_sequence_begin(buffers_),
+        asio::buffer_sequence_end(buffers_));
+  }
+
+  template <typename Handler>
+  void call_handler(Handler& handler,
+      const asio::error_code& ec,
+      const std::size_t& bytes_transferred) const
+  {
+    handler(ec, bytes_transferred);
+  }
+
+private:
+  template <typename Iterator>
+  engine::want process(engine& eng,
+      asio::error_code& ec,
+      std::size_t& bytes_transferred,
+      Iterator begin, Iterator end) const
+  {
+    Iterator iter = begin;
     std::size_t accumulated_size = 0;
 
     for (;;)
@@ -58,9 +77,9 @@ public:
         const_buffer buffer(*iter);
 
         // Skip over any buffers which have already been consumed by the engine.
-        if (bytes_transferred >= accumulated_size + buffer_size(buffer))
+        if (bytes_transferred >= accumulated_size + buffer.size())
         {
-          accumulated_size += buffer_size(buffer);
+          accumulated_size += buffer.size();
           ++iter;
           continue;
         }
@@ -73,23 +92,14 @@ public:
 
         // Pass the buffer to the engine, and update the bytes transferred to
         // reflect the total number of bytes consumed so far.
-        bytes_transferred += buffer_size(buffer);
+        bytes_transferred += buffer.size();
         buffer = eng.put_input(buffer);
-        bytes_transferred -= buffer_size(buffer);
+        bytes_transferred -= buffer.size();
         break;
       }
     }
   }
 
-  template <typename Handler>
-  void call_handler(Handler& handler,
-      const asio::error_code& ec,
-      const std::size_t& bytes_transferred) const
-  {
-    handler(ec, bytes_transferred);
-  }
-
-private:
   stream_base::handshake_type type_;
   ConstBufferSequence buffers_;
   std::size_t total_buffer_size_;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/engine.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/engine.hpp
index f0b738a..c9ea33b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/engine.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/engine.hpp
@@ -2,7 +2,7 @@
 // ssl/detail/engine.hpp
 // ~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -93,7 +93,7 @@ public:
       asio::error_code& ec, std::size_t& bytes_transferred);
 
   // Get output data to be written to the transport.
-  ASIO_DECL asio::mutable_buffers_1 get_output(
+  ASIO_DECL asio::mutable_buffer get_output(
       const asio::mutable_buffer& data);
 
   // Put input data that was read from the transport.
@@ -115,9 +115,11 @@ private:
   ASIO_DECL static int verify_callback_function(
       int preverified, X509_STORE_CTX* ctx);
 
+#if (OPENSSL_VERSION_NUMBER < 0x10000000L)
   // The SSL_accept function may not be thread safe. This mutex is used to
   // protect all calls to the SSL_accept function.
   ASIO_DECL static asio::detail::static_mutex& accept_mutex();
+#endif // (OPENSSL_VERSION_NUMBER < 0x10000000L)
 
   // Perform one operation. Returns >= 0 on success or error, want_read if the
   // operation needs more input, or want_write if it needs to write some output
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/handshake_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/handshake_op.hpp
index baacbf7..b6848ea 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/handshake_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/handshake_op.hpp
@@ -2,7 +2,7 @@
 // ssl/detail/handshake_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/impl/engine.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/impl/engine.ipp
index 5504411..5566149 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/impl/engine.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/impl/engine.ipp
@@ -2,7 +2,7 @@
 // ssl/detail/impl/engine.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -40,7 +40,9 @@ engine::engine(SSL_CTX* context)
     asio::detail::throw_error(ec, "engine");
   }
 
+#if (OPENSSL_VERSION_NUMBER < 0x10000000L)
   accept_mutex().init();
+#endif // (OPENSSL_VERSION_NUMBER < 0x10000000L)
 
   ::SSL_set_mode(ssl_, SSL_MODE_ENABLE_PARTIAL_WRITE);
   ::SSL_set_mode(ssl_, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);
@@ -141,37 +143,35 @@ engine::want engine::shutdown(asio::error_code& ec)
 engine::want engine::write(const asio::const_buffer& data,
     asio::error_code& ec, std::size_t& bytes_transferred)
 {
-  if (asio::buffer_size(data) == 0)
+  if (data.size() == 0)
   {
     ec = asio::error_code();
     return engine::want_nothing;
   }
 
   return perform(&engine::do_write,
-      const_cast<void*>(asio::buffer_cast<const void*>(data)),
-      asio::buffer_size(data), ec, &bytes_transferred);
+      const_cast<void*>(data.data()),
+      data.size(), ec, &bytes_transferred);
 }
 
 engine::want engine::read(const asio::mutable_buffer& data,
     asio::error_code& ec, std::size_t& bytes_transferred)
 {
-  if (asio::buffer_size(data) == 0)
+  if (data.size() == 0)
   {
     ec = asio::error_code();
     return engine::want_nothing;
   }
 
-  return perform(&engine::do_read,
-      asio::buffer_cast<void*>(data),
-      asio::buffer_size(data), ec, &bytes_transferred);
+  return perform(&engine::do_read, data.data(),
+      data.size(), ec, &bytes_transferred);
 }
 
-asio::mutable_buffers_1 engine::get_output(
+asio::mutable_buffer engine::get_output(
     const asio::mutable_buffer& data)
 {
   int length = ::BIO_read(ext_bio_,
-      asio::buffer_cast<void*>(data),
-      static_cast<int>(asio::buffer_size(data)));
+      data.data(), static_cast<int>(data.size()));
 
   return asio::buffer(data,
       length > 0 ? static_cast<std::size_t>(length) : 0);
@@ -181,8 +181,7 @@ asio::const_buffer engine::put_input(
     const asio::const_buffer& data)
 {
   int length = ::BIO_write(ext_bio_,
-      asio::buffer_cast<const void*>(data),
-      static_cast<int>(asio::buffer_size(data)));
+      data.data(), static_cast<int>(data.size()));
 
   return asio::buffer(data +
       (length > 0 ? static_cast<std::size_t>(length) : 0));
@@ -198,33 +197,33 @@ const asio::error_code& engine::map_error_code(
   // If there's data yet to be read, it's an error.
   if (BIO_wpending(ext_bio_))
   {
-    ec = asio::error_code(
-        ERR_PACK(ERR_LIB_SSL, 0, SSL_R_SHORT_READ),
-        asio::error::get_ssl_category());
+    ec = asio::ssl::error::stream_truncated;
     return ec;
   }
 
   // SSL v2 doesn't provide a protocol-level shutdown, so an eof on the
   // underlying transport is passed through.
-  if (ssl_ && ssl_->version == SSL2_VERSION)
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L)
+  if (ssl_->version == SSL2_VERSION)
     return ec;
+#endif // (OPENSSL_VERSION_NUMBER < 0x10100000L)
 
   // Otherwise, the peer should have negotiated a proper shutdown.
   if ((::SSL_get_shutdown(ssl_) & SSL_RECEIVED_SHUTDOWN) == 0)
   {
-    ec = asio::error_code(
-        ERR_PACK(ERR_LIB_SSL, 0, SSL_R_SHORT_READ),
-        asio::error::get_ssl_category());
+    ec = asio::ssl::error::stream_truncated;
   }
 
   return ec;
 }
 
+#if (OPENSSL_VERSION_NUMBER < 0x10000000L)
 asio::detail::static_mutex& engine::accept_mutex()
 {
   static asio::detail::static_mutex mutex = ASIO_STATIC_MUTEX_INIT;
   return mutex;
 }
+#endif // (OPENSSL_VERSION_NUMBER < 0x10000000L)
 
 engine::want engine::perform(int (engine::* op)(void*, std::size_t),
     void* data, std::size_t length, asio::error_code& ec,
@@ -283,7 +282,9 @@ engine::want engine::perform(int (engine::* op)(void*, std::size_t),
 
 int engine::do_accept(void*, std::size_t)
 {
+#if (OPENSSL_VERSION_NUMBER < 0x10000000L)
   asio::detail::static_mutex::scoped_lock lock(accept_mutex());
+#endif // (OPENSSL_VERSION_NUMBER < 0x10000000L)
   return ::SSL_accept(ssl_);
 }
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/impl/openssl_init.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/impl/openssl_init.ipp
index 2c40d40..392eff9 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/impl/openssl_init.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/impl/openssl_init.ipp
@@ -3,7 +3,7 @@
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
 // Copyright (c) 2005 Voipster / Indrek dot Juhani at voipster dot com
-// Copyright (c) 2005-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2005-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -39,11 +39,15 @@ public:
     ::SSL_load_error_strings();        
     ::OpenSSL_add_all_algorithms();
 
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L)
     mutexes_.resize(::CRYPTO_num_locks());
     for (size_t i = 0; i < mutexes_.size(); ++i)
       mutexes_[i].reset(new asio::detail::mutex);
     ::CRYPTO_set_locking_callback(&do_init::openssl_locking_func);
+#endif // (OPENSSL_VERSION_NUMBER < 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER < 0x10000000L)
     ::CRYPTO_set_id_callback(&do_init::openssl_id_func);
+#endif // (OPENSSL_VERSION_NUMBER < 0x10000000L)
 
 #if !defined(SSL_OP_NO_COMPRESSION) \
   && (OPENSSL_VERSION_NUMBER >= 0x00908000L)
@@ -60,16 +64,33 @@ public:
 #endif // !defined(SSL_OP_NO_COMPRESSION)
        // && (OPENSSL_VERSION_NUMBER >= 0x00908000L)
 
+#if (OPENSSL_VERSION_NUMBER < 0x10000000L)
     ::CRYPTO_set_id_callback(0);
+#endif // (OPENSSL_VERSION_NUMBER < 0x10000000L)
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L)
     ::CRYPTO_set_locking_callback(0);
     ::ERR_free_strings();
-    ::ERR_remove_state(0);
     ::EVP_cleanup();
     ::CRYPTO_cleanup_all_ex_data();
+#endif // (OPENSSL_VERSION_NUMBER < 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER < 0x10000000L)
+    ::ERR_remove_state(0);
+#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
+    ::ERR_remove_thread_state(NULL);
+#endif // (OPENSSL_VERSION_NUMBER < 0x10000000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10002000L) \
+    && (OPENSSL_VERSION_NUMBER < 0x10100000L)
+    ::SSL_COMP_free_compression_methods();
+#endif // (OPENSSL_VERSION_NUMBER >= 0x10002000L)
+       // && (OPENSSL_VERSION_NUMBER < 0x10100000L)
+#if !defined(OPENSSL_IS_BORINGSSL)
     ::CONF_modules_unload(1);
-#if !defined(OPENSSL_NO_ENGINE)
+#endif // !defined(OPENSSL_IS_BORINGSSL)
+#if !defined(OPENSSL_NO_ENGINE) \
+  && (OPENSSL_VERSION_NUMBER < 0x10100000L)
     ::ENGINE_cleanup();
 #endif // !defined(OPENSSL_NO_ENGINE)
+       // && (OPENSSL_VERSION_NUMBER < 0x10100000L)
   }
 
 #if !defined(SSL_OP_NO_COMPRESSION) \
@@ -82,19 +103,20 @@ public:
        // && (OPENSSL_VERSION_NUMBER >= 0x00908000L)
 
 private:
+#if (OPENSSL_VERSION_NUMBER < 0x10000000L)
   static unsigned long openssl_id_func()
   {
 #if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
     return ::GetCurrentThreadId();
 #else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-    void* id = instance()->thread_id_;
-    if (id == 0)
-      instance()->thread_id_ = id = &id; // Ugh.
+    void* id = &errno;
     ASIO_ASSERT(sizeof(unsigned long) >= sizeof(void*));
     return reinterpret_cast<unsigned long>(id);
 #endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
   }
+#endif // (OPENSSL_VERSION_NUMBER < 0x10000000L)
 
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L)
   static void openssl_locking_func(int mode, int n, 
     const char* /*file*/, int /*line*/)
   {
@@ -107,11 +129,7 @@ private:
   // Mutexes to be used in locking callbacks.
   std::vector<asio::detail::shared_ptr<
         asio::detail::mutex> > mutexes_;
-
-#if !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-  // The thread identifiers to be used by openssl.
-  asio::detail::tss_ptr<void> thread_id_;
-#endif // !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
+#endif // (OPENSSL_VERSION_NUMBER < 0x10100000L)
 
 #if !defined(SSL_OP_NO_COMPRESSION) \
   && (OPENSSL_VERSION_NUMBER >= 0x00908000L)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/io.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/io.hpp
index b2fdc76..5d35ba4 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/io.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/io.hpp
@@ -2,7 +2,7 @@
 // ssl/detail/io.hpp
 // ~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -38,7 +38,7 @@ std::size_t io(Stream& next_layer, stream_core& core,
 
     // If the input buffer is empty then we need to read some more data from
     // the underlying transport.
-    if (asio::buffer_size(core.input_) == 0)
+    if (core.input_.size() == 0)
       core.input_ = asio::buffer(core.input_buffer_,
           next_layer.read_some(core.input_buffer_, ec));
 
@@ -138,7 +138,7 @@ public:
 
           // If the input buffer already has data in it we can pass it to the
           // engine and then retry the operation immediately.
-          if (asio::buffer_size(core_.input_) != 0)
+          if (core_.input_.size() != 0)
           {
             core_.input_ = core_.engine_.put_input(core_.input_);
             continue;
@@ -201,7 +201,7 @@ public:
           // have to keep in mind that this function might be being called from
           // the async operation's initiating function. In this case we're not
           // allowed to call the handler directly. Instead, issue a zero-sized
-          // read so the handler runs "as-if" posted using io_service::post().
+          // read so the handler runs "as-if" posted using io_context::post().
           if (start)
           {
             next_layer_.async_read_some(
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/openssl_init.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/openssl_init.hpp
index 2564ba7..6144534 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/openssl_init.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/openssl_init.hpp
@@ -2,7 +2,7 @@
 // ssl/detail/openssl_init.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/openssl_types.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/openssl_types.hpp
index 5a14148..eda740d 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/openssl_types.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/openssl_types.hpp
@@ -2,7 +2,7 @@
 // ssl/detail/openssl_types.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -21,7 +21,9 @@
 #if !defined(OPENSSL_NO_ENGINE)
 # include <openssl/engine.h>
 #endif // !defined(OPENSSL_NO_ENGINE)
+#include <openssl/dh.h>
 #include <openssl/err.h>
+#include <openssl/rsa.h>
 #include <openssl/x509v3.h>
 #include "asio/detail/socket_types.hpp"
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/password_callback.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/password_callback.hpp
index ad0d9cd..abff36c 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/password_callback.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/password_callback.hpp
@@ -2,7 +2,7 @@
 // ssl/detail/password_callback.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/read_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/read_op.hpp
index 44209d6..2195bc8 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/read_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/read_op.hpp
@@ -2,7 +2,7 @@
 // ssl/detail/read_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/shutdown_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/shutdown_op.hpp
index cfb11d2..974eaa0 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/shutdown_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/shutdown_op.hpp
@@ -2,7 +2,7 @@
 // ssl/detail/shutdown_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/stream_core.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/stream_core.hpp
index 22442b1..1872912 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/stream_core.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/stream_core.hpp
@@ -2,7 +2,7 @@
 // ssl/detail/stream_core.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -37,10 +37,10 @@ struct stream_core
   // sufficient to hold the largest possible TLS record.
   enum { max_tls_record_size = 17 * 1024 };
 
-  stream_core(SSL_CTX* context, asio::io_service& io_service)
+  stream_core(SSL_CTX* context, asio::io_context& io_context)
     : engine_(context),
-      pending_read_(io_service),
-      pending_write_(io_service),
+      pending_read_(io_context),
+      pending_write_(io_context),
       output_buffer_space_(max_tls_record_size),
       output_buffer_(asio::buffer(output_buffer_space_)),
       input_buffer_space_(max_tls_record_size),
@@ -113,13 +113,13 @@ struct stream_core
   std::vector<unsigned char> output_buffer_space_;
 
   // A buffer that may be used to prepare output intended for the transport.
-  const asio::mutable_buffers_1 output_buffer_;
+  const asio::mutable_buffer output_buffer_;
 
   // Buffer space used to read input intended for the engine.
   std::vector<unsigned char> input_buffer_space_;
 
   // A buffer that may be used to read input intended for the engine.
-  const asio::mutable_buffers_1 input_buffer_;
+  const asio::mutable_buffer input_buffer_;
 
   // The buffer pointing to the engine's unconsumed input.
   asio::const_buffer input_;
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/verify_callback.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/verify_callback.hpp
index 20e246c..288ff66 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/verify_callback.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/verify_callback.hpp
@@ -2,7 +2,7 @@
 // ssl/detail/verify_callback.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/write_op.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/write_op.hpp
index dcd8640..d40719e 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/write_op.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/detail/write_op.hpp
@@ -2,7 +2,7 @@
 // ssl/detail/write_op.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/error.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/error.hpp
index b98b11a..3efef0c 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/error.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/error.hpp
@@ -2,7 +2,7 @@
 // ssl/error.hpp
 // ~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -25,15 +25,39 @@ namespace error {
 
 enum ssl_errors
 {
+  // Error numbers are those produced by openssl.
 };
 
 extern ASIO_DECL
 const asio::error_category& get_ssl_category();
 
-ASIO_USED_VARIABLE static const asio::error_category& ssl_category
+static const asio::error_category& ssl_category
   = asio::error::get_ssl_category();
 
 } // namespace error
+namespace ssl {
+namespace error {
+
+enum stream_errors
+{
+#if defined(GENERATING_DOCUMENTATION)
+  /// The underlying stream closed before the ssl stream gracefully shut down.
+  stream_truncated
+#elif (OPENSSL_VERSION_NUMBER < 0x10100000L) && !defined(OPENSSL_IS_BORINGSSL)
+  stream_truncated = ERR_PACK(ERR_LIB_SSL, 0, SSL_R_SHORT_READ)
+#else
+  stream_truncated = 1
+#endif
+};
+
+extern ASIO_DECL
+const asio::error_category& get_stream_category();
+
+static const asio::error_category& stream_category
+  = asio::ssl::error::get_stream_category();
+
+} // namespace error
+} // namespace ssl
 } // namespace asio
 
 #if defined(ASIO_HAS_STD_SYSTEM_ERROR)
@@ -44,6 +68,11 @@ template<> struct is_error_code_enum<asio::error::ssl_errors>
   static const bool value = true;
 };
 
+template<> struct is_error_code_enum<asio::ssl::error::stream_errors>
+{
+  static const bool value = true;
+};
+
 } // namespace std
 #endif // defined(ASIO_HAS_STD_SYSTEM_ERROR)
 
@@ -57,6 +86,17 @@ inline asio::error_code make_error_code(ssl_errors e)
 }
 
 } // namespace error
+namespace ssl {
+namespace error {
+
+inline asio::error_code make_error_code(stream_errors e)
+{
+  return asio::error_code(
+      static_cast<int>(e), get_stream_category());
+}
+
+} // namespace error
+} // namespace ssl
 } // namespace asio
 
 #include "asio/detail/pop_options.hpp"
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/impl/context.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/impl/context.hpp
index 43d3aa0..2b5a161 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/impl/context.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/impl/context.hpp
@@ -3,7 +3,7 @@
 // ~~~~~~~~~~~~~~~~~~~~
 //
 // Copyright (c) 2005 Voipster / Indrek dot Juhani at voipster dot com
-// Copyright (c) 2005-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2005-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -34,11 +34,12 @@ void context::set_verify_callback(VerifyCallback callback)
 }
 
 template <typename VerifyCallback>
-asio::error_code context::set_verify_callback(
+ASIO_SYNC_OP_VOID context::set_verify_callback(
     VerifyCallback callback, asio::error_code& ec)
 {
-  return do_set_verify_callback(
+  do_set_verify_callback(
       new detail::verify_callback<VerifyCallback>(callback), ec);
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 template <typename PasswordCallback>
@@ -50,11 +51,12 @@ void context::set_password_callback(PasswordCallback callback)
 }
 
 template <typename PasswordCallback>
-asio::error_code context::set_password_callback(
+ASIO_SYNC_OP_VOID context::set_password_callback(
     PasswordCallback callback, asio::error_code& ec)
 {
-  return do_set_password_callback(
+  do_set_password_callback(
       new detail::password_callback<PasswordCallback>(callback), ec);
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 } // namespace ssl
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/impl/context.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/impl/context.ipp
index 2349353..2b0c38d 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/impl/context.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/impl/context.ipp
@@ -3,7 +3,7 @@
 // ~~~~~~~~~~~~~~~~~~~~
 //
 // Copyright (c) 2005 Voipster / Indrek dot Juhani at voipster dot com
-// Copyright (c) 2005-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2005-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -66,7 +66,8 @@ context::context(context::method m)
 
   switch (m)
   {
-#if defined(OPENSSL_NO_SSL2)
+#if defined(OPENSSL_NO_SSL2) \
+  || (OPENSSL_VERSION_NUMBER >= 0x10100000L)
   case context::sslv2:
   case context::sslv2_client:
   case context::sslv2_server:
@@ -74,6 +75,7 @@ context::context(context::method m)
         asio::error::invalid_argument, "context");
     break;
 #else // defined(OPENSSL_NO_SSL2)
+      // || (OPENSSL_VERSION_NUMBER >= 0x10100000L)
   case context::sslv2:
     handle_ = ::SSL_CTX_new(::SSLv2_method());
     break;
@@ -84,6 +86,7 @@ context::context(context::method m)
     handle_ = ::SSL_CTX_new(::SSLv2_server_method());
     break;
 #endif // defined(OPENSSL_NO_SSL2)
+       // || (OPENSSL_VERSION_NUMBER >= 0x10100000L)
 #if defined(OPENSSL_NO_SSL3)
   case context::sslv3:
   case context::sslv3_client:
@@ -102,6 +105,7 @@ context::context(context::method m)
     handle_ = ::SSL_CTX_new(::SSLv3_server_method());
     break;
 #endif // defined(OPENSSL_NO_SSL3)
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L)
   case context::tlsv1:
     handle_ = ::SSL_CTX_new(::TLSv1_method());
     break;
@@ -111,6 +115,7 @@ context::context(context::method m)
   case context::tlsv1_server:
     handle_ = ::SSL_CTX_new(::TLSv1_server_method());
     break;
+#endif // (OPENSSL_VERSION_NUMBER < 0x10100000L)
   case context::sslv23:
     handle_ = ::SSL_CTX_new(::SSLv23_method());
     break;
@@ -120,6 +125,7 @@ context::context(context::method m)
   case context::sslv23_server:
     handle_ = ::SSL_CTX_new(::SSLv23_server_method());
     break;
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L)
 #if defined(SSL_TXT_TLSV1_1)
   case context::tlsv11:
     handle_ = ::SSL_CTX_new(::TLSv1_1_method());
@@ -156,6 +162,23 @@ context::context(context::method m)
         asio::error::invalid_argument, "context");
     break;
 #endif // defined(SSL_TXT_TLSV1_2) 
+#else // (OPENSSL_VERSION_NUMBER < 0x10100000L)
+  case context::tlsv1:
+  case context::tlsv11:
+  case context::tlsv12:
+    handle_ = ::SSL_CTX_new(::TLS_method());
+    break;
+  case context::tlsv1_client:
+  case context::tlsv11_client:
+  case context::tlsv12_client:
+    handle_ = ::SSL_CTX_new(::TLS_client_method());
+    break;
+  case context::tlsv1_server:
+  case context::tlsv11_server:
+  case context::tlsv12_server:
+    handle_ = ::SSL_CTX_new(::TLS_server_method());
+    break;
+#endif // (OPENSSL_VERSION_NUMBER < 0x10100000L)
   default:
     handle_ = ::SSL_CTX_new(0);
     break;
@@ -192,13 +215,22 @@ context::~context()
 {
   if (handle_)
   {
-    if (handle_->default_passwd_callback_userdata)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+    void* cb_userdata = ::SSL_CTX_get_default_passwd_cb_userdata(handle_);
+#else // (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+    void* cb_userdata = handle_->default_passwd_callback_userdata;
+#endif // (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+    if (cb_userdata)
     {
       detail::password_callback_base* callback =
         static_cast<detail::password_callback_base*>(
-            handle_->default_passwd_callback_userdata);
+            cb_userdata);
       delete callback;
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+      ::SSL_CTX_set_default_passwd_cb_userdata(handle_, 0);
+#else // (OPENSSL_VERSION_NUMBER >= 0x10100000L)
       handle_->default_passwd_callback_userdata = 0;
+#endif // (OPENSSL_VERSION_NUMBER >= 0x10100000L)
     }
 
     if (SSL_CTX_get_app_data(handle_))
@@ -226,7 +258,7 @@ void context::clear_options(context::options o)
   asio::detail::throw_error(ec, "clear_options");
 }
 
-asio::error_code context::clear_options(
+ASIO_SYNC_OP_VOID context::clear_options(
     context::options o, asio::error_code& ec)
 {
 #if (OPENSSL_VERSION_NUMBER >= 0x009080DFL) \
@@ -250,7 +282,7 @@ asio::error_code context::clear_options(
   ec = asio::error::operation_not_supported;
 #endif // (OPENSSL_VERSION_NUMBER >= 0x009080DFL)
        //   && (OPENSSL_VERSION_NUMBER != 0x00909000L)
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 void context::set_options(context::options o)
@@ -260,7 +292,7 @@ void context::set_options(context::options o)
   asio::detail::throw_error(ec, "set_options");
 }
 
-asio::error_code context::set_options(
+ASIO_SYNC_OP_VOID context::set_options(
     context::options o, asio::error_code& ec)
 {
 #if !defined(SSL_OP_NO_COMPRESSION)
@@ -277,7 +309,7 @@ asio::error_code context::set_options(
   ::SSL_CTX_set_options(handle_, o);
 
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 void context::set_verify_mode(verify_mode v)
@@ -287,13 +319,13 @@ void context::set_verify_mode(verify_mode v)
   asio::detail::throw_error(ec, "set_verify_mode");
 }
 
-asio::error_code context::set_verify_mode(
+ASIO_SYNC_OP_VOID context::set_verify_mode(
     verify_mode v, asio::error_code& ec)
 {
   ::SSL_CTX_set_verify(handle_, v, ::SSL_CTX_get_verify_callback(handle_));
 
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 void context::set_verify_depth(int depth)
@@ -303,13 +335,13 @@ void context::set_verify_depth(int depth)
   asio::detail::throw_error(ec, "set_verify_depth");
 }
 
-asio::error_code context::set_verify_depth(
+ASIO_SYNC_OP_VOID context::set_verify_depth(
     int depth, asio::error_code& ec)
 {
   ::SSL_CTX_set_verify_depth(handle_, depth);
 
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 void context::load_verify_file(const std::string& filename)
@@ -319,7 +351,7 @@ void context::load_verify_file(const std::string& filename)
   asio::detail::throw_error(ec, "load_verify_file");
 }
 
-asio::error_code context::load_verify_file(
+ASIO_SYNC_OP_VOID context::load_verify_file(
     const std::string& filename, asio::error_code& ec)
 {
   ::ERR_clear_error();
@@ -329,11 +361,11 @@ asio::error_code context::load_verify_file(
     ec = asio::error_code(
         static_cast<int>(::ERR_get_error()),
         asio::error::get_ssl_category());
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 void context::add_certificate_authority(const const_buffer& ca)
@@ -343,7 +375,7 @@ void context::add_certificate_authority(const const_buffer& ca)
   asio::detail::throw_error(ec, "add_certificate_authority");
 }
 
-asio::error_code context::add_certificate_authority(
+ASIO_SYNC_OP_VOID context::add_certificate_authority(
     const const_buffer& ca, asio::error_code& ec)
 {
   ::ERR_clear_error();
@@ -359,7 +391,7 @@ asio::error_code context::add_certificate_authority(
         if (::X509_STORE_add_cert(store, cert.p) == 1)
         {
           ec = asio::error_code();
-          return ec;
+          ASIO_SYNC_OP_VOID_RETURN(ec);
         }
       }
     }
@@ -368,7 +400,7 @@ asio::error_code context::add_certificate_authority(
   ec = asio::error_code(
       static_cast<int>(::ERR_get_error()),
       asio::error::get_ssl_category());
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 void context::set_default_verify_paths()
@@ -378,7 +410,7 @@ void context::set_default_verify_paths()
   asio::detail::throw_error(ec, "set_default_verify_paths");
 }
 
-asio::error_code context::set_default_verify_paths(
+ASIO_SYNC_OP_VOID context::set_default_verify_paths(
     asio::error_code& ec)
 {
   ::ERR_clear_error();
@@ -388,11 +420,11 @@ asio::error_code context::set_default_verify_paths(
     ec = asio::error_code(
         static_cast<int>(::ERR_get_error()),
         asio::error::get_ssl_category());
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 void context::add_verify_path(const std::string& path)
@@ -402,7 +434,7 @@ void context::add_verify_path(const std::string& path)
   asio::detail::throw_error(ec, "add_verify_path");
 }
 
-asio::error_code context::add_verify_path(
+ASIO_SYNC_OP_VOID context::add_verify_path(
     const std::string& path, asio::error_code& ec)
 {
   ::ERR_clear_error();
@@ -412,11 +444,11 @@ asio::error_code context::add_verify_path(
     ec = asio::error_code(
         static_cast<int>(::ERR_get_error()),
         asio::error::get_ssl_category());
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 void context::use_certificate(
@@ -427,7 +459,7 @@ void context::use_certificate(
   asio::detail::throw_error(ec, "use_certificate");
 }
 
-asio::error_code context::use_certificate(
+ASIO_SYNC_OP_VOID context::use_certificate(
     const const_buffer& certificate, file_format format,
     asio::error_code& ec)
 {
@@ -436,11 +468,11 @@ asio::error_code context::use_certificate(
   if (format == context_base::asn1)
   {
     if (::SSL_CTX_use_certificate_ASN1(handle_,
-          static_cast<int>(buffer_size(certificate)),
-          buffer_cast<const unsigned char*>(certificate)) == 1)
+          static_cast<int>(certificate.size()),
+          static_cast<const unsigned char*>(certificate.data())) == 1)
     {
       ec = asio::error_code();
-      return ec;
+      ASIO_SYNC_OP_VOID_RETURN(ec);
     }
   }
   else if (format == context_base::pem)
@@ -454,7 +486,7 @@ asio::error_code context::use_certificate(
         if (::SSL_CTX_use_certificate(handle_, cert.p) == 1)
         {
           ec = asio::error_code();
-          return ec;
+          ASIO_SYNC_OP_VOID_RETURN(ec);
         }
       }
     }
@@ -462,13 +494,13 @@ asio::error_code context::use_certificate(
   else
   {
     ec = asio::error::invalid_argument;
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   ec = asio::error_code(
       static_cast<int>(::ERR_get_error()),
       asio::error::get_ssl_category());
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 void context::use_certificate_file(
@@ -479,7 +511,7 @@ void context::use_certificate_file(
   asio::detail::throw_error(ec, "use_certificate_file");
 }
 
-asio::error_code context::use_certificate_file(
+ASIO_SYNC_OP_VOID context::use_certificate_file(
     const std::string& filename, file_format format,
     asio::error_code& ec)
 {
@@ -495,7 +527,7 @@ asio::error_code context::use_certificate_file(
   default:
     {
       ec = asio::error::invalid_argument;
-      return ec;
+      ASIO_SYNC_OP_VOID_RETURN(ec);
     }
   }
 
@@ -506,11 +538,11 @@ asio::error_code context::use_certificate_file(
     ec = asio::error_code(
         static_cast<int>(::ERR_get_error()),
         asio::error::get_ssl_category());
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 void context::use_certificate_chain(const const_buffer& chain)
@@ -520,7 +552,7 @@ void context::use_certificate_chain(const const_buffer& chain)
   asio::detail::throw_error(ec, "use_certificate_chain");
 }
 
-asio::error_code context::use_certificate_chain(
+ASIO_SYNC_OP_VOID context::use_certificate_chain(
     const const_buffer& chain, asio::error_code& ec)
 {
   ::ERR_clear_error();
@@ -528,15 +560,22 @@ asio::error_code context::use_certificate_chain(
   bio_cleanup bio = { make_buffer_bio(chain) };
   if (bio.p)
   {
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+    pem_password_cb* callback = ::SSL_CTX_get_default_passwd_cb(handle_);
+    void* cb_userdata = ::SSL_CTX_get_default_passwd_cb_userdata(handle_);
+#else // (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+    pem_password_cb* callback = handle_->default_passwd_callback;
+    void* cb_userdata = handle_->default_passwd_callback_userdata;
+#endif // (OPENSSL_VERSION_NUMBER >= 0x10100000L)
     x509_cleanup cert = {
       ::PEM_read_bio_X509_AUX(bio.p, 0,
-          handle_->default_passwd_callback,
-          handle_->default_passwd_callback_userdata) };
+          callback,
+          cb_userdata) };
     if (!cert.p)
     {
       ec = asio::error_code(ERR_R_PEM_LIB,
           asio::error::get_ssl_category());
-      return ec;
+      ASIO_SYNC_OP_VOID_RETURN(ec);
     }
 
     int result = ::SSL_CTX_use_certificate(handle_, cert.p);
@@ -545,25 +584,29 @@ asio::error_code context::use_certificate_chain(
       ec = asio::error_code(
           static_cast<int>(::ERR_get_error()),
           asio::error::get_ssl_category());
-      return ec;
+      ASIO_SYNC_OP_VOID_RETURN(ec);
     }
 
+#if (OPENSSL_VERSION_NUMBER >= 0x10002000L)
+    ::SSL_CTX_clear_chain_certs(handle_);
+#else
     if (handle_->extra_certs)
     {
       ::sk_X509_pop_free(handle_->extra_certs, X509_free);
       handle_->extra_certs = 0;
     }
+#endif // (OPENSSL_VERSION_NUMBER >= 0x10002000L)
 
     while (X509* cacert = ::PEM_read_bio_X509(bio.p, 0,
-          handle_->default_passwd_callback,
-          handle_->default_passwd_callback_userdata))
+          callback,
+          cb_userdata))
     {
       if (!::SSL_CTX_add_extra_chain_cert(handle_, cacert))
       {
         ec = asio::error_code(
             static_cast<int>(::ERR_get_error()),
             asio::error::get_ssl_category());
-        return ec;
+        ASIO_SYNC_OP_VOID_RETURN(ec);
       }
     }
   
@@ -573,14 +616,14 @@ asio::error_code context::use_certificate_chain(
     {
       ::ERR_clear_error();
       ec = asio::error_code();
-      return ec;
+      ASIO_SYNC_OP_VOID_RETURN(ec);
     }
   }
 
   ec = asio::error_code(
       static_cast<int>(::ERR_get_error()),
       asio::error::get_ssl_category());
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 void context::use_certificate_chain_file(const std::string& filename)
@@ -590,7 +633,7 @@ void context::use_certificate_chain_file(const std::string& filename)
   asio::detail::throw_error(ec, "use_certificate_chain_file");
 }
 
-asio::error_code context::use_certificate_chain_file(
+ASIO_SYNC_OP_VOID context::use_certificate_chain_file(
     const std::string& filename, asio::error_code& ec)
 {
   ::ERR_clear_error();
@@ -600,11 +643,11 @@ asio::error_code context::use_certificate_chain_file(
     ec = asio::error_code(
         static_cast<int>(::ERR_get_error()),
         asio::error::get_ssl_category());
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 void context::use_private_key(
@@ -615,12 +658,20 @@ void context::use_private_key(
   asio::detail::throw_error(ec, "use_private_key");
 }
 
-asio::error_code context::use_private_key(
+ASIO_SYNC_OP_VOID context::use_private_key(
     const const_buffer& private_key, context::file_format format,
     asio::error_code& ec)
 {
   ::ERR_clear_error();
 
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+    pem_password_cb* callback = ::SSL_CTX_get_default_passwd_cb(handle_);
+    void* cb_userdata = ::SSL_CTX_get_default_passwd_cb_userdata(handle_);
+#else // (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+    pem_password_cb* callback = handle_->default_passwd_callback;
+    void* cb_userdata = handle_->default_passwd_callback_userdata;
+#endif // (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+
   bio_cleanup bio = { make_buffer_bio(private_key) };
   if (bio.p)
   {
@@ -632,13 +683,13 @@ asio::error_code context::use_private_key(
       break;
     case context_base::pem:
       evp_private_key.p = ::PEM_read_bio_PrivateKey(
-          bio.p, 0, handle_->default_passwd_callback,
-          handle_->default_passwd_callback_userdata);
+          bio.p, 0, callback,
+          cb_userdata);
       break;
     default:
       {
         ec = asio::error::invalid_argument;
-        return ec;
+        ASIO_SYNC_OP_VOID_RETURN(ec);
       }
     }
 
@@ -647,7 +698,7 @@ asio::error_code context::use_private_key(
       if (::SSL_CTX_use_PrivateKey(handle_, evp_private_key.p) == 1)
       {
         ec = asio::error_code();
-        return ec;
+        ASIO_SYNC_OP_VOID_RETURN(ec);
       }
     }
   }
@@ -655,7 +706,7 @@ asio::error_code context::use_private_key(
   ec = asio::error_code(
       static_cast<int>(::ERR_get_error()),
       asio::error::get_ssl_category());
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 void context::use_private_key_file(
@@ -674,12 +725,20 @@ void context::use_rsa_private_key(
   asio::detail::throw_error(ec, "use_rsa_private_key");
 }
 
-asio::error_code context::use_rsa_private_key(
+ASIO_SYNC_OP_VOID context::use_rsa_private_key(
     const const_buffer& private_key, context::file_format format,
     asio::error_code& ec)
 {
   ::ERR_clear_error();
 
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+    pem_password_cb* callback = ::SSL_CTX_get_default_passwd_cb(handle_);
+    void* cb_userdata = ::SSL_CTX_get_default_passwd_cb_userdata(handle_);
+#else // (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+    pem_password_cb* callback = handle_->default_passwd_callback;
+    void* cb_userdata = handle_->default_passwd_callback_userdata;
+#endif // (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+
   bio_cleanup bio = { make_buffer_bio(private_key) };
   if (bio.p)
   {
@@ -691,13 +750,13 @@ asio::error_code context::use_rsa_private_key(
       break;
     case context_base::pem:
       rsa_private_key.p = ::PEM_read_bio_RSAPrivateKey(
-          bio.p, 0, handle_->default_passwd_callback,
-          handle_->default_passwd_callback_userdata);
+          bio.p, 0, callback,
+          cb_userdata);
       break;
     default:
       {
         ec = asio::error::invalid_argument;
-        return ec;
+        ASIO_SYNC_OP_VOID_RETURN(ec);
       }
     }
 
@@ -706,7 +765,7 @@ asio::error_code context::use_rsa_private_key(
       if (::SSL_CTX_use_RSAPrivateKey(handle_, rsa_private_key.p) == 1)
       {
         ec = asio::error_code();
-        return ec;
+        ASIO_SYNC_OP_VOID_RETURN(ec);
       }
     }
   }
@@ -714,10 +773,10 @@ asio::error_code context::use_rsa_private_key(
   ec = asio::error_code(
       static_cast<int>(::ERR_get_error()),
       asio::error::get_ssl_category());
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
-asio::error_code context::use_private_key_file(
+ASIO_SYNC_OP_VOID context::use_private_key_file(
     const std::string& filename, context::file_format format,
     asio::error_code& ec)
 {
@@ -733,7 +792,7 @@ asio::error_code context::use_private_key_file(
   default:
     {
       ec = asio::error::invalid_argument;
-      return ec;
+      ASIO_SYNC_OP_VOID_RETURN(ec);
     }
   }
 
@@ -744,11 +803,11 @@ asio::error_code context::use_private_key_file(
     ec = asio::error_code(
         static_cast<int>(::ERR_get_error()),
         asio::error::get_ssl_category());
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 void context::use_rsa_private_key_file(
@@ -759,7 +818,7 @@ void context::use_rsa_private_key_file(
   asio::detail::throw_error(ec, "use_rsa_private_key_file");
 }
 
-asio::error_code context::use_rsa_private_key_file(
+ASIO_SYNC_OP_VOID context::use_rsa_private_key_file(
     const std::string& filename, context::file_format format,
     asio::error_code& ec)
 {
@@ -775,7 +834,7 @@ asio::error_code context::use_rsa_private_key_file(
   default:
     {
       ec = asio::error::invalid_argument;
-      return ec;
+      ASIO_SYNC_OP_VOID_RETURN(ec);
     }
   }
 
@@ -787,11 +846,11 @@ asio::error_code context::use_rsa_private_key_file(
     ec = asio::error_code(
         static_cast<int>(::ERR_get_error()),
         asio::error::get_ssl_category());
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 void context::use_tmp_dh(const const_buffer& dh)
@@ -801,7 +860,7 @@ void context::use_tmp_dh(const const_buffer& dh)
   asio::detail::throw_error(ec, "use_tmp_dh");
 }
 
-asio::error_code context::use_tmp_dh(
+ASIO_SYNC_OP_VOID context::use_tmp_dh(
     const const_buffer& dh, asio::error_code& ec)
 {
   ::ERR_clear_error();
@@ -815,7 +874,7 @@ asio::error_code context::use_tmp_dh(
   ec = asio::error_code(
       static_cast<int>(::ERR_get_error()),
       asio::error::get_ssl_category());
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 void context::use_tmp_dh_file(const std::string& filename)
@@ -825,7 +884,7 @@ void context::use_tmp_dh_file(const std::string& filename)
   asio::detail::throw_error(ec, "use_tmp_dh_file");
 }
 
-asio::error_code context::use_tmp_dh_file(
+ASIO_SYNC_OP_VOID context::use_tmp_dh_file(
     const std::string& filename, asio::error_code& ec)
 {
   ::ERR_clear_error();
@@ -839,10 +898,10 @@ asio::error_code context::use_tmp_dh_file(
   ec = asio::error_code(
       static_cast<int>(::ERR_get_error()),
       asio::error::get_ssl_category());
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
-asio::error_code context::do_use_tmp_dh(
+ASIO_SYNC_OP_VOID context::do_use_tmp_dh(
     BIO* bio, asio::error_code& ec)
 {
   ::ERR_clear_error();
@@ -853,17 +912,17 @@ asio::error_code context::do_use_tmp_dh(
     if (::SSL_CTX_set_tmp_dh(handle_, dh.p) == 1)
     {
       ec = asio::error_code();
-      return ec;
+      ASIO_SYNC_OP_VOID_RETURN(ec);
     }
   }
 
   ec = asio::error_code(
       static_cast<int>(::ERR_get_error()),
       asio::error::get_ssl_category());
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
-asio::error_code context::do_set_verify_callback(
+ASIO_SYNC_OP_VOID context::do_set_verify_callback(
     detail::verify_callback_base* callback, asio::error_code& ec)
 {
   if (SSL_CTX_get_app_data(handle_))
@@ -879,7 +938,7 @@ asio::error_code context::do_set_verify_callback(
       &context::verify_callback_function);
 
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 int context::verify_callback_function(int preverified, X509_STORE_CTX* ctx)
@@ -908,19 +967,25 @@ int context::verify_callback_function(int preverified, X509_STORE_CTX* ctx)
   return 0;
 }
 
-asio::error_code context::do_set_password_callback(
+ASIO_SYNC_OP_VOID context::do_set_password_callback(
     detail::password_callback_base* callback, asio::error_code& ec)
 {
-  if (handle_->default_passwd_callback_userdata)
-    delete static_cast<detail::password_callback_base*>(
-        handle_->default_passwd_callback_userdata);
-
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+  void* old_callback = ::SSL_CTX_get_default_passwd_cb_userdata(handle_);
+  ::SSL_CTX_set_default_passwd_cb_userdata(handle_, callback);
+#else // (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+  void* old_callback = handle_->default_passwd_callback_userdata;
   handle_->default_passwd_callback_userdata = callback;
+#endif // (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+
+  if (old_callback)
+    delete static_cast<detail::password_callback_base*>(
+        old_callback);
 
   SSL_CTX_set_default_passwd_cb(handle_, &context::password_callback_function);
 
   ec = asio::error_code();
-  return ec;
+  ASIO_SYNC_OP_VOID_RETURN(ec);
 }
 
 int context::password_callback_function(
@@ -940,7 +1005,8 @@ int context::password_callback_function(
     strcpy_s(buf, size, passwd.c_str());
 #else // defined(ASIO_HAS_SECURE_RTL)
     *buf = '\0';
-    strncat(buf, passwd.c_str(), size);
+    if (size > 0)
+      strncat(buf, passwd.c_str(), size - 1);
 #endif // defined(ASIO_HAS_SECURE_RTL)
 
     return static_cast<int>(strlen(buf));
@@ -952,8 +1018,8 @@ int context::password_callback_function(
 BIO* context::make_buffer_bio(const const_buffer& b)
 {
   return ::BIO_new_mem_buf(
-      const_cast<void*>(buffer_cast<const void*>(b)),
-      static_cast<int>(buffer_size(b)));
+      const_cast<void*>(b.data()),
+      static_cast<int>(b.size()));
 }
 
 } // namespace ssl
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/impl/error.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/impl/error.ipp
index 9e76039..268fc96 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/impl/error.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/impl/error.ipp
@@ -2,7 +2,7 @@
 // ssl/impl/error.ipp
 // ~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -23,7 +23,6 @@
 
 namespace asio {
 namespace error {
-
 namespace detail {
 
 class ssl_category : public asio::error_category
@@ -50,6 +49,50 @@ const asio::error_category& get_ssl_category()
 }
 
 } // namespace error
+namespace ssl {
+namespace error {
+
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L) && !defined(OPENSSL_IS_BORINGSSL)
+
+const asio::error_category& get_stream_category()
+{
+  return asio::error::get_ssl_category();
+}
+
+#else
+
+namespace detail {
+
+class stream_category : public asio::error_category
+{
+public:
+  const char* name() const ASIO_ERROR_CATEGORY_NOEXCEPT
+  {
+    return "asio.ssl.stream";
+  }
+
+  std::string message(int value) const
+  {
+    switch (value)
+    {
+    case stream_truncated: return "stream truncated";
+    default: return "asio.ssl.stream error";
+    }
+  }
+};
+
+} // namespace detail
+
+const asio::error_category& get_stream_category()
+{
+  static detail::stream_category instance;
+  return instance;
+}
+
+#endif
+
+} // namespace error
+} // namespace ssl
 } // namespace asio
 
 #include "asio/detail/pop_options.hpp"
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/impl/rfc2818_verification.ipp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/impl/rfc2818_verification.ipp
index dbb9ead..f84b025 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/impl/rfc2818_verification.ipp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/impl/rfc2818_verification.ipp
@@ -2,7 +2,7 @@
 // ssl/impl/rfc2818_verification.ipp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -78,8 +78,7 @@ bool rfc2818_verification::operator()(
       {
         if (address.is_v4() && ip_address->length == 4)
         {
-          ip::address_v4::bytes_type bytes =
-            ip::address_cast<ip::address_v4>(address).to_bytes();
+          ip::address_v4::bytes_type bytes = address.to_v4().to_bytes();
           if (memcmp(bytes.data(), ip_address->data, 4) == 0)
           {
             GENERAL_NAMES_free(gens);
@@ -88,8 +87,7 @@ bool rfc2818_verification::operator()(
         }
         else if (address.is_v6() && ip_address->length == 16)
         {
-          ip::address_v6::bytes_type bytes =
-            ip::address_cast<ip::address_v6>(address).to_bytes();
+          ip::address_v6::bytes_type bytes = address.to_v6().to_bytes();
           if (memcmp(bytes.data(), ip_address->data, 16) == 0)
           {
             GENERAL_NAMES_free(gens);
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/impl/src.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/impl/src.hpp
index 8db35ce..e6e269f 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/impl/src.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/impl/src.hpp
@@ -2,7 +2,7 @@
 // impl/ssl/src.hpp
 // ~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/rfc2818_verification.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/rfc2818_verification.hpp
index 7529855..a4ab67b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/rfc2818_verification.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/rfc2818_verification.hpp
@@ -2,7 +2,7 @@
 // ssl/rfc2818_verification.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -42,9 +42,9 @@ namespace ssl {
  * ctx.set_default_verify_paths();
  *
  * // Open a socket and connect it to the remote host.
- * asio::io_service io_service;
- * ssl_socket sock(io_service, ctx);
- * tcp::resolver resolver(io_service);
+ * asio::io_context io_context;
+ * ssl_socket sock(io_context, ctx);
+ * tcp::resolver resolver(io_context);
  * tcp::resolver::query query("host.name", "https");
  * asio::connect(sock.lowest_layer(), resolver.resolve(query));
  * sock.lowest_layer().set_option(tcp::no_delay(true));
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/stream.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/stream.hpp
index f80a67c..bc259b5 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/stream.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/stream.hpp
@@ -2,7 +2,7 @@
 // ssl/stream.hpp
 // ~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -51,9 +51,9 @@ namespace ssl {
  * @par Example
  * To use the SSL stream template with an ip::tcp::socket, you would write:
  * @code
- * asio::io_service io_service;
+ * asio::io_context io_context;
  * asio::ssl::context ctx(asio::ssl::context::sslv23);
- * asio::ssl::stream<asio:ip::tcp::socket> sock(io_service, ctx);
+ * asio::ssl::stream<asio:ip::tcp::socket> sock(io_context, ctx);
  * @endcode
  *
  * @par Concepts:
@@ -80,6 +80,9 @@ public:
   /// The type of the lowest layer.
   typedef typename next_layer_type::lowest_layer_type lowest_layer_type;
 
+  /// The type of the executor associated with the object.
+  typedef typename lowest_layer_type::executor_type executor_type;
+
 #if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
   /// Construct a stream.
   /**
@@ -108,22 +111,41 @@ public:
 #endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
 
   /// Destructor.
+  /**
+   * @note A @c stream object must not be destroyed while there are pending
+   * asynchronous operations associated with it.
+   */
   ~stream()
   {
   }
 
-  /// Get the io_service associated with the object.
+  /// Get the executor associated with the object.
   /**
-   * This function may be used to obtain the io_service object that the stream
+   * This function may be used to obtain the executor object that the stream
    * uses to dispatch handlers for asynchronous operations.
    *
-   * @return A reference to the io_service object that stream will use to
-   * dispatch handlers. Ownership is not transferred to the caller.
+   * @return A copy of the executor that stream will use to dispatch handlers.
    */
-  asio::io_service& get_io_service()
+  executor_type get_executor() ASIO_NOEXCEPT
+  {
+    return next_layer_.lowest_layer().get_executor();
+  }
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  asio::io_context& get_io_context()
+  {
+    return next_layer_.lowest_layer().get_io_context();
+  }
+
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  asio::io_context& get_io_service()
   {
     return next_layer_.lowest_layer().get_io_service();
   }
+#endif // !defined(ASIO_NO_DEPRECATED)
 
   /// Get the underlying implementation in the native type.
   /**
@@ -136,7 +158,7 @@ public:
    * suitable for passing to functions such as @c SSL_get_verify_result and
    * @c SSL_get_peer_certificate:
    * @code
-   * asio::ssl::stream<asio:ip::tcp::socket> sock(io_service, ctx);
+   * asio::ssl::stream<asio:ip::tcp::socket> sock(io_context, ctx);
    *
    * // ... establish connection and perform handshake ...
    *
@@ -237,10 +259,11 @@ public:
    *
    * @note Calls @c SSL_set_verify.
    */
-  asio::error_code set_verify_mode(
+  ASIO_SYNC_OP_VOID set_verify_mode(
       verify_mode v, asio::error_code& ec)
   {
-    return core_.engine_.set_verify_mode(v, ec);
+    core_.engine_.set_verify_mode(v, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Set the peer verification depth.
@@ -274,10 +297,11 @@ public:
    *
    * @note Calls @c SSL_set_verify_depth.
    */
-  asio::error_code set_verify_depth(
+  ASIO_SYNC_OP_VOID set_verify_depth(
       int depth, asio::error_code& ec)
   {
-    return core_.engine_.set_verify_depth(depth, ec);
+    core_.engine_.set_verify_depth(depth, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Set the callback used to verify peer certificates.
@@ -325,11 +349,12 @@ public:
    * @note Calls @c SSL_set_verify.
    */
   template <typename VerifyCallback>
-  asio::error_code set_verify_callback(VerifyCallback callback,
+  ASIO_SYNC_OP_VOID set_verify_callback(VerifyCallback callback,
       asio::error_code& ec)
   {
-    return core_.engine_.set_verify_callback(
+    core_.engine_.set_verify_callback(
         new detail::verify_callback<VerifyCallback>(callback), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Perform SSL handshaking.
@@ -359,11 +384,11 @@ public:
    *
    * @param ec Set to indicate what error occurred, if any.
    */
-  asio::error_code handshake(handshake_type type,
+  ASIO_SYNC_OP_VOID handshake(handshake_type type,
       asio::error_code& ec)
   {
     detail::io(next_layer_, core_, detail::handshake_op(type), ec);
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Perform SSL handshaking.
@@ -399,12 +424,12 @@ public:
    * @param ec Set to indicate what error occurred, if any.
    */
   template <typename ConstBufferSequence>
-  asio::error_code handshake(handshake_type type,
+  ASIO_SYNC_OP_VOID handshake(handshake_type type,
       const ConstBufferSequence& buffers, asio::error_code& ec)
   {
     detail::io(next_layer_, core_,
         detail::buffered_handshake_op<ConstBufferSequence>(type, buffers), ec);
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Start an asynchronous SSL handshake.
@@ -436,7 +461,7 @@ public:
       void (asio::error_code)> init(handler);
 
     detail::async_io(next_layer_, core_,
-        detail::handshake_op(type), init.handler);
+        detail::handshake_op(type), init.completion_handler);
 
     return init.result.get();
   }
@@ -478,7 +503,7 @@ public:
 
     detail::async_io(next_layer_, core_,
         detail::buffered_handshake_op<ConstBufferSequence>(type, buffers),
-        init.handler);
+        init.completion_handler);
 
     return init.result.get();
   }
@@ -504,10 +529,10 @@ public:
    *
    * @param ec Set to indicate what error occurred, if any.
    */
-  asio::error_code shutdown(asio::error_code& ec)
+  ASIO_SYNC_OP_VOID shutdown(asio::error_code& ec)
   {
     detail::io(next_layer_, core_, detail::shutdown_op(), ec);
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Asynchronously shut down SSL on the stream.
@@ -534,7 +559,8 @@ public:
     asio::async_completion<ShutdownHandler,
       void (asio::error_code)> init(handler);
 
-    detail::async_io(next_layer_, core_, detail::shutdown_op(), init.handler);
+    detail::async_io(next_layer_, core_, detail::shutdown_op(),
+        init.completion_handler);
 
     return init.result.get();
   }
@@ -624,7 +650,8 @@ public:
       void (asio::error_code, std::size_t)> init(handler);
 
     detail::async_io(next_layer_, core_,
-        detail::write_op<ConstBufferSequence>(buffers), init.handler);
+        detail::write_op<ConstBufferSequence>(buffers),
+        init.completion_handler);
 
     return init.result.get();
   }
@@ -715,7 +742,8 @@ public:
       void (asio::error_code, std::size_t)> init(handler);
 
     detail::async_io(next_layer_, core_,
-        detail::read_op<MutableBufferSequence>(buffers), init.handler);
+        detail::read_op<MutableBufferSequence>(buffers),
+        init.completion_handler);
 
     return init.result.get();
   }
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/stream_base.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/stream_base.hpp
index ed74134..275d3e3 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/stream_base.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/stream_base.hpp
@@ -2,7 +2,7 @@
 // ssl/stream_base.hpp
 // ~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/verify_context.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/verify_context.hpp
index 65f97c0..560ffcc 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/verify_context.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/verify_context.hpp
@@ -2,7 +2,7 @@
 // ssl/verify_context.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/verify_mode.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/verify_mode.hpp
index adea0f0..7a2bd56 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/verify_mode.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ssl/verify_mode.hpp
@@ -2,7 +2,7 @@
 // ssl/verify_mode.hpp
 // ~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/steady_timer.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/steady_timer.hpp
index 8e7ca68..746ac04 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/steady_timer.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/steady_timer.hpp
@@ -2,7 +2,7 @@
 // steady_timer.hpp
 // ~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,21 +17,13 @@
 
 #include "asio/detail/config.hpp"
 
-#if defined(ASIO_HAS_STD_CHRONO) \
-  || defined(ASIO_HAS_BOOST_CHRONO) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#if defined(ASIO_HAS_STD_CHRONO)
-# include <chrono>
-#elif defined(ASIO_HAS_BOOST_CHRONO)
-# include <boost/chrono/system_clocks.hpp>
-#endif
+#if defined(ASIO_HAS_CHRONO) || defined(GENERATING_DOCUMENTATION)
 
 #include "asio/basic_waitable_timer.hpp"
+#include "asio/detail/chrono.hpp"
 
 namespace asio {
 
-#if defined(GENERATING_DOCUMENTATION)
 /// Typedef for a timer based on the steady clock.
 /**
  * This typedef uses the C++11 @c &lt;chrono&gt; standard library facility, if
@@ -42,20 +34,9 @@ namespace asio {
  * @endcode
  */
 typedef basic_waitable_timer<chrono::steady_clock> steady_timer;
-#elif defined(ASIO_HAS_STD_CHRONO)
-# if defined(ASIO_HAS_STD_CHRONO_MONOTONIC_CLOCK)
-typedef basic_waitable_timer<std::chrono::monotonic_clock> steady_timer;
-# else // defined(ASIO_HAS_STD_CHRONO_MONOTONIC_CLOCK)
-typedef basic_waitable_timer<std::chrono::steady_clock> steady_timer;
-# endif // defined(ASIO_HAS_STD_CHRONO_MONOTONIC_CLOCK)
-#elif defined(ASIO_HAS_BOOST_CHRONO)
-typedef basic_waitable_timer<boost::chrono::steady_clock> steady_timer;
-#endif
 
 } // namespace asio
 
-#endif // defined(ASIO_HAS_STD_CHRONO) 
-       //   || defined(ASIO_HAS_BOOST_CHRONO)
-       //   || defined(GENERATING_DOCUMENTATION)
+#endif // defined(ASIO_HAS_CHRONO) || defined(GENERATING_DOCUMENTATION)
 
 #endif // ASIO_STEADY_TIMER_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/strand.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/strand.hpp
index 389e004..c70162b 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/strand.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/strand.hpp
@@ -2,7 +2,7 @@
 // strand.hpp
 // ~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -18,7 +18,6 @@
 #include "asio/detail/config.hpp"
 #include "asio/detail/strand_executor_service.hpp"
 #include "asio/detail/type_traits.hpp"
-#include "asio/is_executor.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -272,19 +271,16 @@ private:
   implementation_type impl_;
 };
 
-#if !defined(GENERATING_DOCUMENTATION)
-template <typename Executor>
-struct is_executor<strand<Executor> > : true_type {};
-#endif // !defined(GENERATING_DOCUMENTATION)
-
 } // namespace asio
 
 #include "asio/detail/pop_options.hpp"
 
-// If both io_service.hpp and strand.hpp have been included, automatically
-// include the header file needed for the io_service::strand class.
-#if defined(ASIO_IO_SERVICE_HPP)
-# include "asio/io_service_strand.hpp"
-#endif // defined(ASIO_IO_SERVICE_HPP)
+// If both io_context.hpp and strand.hpp have been included, automatically
+// include the header file needed for the io_context::strand class.
+#if !defined(ASIO_NO_EXTENSIONS)
+# if defined(ASIO_IO_CONTEXT_HPP)
+#  include "asio/io_context_strand.hpp"
+# endif // defined(ASIO_IO_CONTEXT_HPP)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 #endif // ASIO_STRAND_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/stream_socket_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/stream_socket_service.hpp
index bec5b83..5cea565 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/stream_socket_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/stream_socket_service.hpp
@@ -2,7 +2,7 @@
 // stream_socket_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,11 +16,14 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #include <cstddef>
 #include "asio/async_result.hpp"
 #include "asio/detail/type_traits.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 
 #if defined(ASIO_WINDOWS_RUNTIME)
 # include "asio/detail/winrt_ssocket_service.hpp"
@@ -38,7 +41,7 @@ namespace asio {
 template <typename Protocol>
 class stream_socket_service
 #if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
+  : public asio::io_context::service
 #else
   : public asio::detail::service_base<stream_socket_service<Protocol> >
 #endif
@@ -46,7 +49,7 @@ class stream_socket_service
 public:
 #if defined(GENERATING_DOCUMENTATION)
   /// The unique service identifier.
-  static asio::io_service::id id;
+  static asio::io_context::id id;
 #endif
 
   /// The protocol type.
@@ -80,11 +83,11 @@ public:
   typedef typename service_impl_type::native_handle_type native_handle_type;
 #endif
 
-  /// Construct a new stream socket service for the specified io_service.
-  explicit stream_socket_service(asio::io_service& io_service)
+  /// Construct a new stream socket service for the specified io_context.
+  explicit stream_socket_service(asio::io_context& io_context)
     : asio::detail::service_base<
-        stream_socket_service<Protocol> >(io_service),
-      service_impl_(io_service)
+        stream_socket_service<Protocol> >(io_context),
+      service_impl_(io_context)
   {
   }
 
@@ -131,22 +134,23 @@ public:
   }
 
   /// Open a stream socket.
-  asio::error_code open(implementation_type& impl,
+  ASIO_SYNC_OP_VOID open(implementation_type& impl,
       const protocol_type& protocol, asio::error_code& ec)
   {
     if (protocol.type() == ASIO_OS_DEF(SOCK_STREAM))
       service_impl_.open(impl, protocol, ec);
     else
       ec = asio::error::invalid_argument;
-    return ec;
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Assign an existing native socket to a stream socket.
-  asio::error_code assign(implementation_type& impl,
+  ASIO_SYNC_OP_VOID assign(implementation_type& impl,
       const protocol_type& protocol, const native_handle_type& native_socket,
       asio::error_code& ec)
   {
-    return service_impl_.assign(impl, protocol, native_socket, ec);
+    service_impl_.assign(impl, protocol, native_socket, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Determine whether the socket is open.
@@ -156,10 +160,11 @@ public:
   }
 
   /// Close a stream socket implementation.
-  asio::error_code close(implementation_type& impl,
+  ASIO_SYNC_OP_VOID close(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.close(impl, ec);
+    service_impl_.close(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the native socket implementation.
@@ -169,10 +174,11 @@ public:
   }
 
   /// Cancel all asynchronous operations associated with the socket.
-  asio::error_code cancel(implementation_type& impl,
+  ASIO_SYNC_OP_VOID cancel(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.cancel(impl, ec);
+    service_impl_.cancel(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Determine whether the socket is at the out-of-band data mark.
@@ -190,17 +196,19 @@ public:
   }
 
   /// Bind the stream socket to the specified local endpoint.
-  asio::error_code bind(implementation_type& impl,
+  ASIO_SYNC_OP_VOID bind(implementation_type& impl,
       const endpoint_type& endpoint, asio::error_code& ec)
   {
-    return service_impl_.bind(impl, endpoint, ec);
+    service_impl_.bind(impl, endpoint, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Connect the stream socket to the specified endpoint.
-  asio::error_code connect(implementation_type& impl,
+  ASIO_SYNC_OP_VOID connect(implementation_type& impl,
       const endpoint_type& peer_endpoint, asio::error_code& ec)
   {
-    return service_impl_.connect(impl, peer_endpoint, ec);
+    service_impl_.connect(impl, peer_endpoint, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Start an asynchronous connect.
@@ -214,33 +222,36 @@ public:
     async_completion<ConnectHandler,
       void (asio::error_code)> init(handler);
 
-    service_impl_.async_connect(impl, peer_endpoint, init.handler);
+    service_impl_.async_connect(impl, peer_endpoint, init.completion_handler);
 
     return init.result.get();
   }
 
   /// Set a socket option.
   template <typename SettableSocketOption>
-  asio::error_code set_option(implementation_type& impl,
+  ASIO_SYNC_OP_VOID set_option(implementation_type& impl,
       const SettableSocketOption& option, asio::error_code& ec)
   {
-    return service_impl_.set_option(impl, option, ec);
+    service_impl_.set_option(impl, option, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get a socket option.
   template <typename GettableSocketOption>
-  asio::error_code get_option(const implementation_type& impl,
+  ASIO_SYNC_OP_VOID get_option(const implementation_type& impl,
       GettableSocketOption& option, asio::error_code& ec) const
   {
-    return service_impl_.get_option(impl, option, ec);
+    service_impl_.get_option(impl, option, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Perform an IO control command on the socket.
   template <typename IoControlCommand>
-  asio::error_code io_control(implementation_type& impl,
+  ASIO_SYNC_OP_VOID io_control(implementation_type& impl,
       IoControlCommand& command, asio::error_code& ec)
   {
-    return service_impl_.io_control(impl, command, ec);
+    service_impl_.io_control(impl, command, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Gets the non-blocking mode of the socket.
@@ -250,10 +261,11 @@ public:
   }
 
   /// Sets the non-blocking mode of the socket.
-  asio::error_code non_blocking(implementation_type& impl,
+  ASIO_SYNC_OP_VOID non_blocking(implementation_type& impl,
       bool mode, asio::error_code& ec)
   {
-    return service_impl_.non_blocking(impl, mode, ec);
+    service_impl_.non_blocking(impl, mode, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Gets the non-blocking mode of the native socket implementation.
@@ -263,10 +275,11 @@ public:
   }
 
   /// Sets the non-blocking mode of the native socket implementation.
-  asio::error_code native_non_blocking(implementation_type& impl,
+  ASIO_SYNC_OP_VOID native_non_blocking(implementation_type& impl,
       bool mode, asio::error_code& ec)
   {
-    return service_impl_.native_non_blocking(impl, mode, ec);
+    service_impl_.native_non_blocking(impl, mode, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the local endpoint.
@@ -284,18 +297,20 @@ public:
   }
 
   /// Disable sends or receives on the socket.
-  asio::error_code shutdown(implementation_type& impl,
+  ASIO_SYNC_OP_VOID shutdown(implementation_type& impl,
       socket_base::shutdown_type what, asio::error_code& ec)
   {
-    return service_impl_.shutdown(impl, what, ec);
+    service_impl_.shutdown(impl, what, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Wait for the socket to become ready to read, ready to write, or to have
   /// pending error conditions.
-  asio::error_code wait(implementation_type& impl,
+  ASIO_SYNC_OP_VOID wait(implementation_type& impl,
       socket_base::wait_type w, asio::error_code& ec)
   {
-    return service_impl_.wait(impl, w, ec);
+    service_impl_.wait(impl, w, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Asynchronously wait for the socket to become ready to read, ready to
@@ -309,7 +324,7 @@ public:
     async_completion<WaitHandler,
       void (asio::error_code)> init(handler);
 
-    service_impl_.async_wait(impl, w, init.handler);
+    service_impl_.async_wait(impl, w, init.completion_handler);
 
     return init.result.get();
   }
@@ -335,7 +350,7 @@ public:
     async_completion<WriteHandler,
       void (asio::error_code, std::size_t)> init(handler);
 
-    service_impl_.async_send(impl, buffers, flags, init.handler);
+    service_impl_.async_send(impl, buffers, flags, init.completion_handler);
 
     return init.result.get();
   }
@@ -361,16 +376,16 @@ public:
     async_completion<ReadHandler,
       void (asio::error_code, std::size_t)> init(handler);
 
-    service_impl_.async_receive(impl, buffers, flags, init.handler);
+    service_impl_.async_receive(impl, buffers, flags, init.completion_handler);
 
     return init.result.get();
   }
 
 private:
   // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
+  void shutdown()
   {
-    service_impl_.shutdown_service();
+    service_impl_.shutdown();
   }
 
   // The platform-specific implementation.
@@ -381,4 +396,6 @@ private:
 
 #include "asio/detail/pop_options.hpp"
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_STREAM_SOCKET_SERVICE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/streambuf.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/streambuf.hpp
index 75cee1b..8e613e9 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/streambuf.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/streambuf.hpp
@@ -2,7 +2,7 @@
 // streambuf.hpp
 // ~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/system_error.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/system_error.hpp
index 4ec121e..6c7a1e1 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/system_error.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/system_error.hpp
@@ -2,7 +2,7 @@
 // system_error.hpp
 // ~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/system_executor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/system_executor.hpp
index 07c7874..f23e35f 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/system_executor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/system_executor.hpp
@@ -2,7 +2,7 @@
 // system_executor.hpp
 // ~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -19,7 +19,6 @@
 #include "asio/detail/scheduler.hpp"
 #include "asio/detail/thread_group.hpp"
 #include "asio/execution_context.hpp"
-#include "asio/is_executor.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -36,13 +35,13 @@ class system_executor
 {
 public:
   /// Obtain the underlying execution context.
-  execution_context& context() ASIO_NOEXCEPT;
+  execution_context& context() const ASIO_NOEXCEPT;
 
   /// Inform the executor that it has some outstanding work to do.
   /**
    * For the system executor, this is a no-op.
    */
-  void on_work_started() ASIO_NOEXCEPT
+  void on_work_started() const ASIO_NOEXCEPT
   {
   }
 
@@ -50,7 +49,7 @@ public:
   /**
    * For the system executor, this is a no-op.
    */
-  void on_work_finished() ASIO_NOEXCEPT
+  void on_work_finished() const ASIO_NOEXCEPT
   {
   }
 
@@ -67,7 +66,7 @@ public:
    * internal storage needed for function invocation.
    */
   template <typename Function, typename Allocator>
-  void dispatch(ASIO_MOVE_ARG(Function) f, const Allocator& a);
+  void dispatch(ASIO_MOVE_ARG(Function) f, const Allocator& a) const;
 
   /// Request the system executor to invoke the given function object.
   /**
@@ -83,7 +82,7 @@ public:
    * internal storage needed for function invocation.
    */
   template <typename Function, typename Allocator>
-  void post(ASIO_MOVE_ARG(Function) f, const Allocator& a);
+  void post(ASIO_MOVE_ARG(Function) f, const Allocator& a) const;
 
   /// Request the system executor to invoke the given function object.
   /**
@@ -99,7 +98,7 @@ public:
    * internal storage needed for function invocation.
    */
   template <typename Function, typename Allocator>
-  void defer(ASIO_MOVE_ARG(Function) f, const Allocator& a);
+  void defer(ASIO_MOVE_ARG(Function) f, const Allocator& a) const;
 
   /// Compare two executors for equality.
   /**
@@ -142,10 +141,6 @@ private:
   };
 };
 
-#if !defined(GENERATING_DOCUMENTATION)
-template <> struct is_executor<system_executor> : true_type {};
-#endif // !defined(GENERATING_DOCUMENTATION)
-
 } // namespace asio
 
 #include "asio/detail/pop_options.hpp"
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/system_timer.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/system_timer.hpp
index 143056e..d28e92c 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/system_timer.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/system_timer.hpp
@@ -2,7 +2,7 @@
 // system_timer.hpp
 // ~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,21 +17,13 @@
 
 #include "asio/detail/config.hpp"
 
-#if defined(ASIO_HAS_STD_CHRONO) \
-  || defined(ASIO_HAS_BOOST_CHRONO) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#if defined(ASIO_HAS_STD_CHRONO)
-# include <chrono>
-#elif defined(ASIO_HAS_BOOST_CHRONO)
-# include <boost/chrono/system_clocks.hpp>
-#endif
+#if defined(ASIO_HAS_CHRONO) || defined(GENERATING_DOCUMENTATION)
 
 #include "asio/basic_waitable_timer.hpp"
+#include "asio/detail/chrono.hpp"
 
 namespace asio {
 
-#if defined(GENERATING_DOCUMENTATION)
 /// Typedef for a timer based on the system clock.
 /**
  * This typedef uses the C++11 @c &lt;chrono&gt; standard library facility, if
@@ -42,16 +34,9 @@ namespace asio {
  * @endcode
  */
 typedef basic_waitable_timer<chrono::system_clock> system_timer;
-#elif defined(ASIO_HAS_STD_CHRONO)
-typedef basic_waitable_timer<std::chrono::system_clock> system_timer;
-#elif defined(ASIO_HAS_BOOST_CHRONO)
-typedef basic_waitable_timer<boost::chrono::system_clock> system_timer;
-#endif
 
 } // namespace asio
 
-#endif // defined(ASIO_HAS_STD_CHRONO) 
-       //   || defined(ASIO_HAS_BOOST_CHRONO)
-       //   || defined(GENERATING_DOCUMENTATION)
+#endif // defined(ASIO_HAS_CHRONO) || defined(GENERATING_DOCUMENTATION)
 
 #endif // ASIO_SYSTEM_TIMER_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/thread.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/thread.hpp
index 6468130..45ae392 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/thread.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/thread.hpp
@@ -2,7 +2,7 @@
 // thread.hpp
 // ~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -36,12 +36,12 @@ namespace asio {
  *
  * @par Example
  * A typical use of asio::thread would be to launch a thread to run an
- * io_service's event processing loop:
+ * io_context's event processing loop:
  *
  * @par
- * @code asio::io_service io_service;
+ * @code asio::io_context io_context;
  * // ...
- * asio::thread t(boost::bind(&asio::io_service::run, &io_service));
+ * asio::thread t(boost::bind(&asio::io_context::run, &io_context));
  * // ...
  * t.join(); @endcode
  */
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/thread_pool.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/thread_pool.hpp
index 2a6b460..f62fc9d 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/thread_pool.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/thread_pool.hpp
@@ -2,7 +2,7 @@
 // thread_pool.hpp
 // ~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -20,7 +20,6 @@
 #include "asio/detail/scheduler.hpp"
 #include "asio/detail/thread_group.hpp"
 #include "asio/execution_context.hpp"
-#include "asio/is_executor.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -83,7 +82,7 @@ class thread_pool::executor_type
 {
 public:
   /// Obtain the underlying execution context.
-  thread_pool& context() ASIO_NOEXCEPT;
+  thread_pool& context() const ASIO_NOEXCEPT;
 
   /// Inform the thread pool that it has some outstanding work to do.
   /**
@@ -91,7 +90,7 @@ public:
    * This ensures that the thread pool's join() function will not return while
    * the work is underway.
    */
-  void on_work_started() ASIO_NOEXCEPT;
+  void on_work_started() const ASIO_NOEXCEPT;
 
   /// Inform the thread pool that some work is no longer outstanding.
   /**
@@ -99,7 +98,7 @@ public:
    * finished. Once the count of unfinished work reaches zero, the thread
    * pool's join() function is permitted to exit.
    */
-  void on_work_finished() ASIO_NOEXCEPT;
+  void on_work_finished() const ASIO_NOEXCEPT;
 
   /// Request the thread pool to invoke the given function object.
   /**
@@ -116,7 +115,7 @@ public:
    * internal storage needed for function invocation.
    */
   template <typename Function, typename Allocator>
-  void dispatch(ASIO_MOVE_ARG(Function) f, const Allocator& a);
+  void dispatch(ASIO_MOVE_ARG(Function) f, const Allocator& a) const;
 
   /// Request the thread pool to invoke the given function object.
   /**
@@ -132,7 +131,7 @@ public:
    * internal storage needed for function invocation.
    */
   template <typename Function, typename Allocator>
-  void post(ASIO_MOVE_ARG(Function) f, const Allocator& a);
+  void post(ASIO_MOVE_ARG(Function) f, const Allocator& a) const;
 
   /// Request the thread pool to invoke the given function object.
   /**
@@ -152,7 +151,7 @@ public:
    * internal storage needed for function invocation.
    */
   template <typename Function, typename Allocator>
-  void defer(ASIO_MOVE_ARG(Function) f, const Allocator& a);
+  void defer(ASIO_MOVE_ARG(Function) f, const Allocator& a) const;
 
   /// Determine whether the thread pool is running in the current thread.
   /**
@@ -191,10 +190,6 @@ private:
   thread_pool& pool_;
 };
 
-#if !defined(GENERATING_DOCUMENTATION)
-template <> struct is_executor<thread_pool::executor_type> : true_type {};
-#endif // !defined(GENERATING_DOCUMENTATION)
-
 } // namespace asio
 
 #include "asio/detail/pop_options.hpp"
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/time_traits.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/time_traits.hpp
index afdae60..c046794 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/time_traits.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/time_traits.hpp
@@ -2,7 +2,7 @@
 // time_traits.hpp
 // ~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -20,9 +20,7 @@
 #if defined(ASIO_HAS_BOOST_DATE_TIME) \
   || defined(GENERATING_DOCUMENTATION)
 
-#include "asio/detail/push_options.hpp"
 #include <boost/date_time/posix_time/posix_time_types.hpp>
-#include "asio/detail/pop_options.hpp"
 
 #include "asio/detail/push_options.hpp"
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/buffer.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/buffer.hpp
index f68ced9..257de20 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/buffer.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/buffer.hpp
@@ -2,7 +2,7 @@
 // ts/buffer.hpp
 // ~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,7 +16,6 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/buffer.hpp"
-#include "asio/streambuf.hpp"
 #include "asio/completion_condition.hpp"
 #include "asio/read.hpp"
 #include "asio/write.hpp"
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/executor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/executor.hpp
index ead54cd..d67c72e 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/executor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/executor.hpp
@@ -2,7 +2,7 @@
 // ts/executor.hpp
 // ~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -21,15 +21,15 @@
 #include "asio/execution_context.hpp"
 #include "asio/is_executor.hpp"
 #include "asio/associated_executor.hpp"
-#include "asio/wrap.hpp"
-#include "asio/executor_work.hpp"
+#include "asio/bind_executor.hpp"
+#include "asio/executor_work_guard.hpp"
 #include "asio/system_executor.hpp"
 #include "asio/executor.hpp"
 #include "asio/dispatch.hpp"
 #include "asio/post.hpp"
 #include "asio/defer.hpp"
 #include "asio/strand.hpp"
-#include "asio/package.hpp"
+#include "asio/packaged_task.hpp"
 #include "asio/use_future.hpp"
 
 #endif // ASIO_TS_EXECUTOR_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/internet.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/internet.hpp
index c0b1266..39e5b85 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/internet.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/internet.hpp
@@ -2,7 +2,7 @@
 // ts/internet.hpp
 // ~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,7 +17,11 @@
 
 #include "asio/ip/address.hpp"
 #include "asio/ip/address_v4.hpp"
+#include "asio/ip/address_v4_iterator.hpp"
+#include "asio/ip/address_v4_range.hpp"
 #include "asio/ip/address_v6.hpp"
+#include "asio/ip/address_v6_iterator.hpp"
+#include "asio/ip/address_v6_range.hpp"
 #include "asio/ip/bad_address_cast.hpp"
 #include "asio/ip/basic_endpoint.hpp"
 #include "asio/ip/basic_resolver_query.hpp"
@@ -25,6 +29,8 @@
 #include "asio/ip/basic_resolver_iterator.hpp"
 #include "asio/ip/basic_resolver.hpp"
 #include "asio/ip/host_name.hpp"
+#include "asio/ip/network_v4.hpp"
+#include "asio/ip/network_v6.hpp"
 #include "asio/ip/tcp.hpp"
 #include "asio/ip/udp.hpp"
 #include "asio/ip/v6_only.hpp"
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/io_context.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/io_context.hpp
new file mode 100644
index 0000000..fc7e8f8
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/io_context.hpp
@@ -0,0 +1,20 @@
+//
+// ts/io_context.hpp
+// ~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_TS_IO_CONTEXT_HPP
+#define ASIO_TS_IO_CONTEXT_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/io_context.hpp"
+
+#endif // ASIO_TS_IO_CONTEXT_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/io_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/io_service.hpp
deleted file mode 100644
index 5c0a44e..0000000
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/io_service.hpp
+++ /dev/null
@@ -1,20 +0,0 @@
-//
-// ts/io_service.hpp
-// ~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_TS_IO_SERVICE_HPP
-#define ASIO_TS_IO_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/io_service.hpp"
-
-#endif // ASIO_TS_IO_SERVICE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/net.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/net.hpp
new file mode 100644
index 0000000..5af4c6f
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/net.hpp
@@ -0,0 +1,26 @@
+//
+// ts/net.hpp
+// ~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_TS_NET_HPP
+#define ASIO_TS_NET_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/ts/netfwd.hpp"
+#include "asio/ts/executor.hpp"
+#include "asio/ts/io_context.hpp"
+#include "asio/ts/timer.hpp"
+#include "asio/ts/buffer.hpp"
+#include "asio/ts/socket.hpp"
+#include "asio/ts/internet.hpp"
+
+#endif // ASIO_TS_NET_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/netfwd.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/netfwd.hpp
new file mode 100644
index 0000000..5902921
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/netfwd.hpp
@@ -0,0 +1,197 @@
+//
+// ts/netfwd.hpp
+// ~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_TS_NETFWD_HPP
+#define ASIO_TS_NETFWD_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+
+#if defined(ASIO_HAS_CHRONO)
+# include "asio/detail/chrono.hpp"
+#endif // defined(ASIO_HAS_CHRONO)
+
+#if defined(ASIO_HAS_BOOST_DATE_TIME)
+# include "asio/detail/date_time_fwd.hpp"
+#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
+
+#if !defined(GENERATING_DOCUMENTATION)
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+
+class execution_context;
+
+template <typename T, typename Executor>
+class executor_binder;
+
+template <typename Executor>
+class executor_work_guard;
+
+class system_executor;
+
+class executor;
+
+template <typename Executor>
+class strand;
+
+class io_context;
+
+template <typename Clock>
+struct wait_traits;
+
+#if defined(ASIO_HAS_BOOST_DATE_TIME)
+
+template <typename Time>
+struct time_traits;
+
+#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
+template <typename Clock, typename WaitTraits>
+class waitable_timer_service;
+
+#if defined(ASIO_HAS_BOOST_DATE_TIME)
+
+template <typename TimeType, typename TimeTraits>
+class deadline_timer_service;
+
+#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
+
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
+#if !defined(ASIO_BASIC_WAITABLE_TIMER_FWD_DECL)
+#define ASIO_BASIC_WAITABLE_TIMER_FWD_DECL
+
+template <typename Clock,
+    typename WaitTraits = asio::wait_traits<Clock>
+    ASIO_SVC_TPARAM_DEF2(= waitable_timer_service<Clock, WaitTraits>)>
+class basic_waitable_timer;
+
+#endif // !defined(ASIO_BASIC_WAITABLE_TIMER_FWD_DECL)
+
+#if defined(ASIO_HAS_CHRONO)
+
+typedef basic_waitable_timer<chrono::system_clock> system_timer;
+
+typedef basic_waitable_timer<chrono::steady_clock> steady_timer;
+
+typedef basic_waitable_timer<chrono::high_resolution_clock>
+  high_resolution_timer;
+
+#endif // defined(ASIO_HAS_CHRONO)
+
+template <class Protocol ASIO_SVC_TPARAM>
+class basic_socket;
+
+template <typename Protocol ASIO_SVC_TPARAM>
+class basic_datagram_socket;
+
+template <typename Protocol ASIO_SVC_TPARAM>
+class basic_stream_socket;
+
+template <typename Protocol ASIO_SVC_TPARAM>
+class basic_socket_acceptor;
+
+#if !defined(ASIO_BASIC_SOCKET_STREAMBUF_FWD_DECL)
+#define ASIO_BASIC_SOCKET_STREAMBUF_FWD_DECL
+
+// Forward declaration with defaulted arguments.
+template <typename Protocol
+    ASIO_SVC_TPARAM_DEF1(= stream_socket_service<Protocol>),
+#if defined(ASIO_HAS_BOOST_DATE_TIME) \
+  || defined(GENERATING_DOCUMENTATION)
+    typename Clock = boost::posix_time::ptime,
+    typename WaitTraits = time_traits<Clock>
+    ASIO_SVC_TPARAM1_DEF2(= deadline_timer_service<Clock, WaitTraits>)>
+#else
+    typename Clock = chrono::steady_clock,
+    typename WaitTraits = wait_traits<Clock>
+    ASIO_SVC_TPARAM1_DEF1(= steady_timer::service_type)>
+#endif
+class basic_socket_streambuf;
+
+#endif // !defined(ASIO_BASIC_SOCKET_STREAMBUF_FWD_DECL)
+
+#if !defined(ASIO_BASIC_SOCKET_IOSTREAM_FWD_DECL)
+#define ASIO_BASIC_SOCKET_IOSTREAM_FWD_DECL
+
+// Forward declaration with defaulted arguments.
+template <typename Protocol
+    ASIO_SVC_TPARAM_DEF1(= stream_socket_service<Protocol>),
+#if defined(ASIO_HAS_BOOST_DATE_TIME) \
+  || defined(GENERATING_DOCUMENTATION)
+    typename Clock = boost::posix_time::ptime,
+    typename WaitTraits = time_traits<Clock>
+    ASIO_SVC_TPARAM1_DEF2(= deadline_timer_service<Clock, WaitTraits>)>
+#else
+    typename Clock = chrono::steady_clock,
+    typename WaitTraits = wait_traits<Clock>
+    ASIO_SVC_TPARAM1_DEF1(= steady_timer::service_type)>
+#endif
+class basic_socket_iostream;
+
+#endif // !defined(ASIO_BASIC_SOCKET_IOSTREAM_FWD_DECL)
+
+namespace ip {
+
+class address;
+
+class address_v4;
+
+class address_v6;
+
+template <typename Address>
+class basic_address_iterator;
+
+typedef basic_address_iterator<address_v4> address_v4_iterator;
+
+typedef basic_address_iterator<address_v6> address_v6_iterator;
+
+template <typename Address>
+class basic_address_range;
+
+typedef basic_address_range<address_v4> address_v4_range;
+
+typedef basic_address_range<address_v6> address_v6_range;
+
+class network_v4;
+
+class network_v6;
+
+template <typename InternetProtocol>
+class basic_endpoint;
+
+template <typename InternetProtocol>
+class basic_resolver_entry;
+
+template <typename InternetProtocol>
+class basic_resolver_results;
+
+template <typename InternetProtocol ASIO_SVC_TPARAM>
+class basic_resolver;
+
+class tcp;
+
+class udp;
+
+} // namespace ip
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#endif // !defined(GENERATING_DOCUMENTATION)
+
+#endif // ASIO_TS_NETFWD_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/networking.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/networking.hpp
deleted file mode 100644
index a9cd88d..0000000
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/networking.hpp
+++ /dev/null
@@ -1,25 +0,0 @@
-//
-// ts/networking.hpp
-// ~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_TS_NETWORKING_HPP
-#define ASIO_TS_NETWORKING_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/ts/executor.hpp"
-#include "asio/ts/io_service.hpp"
-#include "asio/ts/timer.hpp"
-#include "asio/ts/buffer.hpp"
-#include "asio/ts/socket.hpp"
-#include "asio/ts/internet.hpp"
-
-#endif // ASIO_TS_NETWORKING_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/socket.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/socket.hpp
index bb798dd..ecc4a2e 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/socket.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/socket.hpp
@@ -2,7 +2,7 @@
 // ts/socket.hpp
 // ~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/thread_pool.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/thread_pool.hpp
deleted file mode 100644
index 6d2839d..0000000
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/thread_pool.hpp
+++ /dev/null
@@ -1,20 +0,0 @@
-//
-// ts/thread_pool.hpp
-// ~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_TS_THREAD_POOL_HPP
-#define ASIO_TS_THREAD_POOL_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/thread_pool.hpp"
-
-#endif // ASIO_TS_THREAD_POOL_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/timer.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/timer.hpp
index f2d4026..a47d656 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/timer.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/ts/timer.hpp
@@ -2,7 +2,7 @@
 // ts/timer.hpp
 // ~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/unyield.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/unyield.hpp
index 50ff8cf..ccbb043 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/unyield.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/unyield.hpp
@@ -2,7 +2,7 @@
 // unyield.hpp
 // ~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/use_future.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/use_future.hpp
index 1428bcc..2a0e24f 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/use_future.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/use_future.hpp
@@ -2,7 +2,7 @@
 // use_future.hpp
 // ~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,11 +16,25 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
+
+#if defined(ASIO_HAS_STD_FUTURE) \
+  || defined(GENERATING_DOCUMENTATION)
+
 #include <memory>
+#include "asio/detail/type_traits.hpp"
 
 #include "asio/detail/push_options.hpp"
 
 namespace asio {
+namespace detail {
+
+template <typename Function, typename Allocator>
+class packaged_token;
+
+template <typename Function, typename Allocator, typename Result>
+class packaged_handler;
+
+} // namespace detail
 
 /// Class used to specify that an asynchronous operation should return a future.
 /**
@@ -56,12 +70,21 @@ public:
   {
   }
 
-  /// Specify an alternate allocator.
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use rebind().) Specify an alternate allocator.
   template <typename OtherAllocator>
   use_future_t<OtherAllocator> operator[](const OtherAllocator& allocator) const
   {
     return use_future_t<OtherAllocator>(allocator);
   }
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// Specify an alternate allocator.
+  template <typename OtherAllocator>
+  use_future_t<OtherAllocator> rebind(const OtherAllocator& allocator) const
+  {
+    return use_future_t<OtherAllocator>(allocator);
+  }
 
   /// Obtain allocator.
   allocator_type get_allocator() const
@@ -69,6 +92,31 @@ public:
     return allocator_;
   }
 
+  /// Wrap a function object in a packaged task.
+  /**
+   * The @c package function is used to adapt a function object as a packaged
+   * task. When this adapter is passed as a completion token to an asynchronous
+   * operation, the result of the function object is retuned via a std::future.
+   *
+   * @par Example
+   *
+   * @code std::future<std::size_t> fut =
+   *   my_socket.async_read_some(buffer,
+   *     use_future([](asio::error_code ec, std::size_t n)
+   *       {
+   *         return ec ? 0 : n;
+   *       }));
+   * ...
+   * std::size_t n = fut.get(); @endcode
+   */
+  template <typename Function>
+#if defined(GENERATING_DOCUMENTATION)
+  unspecified
+#else // defined(GENERATING_DOCUMENTATION)
+  detail::packaged_token<typename decay<Function>::type, Allocator>
+#endif // defined(GENERATING_DOCUMENTATION)
+  operator()(ASIO_MOVE_ARG(Function) f) const;
+
 private:
   Allocator allocator_;
 };
@@ -89,4 +137,7 @@ __declspec(selectany) use_future_t<> use_future;
 
 #include "asio/impl/use_future.hpp"
 
+#endif // defined(ASIO_HAS_STD_FUTURE)
+       //   || defined(GENERATING_DOCUMENTATION)
+
 #endif // ASIO_USE_FUTURE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/uses_executor.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/uses_executor.hpp
index 1706fe9..53b7272 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/uses_executor.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/uses_executor.hpp
@@ -2,7 +2,7 @@
 // uses_executor.hpp
 // ~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/version.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/version.hpp
index 9def83c..40b4e9a 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/version.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/version.hpp
@@ -2,7 +2,7 @@
 // version.hpp
 // ~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/wait_traits.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/wait_traits.hpp
index 86814e6..0cc6098 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/wait_traits.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/wait_traits.hpp
@@ -2,7 +2,7 @@
 // wait_traits.hpp
 // ~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -41,10 +41,10 @@ struct wait_traits
       const typename Clock::time_point& t)
   {
     typename Clock::time_point now = Clock::now();
-    if (now + Clock::duration::max() < t)
-      return Clock::duration::max();
-    if (now + Clock::duration::min() > t)
-      return Clock::duration::min();
+    if (now + (Clock::duration::max)() < t)
+      return (Clock::duration::max)();
+    if (now + (Clock::duration::min)() > t)
+      return (Clock::duration::min)();
     return t - now;
   }
 };
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/waitable_timer_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/waitable_timer_service.hpp
index 828bbfe..bcb228d 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/waitable_timer_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/waitable_timer_service.hpp
@@ -2,7 +2,7 @@
 // waitable_timer_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,11 +16,14 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #include <cstddef>
 #include "asio/async_result.hpp"
 #include "asio/detail/chrono_time_traits.hpp"
 #include "asio/detail/deadline_timer_service.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 #include "asio/wait_traits.hpp"
 
 #include "asio/detail/push_options.hpp"
@@ -32,7 +35,7 @@ template <typename Clock,
     typename WaitTraits = asio::wait_traits<Clock> >
 class waitable_timer_service
 #if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
+  : public asio::io_context::service
 #else
   : public asio::detail::service_base<
       waitable_timer_service<Clock, WaitTraits> >
@@ -41,7 +44,7 @@ class waitable_timer_service
 public:
 #if defined(GENERATING_DOCUMENTATION)
   /// The unique service identifier.
-  static asio::io_service::id id;
+  static asio::io_context::id id;
 #endif
 
   /// The clock type.
@@ -69,11 +72,11 @@ public:
   typedef typename service_impl_type::implementation_type implementation_type;
 #endif
 
-  /// Construct a new timer service for the specified io_service.
-  explicit waitable_timer_service(asio::io_service& io_service)
+  /// Construct a new timer service for the specified io_context.
+  explicit waitable_timer_service(asio::io_context& io_context)
     : asio::detail::service_base<
-        waitable_timer_service<Clock, WaitTraits> >(io_service),
-      service_impl_(io_service)
+        waitable_timer_service<Clock, WaitTraits> >(io_context),
+      service_impl_(io_context)
   {
   }
 
@@ -182,16 +185,16 @@ public:
     async_completion<WaitHandler,
       void (asio::error_code)> init(handler);
 
-    service_impl_.async_wait(impl, init.handler);
+    service_impl_.async_wait(impl, init.completion_handler);
 
     return init.result.get();
   }
 
 private:
   // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
+  void shutdown()
   {
-    service_impl_.shutdown_service();
+    service_impl_.shutdown();
   }
 
   // The platform-specific implementation.
@@ -202,4 +205,6 @@ private:
 
 #include "asio/detail/pop_options.hpp"
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_WAITABLE_TIMER_SERVICE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/basic_handle.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/basic_handle.hpp
index 2398e75..3b1ce2c 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/basic_handle.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/basic_handle.hpp
@@ -2,7 +2,7 @@
 // windows/basic_handle.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,6 +17,8 @@
 
 #include "asio/detail/config.hpp"
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #if defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE) \
   || defined(ASIO_HAS_WINDOWS_STREAM_HANDLE) \
   || defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE) \
@@ -55,11 +57,11 @@ public:
   /**
    * This constructor creates a handle without opening it.
    *
-   * @param io_service The io_service object that the handle will use to
+   * @param io_context The io_context object that the handle will use to
    * dispatch handlers for any asynchronous operations performed on the handle.
    */
-  explicit basic_handle(asio::io_service& io_service)
-    : basic_io_object<HandleService>(io_service)
+  explicit basic_handle(asio::io_context& io_context)
+    : basic_io_object<HandleService>(io_context)
   {
   }
 
@@ -67,16 +69,16 @@ public:
   /**
    * This constructor creates a handle object to hold an existing native handle.
    *
-   * @param io_service The io_service object that the handle will use to
+   * @param io_context The io_context object that the handle will use to
    * dispatch handlers for any asynchronous operations performed on the handle.
    *
    * @param handle A native handle.
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_handle(asio::io_service& io_service,
+  basic_handle(asio::io_context& io_context,
       const native_handle_type& handle)
-    : basic_io_object<HandleService>(io_service)
+    : basic_io_object<HandleService>(io_context)
   {
     asio::error_code ec;
     this->get_service().assign(this->get_implementation(), handle, ec);
@@ -91,7 +93,7 @@ public:
    * @param other The other basic_handle object from which the move will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_handle(io_service&) constructor.
+   * constructed using the @c basic_handle(io_context&) constructor.
    */
   basic_handle(basic_handle&& other)
     : basic_io_object<HandleService>(
@@ -106,7 +108,7 @@ public:
    * @param other The other basic_handle object from which the move will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_handle(io_service&) constructor.
+   * constructed using the @c basic_handle(io_context&) constructor.
    */
   basic_handle& operator=(basic_handle&& other)
   {
@@ -167,10 +169,11 @@ public:
    *
    * @param ec Set to indicate what error occurred, if any.
    */
-  asio::error_code assign(const native_handle_type& handle,
+  ASIO_SYNC_OP_VOID assign(const native_handle_type& handle,
       asio::error_code& ec)
   {
-    return this->get_service().assign(this->get_implementation(), handle, ec);
+    this->get_service().assign(this->get_implementation(), handle, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Determine whether the handle is open.
@@ -202,9 +205,10 @@ public:
    *
    * @param ec Set to indicate what error occurred, if any.
    */
-  asio::error_code close(asio::error_code& ec)
+  ASIO_SYNC_OP_VOID close(asio::error_code& ec)
   {
-    return this->get_service().close(this->get_implementation(), ec);
+    this->get_service().close(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the native handle representation.
@@ -241,9 +245,10 @@ public:
    *
    * @param ec Set to indicate what error occurred, if any.
    */
-  asio::error_code cancel(asio::error_code& ec)
+  ASIO_SYNC_OP_VOID cancel(asio::error_code& ec)
   {
-    return this->get_service().cancel(this->get_implementation(), ec);
+    this->get_service().cancel(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
 protected:
@@ -263,4 +268,6 @@ protected:
        //   || defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE)
        //   || defined(GENERATING_DOCUMENTATION)
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_WINDOWS_BASIC_HANDLE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/basic_object_handle.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/basic_object_handle.hpp
index 314badc..d134dbf 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/basic_object_handle.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/basic_object_handle.hpp
@@ -2,7 +2,7 @@
 // windows/basic_object_handle.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2011 Boris Schaeling (boris@highscore.de)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -18,6 +18,8 @@
 
 #include "asio/detail/config.hpp"
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #if defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE) \
   || defined(GENERATING_DOCUMENTATION)
 
@@ -52,11 +54,11 @@ public:
   /**
    * This constructor creates an object handle without opening it.
    *
-   * @param io_service The io_service object that the object handle will use to
+   * @param io_context The io_context object that the object handle will use to
    * dispatch handlers for any asynchronous operations performed on the handle.
    */
-  explicit basic_object_handle(asio::io_service& io_service)
-    : basic_handle<ObjectHandleService>(io_service)
+  explicit basic_object_handle(asio::io_context& io_context)
+    : basic_handle<ObjectHandleService>(io_context)
   {
   }
 
@@ -65,16 +67,16 @@ public:
    * This constructor creates an object handle object to hold an existing native
    * handle.
    *
-   * @param io_service The io_service object that the object handle will use to
+   * @param io_context The io_context object that the object handle will use to
    * dispatch handlers for any asynchronous operations performed on the handle.
    *
    * @param native_handle The new underlying handle implementation.
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_object_handle(asio::io_service& io_service,
+  basic_object_handle(asio::io_context& io_context,
       const native_handle_type& native_handle)
-    : basic_handle<ObjectHandleService>(io_service, native_handle)
+    : basic_handle<ObjectHandleService>(io_context, native_handle)
   {
   }
 
@@ -87,7 +89,7 @@ public:
    * occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_object_handle(io_service&) constructor.
+   * constructed using the @c basic_object_handle(io_context&) constructor.
    */
   basic_object_handle(basic_object_handle&& other)
     : basic_handle<ObjectHandleService>(
@@ -103,7 +105,7 @@ public:
    * occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_object_handle(io_service&) constructor.
+   * constructed using the @c basic_object_handle(io_context&) constructor.
    */
   basic_object_handle& operator=(basic_object_handle&& other)
   {
@@ -155,7 +157,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    */
   template <typename WaitHandler>
   ASIO_INITFN_RESULT_TYPE(WaitHandler,
@@ -175,4 +177,6 @@ public:
 #endif // defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE)
        //   || defined(GENERATING_DOCUMENTATION)
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_WINDOWS_BASIC_OBJECT_HANDLE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/basic_random_access_handle.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/basic_random_access_handle.hpp
index 0da5ec22..4e9ebe5 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/basic_random_access_handle.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/basic_random_access_handle.hpp
@@ -2,7 +2,7 @@
 // windows/basic_random_access_handle.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,6 +17,8 @@
 
 #include "asio/detail/config.hpp"
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #if defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE) \
   || defined(GENERATING_DOCUMENTATION)
 
@@ -55,12 +57,12 @@ public:
    * This constructor creates a random-access handle without opening it. The
    * handle needs to be opened before data can be written to or read from it.
    *
-   * @param io_service The io_service object that the random-access handle will
+   * @param io_context The io_context object that the random-access handle will
    * use to dispatch handlers for any asynchronous operations performed on the
    * handle.
    */
-  explicit basic_random_access_handle(asio::io_service& io_service)
-    : basic_handle<RandomAccessHandleService>(io_service)
+  explicit basic_random_access_handle(asio::io_context& io_context)
+    : basic_handle<RandomAccessHandleService>(io_context)
   {
   }
 
@@ -69,7 +71,7 @@ public:
    * This constructor creates a random-access handle object to hold an existing
    * native handle.
    *
-   * @param io_service The io_service object that the random-access handle will
+   * @param io_context The io_context object that the random-access handle will
    * use to dispatch handlers for any asynchronous operations performed on the
    * handle.
    *
@@ -77,9 +79,9 @@ public:
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_random_access_handle(asio::io_service& io_service,
+  basic_random_access_handle(asio::io_context& io_context,
       const native_handle_type& handle)
-    : basic_handle<RandomAccessHandleService>(io_service, handle)
+    : basic_handle<RandomAccessHandleService>(io_context, handle)
   {
   }
 
@@ -92,7 +94,7 @@ public:
    * move will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_random_access_handle(io_service&)
+   * constructed using the @c basic_random_access_handle(io_context&)
    * constructor.
    */
   basic_random_access_handle(basic_random_access_handle&& other)
@@ -110,7 +112,7 @@ public:
    * move will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_random_access_handle(io_service&)
+   * constructed using the @c basic_random_access_handle(io_context&)
    * constructor.
    */
   basic_random_access_handle& operator=(basic_random_access_handle&& other)
@@ -209,7 +211,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The write operation may not transmit all of the data to the peer.
    * Consider using the @ref async_write_at function if you need to ensure that
@@ -329,7 +331,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The read operation may not read all of the requested number of bytes.
    * Consider using the @ref async_read_at function if you need to ensure that
@@ -369,4 +371,6 @@ public:
 #endif // defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE)
        //   || defined(GENERATING_DOCUMENTATION)
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_WINDOWS_BASIC_RANDOM_ACCESS_HANDLE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/basic_stream_handle.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/basic_stream_handle.hpp
index 7927b55..c0a11fc 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/basic_stream_handle.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/basic_stream_handle.hpp
@@ -2,7 +2,7 @@
 // windows/basic_stream_handle.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,6 +17,8 @@
 
 #include "asio/detail/config.hpp"
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #if defined(ASIO_HAS_WINDOWS_STREAM_HANDLE) \
   || defined(GENERATING_DOCUMENTATION)
 
@@ -58,11 +60,11 @@ public:
    * needs to be opened and then connected or accepted before data can be sent
    * or received on it.
    *
-   * @param io_service The io_service object that the stream handle will use to
+   * @param io_context The io_context object that the stream handle will use to
    * dispatch handlers for any asynchronous operations performed on the handle.
    */
-  explicit basic_stream_handle(asio::io_service& io_service)
-    : basic_handle<StreamHandleService>(io_service)
+  explicit basic_stream_handle(asio::io_context& io_context)
+    : basic_handle<StreamHandleService>(io_context)
   {
   }
 
@@ -71,16 +73,16 @@ public:
    * This constructor creates a stream handle object to hold an existing native
    * handle.
    *
-   * @param io_service The io_service object that the stream handle will use to
+   * @param io_context The io_context object that the stream handle will use to
    * dispatch handlers for any asynchronous operations performed on the handle.
    *
    * @param handle The new underlying handle implementation.
    *
    * @throws asio::system_error Thrown on failure.
    */
-  basic_stream_handle(asio::io_service& io_service,
+  basic_stream_handle(asio::io_context& io_context,
       const native_handle_type& handle)
-    : basic_handle<StreamHandleService>(io_service, handle)
+    : basic_handle<StreamHandleService>(io_context, handle)
   {
   }
 
@@ -93,7 +95,7 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_stream_handle(io_service&) constructor.
+   * constructed using the @c basic_stream_handle(io_context&) constructor.
    */
   basic_stream_handle(basic_stream_handle&& other)
     : basic_handle<StreamHandleService>(
@@ -110,7 +112,7 @@ public:
    * will occur.
    *
    * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_stream_handle(io_service&) constructor.
+   * constructed using the @c basic_stream_handle(io_context&) constructor.
    */
   basic_stream_handle& operator=(basic_stream_handle&& other)
   {
@@ -201,7 +203,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The write operation may not transmit all of the data to the peer.
    * Consider using the @ref async_write function if you need to ensure that all
@@ -313,7 +315,7 @@ public:
    * Regardless of whether the asynchronous operation completes immediately or
    * not, the handler will not be invoked from within this function. Invocation
    * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
+   * asio::io_context::post().
    *
    * @note The read operation may not read all of the requested number of bytes.
    * Consider using the @ref async_read function if you need to ensure that the
@@ -352,4 +354,6 @@ public:
 #endif // defined(ASIO_HAS_WINDOWS_STREAM_HANDLE)
        //   || defined(GENERATING_DOCUMENTATION)
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_WINDOWS_BASIC_STREAM_HANDLE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/object_handle.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/object_handle.hpp
index f4162e1..6b5ad59 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/object_handle.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/object_handle.hpp
@@ -2,7 +2,7 @@
 // windows/object_handle.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2011 Boris Schaeling (boris@highscore.de)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -21,17 +21,360 @@
 #if defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE) \
   || defined(GENERATING_DOCUMENTATION)
 
-#include "asio/windows/basic_object_handle.hpp"
+#include "asio/async_result.hpp"
+#include "asio/basic_io_object.hpp"
+#include "asio/detail/throw_error.hpp"
+#include "asio/detail/win_object_handle_service.hpp"
+#include "asio/error.hpp"
+#include "asio/io_context.hpp"
+
+#if defined(ASIO_HAS_MOVE)
+# include <utility>
+#endif // defined(ASIO_HAS_MOVE)
+
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+# include "asio/windows/basic_object_handle.hpp"
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
+#define ASIO_SVC_T asio::detail::win_object_handle_service
+
+#include "asio/detail/push_options.hpp"
 
 namespace asio {
 namespace windows {
 
-/// Typedef for the typical usage of an object handle.
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+// Typedef for the typical usage of an object handle.
 typedef basic_object_handle<> object_handle;
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+/// Provides object-oriented handle functionality.
+/**
+ * The windows::object_handle class provides asynchronous and blocking
+ * object-oriented handle functionality.
+ *
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Unsafe.
+ */
+class object_handle
+  : ASIO_SVC_ACCESS basic_io_object<ASIO_SVC_T>
+{
+public:
+  /// The type of the executor associated with the object.
+  typedef io_context::executor_type executor_type;
+
+  /// The native representation of a handle.
+#if defined(GENERATING_DOCUMENTATION)
+  typedef implementation_defined native_handle_type;
+#else
+  typedef ASIO_SVC_T::native_handle_type native_handle_type;
+#endif
+
+  /// An object_handle is always the lowest layer.
+  typedef object_handle lowest_layer_type;
+
+  /// Construct an object_handle without opening it.
+  /**
+   * This constructor creates an object handle without opening it.
+   *
+   * @param io_context The io_context object that the object handle will use to
+   * dispatch handlers for any asynchronous operations performed on the handle.
+   */
+  explicit object_handle(asio::io_context& io_context)
+    : basic_io_object<ASIO_SVC_T>(io_context)
+  {
+  }
+
+  /// Construct an object_handle on an existing native handle.
+  /**
+   * This constructor creates an object handle object to hold an existing native
+   * handle.
+   *
+   * @param io_context The io_context object that the object handle will use to
+   * dispatch handlers for any asynchronous operations performed on the handle.
+   *
+   * @param native_handle The new underlying handle implementation.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  object_handle(asio::io_context& io_context,
+      const native_handle_type& native_handle)
+    : basic_io_object<ASIO_SVC_T>(io_context)
+  {
+    asio::error_code ec;
+    this->get_service().assign(this->get_implementation(), native_handle, ec);
+    asio::detail::throw_error(ec, "assign");
+  }
+
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+  /// Move-construct an object_handle from another.
+  /**
+   * This constructor moves an object handle from one object to another.
+   *
+   * @param other The other object_handle object from which the move will
+   * occur.
+   *
+   * @note Following the move, the moved-from object is in the same state as if
+   * constructed using the @c object_handle(io_context&) constructor.
+   */
+  object_handle(object_handle&& other)
+    : basic_io_object<ASIO_SVC_T>(std::move(other))
+  {
+  }
+
+  /// Move-assign an object_handle from another.
+  /**
+   * This assignment operator moves an object handle from one object to another.
+   *
+   * @param other The other object_handle object from which the move will
+   * occur.
+   *
+   * @note Following the move, the moved-from object is in the same state as if
+   * constructed using the @c object_handle(io_context&) constructor.
+   */
+  object_handle& operator=(object_handle&& other)
+  {
+    basic_io_object<ASIO_SVC_T>::operator=(std::move(other));
+    return *this;
+  }
+#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_context()
+  {
+    return basic_io_object<ASIO_SVC_T>::get_io_context();
+  }
+
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_service()
+  {
+    return basic_io_object<ASIO_SVC_T>::get_io_service();
+  }
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// Get the executor associated with the object.
+  executor_type get_executor() ASIO_NOEXCEPT
+  {
+    return basic_io_object<ASIO_SVC_T>::get_executor();
+  }
+
+  /// Get a reference to the lowest layer.
+  /**
+   * This function returns a reference to the lowest layer in a stack of
+   * layers. Since an object_handle cannot contain any further layers, it simply
+   * returns a reference to itself.
+   *
+   * @return A reference to the lowest layer in the stack of layers. Ownership
+   * is not transferred to the caller.
+   */
+  lowest_layer_type& lowest_layer()
+  {
+    return *this;
+  }
+
+  /// Get a const reference to the lowest layer.
+  /**
+   * This function returns a const reference to the lowest layer in a stack of
+   * layers. Since an object_handle cannot contain any further layers, it simply
+   * returns a reference to itself.
+   *
+   * @return A const reference to the lowest layer in the stack of layers.
+   * Ownership is not transferred to the caller.
+   */
+  const lowest_layer_type& lowest_layer() const
+  {
+    return *this;
+  }
+
+  /// Assign an existing native handle to the handle.
+  /*
+   * This function opens the handle to hold an existing native handle.
+   *
+   * @param handle A native handle.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  void assign(const native_handle_type& handle)
+  {
+    asio::error_code ec;
+    this->get_service().assign(this->get_implementation(), handle, ec);
+    asio::detail::throw_error(ec, "assign");
+  }
+
+  /// Assign an existing native handle to the handle.
+  /*
+   * This function opens the handle to hold an existing native handle.
+   *
+   * @param handle A native handle.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   */
+  ASIO_SYNC_OP_VOID assign(const native_handle_type& handle,
+      asio::error_code& ec)
+  {
+    this->get_service().assign(this->get_implementation(), handle, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Determine whether the handle is open.
+  bool is_open() const
+  {
+    return this->get_service().is_open(this->get_implementation());
+  }
+
+  /// Close the handle.
+  /**
+   * This function is used to close the handle. Any asynchronous read or write
+   * operations will be cancelled immediately, and will complete with the
+   * asio::error::operation_aborted error.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  void close()
+  {
+    asio::error_code ec;
+    this->get_service().close(this->get_implementation(), ec);
+    asio::detail::throw_error(ec, "close");
+  }
+
+  /// Close the handle.
+  /**
+   * This function is used to close the handle. Any asynchronous read or write
+   * operations will be cancelled immediately, and will complete with the
+   * asio::error::operation_aborted error.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   */
+  ASIO_SYNC_OP_VOID close(asio::error_code& ec)
+  {
+    this->get_service().close(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Get the native handle representation.
+  /**
+   * This function may be used to obtain the underlying representation of the
+   * handle. This is intended to allow access to native handle functionality
+   * that is not otherwise provided.
+   */
+  native_handle_type native_handle()
+  {
+    return this->get_service().native_handle(this->get_implementation());
+  }
+
+  /// Cancel all asynchronous operations associated with the handle.
+  /**
+   * This function causes all outstanding asynchronous read or write operations
+   * to finish immediately, and the handlers for cancelled operations will be
+   * passed the asio::error::operation_aborted error.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  void cancel()
+  {
+    asio::error_code ec;
+    this->get_service().cancel(this->get_implementation(), ec);
+    asio::detail::throw_error(ec, "cancel");
+  }
+
+  /// Cancel all asynchronous operations associated with the handle.
+  /**
+   * This function causes all outstanding asynchronous read or write operations
+   * to finish immediately, and the handlers for cancelled operations will be
+   * passed the asio::error::operation_aborted error.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   */
+  ASIO_SYNC_OP_VOID cancel(asio::error_code& ec)
+  {
+    this->get_service().cancel(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Perform a blocking wait on the object handle.
+  /**
+   * This function is used to wait for the object handle to be set to the
+   * signalled state. This function blocks and does not return until the object
+   * handle has been set to the signalled state.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  void wait()
+  {
+    asio::error_code ec;
+    this->get_service().wait(this->get_implementation(), ec);
+    asio::detail::throw_error(ec, "wait");
+  }
+
+  /// Perform a blocking wait on the object handle.
+  /**
+   * This function is used to wait for the object handle to be set to the
+   * signalled state. This function blocks and does not return until the object
+   * handle has been set to the signalled state.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   */
+  void wait(asio::error_code& ec)
+  {
+    this->get_service().wait(this->get_implementation(), ec);
+  }
+
+  /// Start an asynchronous wait on the object handle.
+  /**
+   * This function is be used to initiate an asynchronous wait against the
+   * object handle. It always returns immediately.
+   *
+   * @param handler The handler to be called when the object handle is set to
+   * the signalled state. Copies will be made of the handler as required. The
+   * function signature of the handler must be:
+   * @code void handler(
+   *   const asio::error_code& error // Result of operation.
+   * ); @endcode
+   * Regardless of whether the asynchronous operation completes immediately or
+   * not, the handler will not be invoked from within this function. Invocation
+   * of the handler will be performed in a manner equivalent to using
+   * asio::io_context::post().
+   */
+  template <typename WaitHandler>
+  ASIO_INITFN_RESULT_TYPE(WaitHandler,
+      void (asio::error_code))
+  async_wait(ASIO_MOVE_ARG(WaitHandler) handler)
+  {
+    asio::async_completion<WaitHandler,
+      void (asio::error_code)> init(handler);
+
+    this->get_service().async_wait(this->get_implementation(),
+        init.completion_handler);
+
+    return init.result.get();
+  }
+};
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
 
 } // namespace windows
 } // namespace asio
 
+#include "asio/detail/pop_options.hpp"
+
+#undef ASIO_SVC_T
+
 #endif // defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE)
        //   || defined(GENERATING_DOCUMENTATION)
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/object_handle_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/object_handle_service.hpp
index 84384da..524a9f8 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/object_handle_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/object_handle_service.hpp
@@ -2,7 +2,7 @@
 // windows/object_handle_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 // Copyright (c) 2011 Boris Schaeling (boris@highscore.de)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -18,13 +18,15 @@
 
 #include "asio/detail/config.hpp"
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #if defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE) \
   || defined(GENERATING_DOCUMENTATION)
 
 #include "asio/async_result.hpp"
 #include "asio/detail/win_object_handle_service.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -34,7 +36,7 @@ namespace windows {
 /// Default service implementation for an object handle.
 class object_handle_service
 #if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
+  : public asio::io_context::service
 #else
   : public asio::detail::service_base<object_handle_service>
 #endif
@@ -42,7 +44,7 @@ class object_handle_service
 public:
 #if defined(GENERATING_DOCUMENTATION)
   /// The unique service identifier.
-  static asio::io_service::id id;
+  static asio::io_context::id id;
 #endif
 
 private:
@@ -64,10 +66,10 @@ public:
   typedef service_impl_type::native_handle_type native_handle_type;
 #endif
 
-  /// Construct a new object handle service for the specified io_service.
-  explicit object_handle_service(asio::io_service& io_service)
-    : asio::detail::service_base<object_handle_service>(io_service),
-      service_impl_(io_service)
+  /// Construct a new object handle service for the specified io_context.
+  explicit object_handle_service(asio::io_context& io_context)
+    : asio::detail::service_base<object_handle_service>(io_context),
+      service_impl_(io_context)
   {
   }
 
@@ -101,10 +103,11 @@ public:
   }
 
   /// Assign an existing native handle to an object handle.
-  asio::error_code assign(implementation_type& impl,
+  ASIO_SYNC_OP_VOID assign(implementation_type& impl,
       const native_handle_type& handle, asio::error_code& ec)
   {
-    return service_impl_.assign(impl, handle, ec);
+    service_impl_.assign(impl, handle, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Determine whether the handle is open.
@@ -114,10 +117,11 @@ public:
   }
 
   /// Close an object handle implementation.
-  asio::error_code close(implementation_type& impl,
+  ASIO_SYNC_OP_VOID close(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.close(impl, ec);
+    service_impl_.close(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the native handle implementation.
@@ -127,10 +131,11 @@ public:
   }
 
   /// Cancel all asynchronous operations associated with the handle.
-  asio::error_code cancel(implementation_type& impl,
+  ASIO_SYNC_OP_VOID cancel(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.cancel(impl, ec);
+    service_impl_.cancel(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   // Wait for a signaled state.
@@ -149,16 +154,16 @@ public:
     asio::async_completion<WaitHandler,
       void (asio::error_code)> init(handler);
 
-    service_impl_.async_wait(impl, init.handler);
+    service_impl_.async_wait(impl, init.completion_handler);
 
     return init.result.get();
   }
 
 private:
   // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
+  void shutdown()
   {
-    service_impl_.shutdown_service();
+    service_impl_.shutdown();
   }
 
   // The platform-specific implementation.
@@ -173,4 +178,6 @@ private:
 #endif // defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE)
        //   || defined(GENERATING_DOCUMENTATION)
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_WINDOWS_OBJECT_HANDLE_SERVICE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/overlapped_handle.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/overlapped_handle.hpp
new file mode 100644
index 0000000..3db0f1d
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/overlapped_handle.hpp
@@ -0,0 +1,331 @@
+//
+// windows/overlapped_handle.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef ASIO_WINDOWS_OVERLAPPED_HANDLE_HPP
+#define ASIO_WINDOWS_OVERLAPPED_HANDLE_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "asio/detail/config.hpp"
+
+#if !defined(ASIO_ENABLE_OLD_SERVICES)
+
+#if defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE) \
+  || defined(ASIO_HAS_WINDOWS_STREAM_HANDLE) \
+  || defined(GENERATING_DOCUMENTATION)
+
+#include <cstddef>
+#include "asio/async_result.hpp"
+#include "asio/basic_io_object.hpp"
+#include "asio/detail/throw_error.hpp"
+#include "asio/detail/win_iocp_handle_service.hpp"
+#include "asio/error.hpp"
+#include "asio/io_context.hpp"
+
+#if defined(ASIO_HAS_MOVE)
+# include <utility>
+#endif // defined(ASIO_HAS_MOVE)
+
+#define ASIO_SVC_T asio::detail::win_iocp_handle_service
+
+#include "asio/detail/push_options.hpp"
+
+namespace asio {
+namespace windows {
+
+/// Provides Windows handle functionality for objects that support
+/// overlapped I/O.
+/**
+ * The windows::overlapped_handle class provides the ability to wrap a Windows
+ * handle. The underlying object referred to by the handle must support
+ * overlapped I/O.
+ *
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Unsafe.
+ */
+class overlapped_handle
+  : ASIO_SVC_ACCESS basic_io_object<ASIO_SVC_T>
+{
+public:
+  /// The type of the executor associated with the object.
+  typedef io_context::executor_type executor_type;
+
+  /// The native representation of a handle.
+#if defined(GENERATING_DOCUMENTATION)
+  typedef implementation_defined native_handle_type;
+#else
+  typedef ASIO_SVC_T::native_handle_type native_handle_type;
+#endif
+
+  /// An overlapped_handle is always the lowest layer.
+  typedef overlapped_handle lowest_layer_type;
+
+  /// Construct an overlapped_handle without opening it.
+  /**
+   * This constructor creates a handle without opening it.
+   *
+   * @param io_context The io_context object that the handle will use to
+   * dispatch handlers for any asynchronous operations performed on the handle.
+   */
+  explicit overlapped_handle(asio::io_context& io_context)
+    : basic_io_object<ASIO_SVC_T>(io_context)
+  {
+  }
+
+  /// Construct an overlapped_handle on an existing native handle.
+  /**
+   * This constructor creates a handle object to hold an existing native handle.
+   *
+   * @param io_context The io_context object that the handle will use to
+   * dispatch handlers for any asynchronous operations performed on the handle.
+   *
+   * @param handle A native handle.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  overlapped_handle(asio::io_context& io_context,
+      const native_handle_type& handle)
+    : basic_io_object<ASIO_SVC_T>(io_context)
+  {
+    asio::error_code ec;
+    this->get_service().assign(this->get_implementation(), handle, ec);
+    asio::detail::throw_error(ec, "assign");
+  }
+
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+  /// Move-construct an overlapped_handle from another.
+  /**
+   * This constructor moves a handle from one object to another.
+   *
+   * @param other The other overlapped_handle object from which the move will
+   * occur.
+   *
+   * @note Following the move, the moved-from object is in the same state as if
+   * constructed using the @c overlapped_handle(io_context&) constructor.
+   */
+  overlapped_handle(overlapped_handle&& other)
+    : basic_io_object<ASIO_SVC_T>(std::move(other))
+  {
+  }
+
+  /// Move-assign an overlapped_handle from another.
+  /**
+   * This assignment operator moves a handle from one object to another.
+   *
+   * @param other The other overlapped_handle object from which the move will
+   * occur.
+   *
+   * @note Following the move, the moved-from object is in the same state as if
+   * constructed using the @c overlapped_handle(io_context&) constructor.
+   */
+  overlapped_handle& operator=(overlapped_handle&& other)
+  {
+    basic_io_object<ASIO_SVC_T>::operator=(std::move(other));
+    return *this;
+  }
+#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+
+#if !defined(ASIO_NO_DEPRECATED)
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_context()
+  {
+    return basic_io_object<ASIO_SVC_T>::get_io_context();
+  }
+
+  /// (Deprecated: Use get_executor().) Get the io_context associated with the
+  /// object.
+  /**
+   * This function may be used to obtain the io_context object that the I/O
+   * object uses to dispatch handlers for asynchronous operations.
+   *
+   * @return A reference to the io_context object that the I/O object will use
+   * to dispatch handlers. Ownership is not transferred to the caller.
+   */
+  asio::io_context& get_io_service()
+  {
+    return basic_io_object<ASIO_SVC_T>::get_io_service();
+  }
+#endif // !defined(ASIO_NO_DEPRECATED)
+
+  /// Get the executor associated with the object.
+  executor_type get_executor() ASIO_NOEXCEPT
+  {
+    return basic_io_object<ASIO_SVC_T>::get_executor();
+  }
+
+  /// Get a reference to the lowest layer.
+  /**
+   * This function returns a reference to the lowest layer in a stack of
+   * layers. Since an overlapped_handle cannot contain any further layers, it
+   * simply returns a reference to itself.
+   *
+   * @return A reference to the lowest layer in the stack of layers. Ownership
+   * is not transferred to the caller.
+   */
+  lowest_layer_type& lowest_layer()
+  {
+    return *this;
+  }
+
+  /// Get a const reference to the lowest layer.
+  /**
+   * This function returns a const reference to the lowest layer in a stack of
+   * layers. Since an overlapped_handle cannot contain any further layers, it
+   * simply returns a reference to itself.
+   *
+   * @return A const reference to the lowest layer in the stack of layers.
+   * Ownership is not transferred to the caller.
+   */
+  const lowest_layer_type& lowest_layer() const
+  {
+    return *this;
+  }
+
+  /// Assign an existing native handle to the handle.
+  /*
+   * This function opens the handle to hold an existing native handle.
+   *
+   * @param handle A native handle.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  void assign(const native_handle_type& handle)
+  {
+    asio::error_code ec;
+    this->get_service().assign(this->get_implementation(), handle, ec);
+    asio::detail::throw_error(ec, "assign");
+  }
+
+  /// Assign an existing native handle to the handle.
+  /*
+   * This function opens the handle to hold an existing native handle.
+   *
+   * @param handle A native handle.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   */
+  ASIO_SYNC_OP_VOID assign(const native_handle_type& handle,
+      asio::error_code& ec)
+  {
+    this->get_service().assign(this->get_implementation(), handle, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Determine whether the handle is open.
+  bool is_open() const
+  {
+    return this->get_service().is_open(this->get_implementation());
+  }
+
+  /// Close the handle.
+  /**
+   * This function is used to close the handle. Any asynchronous read or write
+   * operations will be cancelled immediately, and will complete with the
+   * asio::error::operation_aborted error.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  void close()
+  {
+    asio::error_code ec;
+    this->get_service().close(this->get_implementation(), ec);
+    asio::detail::throw_error(ec, "close");
+  }
+
+  /// Close the handle.
+  /**
+   * This function is used to close the handle. Any asynchronous read or write
+   * operations will be cancelled immediately, and will complete with the
+   * asio::error::operation_aborted error.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   */
+  ASIO_SYNC_OP_VOID close(asio::error_code& ec)
+  {
+    this->get_service().close(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+  /// Get the native handle representation.
+  /**
+   * This function may be used to obtain the underlying representation of the
+   * handle. This is intended to allow access to native handle functionality
+   * that is not otherwise provided.
+   */
+  native_handle_type native_handle()
+  {
+    return this->get_service().native_handle(this->get_implementation());
+  }
+
+  /// Cancel all asynchronous operations associated with the handle.
+  /**
+   * This function causes all outstanding asynchronous read or write operations
+   * to finish immediately, and the handlers for cancelled operations will be
+   * passed the asio::error::operation_aborted error.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  void cancel()
+  {
+    asio::error_code ec;
+    this->get_service().cancel(this->get_implementation(), ec);
+    asio::detail::throw_error(ec, "cancel");
+  }
+
+  /// Cancel all asynchronous operations associated with the handle.
+  /**
+   * This function causes all outstanding asynchronous read or write operations
+   * to finish immediately, and the handlers for cancelled operations will be
+   * passed the asio::error::operation_aborted error.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   */
+  ASIO_SYNC_OP_VOID cancel(asio::error_code& ec)
+  {
+    this->get_service().cancel(this->get_implementation(), ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
+  }
+
+protected:
+  /// Protected destructor to prevent deletion through this type.
+  /**
+   * This function destroys the handle, cancelling any outstanding asynchronous
+   * wait operations associated with the handle as if by calling @c cancel.
+   */
+  ~overlapped_handle()
+  {
+  }
+};
+
+} // namespace windows
+} // namespace asio
+
+#include "asio/detail/pop_options.hpp"
+
+#undef ASIO_SVC_T
+
+#endif // defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE)
+       //   || defined(ASIO_HAS_WINDOWS_STREAM_HANDLE)
+       //   || defined(GENERATING_DOCUMENTATION)
+
+#endif // !defined(ASIO_ENABLE_OLD_SERVICES)
+
+#endif // ASIO_WINDOWS_OVERLAPPED_HANDLE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/overlapped_ptr.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/overlapped_ptr.hpp
index 284b740..00f3baa 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/overlapped_ptr.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/overlapped_ptr.hpp
@@ -2,7 +2,7 @@
 // windows/overlapped_ptr.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -22,7 +22,7 @@
 
 #include "asio/detail/noncopyable.hpp"
 #include "asio/detail/win_iocp_overlapped_ptr.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -50,9 +50,9 @@ public:
 
   /// Construct an overlapped_ptr to contain the specified handler.
   template <typename Handler>
-  explicit overlapped_ptr(asio::io_service& io_service,
+  explicit overlapped_ptr(asio::io_context& io_context,
       ASIO_MOVE_ARG(Handler) handler)
-    : impl_(io_service, ASIO_MOVE_CAST(Handler)(handler))
+    : impl_(io_context, ASIO_MOVE_CAST(Handler)(handler))
   {
   }
 
@@ -70,10 +70,10 @@ public:
   /// Reset to contain the specified handler, freeing any current OVERLAPPED
   /// object.
   template <typename Handler>
-  void reset(asio::io_service& io_service,
+  void reset(asio::io_context& io_context,
       ASIO_MOVE_ARG(Handler) handler)
   {
-    impl_.reset(io_service, ASIO_MOVE_CAST(Handler)(handler));
+    impl_.reset(io_context, ASIO_MOVE_CAST(Handler)(handler));
   }
 
   /// Get the contained OVERLAPPED object.
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/random_access_handle.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/random_access_handle.hpp
index 9677723..cc3ea5c 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/random_access_handle.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/random_access_handle.hpp
@@ -2,7 +2,7 @@
 // windows/random_access_handle.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,21 +16,362 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
+#include "asio/windows/overlapped_handle.hpp"
 
 #if defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE) \
   || defined(GENERATING_DOCUMENTATION)
 
-#include "asio/windows/basic_random_access_handle.hpp"
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+# include "asio/windows/basic_random_access_handle.hpp"
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
+#include "asio/detail/push_options.hpp"
 
 namespace asio {
 namespace windows {
 
-/// Typedef for the typical usage of a random-access handle.
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+// Typedef for the typical usage of a random-access handle.
 typedef basic_random_access_handle<> random_access_handle;
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+/// Provides random-access handle functionality.
+/**
+ * The windows::random_access_handle class provides asynchronous and
+ * blocking random-access handle functionality.
+ *
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Unsafe.
+ */
+class random_access_handle
+  : public overlapped_handle
+{
+public:
+  /// Construct a random_access_handle without opening it.
+  /**
+   * This constructor creates a random-access handle without opening it. The
+   * handle needs to be opened before data can be written to or read from it.
+   *
+   * @param io_context The io_context object that the random-access handle will
+   * use to dispatch handlers for any asynchronous operations performed on the
+   * handle.
+   */
+  explicit random_access_handle(asio::io_context& io_context)
+    : overlapped_handle(io_context)
+  {
+  }
+
+  /// Construct a random_access_handle on an existing native handle.
+  /**
+   * This constructor creates a random-access handle object to hold an existing
+   * native handle.
+   *
+   * @param io_context The io_context object that the random-access handle will
+   * use to dispatch handlers for any asynchronous operations performed on the
+   * handle.
+   *
+   * @param handle The new underlying handle implementation.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  random_access_handle(asio::io_context& io_context,
+      const native_handle_type& handle)
+    : overlapped_handle(io_context, handle)
+  {
+  }
+
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+  /// Move-construct a random_access_handle from another.
+  /**
+   * This constructor moves a random-access handle from one object to another.
+   *
+   * @param other The other random_access_handle object from which the
+   * move will occur.
+   *
+   * @note Following the move, the moved-from object is in the same state as if
+   * constructed using the @c random_access_handle(io_context&)
+   * constructor.
+   */
+  random_access_handle(random_access_handle&& other)
+    : overlapped_handle(std::move(other))
+  {
+  }
+
+  /// Move-assign a random_access_handle from another.
+  /**
+   * This assignment operator moves a random-access handle from one object to
+   * another.
+   *
+   * @param other The other random_access_handle object from which the
+   * move will occur.
+   *
+   * @note Following the move, the moved-from object is in the same state as if
+   * constructed using the @c random_access_handle(io_context&)
+   * constructor.
+   */
+  random_access_handle& operator=(random_access_handle&& other)
+  {
+    overlapped_handle::operator=(std::move(other));
+    return *this;
+  }
+#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+
+  /// Write some data to the handle at the specified offset.
+  /**
+   * This function is used to write data to the random-access handle. The
+   * function call will block until one or more bytes of the data has been
+   * written successfully, or until an error occurs.
+   *
+   * @param offset The offset at which the data will be written.
+   *
+   * @param buffers One or more data buffers to be written to the handle.
+   *
+   * @returns The number of bytes written.
+   *
+   * @throws asio::system_error Thrown on failure. An error code of
+   * asio::error::eof indicates that the connection was closed by the
+   * peer.
+   *
+   * @note The write_some_at operation may not write all of the data. Consider
+   * using the @ref write_at function if you need to ensure that all data is
+   * written before the blocking operation completes.
+   *
+   * @par Example
+   * To write a single data buffer use the @ref buffer function as follows:
+   * @code
+   * handle.write_some_at(42, asio::buffer(data, size));
+   * @endcode
+   * See the @ref buffer documentation for information on writing multiple
+   * buffers in one go, and how to use it with arrays, boost::array or
+   * std::vector.
+   */
+  template <typename ConstBufferSequence>
+  std::size_t write_some_at(uint64_t offset,
+      const ConstBufferSequence& buffers)
+  {
+    asio::error_code ec;
+    std::size_t s = this->get_service().write_some_at(
+        this->get_implementation(), offset, buffers, ec);
+    asio::detail::throw_error(ec, "write_some_at");
+    return s;
+  }
+
+  /// Write some data to the handle at the specified offset.
+  /**
+   * This function is used to write data to the random-access handle. The
+   * function call will block until one or more bytes of the data has been
+   * written successfully, or until an error occurs.
+   *
+   * @param offset The offset at which the data will be written.
+   *
+   * @param buffers One or more data buffers to be written to the handle.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @returns The number of bytes written. Returns 0 if an error occurred.
+   *
+   * @note The write_some operation may not transmit all of the data to the
+   * peer. Consider using the @ref write_at function if you need to ensure that
+   * all data is written before the blocking operation completes.
+   */
+  template <typename ConstBufferSequence>
+  std::size_t write_some_at(uint64_t offset,
+      const ConstBufferSequence& buffers, asio::error_code& ec)
+  {
+    return this->get_service().write_some_at(
+        this->get_implementation(), offset, buffers, ec);
+  }
+
+  /// Start an asynchronous write at the specified offset.
+  /**
+   * This function is used to asynchronously write data to the random-access
+   * handle. The function call always returns immediately.
+   *
+   * @param offset The offset at which the data will be written.
+   *
+   * @param buffers One or more data buffers to be written to the handle.
+   * Although the buffers object may be copied as necessary, ownership of the
+   * underlying memory blocks is retained by the caller, which must guarantee
+   * that they remain valid until the handler is called.
+   *
+   * @param handler The handler to be called when the write operation completes.
+   * Copies will be made of the handler as required. The function signature of
+   * the handler must be:
+   * @code void handler(
+   *   const asio::error_code& error, // Result of operation.
+   *   std::size_t bytes_transferred           // Number of bytes written.
+   * ); @endcode
+   * Regardless of whether the asynchronous operation completes immediately or
+   * not, the handler will not be invoked from within this function. Invocation
+   * of the handler will be performed in a manner equivalent to using
+   * asio::io_context::post().
+   *
+   * @note The write operation may not transmit all of the data to the peer.
+   * Consider using the @ref async_write_at function if you need to ensure that
+   * all data is written before the asynchronous operation completes.
+   *
+   * @par Example
+   * To write a single data buffer use the @ref buffer function as follows:
+   * @code
+   * handle.async_write_some_at(42, asio::buffer(data, size), handler);
+   * @endcode
+   * See the @ref buffer documentation for information on writing multiple
+   * buffers in one go, and how to use it with arrays, boost::array or
+   * std::vector.
+   */
+  template <typename ConstBufferSequence, typename WriteHandler>
+  ASIO_INITFN_RESULT_TYPE(WriteHandler,
+      void (asio::error_code, std::size_t))
+  async_write_some_at(uint64_t offset,
+      const ConstBufferSequence& buffers,
+      ASIO_MOVE_ARG(WriteHandler) handler)
+  {
+    // If you get an error on the following line it means that your handler does
+    // not meet the documented type requirements for a WriteHandler.
+    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
+
+    asio::async_completion<WriteHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_write_some_at(this->get_implementation(),
+        offset, buffers, init.completion_handler);
+
+    return init.result.get();
+  }
+
+  /// Read some data from the handle at the specified offset.
+  /**
+   * This function is used to read data from the random-access handle. The
+   * function call will block until one or more bytes of data has been read
+   * successfully, or until an error occurs.
+   *
+   * @param offset The offset at which the data will be read.
+   *
+   * @param buffers One or more buffers into which the data will be read.
+   *
+   * @returns The number of bytes read.
+   *
+   * @throws asio::system_error Thrown on failure. An error code of
+   * asio::error::eof indicates that the connection was closed by the
+   * peer.
+   *
+   * @note The read_some operation may not read all of the requested number of
+   * bytes. Consider using the @ref read_at function if you need to ensure that
+   * the requested amount of data is read before the blocking operation
+   * completes.
+   *
+   * @par Example
+   * To read into a single data buffer use the @ref buffer function as follows:
+   * @code
+   * handle.read_some_at(42, asio::buffer(data, size));
+   * @endcode
+   * See the @ref buffer documentation for information on reading into multiple
+   * buffers in one go, and how to use it with arrays, boost::array or
+   * std::vector.
+   */
+  template <typename MutableBufferSequence>
+  std::size_t read_some_at(uint64_t offset,
+      const MutableBufferSequence& buffers)
+  {
+    asio::error_code ec;
+    std::size_t s = this->get_service().read_some_at(
+        this->get_implementation(), offset, buffers, ec);
+    asio::detail::throw_error(ec, "read_some_at");
+    return s;
+  }
+
+  /// Read some data from the handle at the specified offset.
+  /**
+   * This function is used to read data from the random-access handle. The
+   * function call will block until one or more bytes of data has been read
+   * successfully, or until an error occurs.
+   *
+   * @param offset The offset at which the data will be read.
+   *
+   * @param buffers One or more buffers into which the data will be read.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @returns The number of bytes read. Returns 0 if an error occurred.
+   *
+   * @note The read_some operation may not read all of the requested number of
+   * bytes. Consider using the @ref read_at function if you need to ensure that
+   * the requested amount of data is read before the blocking operation
+   * completes.
+   */
+  template <typename MutableBufferSequence>
+  std::size_t read_some_at(uint64_t offset,
+      const MutableBufferSequence& buffers, asio::error_code& ec)
+  {
+    return this->get_service().read_some_at(
+        this->get_implementation(), offset, buffers, ec);
+  }
+
+  /// Start an asynchronous read at the specified offset.
+  /**
+   * This function is used to asynchronously read data from the random-access
+   * handle. The function call always returns immediately.
+   *
+   * @param offset The offset at which the data will be read.
+   *
+   * @param buffers One or more buffers into which the data will be read.
+   * Although the buffers object may be copied as necessary, ownership of the
+   * underlying memory blocks is retained by the caller, which must guarantee
+   * that they remain valid until the handler is called.
+   *
+   * @param handler The handler to be called when the read operation completes.
+   * Copies will be made of the handler as required. The function signature of
+   * the handler must be:
+   * @code void handler(
+   *   const asio::error_code& error, // Result of operation.
+   *   std::size_t bytes_transferred           // Number of bytes read.
+   * ); @endcode
+   * Regardless of whether the asynchronous operation completes immediately or
+   * not, the handler will not be invoked from within this function. Invocation
+   * of the handler will be performed in a manner equivalent to using
+   * asio::io_context::post().
+   *
+   * @note The read operation may not read all of the requested number of bytes.
+   * Consider using the @ref async_read_at function if you need to ensure that
+   * the requested amount of data is read before the asynchronous operation
+   * completes.
+   *
+   * @par Example
+   * To read into a single data buffer use the @ref buffer function as follows:
+   * @code
+   * handle.async_read_some_at(42, asio::buffer(data, size), handler);
+   * @endcode
+   * See the @ref buffer documentation for information on reading into multiple
+   * buffers in one go, and how to use it with arrays, boost::array or
+   * std::vector.
+   */
+  template <typename MutableBufferSequence, typename ReadHandler>
+  ASIO_INITFN_RESULT_TYPE(ReadHandler,
+      void (asio::error_code, std::size_t))
+  async_read_some_at(uint64_t offset,
+      const MutableBufferSequence& buffers,
+      ASIO_MOVE_ARG(ReadHandler) handler)
+  {
+    // If you get an error on the following line it means that your handler does
+    // not meet the documented type requirements for a ReadHandler.
+    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
+
+    asio::async_completion<ReadHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_read_some_at(this->get_implementation(),
+        offset, buffers, init.completion_handler);
+
+    return init.result.get();
+  }
+};
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
 
 } // namespace windows
 } // namespace asio
 
+#include "asio/detail/pop_options.hpp"
+
 #endif // defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE)
        //   || defined(GENERATING_DOCUMENTATION)
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/random_access_handle_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/random_access_handle_service.hpp
index beff1dd..b3df24a 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/random_access_handle_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/random_access_handle_service.hpp
@@ -2,7 +2,7 @@
 // windows/random_access_handle_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,6 +17,8 @@
 
 #include "asio/detail/config.hpp"
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #if defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE) \
   || defined(GENERATING_DOCUMENTATION)
 
@@ -25,7 +27,7 @@
 #include "asio/detail/cstdint.hpp"
 #include "asio/detail/win_iocp_handle_service.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -35,7 +37,7 @@ namespace windows {
 /// Default service implementation for a random-access handle.
 class random_access_handle_service
 #if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
+  : public asio::io_context::service
 #else
   : public asio::detail::service_base<random_access_handle_service>
 #endif
@@ -43,7 +45,7 @@ class random_access_handle_service
 public:
 #if defined(GENERATING_DOCUMENTATION)
   /// The unique service identifier.
-  static asio::io_service::id id;
+  static asio::io_context::id id;
 #endif
 
 private:
@@ -65,11 +67,11 @@ public:
   typedef service_impl_type::native_handle_type native_handle_type;
 #endif
 
-  /// Construct a new random-access handle service for the specified io_service.
-  explicit random_access_handle_service(asio::io_service& io_service)
+  /// Construct a new random-access handle service for the specified io_context.
+  explicit random_access_handle_service(asio::io_context& io_context)
     : asio::detail::service_base<
-        random_access_handle_service>(io_service),
-      service_impl_(io_service)
+        random_access_handle_service>(io_context),
+      service_impl_(io_context)
   {
   }
 
@@ -103,10 +105,11 @@ public:
   }
 
   /// Assign an existing native handle to a random-access handle.
-  asio::error_code assign(implementation_type& impl,
+  ASIO_SYNC_OP_VOID assign(implementation_type& impl,
       const native_handle_type& handle, asio::error_code& ec)
   {
-    return service_impl_.assign(impl, handle, ec);
+    service_impl_.assign(impl, handle, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Determine whether the handle is open.
@@ -116,10 +119,11 @@ public:
   }
 
   /// Close a random-access handle implementation.
-  asio::error_code close(implementation_type& impl,
+  ASIO_SYNC_OP_VOID close(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.close(impl, ec);
+    service_impl_.close(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the native handle implementation.
@@ -129,10 +133,11 @@ public:
   }
 
   /// Cancel all asynchronous operations associated with the handle.
-  asio::error_code cancel(implementation_type& impl,
+  ASIO_SYNC_OP_VOID cancel(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.cancel(impl, ec);
+    service_impl_.cancel(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Write the given data at the specified offset.
@@ -154,7 +159,8 @@ public:
     asio::async_completion<WriteHandler,
       void (asio::error_code, std::size_t)> init(handler);
 
-    service_impl_.async_write_some_at(impl, offset, buffers, init.handler);
+    service_impl_.async_write_some_at(impl,
+        offset, buffers, init.completion_handler);
 
     return init.result.get();
   }
@@ -178,16 +184,17 @@ public:
     asio::async_completion<ReadHandler,
       void (asio::error_code, std::size_t)> init(handler);
 
-    service_impl_.async_read_some_at(impl, offset, buffers, init.handler);
+    service_impl_.async_read_some_at(impl,
+        offset, buffers, init.completion_handler);
 
     return init.result.get();
   }
 
 private:
   // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
+  void shutdown()
   {
-    service_impl_.shutdown_service();
+    service_impl_.shutdown();
   }
 
   // The platform-specific implementation.
@@ -202,4 +209,6 @@ private:
 #endif // defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE)
        //   || defined(GENERATING_DOCUMENTATION)
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_WINDOWS_RANDOM_ACCESS_HANDLE_SERVICE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/stream_handle.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/stream_handle.hpp
index b35dd75..583637a 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/stream_handle.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/stream_handle.hpp
@@ -2,7 +2,7 @@
 // windows/stream_handle.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -16,21 +16,346 @@
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include "asio/detail/config.hpp"
+#include "asio/windows/overlapped_handle.hpp"
 
 #if defined(ASIO_HAS_WINDOWS_STREAM_HANDLE) \
   || defined(GENERATING_DOCUMENTATION)
 
-#include "asio/windows/basic_stream_handle.hpp"
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+# include "asio/windows/basic_stream_handle.hpp"
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
+#include "asio/detail/push_options.hpp"
 
 namespace asio {
 namespace windows {
 
-/// Typedef for the typical usage of a stream-oriented handle.
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+// Typedef for the typical usage of a stream-oriented handle.
 typedef basic_stream_handle<> stream_handle;
+#else // defined(ASIO_ENABLE_OLD_SERVICES)
+/// Provides stream-oriented handle functionality.
+/**
+ * The windows::stream_handle class provides asynchronous and blocking
+ * stream-oriented handle functionality.
+ *
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Unsafe.
+ *
+ * @par Concepts:
+ * AsyncReadStream, AsyncWriteStream, Stream, SyncReadStream, SyncWriteStream.
+ */
+class stream_handle
+  : public overlapped_handle
+{
+public:
+  /// Construct a stream_handle without opening it.
+  /**
+   * This constructor creates a stream handle without opening it. The handle
+   * needs to be opened and then connected or accepted before data can be sent
+   * or received on it.
+   *
+   * @param io_context The io_context object that the stream handle will use to
+   * dispatch handlers for any asynchronous operations performed on the handle.
+   */
+  explicit stream_handle(asio::io_context& io_context)
+    : overlapped_handle(io_context)
+  {
+  }
+
+  /// Construct a stream_handle on an existing native handle.
+  /**
+   * This constructor creates a stream handle object to hold an existing native
+   * handle.
+   *
+   * @param io_context The io_context object that the stream handle will use to
+   * dispatch handlers for any asynchronous operations performed on the handle.
+   *
+   * @param handle The new underlying handle implementation.
+   *
+   * @throws asio::system_error Thrown on failure.
+   */
+  stream_handle(asio::io_context& io_context,
+      const native_handle_type& handle)
+    : overlapped_handle(io_context, handle)
+  {
+  }
+
+#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+  /// Move-construct a stream_handle from another.
+  /**
+   * This constructor moves a stream handle from one object to another.
+   *
+   * @param other The other stream_handle object from which the move
+   * will occur.
+   *
+   * @note Following the move, the moved-from object is in the same state as if
+   * constructed using the @c stream_handle(io_context&) constructor.
+   */
+  stream_handle(stream_handle&& other)
+    : overlapped_handle(std::move(other))
+  {
+  }
+
+  /// Move-assign a stream_handle from another.
+  /**
+   * This assignment operator moves a stream handle from one object to
+   * another.
+   *
+   * @param other The other stream_handle object from which the move
+   * will occur.
+   *
+   * @note Following the move, the moved-from object is in the same state as if
+   * constructed using the @c stream_handle(io_context&) constructor.
+   */
+  stream_handle& operator=(stream_handle&& other)
+  {
+    overlapped_handle::operator=(std::move(other));
+    return *this;
+  }
+#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
+
+  /// Write some data to the handle.
+  /**
+   * This function is used to write data to the stream handle. The function call
+   * will block until one or more bytes of the data has been written
+   * successfully, or until an error occurs.
+   *
+   * @param buffers One or more data buffers to be written to the handle.
+   *
+   * @returns The number of bytes written.
+   *
+   * @throws asio::system_error Thrown on failure. An error code of
+   * asio::error::eof indicates that the connection was closed by the
+   * peer.
+   *
+   * @note The write_some operation may not transmit all of the data to the
+   * peer. Consider using the @ref write function if you need to ensure that
+   * all data is written before the blocking operation completes.
+   *
+   * @par Example
+   * To write a single data buffer use the @ref buffer function as follows:
+   * @code
+   * handle.write_some(asio::buffer(data, size));
+   * @endcode
+   * See the @ref buffer documentation for information on writing multiple
+   * buffers in one go, and how to use it with arrays, boost::array or
+   * std::vector.
+   */
+  template <typename ConstBufferSequence>
+  std::size_t write_some(const ConstBufferSequence& buffers)
+  {
+    asio::error_code ec;
+    std::size_t s = this->get_service().write_some(
+        this->get_implementation(), buffers, ec);
+    asio::detail::throw_error(ec, "write_some");
+    return s;
+  }
+
+  /// Write some data to the handle.
+  /**
+   * This function is used to write data to the stream handle. The function call
+   * will block until one or more bytes of the data has been written
+   * successfully, or until an error occurs.
+   *
+   * @param buffers One or more data buffers to be written to the handle.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @returns The number of bytes written. Returns 0 if an error occurred.
+   *
+   * @note The write_some operation may not transmit all of the data to the
+   * peer. Consider using the @ref write function if you need to ensure that
+   * all data is written before the blocking operation completes.
+   */
+  template <typename ConstBufferSequence>
+  std::size_t write_some(const ConstBufferSequence& buffers,
+      asio::error_code& ec)
+  {
+    return this->get_service().write_some(
+        this->get_implementation(), buffers, ec);
+  }
+
+  /// Start an asynchronous write.
+  /**
+   * This function is used to asynchronously write data to the stream handle.
+   * The function call always returns immediately.
+   *
+   * @param buffers One or more data buffers to be written to the handle.
+   * Although the buffers object may be copied as necessary, ownership of the
+   * underlying memory blocks is retained by the caller, which must guarantee
+   * that they remain valid until the handler is called.
+   *
+   * @param handler The handler to be called when the write operation completes.
+   * Copies will be made of the handler as required. The function signature of
+   * the handler must be:
+   * @code void handler(
+   *   const asio::error_code& error, // Result of operation.
+   *   std::size_t bytes_transferred           // Number of bytes written.
+   * ); @endcode
+   * Regardless of whether the asynchronous operation completes immediately or
+   * not, the handler will not be invoked from within this function. Invocation
+   * of the handler will be performed in a manner equivalent to using
+   * asio::io_context::post().
+   *
+   * @note The write operation may not transmit all of the data to the peer.
+   * Consider using the @ref async_write function if you need to ensure that all
+   * data is written before the asynchronous operation completes.
+   *
+   * @par Example
+   * To write a single data buffer use the @ref buffer function as follows:
+   * @code
+   * handle.async_write_some(asio::buffer(data, size), handler);
+   * @endcode
+   * See the @ref buffer documentation for information on writing multiple
+   * buffers in one go, and how to use it with arrays, boost::array or
+   * std::vector.
+   */
+  template <typename ConstBufferSequence, typename WriteHandler>
+  ASIO_INITFN_RESULT_TYPE(WriteHandler,
+      void (asio::error_code, std::size_t))
+  async_write_some(const ConstBufferSequence& buffers,
+      ASIO_MOVE_ARG(WriteHandler) handler)
+  {
+    // If you get an error on the following line it means that your handler does
+    // not meet the documented type requirements for a WriteHandler.
+    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
+
+    asio::async_completion<WriteHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_write_some(
+        this->get_implementation(), buffers, init.completion_handler);
+
+    return init.result.get();
+  }
+
+  /// Read some data from the handle.
+  /**
+   * This function is used to read data from the stream handle. The function
+   * call will block until one or more bytes of data has been read successfully,
+   * or until an error occurs.
+   *
+   * @param buffers One or more buffers into which the data will be read.
+   *
+   * @returns The number of bytes read.
+   *
+   * @throws asio::system_error Thrown on failure. An error code of
+   * asio::error::eof indicates that the connection was closed by the
+   * peer.
+   *
+   * @note The read_some operation may not read all of the requested number of
+   * bytes. Consider using the @ref read function if you need to ensure that
+   * the requested amount of data is read before the blocking operation
+   * completes.
+   *
+   * @par Example
+   * To read into a single data buffer use the @ref buffer function as follows:
+   * @code
+   * handle.read_some(asio::buffer(data, size));
+   * @endcode
+   * See the @ref buffer documentation for information on reading into multiple
+   * buffers in one go, and how to use it with arrays, boost::array or
+   * std::vector.
+   */
+  template <typename MutableBufferSequence>
+  std::size_t read_some(const MutableBufferSequence& buffers)
+  {
+    asio::error_code ec;
+    std::size_t s = this->get_service().read_some(
+        this->get_implementation(), buffers, ec);
+    asio::detail::throw_error(ec, "read_some");
+    return s;
+  }
+
+  /// Read some data from the handle.
+  /**
+   * This function is used to read data from the stream handle. The function
+   * call will block until one or more bytes of data has been read successfully,
+   * or until an error occurs.
+   *
+   * @param buffers One or more buffers into which the data will be read.
+   *
+   * @param ec Set to indicate what error occurred, if any.
+   *
+   * @returns The number of bytes read. Returns 0 if an error occurred.
+   *
+   * @note The read_some operation may not read all of the requested number of
+   * bytes. Consider using the @ref read function if you need to ensure that
+   * the requested amount of data is read before the blocking operation
+   * completes.
+   */
+  template <typename MutableBufferSequence>
+  std::size_t read_some(const MutableBufferSequence& buffers,
+      asio::error_code& ec)
+  {
+    return this->get_service().read_some(
+        this->get_implementation(), buffers, ec);
+  }
+
+  /// Start an asynchronous read.
+  /**
+   * This function is used to asynchronously read data from the stream handle.
+   * The function call always returns immediately.
+   *
+   * @param buffers One or more buffers into which the data will be read.
+   * Although the buffers object may be copied as necessary, ownership of the
+   * underlying memory blocks is retained by the caller, which must guarantee
+   * that they remain valid until the handler is called.
+   *
+   * @param handler The handler to be called when the read operation completes.
+   * Copies will be made of the handler as required. The function signature of
+   * the handler must be:
+   * @code void handler(
+   *   const asio::error_code& error, // Result of operation.
+   *   std::size_t bytes_transferred           // Number of bytes read.
+   * ); @endcode
+   * Regardless of whether the asynchronous operation completes immediately or
+   * not, the handler will not be invoked from within this function. Invocation
+   * of the handler will be performed in a manner equivalent to using
+   * asio::io_context::post().
+   *
+   * @note The read operation may not read all of the requested number of bytes.
+   * Consider using the @ref async_read function if you need to ensure that the
+   * requested amount of data is read before the asynchronous operation
+   * completes.
+   *
+   * @par Example
+   * To read into a single data buffer use the @ref buffer function as follows:
+   * @code
+   * handle.async_read_some(asio::buffer(data, size), handler);
+   * @endcode
+   * See the @ref buffer documentation for information on reading into multiple
+   * buffers in one go, and how to use it with arrays, boost::array or
+   * std::vector.
+   */
+  template <typename MutableBufferSequence, typename ReadHandler>
+  ASIO_INITFN_RESULT_TYPE(ReadHandler,
+      void (asio::error_code, std::size_t))
+  async_read_some(const MutableBufferSequence& buffers,
+      ASIO_MOVE_ARG(ReadHandler) handler)
+  {
+    // If you get an error on the following line it means that your handler does
+    // not meet the documented type requirements for a ReadHandler.
+    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
+
+    asio::async_completion<ReadHandler,
+      void (asio::error_code, std::size_t)> init(handler);
+
+    this->get_service().async_read_some(
+        this->get_implementation(), buffers, init.completion_handler);
+
+    return init.result.get();
+  }
+};
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
 
 } // namespace windows
 } // namespace asio
 
+#include "asio/detail/pop_options.hpp"
+
 #endif // defined(ASIO_HAS_WINDOWS_STREAM_HANDLE)
        //   || defined(GENERATING_DOCUMENTATION)
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/stream_handle_service.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/stream_handle_service.hpp
index 560f710..5da3dd7 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/stream_handle_service.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/windows/stream_handle_service.hpp
@@ -2,7 +2,7 @@
 // windows/stream_handle_service.hpp
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -17,6 +17,8 @@
 
 #include "asio/detail/config.hpp"
 
+#if defined(ASIO_ENABLE_OLD_SERVICES)
+
 #if defined(ASIO_HAS_WINDOWS_STREAM_HANDLE) \
   || defined(GENERATING_DOCUMENTATION)
 
@@ -24,7 +26,7 @@
 #include "asio/async_result.hpp"
 #include "asio/detail/win_iocp_handle_service.hpp"
 #include "asio/error.hpp"
-#include "asio/io_service.hpp"
+#include "asio/io_context.hpp"
 
 #include "asio/detail/push_options.hpp"
 
@@ -34,7 +36,7 @@ namespace windows {
 /// Default service implementation for a stream handle.
 class stream_handle_service
 #if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
+  : public asio::io_context::service
 #else
   : public asio::detail::service_base<stream_handle_service>
 #endif
@@ -42,7 +44,7 @@ class stream_handle_service
 public:
 #if defined(GENERATING_DOCUMENTATION)
   /// The unique service identifier.
-  static asio::io_service::id id;
+  static asio::io_context::id id;
 #endif
 
 private:
@@ -64,10 +66,10 @@ public:
   typedef service_impl_type::native_handle_type native_handle_type;
 #endif
 
-  /// Construct a new stream handle service for the specified io_service.
-  explicit stream_handle_service(asio::io_service& io_service)
-    : asio::detail::service_base<stream_handle_service>(io_service),
-      service_impl_(io_service)
+  /// Construct a new stream handle service for the specified io_context.
+  explicit stream_handle_service(asio::io_context& io_context)
+    : asio::detail::service_base<stream_handle_service>(io_context),
+      service_impl_(io_context)
   {
   }
 
@@ -101,10 +103,11 @@ public:
   }
 
   /// Assign an existing native handle to a stream handle.
-  asio::error_code assign(implementation_type& impl,
+  ASIO_SYNC_OP_VOID assign(implementation_type& impl,
       const native_handle_type& handle, asio::error_code& ec)
   {
-    return service_impl_.assign(impl, handle, ec);
+    service_impl_.assign(impl, handle, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Determine whether the handle is open.
@@ -114,10 +117,11 @@ public:
   }
 
   /// Close a stream handle implementation.
-  asio::error_code close(implementation_type& impl,
+  ASIO_SYNC_OP_VOID close(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.close(impl, ec);
+    service_impl_.close(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Get the native handle implementation.
@@ -127,10 +131,11 @@ public:
   }
 
   /// Cancel all asynchronous operations associated with the handle.
-  asio::error_code cancel(implementation_type& impl,
+  ASIO_SYNC_OP_VOID cancel(implementation_type& impl,
       asio::error_code& ec)
   {
-    return service_impl_.cancel(impl, ec);
+    service_impl_.cancel(impl, ec);
+    ASIO_SYNC_OP_VOID_RETURN(ec);
   }
 
   /// Write the given data to the stream.
@@ -152,7 +157,7 @@ public:
     asio::async_completion<WriteHandler,
       void (asio::error_code, std::size_t)> init(handler);
 
-    service_impl_.async_write_some(impl, buffers, init.handler);
+    service_impl_.async_write_some(impl, buffers, init.completion_handler);
 
     return init.result.get();
   }
@@ -176,16 +181,16 @@ public:
     asio::async_completion<ReadHandler,
       void (asio::error_code, std::size_t)> init(handler);
 
-    service_impl_.async_read_some(impl, buffers, init.handler);
+    service_impl_.async_read_some(impl, buffers, init.completion_handler);
 
     return init.result.get();
   }
 
 private:
   // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
+  void shutdown()
   {
-    service_impl_.shutdown_service();
+    service_impl_.shutdown();
   }
 
   // The platform-specific implementation.
@@ -200,4 +205,6 @@ private:
 #endif // defined(ASIO_HAS_WINDOWS_STREAM_HANDLE)
        //   || defined(GENERATING_DOCUMENTATION)
 
+#endif // defined(ASIO_ENABLE_OLD_SERVICES)
+
 #endif // ASIO_WINDOWS_STREAM_HANDLE_SERVICE_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/wrap.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/wrap.hpp
deleted file mode 100644
index 505c003..0000000
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/wrap.hpp
+++ /dev/null
@@ -1,578 +0,0 @@
-//
-// wrap.hpp
-// ~~~~~~~~
-//
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_WRAP_HPP
-#define ASIO_WRAP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/type_traits.hpp"
-#include "asio/detail/variadic_templates.hpp"
-#include "asio/associated_allocator.hpp"
-#include "asio/async_result.hpp"
-#include "asio/handler_type.hpp"
-#include "asio/uses_executor.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename T>
-struct executor_wrapper_check
-{
-  typedef void type;
-};
-
-// Helper to automatically define nested typedef result_type.
-
-template <typename T, typename = void>
-struct executor_wrapper_result_type
-{
-protected:
-  typedef void result_type_or_void;
-};
-
-template <typename T>
-struct executor_wrapper_result_type<T,
-  typename executor_wrapper_check<typename T::result_type>::type>
-{
-  typedef typename T::result_type result_type;
-protected:
-  typedef result_type result_type_or_void;
-};
-
-template <typename R>
-struct executor_wrapper_result_type<R(*)()>
-{
-  typedef R result_type;
-protected:
-  typedef result_type result_type_or_void;
-};
-
-template <typename R>
-struct executor_wrapper_result_type<R(&)()>
-{
-  typedef R result_type;
-protected:
-  typedef result_type result_type_or_void;
-};
-
-template <typename R, typename A1>
-struct executor_wrapper_result_type<R(*)(A1)>
-{
-  typedef R result_type;
-protected:
-  typedef result_type result_type_or_void;
-};
-
-template <typename R, typename A1>
-struct executor_wrapper_result_type<R(&)(A1)>
-{
-  typedef R result_type;
-protected:
-  typedef result_type result_type_or_void;
-};
-
-template <typename R, typename A1, typename A2>
-struct executor_wrapper_result_type<R(*)(A1, A2)>
-{
-  typedef R result_type;
-protected:
-  typedef result_type result_type_or_void;
-};
-
-template <typename R, typename A1, typename A2>
-struct executor_wrapper_result_type<R(&)(A1, A2)>
-{
-  typedef R result_type;
-protected:
-  typedef result_type result_type_or_void;
-};
-
-// Helper to automatically define nested typedef argument_type.
-
-template <typename T, typename = void>
-struct executor_wrapper_argument_type {};
-
-template <typename T>
-struct executor_wrapper_argument_type<T,
-  typename executor_wrapper_check<typename T::argument_type>::type>
-{
-  typedef typename T::argument_type argument_type;
-};
-
-template <typename R, typename A1>
-struct executor_wrapper_argument_type<R(*)(A1)>
-{
-  typedef A1 argument_type;
-};
-
-template <typename R, typename A1>
-struct executor_wrapper_argument_type<R(&)(A1)>
-{
-  typedef A1 argument_type;
-};
-
-// Helper to automatically define nested typedefs first_argument_type and
-// second_argument_type.
-
-template <typename T, typename = void>
-struct executor_wrapper_argument_types {};
-
-template <typename T>
-struct executor_wrapper_argument_types<T,
-  typename executor_wrapper_check<typename T::first_argument_type>::type>
-{
-  typedef typename T::first_argument_type first_argument_type;
-  typedef typename T::second_argument_type second_argument_type;
-};
-
-template <typename R, typename A1, typename A2>
-struct executor_wrapper_argument_type<R(*)(A1, A2)>
-{
-  typedef A1 first_argument_type;
-  typedef A2 second_argument_type;
-};
-
-template <typename R, typename A1, typename A2>
-struct executor_wrapper_argument_type<R(&)(A1, A2)>
-{
-  typedef A1 first_argument_type;
-  typedef A2 second_argument_type;
-};
-
-// Helper to:
-// - Apply the empty base optimisation to the executor.
-// - Perform uses_executor construction of the wrapped type, if required.
-
-template <typename T, typename Executor, bool UsesExecutor>
-class executor_wrapper_base;
-
-template <typename T, typename Executor>
-class executor_wrapper_base<T, Executor, true>
-  : protected Executor
-{
-protected:
-  template <typename E, typename U>
-  executor_wrapper_base(ASIO_MOVE_ARG(E) e, ASIO_MOVE_ARG(U) u)
-    : Executor(ASIO_MOVE_CAST(E)(e)),
-      wrapped_(executor_arg_t(), static_cast<const Executor&>(*this),
-          ASIO_MOVE_CAST(U)(u))
-  {
-  }
-
-  T wrapped_;
-};
-
-template <typename T, typename Executor>
-class executor_wrapper_base<T, Executor, false>
-  : protected Executor
-{
-protected:
-  template <typename E, typename U>
-  executor_wrapper_base(ASIO_MOVE_ARG(E) e, ASIO_MOVE_ARG(U) u)
-    : Executor(ASIO_MOVE_CAST(E)(e)),
-      wrapped_(ASIO_MOVE_CAST(U)(u))
-  {
-  }
-
-  T wrapped_;
-};
-
-// Helper to enable SFINAE on zero-argument operator() below.
-
-template <typename T, typename = void>
-struct executor_wrapper_result_of0
-{
-  typedef void type;
-};
-
-template <typename T>
-struct executor_wrapper_result_of0<T,
-  typename executor_wrapper_check<typename result_of<T()>::type>::type>
-{
-  typedef typename result_of<T()>::type type;
-};
-
-} // namespace detail
-
-/// A call wrapper type to associate an object of type @c T with an executor of
-/// type @c Executor.
-template <typename T, typename Executor>
-class executor_wrapper
-#if !defined(GENERATING_DOCUMENTATION)
-  : public detail::executor_wrapper_result_type<T>,
-    public detail::executor_wrapper_argument_type<T>,
-    public detail::executor_wrapper_argument_types<T>,
-    private detail::executor_wrapper_base<
-      T, Executor, uses_executor<T, Executor>::value>
-#endif // !defined(GENERATING_DOCUMENTATION)
-{
-public:
-  /// The type of the wrapped object.
-  typedef T wrapped_type;
-
-  /// The type of the associated executor.
-  typedef Executor executor_type;
-
-#if defined(GENERATING_DOCUMENTATION)
-  /// The return type if a function.
-  /**
-   * The type of @c result_type is based on the type @c T of the wrapper's
-   * target object:
-   *
-   * @li if @c T is a pointer to function type, @c result_type is a synonym for
-   * the return type of @c T;
-   *
-   * @li if @c T is a class type with a member type @c result_type, then @c
-   * result_type is a synonym for @c T::result_type;
-   *
-   * @li otherwise @c result_type is not defined.
-   */
-  typedef see_below result_type;
-
-  /// The type of the function's argument.
-  /**
-   * The type of @c argument_type is based on the type @c T of the wrapper's
-   * target object:
-   *
-   * @li if @c T is a pointer to a function type accepting a single argument,
-   * @c argument_type is a synonym for the return type of @c T;
-   *
-   * @li if @c T is a class type with a member type @c argument_type, then @c
-   * argument_type is a synonym for @c T::argument_type;
-   *
-   * @li otherwise @c argument_type is not defined.
-   */
-  typedef see_below argument_type;
-
-  /// The type of the function's first argument.
-  /**
-   * The type of @c first_argument_type is based on the type @c T of the
-   * wrapper's target object:
-   *
-   * @li if @c T is a pointer to a function type accepting two arguments, @c
-   * first_argument_type is a synonym for the return type of @c T;
-   *
-   * @li if @c T is a class type with a member type @c first_argument_type,
-   * then @c first_argument_type is a synonym for @c T::first_argument_type;
-   *
-   * @li otherwise @c first_argument_type is not defined.
-   */
-  typedef see_below first_argument_type;
-
-  /// The type of the function's second argument.
-  /**
-   * The type of @c second_argument_type is based on the type @c T of the
-   * wrapper's target object:
-   *
-   * @li if @c T is a pointer to a function type accepting two arguments, @c
-   * second_argument_type is a synonym for the return type of @c T;
-   *
-   * @li if @c T is a class type with a member type @c first_argument_type,
-   * then @c second_argument_type is a synonym for @c T::second_argument_type;
-   *
-   * @li otherwise @c second_argument_type is not defined.
-   */
-  typedef see_below second_argument_type;
-#endif // defined(GENERATING_DOCUMENTATION)
-
-  /// Construct an executor wrapper for the specified object.
-  /**
-   * This constructor is only valid if the type @c T is constructible from type
-   * @c U.
-   */
-  template <typename U>
-  executor_wrapper(executor_arg_t, const executor_type& e,
-      ASIO_MOVE_ARG(U) u)
-    : base_type(e, ASIO_MOVE_CAST(U)(u))
-  {
-  }
-
-  /// Copy constructor.
-  executor_wrapper(const executor_wrapper& other)
-    : base_type(other.get_executor(), other.unwrap())
-  {
-  }
-
-  /// Construct a copy, but specify a different executor.
-  executor_wrapper(executor_arg_t, const executor_type& e,
-      const executor_wrapper& other)
-    : base_type(e, other.unwrap())
-  {
-  }
-
-  /// Construct a copy of a different executor wrapper type.
-  /**
-   * This constructor is only valid if the @c Executor type is constructible
-   * from type @c OtherExecutor, and the type @c T is constructible from type
-   * @c U.
-   */
-  template <typename U, typename OtherExecutor>
-  executor_wrapper(const executor_wrapper<U, OtherExecutor>& other)
-    : base_type(other.get_executor(), other.unwrap())
-  {
-  }
-
-  /// Construct a copy of a different executor wrapper type, but specify a
-  /// different executor.
-  /**
-   * This constructor is only valid if the type @c T is constructible from type
-   * @c U.
-   */
-  template <typename U, typename OtherExecutor>
-  executor_wrapper(executor_arg_t, const executor_type& e,
-      const executor_wrapper<U, OtherExecutor>& other)
-    : base_type(e, other.unwrap())
-  {
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Move constructor.
-  executor_wrapper(executor_wrapper&& other)
-    : base_type(ASIO_MOVE_CAST(executor_type)(other.get_executor()),
-        ASIO_MOVE_CAST(T)(other.unwrap()))
-  {
-  }
-
-  /// Move construct the wrapped object, but specify a different executor.
-  executor_wrapper(executor_arg_t, const executor_type& e,
-      executor_wrapper&& other)
-    : base_type(e, ASIO_MOVE_CAST(T)(other.unwrap()))
-  {
-  }
-
-  /// Move construct from a different executor wrapper type.
-  template <typename U, typename OtherExecutor>
-  executor_wrapper(executor_wrapper<U, OtherExecutor>&& other)
-    : base_type(ASIO_MOVE_CAST(OtherExecutor)(other.get_executor()),
-        ASIO_MOVE_CAST(U)(other.unwrap()))
-  {
-  }
-
-  /// Move construct from a different executor wrapper type, but specify a
-  /// different executor.
-  template <typename U, typename OtherExecutor>
-  executor_wrapper(executor_arg_t, const executor_type& e,
-      executor_wrapper<U, OtherExecutor>&& other)
-    : base_type(e, ASIO_MOVE_CAST(U)(other.unwrap()))
-  {
-  }
-
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Destructor.
-  ~executor_wrapper()
-  {
-  }
-
-  /// Obtain a reference to the wrapped object.
-  wrapped_type& unwrap() ASIO_NOEXCEPT
-  {
-    return this->wrapped_;
-  }
-
-  /// Obtain a reference to the wrapped object.
-  const wrapped_type& unwrap() const ASIO_NOEXCEPT
-  {
-    return this->wrapped_;
-  }
-
-  /// Obtain the associated executor.
-  executor_type get_executor() const ASIO_NOEXCEPT
-  {
-    return static_cast<const Executor&>(*this);
-  }
-
-#if defined(GENERATING_DOCUMENTATION)
-
-  template <typename... Args> auto operator()(Args&& ...);
-  template <typename... Args> auto operator()(Args&& ...) const;
-
-#elif defined(ASIO_HAS_VARIADIC_TEMPLATES)
-
-  /// Forwarding function call operator.
-  template <typename... Args>
-  typename result_of<T(Args...)>::type operator()(
-      ASIO_MOVE_ARG(Args)... args)
-  {
-    return this->wrapped_(ASIO_MOVE_CAST(Args)(args)...);
-  }
-
-  /// Forwarding function call operator.
-  template <typename... Args>
-  typename result_of<T(Args...)>::type operator()(
-      ASIO_MOVE_ARG(Args)... args) const
-  {
-    return this->wrapped_(ASIO_MOVE_CAST(Args)(args)...);
-  }
-
-#elif defined(ASIO_HAS_STD_TYPE_TRAITS) && !defined(_MSC_VER)
-
-  typename detail::executor_wrapper_result_of0<T>::type operator()()
-  {
-    return this->wrapped_();
-  }
-
-  typename detail::executor_wrapper_result_of0<T>::type operator()() const
-  {
-    return this->wrapped_();
-  }
-
-#define ASIO_PRIVATE_WRAP_CALL_DEF(n) \
-  template <ASIO_VARIADIC_TPARAMS(n)> \
-  typename result_of<T(ASIO_VARIADIC_TARGS(n))>::type operator()( \
-      ASIO_VARIADIC_MOVE_PARAMS(n)) \
-  { \
-    return this->wrapped_(ASIO_VARIADIC_MOVE_ARGS(n)); \
-  } \
-  \
-  template <ASIO_VARIADIC_TPARAMS(n)> \
-  typename result_of<T(ASIO_VARIADIC_TARGS(n))>::type operator()( \
-      ASIO_VARIADIC_MOVE_PARAMS(n)) const \
-  { \
-    return this->wrapped_(ASIO_VARIADIC_MOVE_ARGS(n)); \
-  } \
-  /**/
-  ASIO_VARIADIC_GENERATE(ASIO_PRIVATE_WRAP_CALL_DEF)
-#undef ASIO_PRIVATE_WRAP_CALL_DEF
-
-#else // defined(ASIO_HAS_STD_TYPE_TRAITS) && !defined(_MSC_VER)
-
-  typedef typename detail::executor_wrapper_result_type<T>::result_type_or_void
-    result_type_or_void;
-
-  result_type_or_void operator()()
-  {
-    return this->wrapped_();
-  }
-
-  result_type_or_void operator()() const
-  {
-    return this->wrapped_();
-  }
-
-#define ASIO_PRIVATE_WRAP_CALL_DEF(n) \
-  template <ASIO_VARIADIC_TPARAMS(n)> \
-  result_type_or_void operator()( \
-      ASIO_VARIADIC_MOVE_PARAMS(n)) \
-  { \
-    return this->wrapped_(ASIO_VARIADIC_MOVE_ARGS(n)); \
-  } \
-  \
-  template <ASIO_VARIADIC_TPARAMS(n)> \
-  result_type_or_void operator()( \
-      ASIO_VARIADIC_MOVE_PARAMS(n)) const \
-  { \
-    return this->wrapped_(ASIO_VARIADIC_MOVE_ARGS(n)); \
-  } \
-  /**/
-  ASIO_VARIADIC_GENERATE(ASIO_PRIVATE_WRAP_CALL_DEF)
-#undef ASIO_PRIVATE_WRAP_CALL_DEF
-
-#endif // defined(ASIO_HAS_STD_TYPE_TRAITS) && !defined(_MSC_VER)
-
-private:
-  typedef detail::executor_wrapper_base<T, Executor,
-    uses_executor<T, Executor>::value> base_type;
-};
-
-/// Associate an object of type @c T with an executor of type @c Executor.
-template <typename Executor, typename T>
-inline executor_wrapper<typename decay<T>::type, Executor>
-wrap(const Executor& ex, ASIO_MOVE_ARG(T) t,
-    typename enable_if<is_executor<Executor>::value>::type* = 0)
-{
-  return executor_wrapper<typename decay<T>::type, Executor>(
-      executor_arg_t(), ex, ASIO_MOVE_CAST(T)(t));
-}
-
-/// Associate an object of type @c T with an execution context's executor.
-template <typename ExecutionContext, typename T>
-inline executor_wrapper<typename decay<T>::type,
-  typename ExecutionContext::executor_type>
-wrap(ExecutionContext& ctx, ASIO_MOVE_ARG(T) t,
-    typename enable_if<is_convertible<
-      ExecutionContext&, execution_context&>::value>::type* = 0)
-{
-  return executor_wrapper<typename decay<T>::type,
-    typename ExecutionContext::executor_type>(
-      executor_arg_t(), ctx.get_executor(), ASIO_MOVE_CAST(T)(t));
-}
-
-#if !defined(GENERATING_DOCUMENTATION)
-
-template <typename T, typename Executor>
-struct uses_executor<executor_wrapper<T, Executor>, Executor>
-  : true_type {};
-
-template <typename T, typename Executor, typename Signature>
-struct handler_type<executor_wrapper<T, Executor>, Signature>
-{
-  typedef executor_wrapper<
-    typename handler_type<T, Signature>::type, Executor> type;
-};
-
-template <typename T, typename Executor>
-class async_result<executor_wrapper<T, Executor> >
-{
-public:
-  typedef typename async_result<T>::type type;
-
-  explicit async_result(executor_wrapper<T, Executor>& w)
-    : wrapped_(w.unwrap())
-  {
-  }
-
-  type get()
-  {
-    return wrapped_.get();
-  }
-
-private:
-  async_result<T> wrapped_;
-};
-
-template <typename T, typename Executor, typename Allocator>
-struct associated_allocator<executor_wrapper<T, Executor>, Allocator>
-{
-  typedef typename associated_allocator<T, Allocator>::type type;
-
-  static type get(const executor_wrapper<T, Executor>& w,
-      const Allocator& a = Allocator()) ASIO_NOEXCEPT
-  {
-    return associated_allocator<T, Allocator>::get(w.unwrap(), a);
-  }
-};
-
-template <typename T, typename Executor, typename Executor1>
-struct associated_executor<executor_wrapper<T, Executor>, Executor1>
-{
-  typedef Executor type;
-
-  static type get(const executor_wrapper<T, Executor>& w,
-      const Executor1& = Executor1()) ASIO_NOEXCEPT
-  {
-    return w.get_executor();
-  }
-};
-
-#endif // !defined(GENERATING_DOCUMENTATION)
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_WRAP_HPP
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/write.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/write.hpp
index de309bf..0010862 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/write.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/write.hpp
@@ -2,7 +2,7 @@
 // write.hpp
 // ~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -18,10 +18,13 @@
 #include "asio/detail/config.hpp"
 #include <cstddef>
 #include "asio/async_result.hpp"
-#include "asio/basic_streambuf_fwd.hpp"
 #include "asio/buffer.hpp"
 #include "asio/error.hpp"
 
+#if !defined(ASIO_NO_EXTENSIONS)
+# include "asio/basic_streambuf_fwd.hpp"
+#endif // !defined(ASIO_NO_EXTENSIONS)
+
 #include "asio/detail/push_options.hpp"
 
 namespace asio {
@@ -246,11 +249,11 @@ std::size_t write(SyncWriteStream& s, const ConstBufferSequence& buffers,
  *     s, buffers,
  *     asio::transfer_all()); @endcode
  */
-template <typename SyncWriteStream, typename DynamicBufferSequence>
+template <typename SyncWriteStream, typename DynamicBuffer>
 std::size_t write(SyncWriteStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type* = 0);
 
 /// Write all of the supplied data to a stream before returning.
@@ -280,12 +283,12 @@ std::size_t write(SyncWriteStream& s,
  *     s, buffers,
  *     asio::transfer_all(), ec); @endcode
  */
-template <typename SyncWriteStream, typename DynamicBufferSequence>
+template <typename SyncWriteStream, typename DynamicBuffer>
 std::size_t write(SyncWriteStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     asio::error_code& ec,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type* = 0);
 
 /// Write a certain amount of data to a stream before returning.
@@ -324,13 +327,13 @@ std::size_t write(SyncWriteStream& s,
  *
  * @throws asio::system_error Thrown on failure.
  */
-template <typename SyncWriteStream, typename DynamicBufferSequence,
+template <typename SyncWriteStream, typename DynamicBuffer,
     typename CompletionCondition>
 std::size_t write(SyncWriteStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     CompletionCondition completion_condition,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type* = 0);
 
 /// Write a certain amount of data to a stream before returning.
@@ -370,15 +373,16 @@ std::size_t write(SyncWriteStream& s,
  * @returns The number of bytes written. If an error occurs, returns the total
  * number of bytes successfully transferred prior to the error.
  */
-template <typename SyncWriteStream, typename DynamicBufferSequence,
+template <typename SyncWriteStream, typename DynamicBuffer,
     typename CompletionCondition>
 std::size_t write(SyncWriteStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     CompletionCondition completion_condition, asio::error_code& ec,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type* = 0);
 
+#if !defined(ASIO_NO_EXTENSIONS)
 #if !defined(ASIO_NO_IOSTREAM)
 
 /// Write all of the supplied data to a stream before returning.
@@ -522,6 +526,7 @@ std::size_t write(SyncWriteStream& s, basic_streambuf<Allocator>& b,
     CompletionCondition completion_condition, asio::error_code& ec);
 
 #endif // !defined(ASIO_NO_IOSTREAM)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 /*@}*/
 /**
@@ -573,7 +578,7 @@ std::size_t write(SyncWriteStream& s, basic_streambuf<Allocator>& b,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @par Example
  * To write a single data buffer use the @ref buffer function as follows:
@@ -649,7 +654,7 @@ async_write(AsyncWriteStream& s, const ConstBufferSequence& buffers,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @par Example
  * To write a single data buffer use the @ref buffer function as follows:
@@ -713,17 +718,17 @@ async_write(AsyncWriteStream& s, const ConstBufferSequence& buffers,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  */
 template <typename AsyncWriteStream,
-    typename DynamicBufferSequence, typename WriteHandler>
+    typename DynamicBuffer, typename WriteHandler>
 ASIO_INITFN_RESULT_TYPE(WriteHandler,
     void (asio::error_code, std::size_t))
 async_write(AsyncWriteStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     ASIO_MOVE_ARG(WriteHandler) handler,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type* = 0);
 
 /// Start an asynchronous operation to write a certain amount of data to a
@@ -781,20 +786,21 @@ async_write(AsyncWriteStream& s,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  */
-template <typename AsyncWriteStream, typename DynamicBufferSequence,
+template <typename AsyncWriteStream, typename DynamicBuffer,
     typename CompletionCondition, typename WriteHandler>
 ASIO_INITFN_RESULT_TYPE(WriteHandler,
     void (asio::error_code, std::size_t))
 async_write(AsyncWriteStream& s,
-    ASIO_MOVE_ARG(DynamicBufferSequence) buffers,
+    ASIO_MOVE_ARG(DynamicBuffer) buffers,
     CompletionCondition completion_condition,
     ASIO_MOVE_ARG(WriteHandler) handler,
     typename enable_if<
-      is_dynamic_buffer_sequence<DynamicBufferSequence>::value
+      is_dynamic_buffer<DynamicBuffer>::value
     >::type* = 0);
 
+#if !defined(ASIO_NO_EXTENSIONS)
 #if !defined(ASIO_NO_IOSTREAM)
 
 /// Start an asynchronous operation to write all of the supplied data to a
@@ -836,7 +842,7 @@ async_write(AsyncWriteStream& s,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  */
 template <typename AsyncWriteStream, typename Allocator, typename WriteHandler>
 ASIO_INITFN_RESULT_TYPE(WriteHandler,
@@ -897,7 +903,7 @@ async_write(AsyncWriteStream& s, basic_streambuf<Allocator>& b,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  */
 template <typename AsyncWriteStream, typename Allocator,
     typename CompletionCondition, typename WriteHandler>
@@ -908,6 +914,7 @@ async_write(AsyncWriteStream& s, basic_streambuf<Allocator>& b,
     ASIO_MOVE_ARG(WriteHandler) handler);
 
 #endif // !defined(ASIO_NO_IOSTREAM)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 /*@}*/
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/write_at.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/write_at.hpp
index 45edd08..1722774 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/write_at.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/write_at.hpp
@@ -2,7 +2,7 @@
 // write_at.hpp
 // ~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -18,10 +18,13 @@
 #include "asio/detail/config.hpp"
 #include <cstddef>
 #include "asio/async_result.hpp"
-#include "asio/basic_streambuf_fwd.hpp"
 #include "asio/detail/cstdint.hpp"
 #include "asio/error.hpp"
 
+#if !defined(ASIO_NO_EXTENSIONS)
+# include "asio/basic_streambuf_fwd.hpp"
+#endif // !defined(ASIO_NO_EXTENSIONS)
+
 #include "asio/detail/push_options.hpp"
 
 namespace asio {
@@ -224,6 +227,7 @@ std::size_t write_at(SyncRandomAccessWriteDevice& d,
     uint64_t offset, const ConstBufferSequence& buffers,
     CompletionCondition completion_condition, asio::error_code& ec);
 
+#if !defined(ASIO_NO_EXTENSIONS)
 #if !defined(ASIO_NO_IOSTREAM)
 
 /// Write all of the supplied data at the specified offset before returning.
@@ -382,6 +386,7 @@ std::size_t write_at(SyncRandomAccessWriteDevice& d, uint64_t offset,
     asio::error_code& ec);
 
 #endif // !defined(ASIO_NO_IOSTREAM)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 /*@}*/
 /**
@@ -437,7 +442,7 @@ std::size_t write_at(SyncRandomAccessWriteDevice& d, uint64_t offset,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @par Example
  * To write a single data buffer use the @ref buffer function as follows:
@@ -515,7 +520,7 @@ async_write_at(AsyncRandomAccessWriteDevice& d, uint64_t offset,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  *
  * @par Example
  * To write a single data buffer use the @ref buffer function as follows:
@@ -536,6 +541,7 @@ async_write_at(AsyncRandomAccessWriteDevice& d,
     CompletionCondition completion_condition,
     ASIO_MOVE_ARG(WriteHandler) handler);
 
+#if !defined(ASIO_NO_EXTENSIONS)
 #if !defined(ASIO_NO_IOSTREAM)
 
 /// Start an asynchronous operation to write all of the supplied data at the
@@ -581,7 +587,7 @@ async_write_at(AsyncRandomAccessWriteDevice& d,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  */
 template <typename AsyncRandomAccessWriteDevice, typename Allocator,
     typename WriteHandler>
@@ -647,7 +653,7 @@ async_write_at(AsyncRandomAccessWriteDevice& d, uint64_t offset,
  * Regardless of whether the asynchronous operation completes immediately or
  * not, the handler will not be invoked from within this function. Invocation of
  * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
+ * asio::io_context::post().
  */
 template <typename AsyncRandomAccessWriteDevice, typename Allocator,
     typename CompletionCondition, typename WriteHandler>
@@ -658,6 +664,7 @@ async_write_at(AsyncRandomAccessWriteDevice& d, uint64_t offset,
     ASIO_MOVE_ARG(WriteHandler) handler);
 
 #endif // !defined(ASIO_NO_IOSTREAM)
+#endif // !defined(ASIO_NO_EXTENSIONS)
 
 /*@}*/
 
diff --git a/src/third_party/asio-asio-1-11-0/asio/include/asio/yield.hpp b/src/third_party/asio-asio-1-11-0/asio/include/asio/yield.hpp
index 6cf5d6b..fa17817 100644
--- a/src/third_party/asio-asio-1-11-0/asio/include/asio/yield.hpp
+++ b/src/third_party/asio-asio-1-11-0/asio/include/asio/yield.hpp
@@ -2,7 +2,7 @@
 // yield.hpp
 // ~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/src/Makefile.mgw b/src/third_party/asio-asio-1-11-0/asio/src/Makefile.mgw
index 015da58..ffbb1f2 100644
--- a/src/third_party/asio-asio-1-11-0/asio/src/Makefile.mgw
+++ b/src/third_party/asio-asio-1-11-0/asio/src/Makefile.mgw
@@ -11,8 +11,6 @@ PERFORMANCE_TEST_EXES = \
 	tests/performance/client.exe \
 	tests/performance/server.exe
 
-UNIT_TEST_OBJ = tests/unit/unit_test.o
-
 UNIT_TEST_EXES = \
 	tests/unit/basic_datagram_socket.exe \
 	tests/unit/basic_deadline_timer.exe \
@@ -42,7 +40,7 @@ UNIT_TEST_EXES = \
 	tests/unit/generic/seq_packet_protocol.exe \
 	tests/unit/generic/stream_protocol.exe \
 	tests/unit/high_resolution_timer.exe \
-	tests/unit/io_service.exe \
+	tests/unit/io_context.exe \
 	tests/unit/ip/address.exe \
 	tests/unit/ip/address_v4.exe \
 	tests/unit/ip/address_v6.exe \
@@ -146,12 +144,11 @@ OTHER_EXAMPLE_EXES = \
 
 all: \
 	$(PERFORMANCE_TEST_EXES) \
-	$(UNIT_TEST_OBJ) \
 	$(UNIT_TEST_EXES) \
 	$(EXAMPLE_EXES) \
 	$(OTHER_EXAMPLE_EXES)
 
-check: $(UNIT_TEST_OBJ) $(UNIT_TEST_EXES) $(addprefix run.,$(UNIT_TEST_EXES))
+check: $(UNIT_TEST_EXES) $(addprefix run.,$(UNIT_TEST_EXES))
 
 $(addprefix run.,$(UNIT_TEST_EXES))::
 	@echo === Running $(@:run.%=%) ===
@@ -170,7 +167,7 @@ clean:
 	-rm -f $(OTHER_EXAMPLE_EXES:.exe=.o)
 
 $(UNIT_TEST_EXES): %.exe: %.o
-	g++ -o$@ $(LDFLAGS) $< $(UNIT_TEST_OBJ) $(LIBS)
+	g++ -o$@ $(LDFLAGS) $< $(LIBS)
 
 $(PERFORMANCE_TEST_EXES) $(EXAMPLE_EXES): %.exe: %.o
 	g++ -o$@ $(LDFLAGS) $< $(LIBS)
@@ -188,7 +185,7 @@ examples/cpp03/http/server/http_server.exe: \
 
 examples/cpp03/http/server2/http_server.exe: \
 		examples/cpp03/http/server2/connection.o \
-		examples/cpp03/http/server2/io_service_pool.o \
+		examples/cpp03/http/server2/io_context_pool.o \
 		examples/cpp03/http/server2/main.o \
 		examples/cpp03/http/server2/mime_types.o \
 		examples/cpp03/http/server2/reply.o \
diff --git a/src/third_party/asio-asio-1-11-0/asio/src/Makefile.msc b/src/third_party/asio-asio-1-11-0/asio/src/Makefile.msc
index 8f66356..7cb1c56 100644
--- a/src/third_party/asio-asio-1-11-0/asio/src/Makefile.msc
+++ b/src/third_party/asio-asio-1-11-0/asio/src/Makefile.msc
@@ -31,7 +31,11 @@ TRACKING_CXXFLAGS = -DASIO_ENABLE_HANDLER_TRACKING
 !endif
 
 !ifndef _WIN32_WINNT
+! ifdef STORE
+_WIN32_WINNT=0x0603
+! else
 _WIN32_WINNT=0x0501
+! endif
 !endif
 
 !ifdef WIN9X
@@ -40,14 +44,21 @@ DEFINES = \
 	-D_WIN32_WINNT=$(_WIN32_WINNT) \
 	-DBOOST_ALL_NO_LIB
 !else
-! ifdef WINRT
+! ifdef STORE
+DEFINES = \
+	-DWINAPI_FAMILY=WINAPI_FAMILY_PC_APP \
+	-DBOOST_ALL_NO_LIB -D_WIN32_WINNT=$(_WIN32_WINNT) \
+  -DUNICODE -D_UNICODE
+! else
+!  ifdef WINRT
 DEFINES = \
 	-ZW -FI SDKDDKVer.h -FI winapifamily.h -DWINAPI_FAMILY=WINAPI_PARTITION_APP \
 	-DBOOST_ALL_NO_LIB
-! else
+!  else
 DEFINES = \
 	-D_WIN32_WINNT=$(_WIN32_WINNT) \
 	-DBOOST_ALL_NO_LIB
+!  endif
 ! endif
 !endif
 
@@ -94,8 +105,6 @@ PERFORMANCE_TEST_EXES = \
 	tests\performance\client.exe \
 	tests\performance\server.exe
 
-UNIT_TEST_OBJ = tests\unit\unit_test.obj
-
 UNIT_TEST_EXES = \
 	tests\unit\basic_datagram_socket.exe \
 	tests\unit\basic_deadline_timer.exe \
@@ -125,7 +134,7 @@ UNIT_TEST_EXES = \
 	tests\unit\generic\seq_packet_protocol.exe \
 	tests\unit\generic\stream_protocol.exe \
 	tests\unit\high_resolution_timer.exe \
-	tests\unit\io_service.exe \
+	tests\unit\io_context.exe \
 	tests\unit\ip\address.exe \
 	tests\unit\ip\address_v4.exe \
 	tests\unit\ip\address_v6.exe \
@@ -265,10 +274,6 @@ ssl: \
 	$(SSL_UNIT_TEST_EXES) \
 	$(SSL_EXAMPLE_EXES)
 
-$(UNIT_TEST_EXES): $(UNIT_TEST_OBJ)
-
-$(SSL_UNIT_TEST_EXES): $(UNIT_TEST_OBJ)
-
 check: $(UNIT_TEST_EXES)
 	!@echo === Running $** === && $** && echo.
 
@@ -282,19 +287,19 @@ tests\unit\unit_test.obj: tests\unit\unit_test.cpp
 	cl -Fe$@ -Fotests\unit\unit_test.obj $(CXXFLAGS) $(DEFINES) -c tests\unit\unit_test.cpp
 
 {tests\unit}.cpp{tests\unit}.exe:
-	cl -Fe$@ -Fo$(<:.cpp=.obj) $(CXXFLAGS) $(DEFINES) $< $(UNIT_TEST_OBJ) $(LIBS) -link -opt:ref
+	cl -Fe$@ -Fo$(<:.cpp=.obj) $(CXXFLAGS) $(DEFINES) $< $(LIBS) -link -opt:ref
 
 {tests\unit\generic}.cpp{tests\unit\generic}.exe:
-	cl -Fe$@ -Fo$(<:.cpp=.obj) $(CXXFLAGS) $(DEFINES) $< $(UNIT_TEST_OBJ) $(LIBS) -link -opt:ref
+	cl -Fe$@ -Fo$(<:.cpp=.obj) $(CXXFLAGS) $(DEFINES) $< $(LIBS) -link -opt:ref
 
 {tests\unit\ip}.cpp{tests\unit\ip}.exe:
-	cl -Fe$@ -Fo$(<:.cpp=.obj) $(CXXFLAGS) $(DEFINES) $< $(UNIT_TEST_OBJ) $(LIBS) -link -opt:ref
+	cl -Fe$@ -Fo$(<:.cpp=.obj) $(CXXFLAGS) $(DEFINES) $< $(LIBS) -link -opt:ref
 
 {tests\unit\ssl}.cpp{tests\unit\ssl}.exe:
-	cl -Fe$@ -Fo$(<:.cpp=.obj) $(CXXFLAGS) $(SSL_CXXFLAGS) $(DEFINES) $< $(UNIT_TEST_OBJ) $(SSL_LIBS) $(LIBS) -link -opt:ref
+	cl -Fe$@ -Fo$(<:.cpp=.obj) $(CXXFLAGS) $(SSL_CXXFLAGS) $(DEFINES) $< $(SSL_LIBS) $(LIBS) -link -opt:ref
 
 {tests\unit\windows}.cpp{tests\unit\windows}.exe:
-	cl -Fe$@ -Fo$(<:.cpp=.obj) $(CXXFLAGS) $(DEFINES) $< $(UNIT_TEST_OBJ) $(LIBS) -link -opt:ref
+	cl -Fe$@ -Fo$(<:.cpp=.obj) $(CXXFLAGS) $(DEFINES) $< $(LIBS) -link -opt:ref
 
 {examples\cpp03\allocation}.cpp{examples\cpp03\allocation}.exe:
 	cl -Fe$@ -Fo$(<:.cpp=.obj) $(CXXFLAGS) $(DEFINES) $< $(LIBS) -link -opt:ref
@@ -396,7 +401,7 @@ examples\cpp03\http\server\http_server.exe: \
 
 examples\cpp03\http\server2\http_server.exe: \
 		examples\cpp03\http\server2\connection.cpp \
-		examples\cpp03\http\server2\io_service_pool.cpp \
+		examples\cpp03\http\server2\io_context_pool.cpp \
 		examples\cpp03\http\server2\main.cpp \
 		examples\cpp03\http\server2\mime_types.cpp \
 		examples\cpp03\http\server2\reply.cpp \
diff --git a/src/third_party/asio-asio-1-11-0/asio/src/asio.cpp b/src/third_party/asio-asio-1-11-0/asio/src/asio.cpp
index f1725fc..2125d62 100644
--- a/src/third_party/asio-asio-1-11-0/asio/src/asio.cpp
+++ b/src/third_party/asio-asio-1-11-0/asio/src/asio.cpp
@@ -2,7 +2,7 @@
 // asio.cpp
 // ~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/src/asio_ssl.cpp b/src/third_party/asio-asio-1-11-0/asio/src/asio_ssl.cpp
index d9cc2cb..68a16c0 100644
--- a/src/third_party/asio-asio-1-11-0/asio/src/asio_ssl.cpp
+++ b/src/third_party/asio-asio-1-11-0/asio/src/asio_ssl.cpp
@@ -2,7 +2,7 @@
 // asio_ssl.cpp
 // ~~~~~~~~~~~~
 //
-// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/src/third_party/asio-asio-1-11-0/asio/tsify.pl b/src/third_party/asio-asio-1-11-0/asio/tsify.pl
new file mode 100755
index 0000000..3dc1038
--- /dev/null
+++ b/src/third_party/asio-asio-1-11-0/asio/tsify.pl
@@ -0,0 +1,551 @@
+#!/usr/bin/perl -w
+
+use strict;
+use File::Path;
+# use Switch;
+
+our $output_dir = "tsified";
+
+sub print_line
+{
+  my ($output, $line, $from, $lineno) = @_;
+
+  # Warn if the resulting line is >80 characters wide.
+  if (length($line) > 80)
+  {
+    if ($from =~ /\.[chi]pp$/)
+    {
+      print("Warning: $from:$lineno: output >80 characters wide.\n");
+    }
+  }
+
+  # Write the output.
+  print($output $line . "\n");
+}
+
+sub source_contains_asio_thread_usage
+{
+  my ($from) = @_;
+
+  # Open the input file.
+  open(my $input, "<$from") or die("Can't open $from for reading");
+
+  # Check file for use of asio::thread.
+  while (my $line = <$input>)
+  {
+    chomp($line);
+    if ($line =~ /asio::thread/)
+    {
+      close($input);
+      return 1;
+    }
+    elsif ($line =~ /^ *thread /)
+    {
+      close($input);
+      return 1;
+    }
+  }
+
+  close($input);
+  return 0;
+}
+
+sub source_contains_asio_include
+{
+  my ($from) = @_;
+
+  # Open the input file.
+  open(my $input, "<$from") or die("Can't open $from for reading");
+
+  # Check file for inclusion of asio.hpp.
+  while (my $line = <$input>)
+  {
+    chomp($line);
+    if ($line =~ /# *include [<"]asio\.hpp[>"]/)
+    {
+      close($input);
+      return 1;
+    }
+  }
+
+  close($input);
+  return 0;
+}
+
+sub copy_source_file
+{
+  my ($from, $to) = @_;
+
+  # Ensure the output directory exists.
+  my $dir = $to;
+  $dir =~ s/[^\/]*$//;
+  mkpath($dir);
+
+  # First determine whether the file makes any use of asio::thread.
+  my $uses_asio_thread = source_contains_asio_thread_usage($from);
+
+  my $includes_asio = source_contains_asio_include($from);
+
+  my $is_asio_hpp = 0;
+  $is_asio_hpp = 1 if ($from =~ /asio\.hpp/);
+
+  my $needs_doc_link = 0;
+  $needs_doc_link = 1 if ($is_asio_hpp);
+
+  my $is_config_hpp = 0;
+  $is_config_hpp = 1 if ($from =~ /asio\/detail\/config\.hpp/);
+
+  my $is_error_hpp = 0;
+  $is_error_hpp = 1 if ($from =~ /asio\/error\.hpp/);
+
+  my $is_impl_src_hpp = 0;
+  $is_impl_src_hpp = 1 if ($from =~ /asio\/impl\/src\.hpp/);
+
+  my $is_test = 0;
+  $is_test = 1 if ($from =~ /tests\/unit/);
+
+  # Open the files.
+  open(my $input, "<$from") or die("Can't open $from for reading");
+  open(my $output, ">$to") or die("Can't open $to for writing");
+
+  # State for stripping out deprecated, extension, and old services code.
+  my $deprecated_state = 0;
+  my $extension_state = 0;
+  my $old_services_state = 0;
+
+  # Copy the content.
+  my $lineno = 1;
+  while (my $line = <$input>)
+  {
+    chomp($line);
+
+    # Strip out deprecated code.
+    if ($deprecated_state == 0)
+    {
+      if ($line =~ /#\s*if\s*defined\(ASIO_NO_DEPRECATED\)/)
+      {
+        $deprecated_state = 1;
+        next;
+      }
+      elsif ($line =~ /#\s*if\s*!defined\(ASIO_NO_DEPRECATED\)/)
+      {
+        $deprecated_state = -1;
+        next;
+      }
+    }
+    elsif ($deprecated_state == 1)
+    {
+      if ($line =~ /#\s*else\s*\/\/\s*!*defined\(ASIO_NO_DEPRECATED\)/)
+      {
+        $deprecated_state = -1;
+        next;
+      }
+      elsif ($line =~ /#\s*endif\s*\/\/\s*!*defined\(ASIO_NO_DEPRECATED\)/)
+      {
+        $deprecated_state = 0;
+        next;
+      }
+      else
+      {
+        $line =~ s/^# /#/;
+      }
+    }
+    elsif ($deprecated_state == -1)
+    {
+      if ($line =~ /#\s*else\s*\/\/\s*!*defined\(ASIO_NO_DEPRECATED\)/)
+      {
+        $deprecated_state = 1;
+      }
+      elsif ($line =~ /#\s*endif\s*\/\/\s*!*defined\(ASIO_NO_DEPRECATED\)/)
+      {
+        $deprecated_state = -2;
+      }
+      next;
+    }
+    elsif ($deprecated_state == -2)
+    {
+      $deprecated_state = 0;
+      next if ($line eq "");
+    }
+
+    # Strip out code for extensions.
+    if ($extension_state == 0)
+    {
+      if ($line =~ /#\s*if\s*!defined\(ASIO_NO_EXTENSIONS\)\s*$/)
+      {
+        $extension_state = -1;
+        next;
+      }
+    }
+    elsif ($extension_state == -1)
+    {
+      $extension_state = -2 if ($line =~ /#\s*endif\s*\/\/\s*!defined\(ASIO_NO_EXTENSIONS\)\s*$/);
+      next;
+    }
+    elsif ($extension_state == -2)
+    {
+      $extension_state = 0;
+      next if ($line eq "");
+    }
+
+    # Strip out code for old services.
+    if ($old_services_state == 0)
+    {
+      if ($line =~ /#\s*if\s*defined\(ASIO_ENABLE_OLD_SERVICES\)/)
+      {
+        $old_services_state = -1;
+        next;
+      }
+      elsif ($line =~ /#\s*if\s*!defined\(ASIO_ENABLE_OLD_SERVICES\)/)
+      {
+        $old_services_state = 1;
+        next;
+      }
+    }
+    elsif ($old_services_state == 1)
+    {
+      if ($line =~ /#\s*else\s*\/\/\s*!*defined\(ASIO_ENABLE_OLD_SERVICES\)/)
+      {
+        $old_services_state = -1;
+        next;
+      }
+      elsif ($line =~ /#\s*endif\s*\/\/\s*!*defined\(ASIO_ENABLE_OLD_SERVICES\)/)
+      {
+        $old_services_state = 0;
+        next;
+      }
+      else
+      {
+        $line =~ s/^# /#/;
+      }
+    }
+    elsif ($old_services_state == -1)
+    {
+      if ($line =~ /#\s*else\s*\/\/\s*!*defined\(ASIO_ENABLE_OLD_SERVICES\)/)
+      {
+        $old_services_state = 1;
+      }
+      elsif ($line =~ /#\s*endif\s*\/\/\s*!*defined\(ASIO_ENABLE_OLD_SERVICES\)/)
+      {
+        $old_services_state = -2;
+      }
+      next;
+    }
+    elsif ($old_services_state == -2)
+    {
+      $old_services_state = 0;
+      next if ($line eq "");
+    }
+
+    # Unconditional replacements.
+    $line =~ s/[\\@]ref boost_bind/std::bind()/g;
+    if ($from =~ /.*\.txt$/)
+    {
+      $line =~ s/[\\@]ref async_read/std::experimental::net::async_read()/g;
+      $line =~ s/[\\@]ref async_write/std::experimental::net::async_write()/g;
+    }
+    if ($line =~ /asio_detail_posix_thread_function/)
+    {
+      $line =~ s/asio_detail_posix_thread_function/networking_ts_detail_posix_thread_function/g;
+    }
+    if ($line =~ /asio_signal_handler/)
+    {
+      $line =~ s/asio_signal_handler/networking_ts_signal_handler/g;
+    }
+    if ($line =~ /ASIO_/ && !($line =~ /NET_TS_/))
+    {
+      $line =~ s/ASIO_/NET_TS_/g;
+    }
+    if ($line =~ /asio_handler_/)
+    {
+      $line =~ s/asio_handler_/networking_ts_handler_/g;
+    }
+    if ($line =~ /asio_true_handler_/)
+    {
+      $line =~ s/asio_true_handler_/networking_ts_true_handler_/g;
+    }
+
+    # Lines skipped in asio/impl/src.hpp.
+    if ($is_impl_src_hpp)
+    {
+      next if
+        (
+             $line =~ /serial_port/
+          or $line =~ /\/local\//
+          or $line =~ /\/generic\//
+          or $line =~ /signal_set/
+        );
+    }
+
+    # Conditional replacements.
+    if ($line =~ /^(.* *)namespace asio {/)
+    {
+      print_line($output, $1 . "namespace std {", $from, $lineno);
+      print_line($output, $1 . "namespace experimental {", $from, $lineno);
+      print_line($output, $1 . "namespace net {", $from, $lineno);
+      print_line($output, $1 . "inline namespace v1 {", $from, $lineno);
+    }
+    elsif ($line =~ /^(.* *)} \/\/ namespace asio$/)
+    {
+      print_line($output, $1 . "} // inline namespace v1", $from, $lineno);
+      print_line($output, $1 . "} // namespace net", $from, $lineno);
+      print_line($output, $1 . "} // namespace experimental", $from, $lineno);
+      print_line($output, $1 . "} // namespace std", $from, $lineno);
+    }
+    elsif ($line =~ /^(# *include )[<"](asio\.hpp)[>"]$/)
+    {
+      print_line($output, $1 . "<net>", $from, $lineno);
+      if ($uses_asio_thread)
+      {
+        print_line($output, $1 . "<thread>", $from, $lineno) if (!$is_test);
+        $uses_asio_thread = 0;
+      }
+    }
+    elsif ($line =~ /^(# *include )[<"]boost\/.*[>"].*$/)
+    {
+      if (!$includes_asio && $uses_asio_thread)
+      {
+        print_line($output, $1 . "<thread>", $from, $lineno) if (!$is_test);
+        $uses_asio_thread = 0;
+      }
+      print_line($output, $line, $from, $lineno);
+    }
+    elsif ($line =~ /^(# *include )[<"]asio\/thread\.hpp[>"]/)
+    {
+      if ($is_test)
+      {
+        print_line($output, $1 . "<experimental/__net_ts/detail/thread.hpp>", $from, $lineno);
+      }
+      else
+      {
+        # Line is removed.
+      }
+    }
+    elsif ($line =~ /(# *include )[<"]asio\/error_code\.hpp[>"]/)
+    {
+      if ($is_asio_hpp)
+      {
+        # Line is removed.
+      }
+      else
+      {
+        print_line($output, $1 . "<cerrno>", $from, $lineno) if ($is_error_hpp);
+        print_line($output, $1 . "<system_error>", $from, $lineno);
+      }
+    }
+    elsif ($line =~ /# *include [<"]asio\/impl\/error_code\.[hi]pp[>"]/)
+    {
+      # Line is removed.
+    }
+    elsif ($line =~ /(# *include )[<"]asio\/system_error\.hpp[>"]/)
+    {
+      if ($is_asio_hpp)
+      {
+        # Line is removed.
+      }
+      else
+      {
+        print_line($output, $1 . "<system_error>", $from, $lineno);
+      }
+    }
+    elsif ($line =~ /(^.*# *include )[<"]asio\/([^>"]*)[>"](.*)$/)
+    {
+      print_line($output, $1 . "<experimental/__net_ts/" . $2 . ">" . $3, $from, $lineno);
+    }
+    elsif ($line =~ /#.*defined\(.*ASIO_HAS_STD_SYSTEM_ERROR\)$/)
+    {
+      # Line is removed.
+    }
+    elsif ($line =~ /asio::thread/)
+    {
+      if ($is_test)
+      {
+        $line =~ s/asio::thread/std::experimental::net::v1::detail::thread/g;
+      }
+      else
+      {
+        $line =~ s/asio::thread/std::thread/g;
+      }
+      print_line($output, $line, $from, $lineno);
+    }
+    elsif ($line =~ /^( *)thread( .*)$/)
+    {
+      if ($is_test)
+      {
+        print_line($output, $1 . "std::experimental::net::v1::detail::thread" . $2, $from, $lineno);
+      }
+      else
+      {
+        print_line($output, $1 . "std::thread" . $2, $from, $lineno);
+      }
+    }
+    elsif ($line =~ /asio::/ && !($line =~ /boost::asio::/))
+    {
+      $line =~ s/asio::error_code/std::error_code/g;
+      $line =~ s/asio::error_category/std::error_category/g;
+      $line =~ s/asio::system_category/std::system_category/g;
+      $line =~ s/asio::system_error/std::system_error/g;
+      $line =~ s/asio::/std::experimental::net::/g;
+      print_line($output, $line, $from, $lineno);
+    }
+    elsif ($line =~ /using namespace asio/)
+    {
+      $line =~ s/using namespace asio/using namespace std::experimental::net/g;
+      print_line($output, $line, $from, $lineno);
+    }
+    elsif ($line =~ /[\\@]ref boost_bind/)
+    {
+      $line =~ s/[\\@]ref boost_bind/std::bind()/g;
+      print_line($output, $line, $from, $lineno);
+    }
+    elsif ($line =~ /define.*DETAIL_CONFIG_HPP/)
+    {
+      print_line($output, $line, $from, $lineno);
+      print_line($output, "", $from, $lineno);
+      print_line($output, "#define NET_TS_STANDALONE 1", $from, $lineno);
+    }
+    else
+    {
+      print_line($output, $line, $from, $lineno);
+    }
+    ++$lineno;
+  }
+
+  # Ok, we're done.
+  close($input);
+  close($output);
+}
+
+sub find_include_files
+{
+  my @root_includes = (
+      "asio/ts/buffer.hpp",
+      "asio/ts/executor.hpp",
+      "asio/ts/internet.hpp",
+      "asio/ts/io_context.hpp",
+      "asio/ts/net.hpp",
+      "asio/ts/netfwd.hpp",
+      "asio/ts/socket.hpp",
+      "asio/ts/timer.hpp");
+
+  my @excluded_includes = (
+      "asio/basic_deadline_timer.hpp",
+      "asio/basic_streambuf.hpp",
+      "asio/basic_streambuf_fwd.hpp",
+      "asio/datagram_socket_service.hpp",
+      "asio/deadline_timer.hpp",
+      "asio/deadline_timer_service.hpp",
+      "asio/io_context_strand.hpp",
+      "asio/detail/strand_service.hpp",
+      "asio/detail/impl/strand_service.hpp",
+      "asio/detail/impl/strand_service.ipp",
+      "asio/socket_acceptor_service.hpp",
+      "asio/seq_packet_socket_service.hpp",
+      "asio/stream_socket_service.hpp",
+      "asio/time_traits.hpp",
+      "asio/waitable_timer_service.hpp");
+
+  my @include_files = ();
+  my %known_includes = ();
+
+  foreach my $include (@root_includes)
+  {
+    $known_includes{$include} = 1;
+    push(@include_files, "include/" . $include);
+  }
+
+  foreach my $include (@excluded_includes)
+  {
+    $known_includes{$include} = 1;
+  }
+
+  my @unprocessed_includes = sort keys %known_includes;
+  while (scalar(@unprocessed_includes) > 0)
+  {
+    my $include = pop(@unprocessed_includes);
+
+    open(my $input, "<include/$include") or die("Can't open include/$include for reading");
+    while (my $line = <$input>)
+    {
+      chomp($line);
+      if ($line =~ /^\s*#\s*include\s*"(asio\/[^"]*)"/)
+      {
+        if (not defined($known_includes{$1}))
+        {
+          $known_includes{$1} = 1;
+          push(@include_files, "include/" . $1);
+          push(@unprocessed_includes, $1);
+        }
+      }
+    }
+    close($input);
+  }
+
+  return @include_files;
+}
+
+sub copy_include_files
+{
+  my @files = find_include_files();
+  push(@files, "include/asio/impl/src.hpp");
+
+  foreach my $file (@files)
+  {
+    if ($file ne "include/asio/thread.hpp"
+        and $file ne "include/asio/error_code.hpp"
+        and $file ne "include/asio/system_error.hpp"
+        and $file ne "include/asio/impl/error_code.hpp"
+        and $file ne "include/asio/impl/error_code.ipp")
+    {
+      my $from = $file;
+      my $to = $file;
+      $to =~ s/^include\/asio\//$output_dir\/include\/experimental\/__net_ts\//;
+      copy_source_file($from, $to);
+    }
+  }
+}
+
+sub create_top_level_includes
+{
+  my @includes = (
+      "buffer",
+      "executor",
+      "internet",
+      "io_context",
+      "net",
+      "netfwd",
+      "socket",
+      "timer");
+
+  our $output_dir;
+  mkpath("$output_dir/include/experimental");
+  foreach my $include (@includes)
+  {
+    open(my $output, ">$output_dir/include/experimental/$include")
+      or die("Can't open $output_dir/include/experimental/$include for writing");
+
+    my $guard = "NET_TS_" . uc($include) . "_INCLUDED";
+
+    print($output "//\n");
+    print($output "// experimental/$include\n");
+    print($output "// " . '~' x length("experimental/" . $include) . "\n");
+    print($output "//\n");
+    print($output "// Copyright (c) 2003-2016 Christopher M. Kohlhoff (chris at kohlhoff dot com)\n");
+    print($output "//\n");
+    print($output "// Distributed under the Boost Software License, Version 1.0. (See accompanying\n");
+    print($output "// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n");
+    print($output "//\n");
+    print($output "\n");
+    print($output "#ifndef $guard\n");
+    print($output "#define $guard\n");
+    print($output "\n");
+    print($output "#include <experimental/__net_ts/ts/$include.hpp>\n");
+    print($output "\n");
+    print($output "#endif // $guard\n");
+
+    close($output);
+  }
+}
+
+copy_include_files();
+create_top_level_includes();
